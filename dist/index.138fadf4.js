// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this,
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function() {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"2t7XM":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "aa9dba8ca27d5955";
module.bundle.HMR_BUNDLE_ID = "e38501f1138fadf4"; // @flow
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets/*: {|[string]: boolean|} */ , acceptedAssets/*: {|[string]: boolean|} */ , assetsToAccept/*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
    // $FlowFixMe
    ws.onmessage = function(event/*: {data: string, ...} */ ) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH
            );
            // Handle HMR Update
            var handled = false;
            assets.forEach((asset)=>{
                var didAccept = asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
                if (didAccept) handled = true;
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
            }
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function(e) {
        console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] âœ¨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
        errorHTML += `\n      <div>\n        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">\n          ðŸš¨ ${diagnostic.message}\n        </div>\n        <pre>\n          ${stack}\n        </pre>\n        <div>\n          ${diagnostic.hints.map((hint)=>'<div>' + hint + '</div>'
        ).join('')}\n        </div>\n      </div>\n    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    link.getAttribute('href').split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle/*: ParcelRequire */ , asset/*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') {
        reloadCSS();
        return;
    }
    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
    if (deps) {
        var fn = new Function('require', 'module', 'exports', asset.output);
        modules[asset.id] = [
            fn,
            deps
        ];
    } else if (bundle.parent) hmrApply(bundle.parent, asset);
}
function hmrAcceptCheck(bundle/*: ParcelRequire */ , id/*: string */ , depsByBundle/*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    return getParents(module.bundle.root, id).some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle/*: ParcelRequire */ , id/*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"3pX0n":[function(require,module,exports) {
var _three = require("three");
var _sky = require("three/examples/jsm/objects/Sky");
var _orbitControls = require("three/examples/jsm/controls/OrbitControls");
var _utils = require("./utils");
var _textures = require("./textures");
const renderer = new _three.WebGLRenderer({
    canvas: _utils.$0("#threejs-canvas"),
    antialias: true,
    failIfMajorPerformanceCaveat: true,
    powerPreference: "high-performance",
    precision: "lowp"
});
renderer.outputEncoding = _three.sRGBEncoding;
renderer.toneMapping = _three.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.5;
renderer.setSize(window.innerWidth / 2, window.innerHeight);
const scene = new _three.Scene();
scene.autoUpdate = false;
const group = new _three.Group();
const camera = new _three.PerspectiveCamera(45, window.innerWidth / window.innerHeight / 2, 0.01, 1000000);
camera.position.set(1, 1, 1).multiplyScalar(20);
camera.lookAt(0, 0, 0);
scene.fog = new _three.Fog(12303291, 1);
const ambientLight = new _three.AmbientLight(new _three.Color(5592405), 0.6);
const directionalLight = new _three.DirectionalLight(new _three.Color(15658734), 1);
directionalLight.position.set(1, 1, 1).multiplyScalar(45000);
directionalLight.lookAt(0, 0, 0);
scene.add(ambientLight, directionalLight);
const geometries = [
    "BoxBufferGeometry",
    "CircleBufferGeometry",
    "ConeBufferGeometry",
    "CylinderBufferGeometry",
    "DodecahedronBufferGeometry",
    "IcosahedronBufferGeometry",
    "OctahedronBufferGeometry",
    "PlaneBufferGeometry",
    "RingBufferGeometry",
    "SphereBufferGeometry",
    "TetrahedronBufferGeometry",
    "TorusBufferGeometry",
    "TorusKnotBufferGeometry"
];
const textureArray = [
    _textures.water,
    _textures.nylon,
    _textures.wood
];
for(let index = 0; index < geometries.length; index++){
    const geometry = new _three[geometries[index]](); // Don't worry about this.
    geometry.computeVertexNormals(true); // smooth lighting
    const mesh = new _three.Mesh(geometry, textureArray[(index + 2) % 3].clone()); // puts the material on the geometry
    mesh.material.side = _three.DoubleSide;
    mesh.matrixWorld.setPosition(15 * Math.cos(index / 13 * Math.PI * 2), 0, 15 * Math.sin(index / 13 * Math.PI * 2)//places geometries in a circle
    );
    group.add(mesh);
}
scene.add(group);
//Sky setup
const sky = new _sky.Sky();
sky.matrixWorld.makeScale(15000, 15000, 15000);
let uniforms = {
    turbidity: {
        value: 10
    },
    rayleigh: {
        value: 3
    },
    mieCoefficient: {
        value: 0.005
    },
    mieDirectionalG: {
        value: 0.7
    },
    elevation: {
        value: 2.7
    },
    azimuth: {
        value: 180
    },
    exposure: {
        value: renderer.toneMappingExposure
    },
    sunPosition: {
        value: new _three.Vector3(0, Math.PI / 4, 0)
    }
};
Object.assign(sky.material.uniforms, uniforms);
//Floor setup
let floorGeometry = new _three.PlaneBufferGeometry(1, 1);
let floorMat = new _three.Mesh(floorGeometry, _textures.floor);
floorMat.rotation.set(-Math.PI / 2, 0, 0);
floorMat.position.set(0, -10, 0);
floorMat.scale.set(1000, 1000, 1100);
floorMat.updateMatrixWorld();
scene.add(floorMat);
scene.add(sky);
//controls
let controls = new _orbitControls.OrbitControls(camera, renderer.domElement);
controls.maxDistance = 2000;
//render loop
function render() {
    renderer.render(scene, camera);
    controls.update();
}
renderer.setAnimationLoop(render);
//raycasting. making objects clickable
const raycaster = new _three.Raycaster();
const mouse = new _three.Vector2();
let pickedObject = null;
//setup
const matrixEls = [
    ..._utils.$('[data-matrix]')
];
const positionEls = [
    ..._utils.$('[data-position]')
];
const scaleEls = [
    ..._utils.$('[data-scale]')
];
const rotationEls = [
    ..._utils.$('[data-rotation]')
];
const positionVec = new _three.Vector3();
const scaleVec = new _three.Vector3();
const rotationVec = new _three.Euler();
//updating scene + input boxes
function handleInput(event) {
    let element = event.target;
    if (element === null || pickedObject === null || element.contentEditable == undefined) return;
    if (element.dataset.matrix !== undefined) {
        const noNaNMatrix = _utils.parseElements(matrixEls, pickedObject.matrixWorld);
        if (!noNaNMatrix) return;
        positionVec.setFromMatrixPosition(pickedObject.matrixWorld);
        scaleVec.setFromMatrixScale(pickedObject.matrixWorld);
        rotationVec.setFromRotationMatrix(pickedObject.matrixWorld);
        _utils.putInGui(positionVec.toArray(), positionEls, 2);
        _utils.putInGui(scaleVec.toArray(), scaleEls, 2);
        _utils.putInGui(rotationVec.toArray(), rotationEls, 2);
    } else if (element.dataset.matrix === undefined) {
        const noNaNPosition = _utils.parseElements(positionEls, positionVec);
        const noNaNScale = _utils.parseElements(rotationEls, rotationVec);
        const noNaNRotation = _utils.parseElements(scaleEls, scaleVec);
        if (!noNaNPosition && !noNaNRotation && !noNaNScale) return;
        pickedObject.matrixWorld.compose(positionVec, new _three.Quaternion().setFromEuler(rotationVec), scaleVec);
        _utils.putInGui(pickedObject.matrixWorld.elements, matrixEls, 2);
    }
    event.preventDefault();
    event.stopPropagation();
}
_utils.$0("#left-container").oninput = handleInput; //event bubbling input event
function pickObject(x, y) {
    mouse.set(x / (0.5 * window.innerWidth) * 2 - 1, -(y / window.innerHeight) * 2 + 1);
    raycaster.setFromCamera(mouse, camera);
    const selectedObject = raycaster.intersectObjects(group.children)[0];
    if (!selectedObject?.object) return;
    for (let object of group.children)object.material.emissive.set(0);
    selectedObject.object.material.emissive.set(3355443);
    pickedObject = selectedObject.object;
    positionVec.setFromMatrixPosition(pickedObject.matrixWorld);
    scaleVec.setFromMatrixScale(pickedObject.matrixWorld);
    rotationVec.setFromRotationMatrix(pickedObject.matrixWorld);
    _utils.putInGui(pickedObject.matrixWorld.elements, matrixEls, 2);
    _utils.putInGui(positionVec.toArray(), positionEls, 2);
    _utils.putInGui(scaleVec.toArray(), scaleEls, 2);
    _utils.putInGui(rotationVec.toArray(), rotationEls, 2);
}
renderer.domElement.addEventListener("click", (event)=>{
    pickObject(event.clientX, event.clientY);
    event.preventDefault();
    event.stopPropagation();
});
renderer.domElement.addEventListener("touchstart", (event)=>{
    pickObject(event.touches[0].clientX, event.touches[0].clientY);
    event.preventDefault();
    event.stopPropagation();
}, {
    passive: true
});
//making the advanced tab work
const buttonAdvanced = _utils.$0("#click-advanced");
const matrixRow4 = _utils.$(".advanced");
function toggleAdvanced(event) {
    if (buttonAdvanced.style.backgroundColor === "") buttonAdvanced.style.backgroundColor = "limegreen";
    else buttonAdvanced.style.backgroundColor = "";
    for (let element of matrixRow4)element.contentEditable = (!element.isContentEditable).toString();
    event.preventDefault();
    event.stopPropagation();
}
buttonAdvanced.addEventListener("click", toggleAdvanced);
buttonAdvanced.addEventListener("touchstart", toggleAdvanced, {
    passive: true
});
window.onresize = ()=>{
    renderer.setSize(window.innerWidth / 2, window.innerHeight);
    camera.aspect = window.innerWidth / (2 * window.innerHeight);
    camera.updateProjectionMatrix();
};

},{"three":"5bvHB","three/examples/jsm/objects/Sky":"2eXZP","three/examples/jsm/controls/OrbitControls":"gmleG","./utils":"cGDrh","./textures":"3X92b"}],"5bvHB":[function(require,module,exports) {
(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define([
        'exports'
    ], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {
    }));
})(this, function(exports) {
    'use strict';
    // Polyfills
    if (Number.EPSILON === undefined) Number.EPSILON = Math.pow(2, -52);
    if (Number.isInteger === undefined) // Missing in IE
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
    Number.isInteger = function(value) {
        return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
    };
     //
    if (Math.sign === undefined) // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
    Math.sign = function(x) {
        return x < 0 ? -1 : x > 0 ? 1 : +x;
    };
    if ('name' in Function.prototype === false) // Missing in IE
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
    Object.defineProperty(Function.prototype, 'name', {
        get: function get() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
        }
    });
    if (Object.assign === undefined) // Missing in IE
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    Object.assign = function(target) {
        if (target === undefined || target === null) throw new TypeError('Cannot convert undefined or null to object');
        var output = Object(target);
        for(var index = 1; index < arguments.length; index++){
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for(var nextKey in source)if (Object.prototype.hasOwnProperty.call(source, nextKey)) output[nextKey] = source[nextKey];
            }
        }
        return output;
    };
    /**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */ var runtime = function(exports1) {
        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var undefined$1; // More compressible than void 0.
        var $Symbol = typeof Symbol === "function" ? Symbol : {
        };
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define(obj, key, value) {
            Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
            return obj[key];
        }
        try {
            // IE 8 has a broken Object.defineProperty that only works on DOM objects.
            define({
            }, "");
        } catch (err) {
            define = function define1(obj, key, value) {
                return obj[key] = value;
            };
        }
        function wrap(innerFn, outerFn, self, tryLocsList) {
            // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
            var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
            var generator = Object.create(protoGenerator.prototype);
            var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
            // .throw, and .return methods.
            generator._invoke = makeInvokeMethod(innerFn, self, context);
            return generator;
        }
        exports1.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
        // record like context.tryEntries[i].completion. This interface could
        // have been (and was previously) designed to take a closure to be
        // invoked without arguments, but in all the cases we care about we
        // already have an existing method we want to call, so there's no need
        // to create a new function object. We can even get away with assuming
        // the method takes exactly one argument, since that happens to be true
        // in every case, so we don't have to touch the arguments object. The
        // only additional allocation required is the completion record, which
        // has a stable shape and so hopefully should be cheap to allocate.
        function tryCatch(fn, obj, arg) {
            try {
                return {
                    type: "normal",
                    arg: fn.call(obj, arg)
                };
            } catch (err) {
                return {
                    type: "throw",
                    arg: err
                };
            }
        }
        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
        // breaking out of the dispatch switch statement.
        var ContinueSentinel = {
        }; // Dummy constructor functions that we use as the .constructor and
        // .constructor.prototype properties for functions that return Generator
        // objects. For full spec compliance, you may wish to configure your
        // minifier not to mangle the names of these two functions.
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        } // This is a polyfill for %IteratorPrototype% for environments that
        // don't natively support it.
        var IteratorPrototype = {
        };
        IteratorPrototype[iteratorSymbol] = function() {
            return this;
        };
        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
        GeneratorFunctionPrototype.constructor = GeneratorFunction;
        GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
        // Iterator interface in terms of a single ._invoke method.
        function defineIteratorMethods(prototype) {
            [
                "next",
                "throw",
                "return"
            ].forEach(function(method) {
                define(prototype, method, function(arg) {
                    return this._invoke(method, arg);
                });
            });
        }
        exports1.isGeneratorFunction = function(genFun) {
            var ctor = typeof genFun === "function" && genFun.constructor;
            return ctor ? ctor === GeneratorFunction || // do is to check its .name property.
            (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
        };
        exports1.mark = function(genFun) {
            if (Object.setPrototypeOf) Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
            else {
                genFun.__proto__ = GeneratorFunctionPrototype;
                define(genFun, toStringTagSymbol, "GeneratorFunction");
            }
            genFun.prototype = Object.create(Gp);
            return genFun;
        }; // Within the body of any async function, `await x` is transformed to
        // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
        // `hasOwn.call(value, "__await")` to determine if the yielded value is
        // meant to be awaited.
        exports1.awrap = function(arg) {
            return {
                __await: arg
            };
        };
        function AsyncIterator(generator, PromiseImpl) {
            function invoke(method, arg, resolve, reject) {
                var record = tryCatch(generator[method], generator, arg);
                if (record.type === "throw") reject(record.arg);
                else {
                    var result = record.arg;
                    var value = result.value;
                    if (value && typeof value === "object" && hasOwn.call(value, "__await")) return PromiseImpl.resolve(value.__await).then(function(value1) {
                        invoke("next", value1, resolve, reject);
                    }, function(err) {
                        invoke("throw", err, resolve, reject);
                    });
                    return PromiseImpl.resolve(value).then(function(unwrapped) {
                        // When a yielded Promise is resolved, its final value becomes
                        // the .value of the Promise<{value,done}> result for the
                        // current iteration.
                        result.value = unwrapped;
                        resolve(result);
                    }, function(error) {
                        // If a rejected Promise was yielded, throw the rejection back
                        // into the async generator function so it can be handled there.
                        return invoke("throw", error, resolve, reject);
                    });
                }
            }
            var previousPromise;
            function enqueue(method, arg) {
                function callInvokeWithMethodAndArg() {
                    return new PromiseImpl(function(resolve, reject) {
                        invoke(method, arg, resolve, reject);
                    });
                }
                return previousPromise = // all previous Promises have been resolved before calling invoke,
                // so that results are always delivered in the correct order. If
                // enqueue has not been called before, then it is important to
                // call invoke immediately, without waiting on a callback to fire,
                // so that the async generator function has the opportunity to do
                // any necessary setup in a predictable way. This predictability
                // is why the Promise constructor synchronously invokes its
                // executor callback, and why async functions synchronously
                // execute code before the first await. Since we implement simple
                // async functions in terms of async generators, it is especially
                // important to get this right, even though it requires care.
                previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // invocations of the iterator.
                callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            } // Define the unified helper method that is used to implement .next,
            // .throw, and .return (see defineIteratorMethods).
            this._invoke = enqueue;
        }
        defineIteratorMethods(AsyncIterator.prototype);
        AsyncIterator.prototype[asyncIteratorSymbol] = function() {
            return this;
        };
        exports1.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
        // AsyncIterator objects; they just return a Promise for the value of
        // the final result produced by the iterator.
        exports1.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
            if (PromiseImpl === void 0) PromiseImpl = Promise;
            var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
            return exports1.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
                return result.done ? result.value : iter.next();
            });
        };
        function makeInvokeMethod(innerFn, self, context) {
            var state = GenStateSuspendedStart;
            return function invoke(method, arg) {
                if (state === GenStateExecuting) throw new Error("Generator is already running");
                if (state === GenStateCompleted) {
                    if (method === "throw") throw arg;
                     // Be forgiving, per 25.3.3.3.3 of the spec:
                    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                    return doneResult();
                }
                context.method = method;
                context.arg = arg;
                while(true){
                    var delegate = context.delegate;
                    if (delegate) {
                        var delegateResult = maybeInvokeDelegate(delegate, context);
                        if (delegateResult) {
                            if (delegateResult === ContinueSentinel) continue;
                            return delegateResult;
                        }
                    }
                    if (context.method === "next") // Setting context._sent for legacy support of Babel's
                    // function.sent implementation.
                    context.sent = context._sent = context.arg;
                    else if (context.method === "throw") {
                        if (state === GenStateSuspendedStart) {
                            state = GenStateCompleted;
                            throw context.arg;
                        }
                        context.dispatchException(context.arg);
                    } else if (context.method === "return") context.abrupt("return", context.arg);
                    state = GenStateExecuting;
                    var record = tryCatch(innerFn, self, context);
                    if (record.type === "normal") {
                        // If an exception is thrown from innerFn, we leave state ===
                        // GenStateExecuting and loop back for another invocation.
                        state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                        if (record.arg === ContinueSentinel) continue;
                        return {
                            value: record.arg,
                            done: context.done
                        };
                    } else if (record.type === "throw") {
                        state = GenStateCompleted; // Dispatch the exception by looping back around to the
                        // context.dispatchException(context.arg) call above.
                        context.method = "throw";
                        context.arg = record.arg;
                    }
                }
            };
        } // Call delegate.iterator[context.method](context.arg) and handle the
        // result, either by returning a { value, done } result from the
        // delegate iterator, or by modifying context.method and context.arg,
        // setting context.delegate to null, and returning the ContinueSentinel.
        function maybeInvokeDelegate(delegate, context) {
            var method = delegate.iterator[context.method];
            if (method === undefined$1) {
                // A .throw or .return when the delegate iterator has no .throw
                // method always terminates the yield* loop.
                context.delegate = null;
                if (context.method === "throw") {
                    // Note: ["return"] must be used for ES3 parsing compatibility.
                    if (delegate.iterator["return"]) {
                        // If the delegate iterator has a return method, give it a
                        // chance to clean up.
                        context.method = "return";
                        context.arg = undefined$1;
                        maybeInvokeDelegate(delegate, context);
                        if (context.method === "throw") // If maybeInvokeDelegate(context) changed context.method from
                        // "return" to "throw", let that override the TypeError below.
                        return ContinueSentinel;
                    }
                    context.method = "throw";
                    context.arg = new TypeError("The iterator does not provide a 'throw' method");
                }
                return ContinueSentinel;
            }
            var record = tryCatch(method, delegate.iterator, context.arg);
            if (record.type === "throw") {
                context.method = "throw";
                context.arg = record.arg;
                context.delegate = null;
                return ContinueSentinel;
            }
            var info = record.arg;
            if (!info) {
                context.method = "throw";
                context.arg = new TypeError("iterator result is not an object");
                context.delegate = null;
                return ContinueSentinel;
            }
            if (info.done) {
                // Assign the result of the finished delegate to the temporary
                // variable specified by delegate.resultName (see delegateYield).
                context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).
                context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
                // exception, let the outer generator proceed normally. If
                // context.method was "next", forget context.arg since it has been
                // "consumed" by the delegate iterator. If context.method was
                // "return", allow the original .return call to continue in the
                // outer generator.
                if (context.method !== "return") {
                    context.method = "next";
                    context.arg = undefined$1;
                }
            } else // Re-yield the result returned by the delegate method.
            return info;
             // The delegate iterator is finished, so forget it and continue with
            // the outer generator.
            context.delegate = null;
            return ContinueSentinel;
        } // Define Generator.prototype.{next,throw,return} in terms of the
        // unified ._invoke helper method.
        defineIteratorMethods(Gp);
        define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
        // @@iterator function is called on it. Some browsers' implementations of the
        // iterator prototype chain incorrectly implement this, causing the Generator
        // object to not be returned from this call. This ensures that doesn't happen.
        // See https://github.com/facebook/regenerator/issues/274 for more details.
        Gp[iteratorSymbol] = function() {
            return this;
        };
        Gp.toString = function() {
            return "[object Generator]";
        };
        function pushTryEntry(locs) {
            var entry = {
                tryLoc: locs[0]
            };
            if (1 in locs) entry.catchLoc = locs[1];
            if (2 in locs) {
                entry.finallyLoc = locs[2];
                entry.afterLoc = locs[3];
            }
            this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
            var record = entry.completion || {
            };
            record.type = "normal";
            delete record.arg;
            entry.completion = record;
        }
        function Context(tryLocsList) {
            // The root entry object (effectively a try statement without a catch
            // or a finally block) gives us a place to store values thrown from
            // locations where there is no enclosing try statement.
            this.tryEntries = [
                {
                    tryLoc: "root"
                }
            ];
            tryLocsList.forEach(pushTryEntry, this);
            this.reset(true);
        }
        exports1.keys = function(object) {
            var keys = [];
            for(var key in object)keys.push(key);
            keys.reverse(); // Rather than returning an object with a next method, we keep
            // things simple and return the next function itself.
            return function next() {
                while(keys.length){
                    var key1 = keys.pop();
                    if (key1 in object) {
                        next.value = key1;
                        next.done = false;
                        return next;
                    }
                } // To avoid creating an additional object, we just hang the .value
                // and .done properties off the next function object itself. This
                // also ensures that the minifier will not anonymize the function.
                next.done = true;
                return next;
            };
        };
        function values(iterable) {
            if (iterable) {
                var iteratorMethod = iterable[iteratorSymbol];
                if (iteratorMethod) return iteratorMethod.call(iterable);
                if (typeof iterable.next === "function") return iterable;
                if (!isNaN(iterable.length)) {
                    var i = -1, next = function next1() {
                        while((++i) < iterable.length)if (hasOwn.call(iterable, i)) {
                            next1.value = iterable[i];
                            next1.done = false;
                            return next1;
                        }
                        next1.value = undefined$1;
                        next1.done = true;
                        return next1;
                    };
                    return next.next = next;
                }
            } // Return an iterator with no values.
            return {
                next: doneResult
            };
        }
        exports1.values = values;
        function doneResult() {
            return {
                value: undefined$1,
                done: true
            };
        }
        Context.prototype = {
            constructor: Context,
            reset: function reset(skipTempReset) {
                this.prev = 0;
                this.next = 0; // Resetting context._sent for legacy support of Babel's
                // function.sent implementation.
                this.sent = this._sent = undefined$1;
                this.done = false;
                this.delegate = null;
                this.method = "next";
                this.arg = undefined$1;
                this.tryEntries.forEach(resetTryEntry);
                if (!skipTempReset) {
                    for(var name in this)// Not sure about the optimal order of these conditions:
                    if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) this[name] = undefined$1;
                }
            },
            stop: function stop() {
                this.done = true;
                var rootEntry = this.tryEntries[0];
                var rootRecord = rootEntry.completion;
                if (rootRecord.type === "throw") throw rootRecord.arg;
                return this.rval;
            },
            dispatchException: function dispatchException(exception) {
                if (this.done) throw exception;
                var context = this;
                function handle(loc, caught) {
                    record.type = "throw";
                    record.arg = exception;
                    context.next = loc;
                    if (caught) {
                        // If the dispatched exception was caught by a catch block,
                        // then let that catch block handle the exception normally.
                        context.method = "next";
                        context.arg = undefined$1;
                    }
                    return !!caught;
                }
                for(var i = this.tryEntries.length - 1; i >= 0; --i){
                    var entry = this.tryEntries[i];
                    var record = entry.completion;
                    if (entry.tryLoc === "root") // Exception thrown outside of any try block that could handle
                    // it, so set the completion value of the entire function to
                    // throw the exception.
                    return handle("end");
                    if (entry.tryLoc <= this.prev) {
                        var hasCatch = hasOwn.call(entry, "catchLoc");
                        var hasFinally = hasOwn.call(entry, "finallyLoc");
                        if (hasCatch && hasFinally) {
                            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);
                            else if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                        } else if (hasCatch) {
                            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);
                        } else if (hasFinally) {
                            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                        } else throw new Error("try statement without catch or finally");
                    }
                }
            },
            abrupt: function abrupt(type, arg) {
                for(var i = this.tryEntries.length - 1; i >= 0; --i){
                    var entry = this.tryEntries[i];
                    if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                        var finallyEntry = entry;
                        break;
                    }
                }
                if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) // Ignore the finally entry if control is not jumping to a
                // location outside the try/catch block.
                finallyEntry = null;
                var record = finallyEntry ? finallyEntry.completion : {
                };
                record.type = type;
                record.arg = arg;
                if (finallyEntry) {
                    this.method = "next";
                    this.next = finallyEntry.finallyLoc;
                    return ContinueSentinel;
                }
                return this.complete(record);
            },
            complete: function complete(record, afterLoc) {
                if (record.type === "throw") throw record.arg;
                if (record.type === "break" || record.type === "continue") this.next = record.arg;
                else if (record.type === "return") {
                    this.rval = this.arg = record.arg;
                    this.method = "return";
                    this.next = "end";
                } else if (record.type === "normal" && afterLoc) this.next = afterLoc;
                return ContinueSentinel;
            },
            finish: function finish(finallyLoc) {
                for(var i = this.tryEntries.length - 1; i >= 0; --i){
                    var entry = this.tryEntries[i];
                    if (entry.finallyLoc === finallyLoc) {
                        this.complete(entry.completion, entry.afterLoc);
                        resetTryEntry(entry);
                        return ContinueSentinel;
                    }
                }
            },
            "catch": function _catch(tryLoc) {
                for(var i = this.tryEntries.length - 1; i >= 0; --i){
                    var entry = this.tryEntries[i];
                    if (entry.tryLoc === tryLoc) {
                        var record = entry.completion;
                        if (record.type === "throw") {
                            var thrown = record.arg;
                            resetTryEntry(entry);
                        }
                        return thrown;
                    }
                } // The context.catch method must only be called with a location
                // argument that corresponds to a known catch block.
                throw new Error("illegal catch attempt");
            },
            delegateYield: function delegateYield(iterable, resultName, nextLoc) {
                this.delegate = {
                    iterator: values(iterable),
                    resultName: resultName,
                    nextLoc: nextLoc
                };
                if (this.method === "next") // Deliberately forget the last sent value so that we don't
                // accidentally pass it on to the delegate.
                this.arg = undefined$1;
                return ContinueSentinel;
            }
        }; // Regardless of whether this script is executing as a CommonJS module
        // or not, return the runtime object so that we can declare the variable
        // regeneratorRuntime in the outer scope, which allows this module to be
        // injected easily by `bin/regenerator --include-runtime script.js`.
        return exports1;
    }(// as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    typeof module === "object" ? module.exports : {
    });
    try {
        regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
        // This module should not be running in strict mode, so the above
        // assignment should always work unless something is misconfigured. Just
        // in case runtime.js accidentally runs in strict mode, we can escape
        // strict mode using a global Function call. This could conceivably fail
        // if a Content Security Policy forbids using Function, but in that case
        // the proper solution is to fix the accidental strict mode problem. If
        // you've misconfigured your bundler to force strict mode and applied a
        // CSP to forbid Function, and you're not willing to fix either of those
        // problems, please detail your unique predicament in a GitHub issue.
        Function("r", "regeneratorRuntime = r")(runtime);
    }
    var REVISION = '125';
    var MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    };
    var TOUCH = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    };
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var CullFaceFrontBack = 3;
    var BasicShadowMap = 0;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var VSMShadowMap = 3;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var SmoothShading = 2;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var CineonToneMapping = 3;
    var ACESFilmicToneMapping = 4;
    var CustomToneMapping = 5;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var RepeatWrapping = 1000;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var NearestFilter = 1003;
    var NearestMipmapNearestFilter = 1004;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipmapLinearFilter = 1005;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipmapNearestFilter = 1007;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipmapLinearFilter = 1008;
    var LinearMipMapLinearFilter = 1008;
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RedFormat = 1028;
    var RedIntegerFormat = 1029;
    var RGFormat = 1030;
    var RGIntegerFormat = 1031;
    var RGBIntegerFormat = 1032;
    var RGBAIntegerFormat = 1033;
    var RGB_S3TC_DXT1_Format = 33776;
    var RGBA_S3TC_DXT1_Format = 33777;
    var RGBA_S3TC_DXT3_Format = 33778;
    var RGBA_S3TC_DXT5_Format = 33779;
    var RGB_PVRTC_4BPPV1_Format = 35840;
    var RGB_PVRTC_2BPPV1_Format = 35841;
    var RGBA_PVRTC_4BPPV1_Format = 35842;
    var RGBA_PVRTC_2BPPV1_Format = 35843;
    var RGB_ETC1_Format = 36196;
    var RGB_ETC2_Format = 37492;
    var RGBA_ETC2_EAC_Format = 37496;
    var RGBA_ASTC_4x4_Format = 37808;
    var RGBA_ASTC_5x4_Format = 37809;
    var RGBA_ASTC_5x5_Format = 37810;
    var RGBA_ASTC_6x5_Format = 37811;
    var RGBA_ASTC_6x6_Format = 37812;
    var RGBA_ASTC_8x5_Format = 37813;
    var RGBA_ASTC_8x6_Format = 37814;
    var RGBA_ASTC_8x8_Format = 37815;
    var RGBA_ASTC_10x5_Format = 37816;
    var RGBA_ASTC_10x6_Format = 37817;
    var RGBA_ASTC_10x8_Format = 37818;
    var RGBA_ASTC_10x10_Format = 37819;
    var RGBA_ASTC_12x10_Format = 37820;
    var RGBA_ASTC_12x12_Format = 37821;
    var RGBA_BPTC_Format = 36492;
    var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
    var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
    var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
    var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
    var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
    var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
    var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
    var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
    var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
    var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
    var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
    var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
    var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
    var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var NormalAnimationBlendMode = 2500;
    var AdditiveAnimationBlendMode = 2501;
    var TrianglesDrawMode = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3000;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;
    var TangentSpaceNormalMap = 0;
    var ObjectSpaceNormalMap = 1;
    var ZeroStencilOp = 0;
    var KeepStencilOp = 7680;
    var ReplaceStencilOp = 7681;
    var IncrementStencilOp = 7682;
    var DecrementStencilOp = 7683;
    var IncrementWrapStencilOp = 34055;
    var DecrementWrapStencilOp = 34056;
    var InvertStencilOp = 5386;
    var NeverStencilFunc = 512;
    var LessStencilFunc = 513;
    var EqualStencilFunc = 514;
    var LessEqualStencilFunc = 515;
    var GreaterStencilFunc = 516;
    var NotEqualStencilFunc = 517;
    var GreaterEqualStencilFunc = 518;
    var AlwaysStencilFunc = 519;
    var StaticDrawUsage = 35044;
    var DynamicDrawUsage = 35048;
    var StreamDrawUsage = 35040;
    var StaticReadUsage = 35045;
    var DynamicReadUsage = 35049;
    var StreamReadUsage = 35041;
    var StaticCopyUsage = 35046;
    var DynamicCopyUsage = 35050;
    var StreamCopyUsage = 35042;
    var GLSL1 = '100';
    var GLSL3 = '300 es';
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key2, arg) {
        try {
            var info = gen[key2](arg);
            var value = info.value;
        } catch (error) {
            reject(error);
            return;
        }
        if (info.done) resolve(value);
        else Promise.resolve(value).then(_next, _throw);
    }
    function _asyncToGenerator(fn) {
        return function() {
            var self = this, args = arguments;
            return new Promise(function(resolve, reject) {
                var gen = fn.apply(self, args);
                function _next(value) {
                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                }
                function _throw(err) {
                    asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                }
                _next(undefined);
            });
        };
    }
    function _defineProperties(target, props) {
        for(var i = 0; i < props.length; i++){
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
    }
    function _assertThisInitialized(self) {
        if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
    }
    function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
        return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                if (it) o = it;
                var i = 0;
                return function() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        it = o[Symbol.iterator]();
        return it.next.bind(it);
    }
    /**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */ function EventDispatcher() {
    }
    Object.assign(EventDispatcher.prototype, {
        addEventListener: function addEventListener(type, listener) {
            if (this._listeners === undefined) this._listeners = {
            };
            var listeners = this._listeners;
            if (listeners[type] === undefined) listeners[type] = [];
            if (listeners[type].indexOf(listener) === -1) listeners[type].push(listener);
        },
        hasEventListener: function hasEventListener(type, listener) {
            if (this._listeners === undefined) return false;
            var listeners = this._listeners;
            return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
        },
        removeEventListener: function removeEventListener(type, listener) {
            if (this._listeners === undefined) return;
            var listeners = this._listeners;
            var listenerArray = listeners[type];
            if (listenerArray !== undefined) {
                var index = listenerArray.indexOf(listener);
                if (index !== -1) listenerArray.splice(index, 1);
            }
        },
        dispatchEvent: function dispatchEvent(event) {
            if (this._listeners === undefined) return;
            var listeners = this._listeners;
            var listenerArray = listeners[event.type];
            if (listenerArray !== undefined) {
                event.target = this; // Make a copy, in case listeners are removed while iterating.
                var array = listenerArray.slice(0);
                for(var i = 0, l = array.length; i < l; i++)array[i].call(this, event);
            }
        }
    });
    var _lut = [];
    for(var i = 0; i < 256; i++)_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
    var _seed = 1234567;
    var MathUtils = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function generateUUID() {
            // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
            var d0 = Math.random() * 4294967295 | 0;
            var d1 = Math.random() * 4294967295 | 0;
            var d2 = Math.random() * 4294967295 | 0;
            var d3 = Math.random() * 4294967295 | 0;
            var uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + '-' + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + '-' + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + '-' + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + '-' + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255]; // .toUpperCase() here flattens concatenated strings to save heap memory space.
            return uuid.toUpperCase();
        },
        clamp: function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        },
        // compute euclidian modulo of m % n
        // https://en.wikipedia.org/wiki/Modulo_operation
        euclideanModulo: function euclideanModulo(n, m) {
            return (n % m + m) % m;
        },
        // Linear mapping from range <a1, a2> to range <b1, b2>
        mapLinear: function mapLinear(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        },
        // https://en.wikipedia.org/wiki/Linear_interpolation
        lerp: function lerp(x, y, t) {
            return (1 - t) * x + t * y;
        },
        // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
        damp: function damp(x, y, lambda, dt) {
            return MathUtils.lerp(x, y, 1 - Math.exp(-lambda * dt));
        },
        // https://www.desmos.com/calculator/vcsjnyz7x4
        pingpong: function pingpong(x, length) {
            if (length === void 0) length = 1;
            return length - Math.abs(MathUtils.euclideanModulo(x, length * 2) - length);
        },
        // http://en.wikipedia.org/wiki/Smoothstep
        smoothstep: function smoothstep(x, min, max) {
            if (x <= min) return 0;
            if (x >= max) return 1;
            x = (x - min) / (max - min);
            return x * x * (3 - 2 * x);
        },
        smootherstep: function smootherstep(x, min, max) {
            if (x <= min) return 0;
            if (x >= max) return 1;
            x = (x - min) / (max - min);
            return x * x * x * (x * (x * 6 - 15) + 10);
        },
        // Random integer from <low, high> interval
        randInt: function randInt(low, high) {
            return low + Math.floor(Math.random() * (high - low + 1));
        },
        // Random float from <low, high> interval
        randFloat: function randFloat(low, high) {
            return low + Math.random() * (high - low);
        },
        // Random float from <-range/2, range/2> interval
        randFloatSpread: function randFloatSpread(range) {
            return range * (0.5 - Math.random());
        },
        // Deterministic pseudo-random float in the interval [ 0, 1 ]
        seededRandom: function seededRandom(s) {
            if (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm
            _seed = _seed * 16807 % 2147483647;
            return (_seed - 1) / 2147483646;
        },
        degToRad: function degToRad(degrees) {
            return degrees * MathUtils.DEG2RAD;
        },
        radToDeg: function radToDeg(radians) {
            return radians * MathUtils.RAD2DEG;
        },
        isPowerOfTwo: function isPowerOfTwo(value) {
            return (value & value - 1) === 0 && value !== 0;
        },
        ceilPowerOfTwo: function ceilPowerOfTwo(value) {
            return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
        },
        floorPowerOfTwo: function floorPowerOfTwo(value) {
            return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
        },
        setQuaternionFromProperEuler: function setQuaternionFromProperEuler(q, a, b, c, order) {
            // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
            // rotations are applied to the axes in the order specified by 'order'
            // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
            // angles are in radians
            var cos = Math.cos;
            var sin = Math.sin;
            var c2 = cos(b / 2);
            var s2 = sin(b / 2);
            var c13 = cos((a + c) / 2);
            var s13 = sin((a + c) / 2);
            var c1_3 = cos((a - c) / 2);
            var s1_3 = sin((a - c) / 2);
            var c3_1 = cos((c - a) / 2);
            var s3_1 = sin((c - a) / 2);
            switch(order){
                case 'XYX':
                    q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                    break;
                case 'YZY':
                    q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                    break;
                case 'ZXZ':
                    q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                    break;
                case 'XZX':
                    q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                    break;
                case 'YXY':
                    q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                    break;
                case 'ZYZ':
                    q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                    break;
                default:
                    console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
            }
        }
    };
    var Vector2 = /*#__PURE__*/ function() {
        function Vector21(x, y) {
            if (x === void 0) x = 0;
            if (y === void 0) y = 0;
            Object.defineProperty(this, 'isVector2', {
                value: true
            });
            this.x = x;
            this.y = y;
        }
        var _proto = Vector21.prototype;
        _proto.set = function set(x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        _proto.setScalar = function setScalar(scalar) {
            this.x = scalar;
            this.y = scalar;
            return this;
        };
        _proto.setX = function setX(x) {
            this.x = x;
            return this;
        };
        _proto.setY = function setY(y) {
            this.y = y;
            return this;
        };
        _proto.setComponent = function setComponent(index, value) {
            switch(index){
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                default:
                    throw new Error('index is out of range: ' + index);
            }
            return this;
        };
        _proto.getComponent = function getComponent(index) {
            switch(index){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error('index is out of range: ' + index);
            }
        };
        _proto.clone = function clone() {
            return new this.constructor(this.x, this.y);
        };
        _proto.copy = function copy(v) {
            this.x = v.x;
            this.y = v.y;
            return this;
        };
        _proto.add = function add(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            return this;
        };
        _proto.addScalar = function addScalar(s) {
            this.x += s;
            this.y += s;
            return this;
        };
        _proto.addVectors = function addVectors(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this;
        };
        _proto.addScaledVector = function addScaledVector(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            return this;
        };
        _proto.sub = function sub(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            return this;
        };
        _proto.subScalar = function subScalar(s) {
            this.x -= s;
            this.y -= s;
            return this;
        };
        _proto.subVectors = function subVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;
        };
        _proto.multiply = function multiply(v) {
            this.x *= v.x;
            this.y *= v.y;
            return this;
        };
        _proto.multiplyScalar = function multiplyScalar(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            return this;
        };
        _proto.divide = function divide(v) {
            this.x /= v.x;
            this.y /= v.y;
            return this;
        };
        _proto.divideScalar = function divideScalar(scalar) {
            return this.multiplyScalar(1 / scalar);
        };
        _proto.applyMatrix3 = function applyMatrix3(m) {
            var x = this.x, y = this.y;
            var e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6];
            this.y = e[1] * x + e[4] * y + e[7];
            return this;
        };
        _proto.min = function min(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            return this;
        };
        _proto.max = function max(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            return this;
        };
        _proto.clamp = function clamp(min1, max1) {
            // assumes min < max, componentwise
            this.x = Math.max(min1.x, Math.min(max1.x, this.x));
            this.y = Math.max(min1.y, Math.min(max1.y, this.y));
            return this;
        };
        _proto.clampScalar = function clampScalar(minVal, maxVal) {
            this.x = Math.max(minVal, Math.min(maxVal, this.x));
            this.y = Math.max(minVal, Math.min(maxVal, this.y));
            return this;
        };
        _proto.clampLength = function clampLength(min1, max1) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min1, Math.min(max1, length)));
        };
        _proto.floor = function floor() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        };
        _proto.ceil = function ceil() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
        };
        _proto.round = function round() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        };
        _proto.roundToZero = function roundToZero() {
            this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
            return this;
        };
        _proto.negate = function negate() {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        };
        _proto.dot = function dot(v) {
            return this.x * v.x + this.y * v.y;
        };
        _proto.cross = function cross(v) {
            return this.x * v.y - this.y * v.x;
        };
        _proto.lengthSq = function lengthSq() {
            return this.x * this.x + this.y * this.y;
        };
        _proto.length = function length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        };
        _proto.manhattanLength = function manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
        };
        _proto.normalize = function normalize() {
            return this.divideScalar(this.length() || 1);
        };
        _proto.angle = function angle() {
            // computes the angle in radians with respect to the positive x-axis
            var angle = Math.atan2(-this.y, -this.x) + Math.PI;
            return angle;
        };
        _proto.distanceTo = function distanceTo(v) {
            return Math.sqrt(this.distanceToSquared(v));
        };
        _proto.distanceToSquared = function distanceToSquared(v) {
            var dx = this.x - v.x, dy = this.y - v.y;
            return dx * dx + dy * dy;
        };
        _proto.manhattanDistanceTo = function manhattanDistanceTo(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        };
        _proto.setLength = function setLength(length1) {
            return this.normalize().multiplyScalar(length1);
        };
        _proto.lerp = function lerp(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            return this;
        };
        _proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
            this.x = v1.x + (v2.x - v1.x) * alpha;
            this.y = v1.y + (v2.y - v1.y) * alpha;
            return this;
        };
        _proto.equals = function equals(v) {
            return v.x === this.x && v.y === this.y;
        };
        _proto.fromArray = function fromArray(array, offset) {
            if (offset === void 0) offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            return this;
        };
        _proto.toArray = function toArray(array, offset) {
            if (array === void 0) array = [];
            if (offset === void 0) offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            return array;
        };
        _proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
            if (offset !== undefined) console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            return this;
        };
        _proto.rotateAround = function rotateAround(center, angle1) {
            var c = Math.cos(angle1), s = Math.sin(angle1);
            var x = this.x - center.x;
            var y = this.y - center.y;
            this.x = x * c - y * s + center.x;
            this.y = x * s + y * c + center.y;
            return this;
        };
        _proto.random = function random() {
            this.x = Math.random();
            this.y = Math.random();
            return this;
        };
        _createClass(Vector21, [
            {
                key: "width",
                get: function get() {
                    return this.x;
                },
                set: function set1(value) {
                    this.x = value;
                }
            },
            {
                key: "height",
                get: function get() {
                    return this.y;
                },
                set: function set1(value) {
                    this.y = value;
                }
            }
        ]);
        return Vector21;
    }();
    var Matrix3 = /*#__PURE__*/ function() {
        function Matrix31() {
            Object.defineProperty(this, 'isMatrix3', {
                value: true
            });
            this.elements = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ];
            if (arguments.length > 0) console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
        }
        var _proto = Matrix31.prototype;
        _proto.set = function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var te = this.elements;
            te[0] = n11;
            te[1] = n21;
            te[2] = n31;
            te[3] = n12;
            te[4] = n22;
            te[5] = n32;
            te[6] = n13;
            te[7] = n23;
            te[8] = n33;
            return this;
        };
        _proto.identity = function identity() {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor().fromArray(this.elements);
        };
        _proto.copy = function copy(m) {
            var te = this.elements;
            var me = m.elements;
            te[0] = me[0];
            te[1] = me[1];
            te[2] = me[2];
            te[3] = me[3];
            te[4] = me[4];
            te[5] = me[5];
            te[6] = me[6];
            te[7] = me[7];
            te[8] = me[8];
            return this;
        };
        _proto.extractBasis = function extractBasis(xAxis, yAxis, zAxis) {
            xAxis.setFromMatrix3Column(this, 0);
            yAxis.setFromMatrix3Column(this, 1);
            zAxis.setFromMatrix3Column(this, 2);
            return this;
        };
        _proto.setFromMatrix4 = function setFromMatrix4(m) {
            var me = m.elements;
            this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
            return this;
        };
        _proto.multiply = function multiply(m) {
            return this.multiplyMatrices(this, m);
        };
        _proto.premultiply = function premultiply(m) {
            return this.multiplyMatrices(m, this);
        };
        _proto.multiplyMatrices = function multiplyMatrices(a, b) {
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
            var a11 = ae[0], a12 = ae[3], a13 = ae[6];
            var a21 = ae[1], a22 = ae[4], a23 = ae[7];
            var a31 = ae[2], a32 = ae[5], a33 = ae[8];
            var b11 = be[0], b12 = be[3], b13 = be[6];
            var b21 = be[1], b22 = be[4], b23 = be[7];
            var b31 = be[2], b32 = be[5], b33 = be[8];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31;
            te[3] = a11 * b12 + a12 * b22 + a13 * b32;
            te[6] = a11 * b13 + a12 * b23 + a13 * b33;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31;
            te[4] = a21 * b12 + a22 * b22 + a23 * b32;
            te[7] = a21 * b13 + a22 * b23 + a23 * b33;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31;
            te[5] = a31 * b12 + a32 * b22 + a33 * b32;
            te[8] = a31 * b13 + a32 * b23 + a33 * b33;
            return this;
        };
        _proto.multiplyScalar = function multiplyScalar(s) {
            var te = this.elements;
            te[0] *= s;
            te[3] *= s;
            te[6] *= s;
            te[1] *= s;
            te[4] *= s;
            te[7] *= s;
            te[2] *= s;
            te[5] *= s;
            te[8] *= s;
            return this;
        };
        _proto.determinant = function determinant() {
            var te = this.elements;
            var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i1 = te[8];
            return a * e * i1 - a * f * h - b * d * i1 + b * f * g + c * d * h - c * e * g;
        };
        _proto.invert = function invert() {
            var te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        };
        _proto.transpose = function transpose() {
            var tmp;
            var m = this.elements;
            tmp = m[1];
            m[1] = m[3];
            m[3] = tmp;
            tmp = m[2];
            m[2] = m[6];
            m[6] = tmp;
            tmp = m[5];
            m[5] = m[7];
            m[7] = tmp;
            return this;
        };
        _proto.getNormalMatrix = function getNormalMatrix(matrix4) {
            return this.setFromMatrix4(matrix4).copy(this).invert().transpose();
        };
        _proto.transposeIntoArray = function transposeIntoArray(r) {
            var m = this.elements;
            r[0] = m[0];
            r[1] = m[3];
            r[2] = m[6];
            r[3] = m[1];
            r[4] = m[4];
            r[5] = m[7];
            r[6] = m[2];
            r[7] = m[5];
            r[8] = m[8];
            return this;
        };
        _proto.setUvTransform = function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
            var c = Math.cos(rotation);
            var s = Math.sin(rotation);
            this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
            return this;
        };
        _proto.scale = function scale(sx, sy) {
            var te = this.elements;
            te[0] *= sx;
            te[3] *= sx;
            te[6] *= sx;
            te[1] *= sy;
            te[4] *= sy;
            te[7] *= sy;
            return this;
        };
        _proto.rotate = function rotate(theta) {
            var c = Math.cos(theta);
            var s = Math.sin(theta);
            var te = this.elements;
            var a11 = te[0], a12 = te[3], a13 = te[6];
            var a21 = te[1], a22 = te[4], a23 = te[7];
            te[0] = c * a11 + s * a21;
            te[3] = c * a12 + s * a22;
            te[6] = c * a13 + s * a23;
            te[1] = -s * a11 + c * a21;
            te[4] = -s * a12 + c * a22;
            te[7] = -s * a13 + c * a23;
            return this;
        };
        _proto.translate = function translate(tx, ty) {
            var te = this.elements;
            te[0] += tx * te[2];
            te[3] += tx * te[5];
            te[6] += tx * te[8];
            te[1] += ty * te[2];
            te[4] += ty * te[5];
            te[7] += ty * te[8];
            return this;
        };
        _proto.equals = function equals(matrix) {
            var te = this.elements;
            var me = matrix.elements;
            for(var i1 = 0; i1 < 9; i1++){
                if (te[i1] !== me[i1]) return false;
            }
            return true;
        };
        _proto.fromArray = function fromArray(array, offset) {
            if (offset === void 0) offset = 0;
            for(var i1 = 0; i1 < 9; i1++)this.elements[i1] = array[i1 + offset];
            return this;
        };
        _proto.toArray = function toArray(array, offset) {
            if (array === void 0) array = [];
            if (offset === void 0) offset = 0;
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            return array;
        };
        return Matrix31;
    }();
    var _canvas;
    var ImageUtils = {
        getDataURL: function getDataURL(image) {
            if (/^data:/i.test(image.src)) return image.src;
            if (typeof HTMLCanvasElement == 'undefined') return image.src;
            var canvas;
            if (image instanceof HTMLCanvasElement) canvas = image;
            else {
                if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                _canvas.width = image.width;
                _canvas.height = image.height;
                var context = _canvas.getContext('2d');
                if (image instanceof ImageData) context.putImageData(image, 0, 0);
                else context.drawImage(image, 0, 0, image.width, image.height);
                canvas = _canvas;
            }
            if (canvas.width > 2048 || canvas.height > 2048) return canvas.toDataURL('image/jpeg', 0.6);
            else return canvas.toDataURL('image/png');
        }
    };
    var textureId = 0;
    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        if (image === void 0) image = Texture.DEFAULT_IMAGE;
        if (mapping === void 0) mapping = Texture.DEFAULT_MAPPING;
        if (wrapS === void 0) wrapS = ClampToEdgeWrapping;
        if (wrapT === void 0) wrapT = ClampToEdgeWrapping;
        if (magFilter === void 0) magFilter = LinearFilter;
        if (minFilter === void 0) minFilter = LinearMipmapLinearFilter;
        if (format === void 0) format = RGBAFormat;
        if (type === void 0) type = UnsignedByteType;
        if (anisotropy === void 0) anisotropy = 1;
        if (encoding === void 0) encoding = LinearEncoding;
        Object.defineProperty(this, 'id', {
            value: textureId++
        });
        this.uuid = MathUtils.generateUUID();
        this.name = '';
        this.image = image;
        this.mipmaps = [];
        this.mapping = mapping;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.anisotropy = anisotropy;
        this.format = format;
        this.internalFormat = null;
        this.type = type;
        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.center = new Vector2(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new Matrix3();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
        // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
        //
        // Also changing the encoding after already used by a Material will not automatically make the Material
        // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
        this.encoding = encoding;
        this.version = 0;
        this.onUpdate = null;
    }
    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: Texture,
        isTexture: true,
        updateMatrix: function updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        },
        clone: function clone() {
            return new this.constructor().copy(this);
        },
        copy: function copy(source) {
            this.name = source.name;
            this.image = source.image;
            this.mipmaps = source.mipmaps.slice(0);
            this.mapping = source.mapping;
            this.wrapS = source.wrapS;
            this.wrapT = source.wrapT;
            this.magFilter = source.magFilter;
            this.minFilter = source.minFilter;
            this.anisotropy = source.anisotropy;
            this.format = source.format;
            this.internalFormat = source.internalFormat;
            this.type = source.type;
            this.offset.copy(source.offset);
            this.repeat.copy(source.repeat);
            this.center.copy(source.center);
            this.rotation = source.rotation;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrix.copy(source.matrix);
            this.generateMipmaps = source.generateMipmaps;
            this.premultiplyAlpha = source.premultiplyAlpha;
            this.flipY = source.flipY;
            this.unpackAlignment = source.unpackAlignment;
            this.encoding = source.encoding;
            return this;
        },
        toJSON: function toJSON(meta) {
            var isRootObject = meta === undefined || typeof meta === 'string';
            if (!isRootObject && meta.textures[this.uuid] !== undefined) return meta.textures[this.uuid];
            var output = {
                metadata: {
                    version: 4.5,
                    type: 'Texture',
                    generator: 'Texture.toJSON'
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [
                    this.repeat.x,
                    this.repeat.y
                ],
                offset: [
                    this.offset.x,
                    this.offset.y
                ],
                center: [
                    this.center.x,
                    this.center.y
                ],
                rotation: this.rotation,
                wrap: [
                    this.wrapS,
                    this.wrapT
                ],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (this.image !== undefined) {
                // TODO: Move to THREE.Image
                var image = this.image;
                if (image.uuid === undefined) image.uuid = MathUtils.generateUUID(); // UGH
                if (!isRootObject && meta.images[image.uuid] === undefined) {
                    var url;
                    if (Array.isArray(image)) {
                        // process array of images e.g. CubeTexture
                        url = [];
                        for(var i1 = 0, l = image.length; i1 < l; i1++)// check cube texture with data textures
                        if (image[i1].isDataTexture) url.push(serializeImage(image[i1].image));
                        else url.push(serializeImage(image[i1]));
                    } else // process single image
                    url = serializeImage(image);
                    meta.images[image.uuid] = {
                        uuid: image.uuid,
                        url: url
                    };
                }
                output.image = image.uuid;
            }
            if (!isRootObject) meta.textures[this.uuid] = output;
            return output;
        },
        dispose: function dispose() {
            this.dispatchEvent({
                type: 'dispose'
            });
        },
        transformUv: function transformUv(uv) {
            if (this.mapping !== UVMapping) return uv;
            uv.applyMatrix3(this.matrix);
            if (uv.x < 0 || uv.x > 1) switch(this.wrapS){
                case RepeatWrapping:
                    uv.x = uv.x - Math.floor(uv.x);
                    break;
                case ClampToEdgeWrapping:
                    uv.x = uv.x < 0 ? 0 : 1;
                    break;
                case MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(uv.x) % 2) === 1) uv.x = Math.ceil(uv.x) - uv.x;
                    else uv.x = uv.x - Math.floor(uv.x);
                    break;
            }
            if (uv.y < 0 || uv.y > 1) switch(this.wrapT){
                case RepeatWrapping:
                    uv.y = uv.y - Math.floor(uv.y);
                    break;
                case ClampToEdgeWrapping:
                    uv.y = uv.y < 0 ? 0 : 1;
                    break;
                case MirroredRepeatWrapping:
                    if (Math.abs(Math.floor(uv.y) % 2) === 1) uv.y = Math.ceil(uv.y) - uv.y;
                    else uv.y = uv.y - Math.floor(uv.y);
                    break;
            }
            if (this.flipY) uv.y = 1 - uv.y;
            return uv;
        }
    });
    Object.defineProperty(Texture.prototype, 'needsUpdate', {
        set: function set(value) {
            if (value === true) this.version++;
        }
    });
    function serializeImage(image) {
        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) // default images
        return ImageUtils.getDataURL(image);
        else {
            if (image.data) // images of DataTexture
            return {
                data: Array.prototype.slice.call(image.data),
                width: image.width,
                height: image.height,
                type: image.data.constructor.name
            };
            else {
                console.warn('THREE.Texture: Unable to serialize Texture.');
                return {
                };
            }
        }
    }
    var Vector4 = /*#__PURE__*/ function() {
        function Vector41(x, y, z, w) {
            if (x === void 0) x = 0;
            if (y === void 0) y = 0;
            if (z === void 0) z = 0;
            if (w === void 0) w = 1;
            Object.defineProperty(this, 'isVector4', {
                value: true
            });
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        var _proto = Vector41.prototype;
        _proto.set = function set(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        _proto.setScalar = function setScalar(scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            this.w = scalar;
            return this;
        };
        _proto.setX = function setX(x) {
            this.x = x;
            return this;
        };
        _proto.setY = function setY(y) {
            this.y = y;
            return this;
        };
        _proto.setZ = function setZ(z) {
            this.z = z;
            return this;
        };
        _proto.setW = function setW(w) {
            this.w = w;
            return this;
        };
        _proto.setComponent = function setComponent(index, value) {
            switch(index){
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                case 3:
                    this.w = value;
                    break;
                default:
                    throw new Error('index is out of range: ' + index);
            }
            return this;
        };
        _proto.getComponent = function getComponent(index) {
            switch(index){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error('index is out of range: ' + index);
            }
        };
        _proto.clone = function clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        };
        _proto.copy = function copy(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = v.w !== undefined ? v.w : 1;
            return this;
        };
        _proto.add = function add(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;
            return this;
        };
        _proto.addScalar = function addScalar(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            this.w += s;
            return this;
        };
        _proto.addVectors = function addVectors(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this;
        };
        _proto.addScaledVector = function addScaledVector(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            this.w += v.w * s;
            return this;
        };
        _proto.sub = function sub(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;
            return this;
        };
        _proto.subScalar = function subScalar(s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            this.w -= s;
            return this;
        };
        _proto.subVectors = function subVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this;
        };
        _proto.multiply = function multiply(v) {
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            this.w *= v.w;
            return this;
        };
        _proto.multiplyScalar = function multiplyScalar(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;
            return this;
        };
        _proto.applyMatrix4 = function applyMatrix4(m) {
            var x = this.x, y = this.y, z = this.z, w = this.w;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
            this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
            return this;
        };
        _proto.divideScalar = function divideScalar(scalar) {
            return this.multiplyScalar(1 / scalar);
        };
        _proto.setAxisAngleFromQuaternion = function setAxisAngleFromQuaternion(q) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
            // q is assumed to be normalized
            this.w = 2 * Math.acos(q.w);
            var s = Math.sqrt(1 - q.w * q.w);
            if (s < 0.0001) {
                this.x = 1;
                this.y = 0;
                this.z = 0;
            } else {
                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
            }
            return this;
        };
        _proto.setAxisAngleFromRotationMatrix = function setAxisAngleFromRotationMatrix(m) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var angle, x, y, z; // variables for result
            var epsilon = 0.01, // margin to allow for rounding errors
            epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
            te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
                // singularity found
                // first check for identity matrix which must have +1 for all terms
                // in leading diagonal and zero in other terms
                if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                    // this singularity is identity matrix so angle = 0
                    this.set(1, 0, 0, 0);
                    return this; // zero angle, arbitrary axis
                } // otherwise this singularity is angle = 180
                angle = Math.PI;
                var xx = (m11 + 1) / 2;
                var yy = (m22 + 1) / 2;
                var zz = (m33 + 1) / 2;
                var xy = (m12 + m21) / 4;
                var xz = (m13 + m31) / 4;
                var yz = (m23 + m32) / 4;
                if (xx > yy && xx > zz) {
                    // m11 is the largest diagonal term
                    if (xx < epsilon) {
                        x = 0;
                        y = 0.707106781;
                        z = 0.707106781;
                    } else {
                        x = Math.sqrt(xx);
                        y = xy / x;
                        z = xz / x;
                    }
                } else if (yy > zz) {
                    // m22 is the largest diagonal term
                    if (yy < epsilon) {
                        x = 0.707106781;
                        y = 0;
                        z = 0.707106781;
                    } else {
                        y = Math.sqrt(yy);
                        x = xy / y;
                        z = yz / y;
                    }
                } else // m33 is the largest diagonal term so base result on this
                if (zz < epsilon) {
                    x = 0.707106781;
                    y = 0.707106781;
                    z = 0;
                } else {
                    z = Math.sqrt(zz);
                    x = xz / z;
                    y = yz / z;
                }
                this.set(x, y, z, angle);
                return this; // return 180 deg rotation
            } // as we have reached here there are no singularities so we can handle normally
            var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize
            if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
            // caught by singularity test above, but I've left it in just in case
            this.x = (m32 - m23) / s;
            this.y = (m13 - m31) / s;
            this.z = (m21 - m12) / s;
            this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
            return this;
        };
        _proto.min = function min(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            this.w = Math.min(this.w, v.w);
            return this;
        };
        _proto.max = function max(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            this.w = Math.max(this.w, v.w);
            return this;
        };
        _proto.clamp = function clamp(min1, max1) {
            // assumes min < max, componentwise
            this.x = Math.max(min1.x, Math.min(max1.x, this.x));
            this.y = Math.max(min1.y, Math.min(max1.y, this.y));
            this.z = Math.max(min1.z, Math.min(max1.z, this.z));
            this.w = Math.max(min1.w, Math.min(max1.w, this.w));
            return this;
        };
        _proto.clampScalar = function clampScalar(minVal, maxVal) {
            this.x = Math.max(minVal, Math.min(maxVal, this.x));
            this.y = Math.max(minVal, Math.min(maxVal, this.y));
            this.z = Math.max(minVal, Math.min(maxVal, this.z));
            this.w = Math.max(minVal, Math.min(maxVal, this.w));
            return this;
        };
        _proto.clampLength = function clampLength(min1, max1) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min1, Math.min(max1, length)));
        };
        _proto.floor = function floor() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            this.w = Math.floor(this.w);
            return this;
        };
        _proto.ceil = function ceil() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);
            return this;
        };
        _proto.round = function round() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            this.w = Math.round(this.w);
            return this;
        };
        _proto.roundToZero = function roundToZero() {
            this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
            return this;
        };
        _proto.negate = function negate() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
        };
        _proto.dot = function dot(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        };
        _proto.lengthSq = function lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        };
        _proto.length = function length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        };
        _proto.manhattanLength = function manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        };
        _proto.normalize = function normalize() {
            return this.divideScalar(this.length() || 1);
        };
        _proto.setLength = function setLength(length1) {
            return this.normalize().multiplyScalar(length1);
        };
        _proto.lerp = function lerp(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            this.w += (v.w - this.w) * alpha;
            return this;
        };
        _proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
            this.x = v1.x + (v2.x - v1.x) * alpha;
            this.y = v1.y + (v2.y - v1.y) * alpha;
            this.z = v1.z + (v2.z - v1.z) * alpha;
            this.w = v1.w + (v2.w - v1.w) * alpha;
            return this;
        };
        _proto.equals = function equals(v) {
            return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
        };
        _proto.fromArray = function fromArray(array, offset) {
            if (offset === void 0) offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
            return this;
        };
        _proto.toArray = function toArray(array, offset) {
            if (array === void 0) array = [];
            if (offset === void 0) offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            array[offset + 3] = this.w;
            return array;
        };
        _proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
            if (offset !== undefined) console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            this.w = attribute.getW(index);
            return this;
        };
        _proto.random = function random() {
            this.x = Math.random();
            this.y = Math.random();
            this.z = Math.random();
            this.w = Math.random();
            return this;
        };
        _createClass(Vector41, [
            {
                key: "width",
                get: function get() {
                    return this.z;
                },
                set: function set1(value) {
                    this.z = value;
                }
            },
            {
                key: "height",
                get: function get() {
                    return this.w;
                },
                set: function set1(value) {
                    this.w = value;
                }
            }
        ]);
        return Vector41;
    }();
    /*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/ var WebGLRenderTarget1 = /*#__PURE__*/ function(_EventDispatcher) {
        _inheritsLoose(WebGLRenderTarget2, _EventDispatcher);
        function WebGLRenderTarget2(width, height, options) {
            var _this;
            _this = _EventDispatcher.call(this) || this;
            Object.defineProperty(_assertThisInitialized(_this), 'isWebGLRenderTarget', {
                value: true
            });
            _this.width = width;
            _this.height = height;
            _this.scissor = new Vector4(0, 0, width, height);
            _this.scissorTest = false;
            _this.viewport = new Vector4(0, 0, width, height);
            options = options || {
            };
            _this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
            _this.texture.image = {
            };
            _this.texture.image.width = width;
            _this.texture.image.height = height;
            _this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
            _this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
            _this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
            _this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
            _this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
            return _this;
        }
        var _proto = WebGLRenderTarget2.prototype;
        _proto.setSize = function setSize(width, height) {
            if (this.width !== width || this.height !== height) {
                this.width = width;
                this.height = height;
                this.texture.image.width = width;
                this.texture.image.height = height;
                this.dispose();
            }
            this.viewport.set(0, 0, width, height);
            this.scissor.set(0, 0, width, height);
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(source) {
            this.width = source.width;
            this.height = source.height;
            this.viewport.copy(source.viewport);
            this.texture = source.texture.clone();
            this.depthBuffer = source.depthBuffer;
            this.stencilBuffer = source.stencilBuffer;
            this.depthTexture = source.depthTexture;
            return this;
        };
        _proto.dispose = function dispose() {
            this.dispatchEvent({
                type: 'dispose'
            });
        };
        return WebGLRenderTarget2;
    }(EventDispatcher);
    var WebGLMultisampleRenderTarget1 = /*#__PURE__*/ function(_WebGLRenderTarget) {
        _inheritsLoose(WebGLMultisampleRenderTarget2, _WebGLRenderTarget);
        function WebGLMultisampleRenderTarget2(width, height, options) {
            var _this;
            _this = _WebGLRenderTarget.call(this, width, height, options) || this;
            Object.defineProperty(_assertThisInitialized(_this), 'isWebGLMultisampleRenderTarget', {
                value: true
            });
            _this.samples = 4;
            return _this;
        }
        var _proto = WebGLMultisampleRenderTarget2.prototype;
        _proto.copy = function copy(source) {
            _WebGLRenderTarget.prototype.copy.call(this, source);
            this.samples = source.samples;
            return this;
        };
        return WebGLMultisampleRenderTarget2;
    }(WebGLRenderTarget1);
    var Quaternion = /*#__PURE__*/ function() {
        function Quaternion1(x, y, z, w) {
            if (x === void 0) x = 0;
            if (y === void 0) y = 0;
            if (z === void 0) z = 0;
            if (w === void 0) w = 1;
            Object.defineProperty(this, 'isQuaternion', {
                value: true
            });
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
        }
        Quaternion1.slerp = function slerp(qa, qb, qm, t) {
            return qm.copy(qa).slerp(qb, t);
        };
        Quaternion1.slerpFlat = function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
            // fuzz-free, array-based Quaternion SLERP operation
            var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
            var x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
            if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                var s = 1 - t;
                var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:
                if (sqrSin > Number.EPSILON) {
                    var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                    s = Math.sin(s * len) / sin;
                    t = Math.sin(t * len) / sin;
                }
                var tDir = t * dir;
                x0 = x0 * s + x1 * tDir;
                y0 = y0 * s + y1 * tDir;
                z0 = z0 * s + z1 * tDir;
                w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:
                if (s === 1 - t) {
                    var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                    x0 *= f;
                    y0 *= f;
                    z0 *= f;
                    w0 *= f;
                }
            }
            dst[dstOffset] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
        };
        Quaternion1.multiplyQuaternionsFlat = function multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
            var x0 = src0[srcOffset0];
            var y0 = src0[srcOffset0 + 1];
            var z0 = src0[srcOffset0 + 2];
            var w0 = src0[srcOffset0 + 3];
            var x1 = src1[srcOffset1];
            var y1 = src1[srcOffset1 + 1];
            var z1 = src1[srcOffset1 + 2];
            var w1 = src1[srcOffset1 + 3];
            dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
            dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
            dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
            dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
            return dst;
        };
        var _proto = Quaternion1.prototype;
        _proto.set = function set(x, y, z, w) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
            this._onChangeCallback();
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        };
        _proto.copy = function copy(quaternion) {
            this._x = quaternion.x;
            this._y = quaternion.y;
            this._z = quaternion.z;
            this._w = quaternion.w;
            this._onChangeCallback();
            return this;
        };
        _proto.setFromEuler = function setFromEuler(euler, update) {
            if (!(euler && euler.isEuler)) throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
            var x = euler._x, y = euler._y, z = euler._z, order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
            var cos = Math.cos;
            var sin = Math.sin;
            var c1 = cos(x / 2);
            var c2 = cos(y / 2);
            var c3 = cos(z / 2);
            var s1 = sin(x / 2);
            var s2 = sin(y / 2);
            var s3 = sin(z / 2);
            switch(order){
                case 'XYZ':
                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 'YXZ':
                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 'ZXY':
                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 'ZYX':
                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 'YZX':
                    this._x = s1 * c2 * c3 + c1 * s2 * s3;
                    this._y = c1 * s2 * c3 + s1 * c2 * s3;
                    this._z = c1 * c2 * s3 - s1 * s2 * c3;
                    this._w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 'XZY':
                    this._x = s1 * c2 * c3 - c1 * s2 * s3;
                    this._y = c1 * s2 * c3 - s1 * c2 * s3;
                    this._z = c1 * c2 * s3 + s1 * s2 * c3;
                    this._w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                default:
                    console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
            }
            if (update !== false) this._onChangeCallback();
            return this;
        };
        _proto.setFromAxisAngle = function setFromAxisAngle(axis, angle) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
            // assumes axis is normalized
            var halfAngle = angle / 2, s = Math.sin(halfAngle);
            this._x = axis.x * s;
            this._y = axis.y * s;
            this._z = axis.z * s;
            this._w = Math.cos(halfAngle);
            this._onChangeCallback();
            return this;
        };
        _proto.setFromRotationMatrix = function setFromRotationMatrix(m) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
            if (trace > 0) {
                var s = 0.5 / Math.sqrt(trace + 1);
                this._w = 0.25 / s;
                this._x = (m32 - m23) * s;
                this._y = (m13 - m31) * s;
                this._z = (m21 - m12) * s;
            } else if (m11 > m22 && m11 > m33) {
                var _s = 2 * Math.sqrt(1 + m11 - m22 - m33);
                this._w = (m32 - m23) / _s;
                this._x = 0.25 * _s;
                this._y = (m12 + m21) / _s;
                this._z = (m13 + m31) / _s;
            } else if (m22 > m33) {
                var _s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
                this._w = (m13 - m31) / _s2;
                this._x = (m12 + m21) / _s2;
                this._y = 0.25 * _s2;
                this._z = (m23 + m32) / _s2;
            } else {
                var _s3 = 2 * Math.sqrt(1 + m33 - m11 - m22);
                this._w = (m21 - m12) / _s3;
                this._x = (m13 + m31) / _s3;
                this._y = (m23 + m32) / _s3;
                this._z = 0.25 * _s3;
            }
            this._onChangeCallback();
            return this;
        };
        _proto.setFromUnitVectors = function setFromUnitVectors(vFrom, vTo) {
            // assumes direction vectors vFrom and vTo are normalized
            var EPS = 0.000001;
            var r = vFrom.dot(vTo) + 1;
            if (r < EPS) {
                r = 0;
                if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                    this._x = -vFrom.y;
                    this._y = vFrom.x;
                    this._z = 0;
                    this._w = r;
                } else {
                    this._x = 0;
                    this._y = -vFrom.z;
                    this._z = vFrom.y;
                    this._w = r;
                }
            } else {
                // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
                this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
                this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
                this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
                this._w = r;
            }
            return this.normalize();
        };
        _proto.angleTo = function angleTo(q) {
            return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
        };
        _proto.rotateTowards = function rotateTowards(q, step) {
            var angle = this.angleTo(q);
            if (angle === 0) return this;
            var t = Math.min(1, step / angle);
            this.slerp(q, t);
            return this;
        };
        _proto.identity = function identity() {
            return this.set(0, 0, 0, 1);
        };
        _proto.invert = function invert() {
            // quaternion is assumed to have unit length
            return this.conjugate();
        };
        _proto.conjugate = function conjugate() {
            this._x *= -1;
            this._y *= -1;
            this._z *= -1;
            this._onChangeCallback();
            return this;
        };
        _proto.dot = function dot(v) {
            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        };
        _proto.lengthSq = function lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        };
        _proto.length = function length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        };
        _proto.normalize = function normalize() {
            var l = this.length();
            if (l === 0) {
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
            } else {
                l = 1 / l;
                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
            }
            this._onChangeCallback();
            return this;
        };
        _proto.multiply = function multiply(q, p) {
            if (p !== undefined) {
                console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
                return this.multiplyQuaternions(q, p);
            }
            return this.multiplyQuaternions(this, q);
        };
        _proto.premultiply = function premultiply(q) {
            return this.multiplyQuaternions(q, this);
        };
        _proto.multiplyQuaternions = function multiplyQuaternions(a, b) {
            // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
            var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
            var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
            this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
            this._onChangeCallback();
            return this;
        };
        _proto.slerp = function slerp1(qb, t) {
            if (t === 0) return this;
            if (t === 1) return this.copy(qb);
            var x = this._x, y = this._y, z = this._z, w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
            if (cosHalfTheta < 0) {
                this._w = -qb._w;
                this._x = -qb._x;
                this._y = -qb._y;
                this._z = -qb._z;
                cosHalfTheta = -cosHalfTheta;
            } else this.copy(qb);
            if (cosHalfTheta >= 1) {
                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;
                return this;
            }
            var sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
            if (sqrSinHalfTheta <= Number.EPSILON) {
                var s = 1 - t;
                this._w = s * w + t * this._w;
                this._x = s * x + t * this._x;
                this._y = s * y + t * this._y;
                this._z = s * z + t * this._z;
                this.normalize();
                this._onChangeCallback();
                return this;
            }
            var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            this._w = w * ratioA + this._w * ratioB;
            this._x = x * ratioA + this._x * ratioB;
            this._y = y * ratioA + this._y * ratioB;
            this._z = z * ratioA + this._z * ratioB;
            this._onChangeCallback();
            return this;
        };
        _proto.equals = function equals(quaternion) {
            return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        };
        _proto.fromArray = function fromArray(array, offset) {
            if (offset === void 0) offset = 0;
            this._x = array[offset];
            this._y = array[offset + 1];
            this._z = array[offset + 2];
            this._w = array[offset + 3];
            this._onChangeCallback();
            return this;
        };
        _proto.toArray = function toArray(array, offset) {
            if (array === void 0) array = [];
            if (offset === void 0) offset = 0;
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._w;
            return array;
        };
        _proto.fromBufferAttribute = function fromBufferAttribute(attribute, index) {
            this._x = attribute.getX(index);
            this._y = attribute.getY(index);
            this._z = attribute.getZ(index);
            this._w = attribute.getW(index);
            return this;
        };
        _proto._onChange = function _onChange(callback) {
            this._onChangeCallback = callback;
            return this;
        };
        _proto._onChangeCallback = function _onChangeCallback() {
        };
        _createClass(Quaternion1, [
            {
                key: "x",
                get: function get() {
                    return this._x;
                },
                set: function set1(value) {
                    this._x = value;
                    this._onChangeCallback();
                }
            },
            {
                key: "y",
                get: function get() {
                    return this._y;
                },
                set: function set1(value) {
                    this._y = value;
                    this._onChangeCallback();
                }
            },
            {
                key: "z",
                get: function get() {
                    return this._z;
                },
                set: function set1(value) {
                    this._z = value;
                    this._onChangeCallback();
                }
            },
            {
                key: "w",
                get: function get() {
                    return this._w;
                },
                set: function set1(value) {
                    this._w = value;
                    this._onChangeCallback();
                }
            }
        ]);
        return Quaternion1;
    }();
    var Vector3 = /*#__PURE__*/ function() {
        function Vector31(x, y, z) {
            if (x === void 0) x = 0;
            if (y === void 0) y = 0;
            if (z === void 0) z = 0;
            Object.defineProperty(this, 'isVector3', {
                value: true
            });
            this.x = x;
            this.y = y;
            this.z = z;
        }
        var _proto = Vector31.prototype;
        _proto.set = function set(x, y, z) {
            if (z === undefined) z = this.z; // sprite.scale.set(x,y)
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        _proto.setScalar = function setScalar(scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            return this;
        };
        _proto.setX = function setX(x) {
            this.x = x;
            return this;
        };
        _proto.setY = function setY(y) {
            this.y = y;
            return this;
        };
        _proto.setZ = function setZ(z) {
            this.z = z;
            return this;
        };
        _proto.setComponent = function setComponent(index, value) {
            switch(index){
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                default:
                    throw new Error('index is out of range: ' + index);
            }
            return this;
        };
        _proto.getComponent = function getComponent(index) {
            switch(index){
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error('index is out of range: ' + index);
            }
        };
        _proto.clone = function clone() {
            return new this.constructor(this.x, this.y, this.z);
        };
        _proto.copy = function copy(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        };
        _proto.add = function add(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            return this;
        };
        _proto.addScalar = function addScalar(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            return this;
        };
        _proto.addVectors = function addVectors(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this;
        };
        _proto.addScaledVector = function addScaledVector(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            return this;
        };
        _proto.sub = function sub(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            return this;
        };
        _proto.subScalar = function subScalar(s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            return this;
        };
        _proto.subVectors = function subVectors(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this;
        };
        _proto.multiply = function multiply(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
                return this.multiplyVectors(v, w);
            }
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            return this;
        };
        _proto.multiplyScalar = function multiplyScalar(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            return this;
        };
        _proto.multiplyVectors = function multiplyVectors(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this;
        };
        _proto.applyEuler = function applyEuler(euler) {
            if (!(euler && euler.isEuler)) console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
            return this.applyQuaternion(_quaternion.setFromEuler(euler));
        };
        _proto.applyAxisAngle = function applyAxisAngle(axis, angle) {
            return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
        };
        _proto.applyMatrix3 = function applyMatrix3(m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;
            return this;
        };
        _proto.applyNormalMatrix = function applyNormalMatrix(m) {
            return this.applyMatrix3(m).normalize();
        };
        _proto.applyMatrix4 = function applyMatrix4(m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
            this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
            this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
            this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
            return this;
        };
        _proto.applyQuaternion = function applyQuaternion(q) {
            var x = this.x, y = this.y, z = this.z;
            var qx = q.x, qy = q.y, qz = q.z, qw = q.w; // calculate quat * vector
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        };
        _proto.project = function project(camera) {
            return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
        };
        _proto.unproject = function unproject(camera) {
            return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
        };
        _proto.transformDirection = function transformDirection(m) {
            // input: THREE.Matrix4 affine matrix
            // vector interpreted as a direction
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z;
            this.y = e[1] * x + e[5] * y + e[9] * z;
            this.z = e[2] * x + e[6] * y + e[10] * z;
            return this.normalize();
        };
        _proto.divide = function divide(v) {
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
            return this;
        };
        _proto.divideScalar = function divideScalar(scalar) {
            return this.multiplyScalar(1 / scalar);
        };
        _proto.min = function min(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            return this;
        };
        _proto.max = function max(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            return this;
        };
        _proto.clamp = function clamp(min1, max1) {
            // assumes min < max, componentwise
            this.x = Math.max(min1.x, Math.min(max1.x, this.x));
            this.y = Math.max(min1.y, Math.min(max1.y, this.y));
            this.z = Math.max(min1.z, Math.min(max1.z, this.z));
            return this;
        };
        _proto.clampScalar = function clampScalar(minVal, maxVal) {
            this.x = Math.max(minVal, Math.min(maxVal, this.x));
            this.y = Math.max(minVal, Math.min(maxVal, this.y));
            this.z = Math.max(minVal, Math.min(maxVal, this.z));
            return this;
        };
        _proto.clampLength = function clampLength(min1, max1) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min1, Math.min(max1, length)));
        };
        _proto.floor = function floor() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this;
        };
        _proto.ceil = function ceil() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this;
        };
        _proto.round = function round() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this;
        };
        _proto.roundToZero = function roundToZero() {
            this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
            return this;
        };
        _proto.negate = function negate() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        };
        _proto.dot = function dot(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        };
        _proto.lengthSq = function lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        };
        _proto.length = function length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        };
        _proto.manhattanLength = function manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        };
        _proto.normalize = function normalize() {
            return this.divideScalar(this.length() || 1);
        };
        _proto.setLength = function setLength(length1) {
            return this.normalize().multiplyScalar(length1);
        };
        _proto.lerp = function lerp(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            return this;
        };
        _proto.lerpVectors = function lerpVectors(v1, v2, alpha) {
            this.x = v1.x + (v2.x - v1.x) * alpha;
            this.y = v1.y + (v2.y - v1.y) * alpha;
            this.z = v1.z + (v2.z - v1.z) * alpha;
            return this;
        };
        _proto.cross = function cross(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
                return this.crossVectors(v, w);
            }
            return this.crossVectors(this, v);
        };
        _proto.crossVectors = function crossVectors(a, b) {
            var ax = a.x, ay = a.y, az = a.z;
            var bx = b.x, by = b.y, bz = b.z;
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
            return this;
        };
        _proto.projectOnVector = function projectOnVector(v) {
            var denominator = v.lengthSq();
            if (denominator === 0) return this.set(0, 0, 0);
            var scalar = v.dot(this) / denominator;
            return this.copy(v).multiplyScalar(scalar);
        };
        _proto.projectOnPlane = function projectOnPlane(planeNormal) {
            _vector.copy(this).projectOnVector(planeNormal);
            return this.sub(_vector);
        };
        _proto.reflect = function reflect(normal) {
            // reflect incident vector off plane orthogonal to normal
            // normal is assumed to have unit length
            return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
        };
        _proto.angleTo = function angleTo(v) {
            var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
            if (denominator === 0) return Math.PI / 2;
            var theta = this.dot(v) / denominator; // clamp, to handle numerical problems
            return Math.acos(MathUtils.clamp(theta, -1, 1));
        };
        _proto.distanceTo = function distanceTo(v) {
            return Math.sqrt(this.distanceToSquared(v));
        };
        _proto.distanceToSquared = function distanceToSquared(v) {
            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        };
        _proto.manhattanDistanceTo = function manhattanDistanceTo(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        };
        _proto.setFromSpherical = function setFromSpherical(s) {
            return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
        };
        _proto.setFromSphericalCoords = function setFromSphericalCoords(radius, phi, theta) {
            var sinPhiRadius = Math.sin(phi) * radius;
            this.x = sinPhiRadius * Math.sin(theta);
            this.y = Math.cos(phi) * radius;
            this.z = sinPhiRadius * Math.cos(theta);
            return this;
        };
        _proto.setFromCylindrical = function setFromCylindrical(c) {
            return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
        };
        _proto.setFromCylindricalCoords = function setFromCylindricalCoords(radius, theta, y) {
            this.x = radius * Math.sin(theta);
            this.y = y;
            this.z = radius * Math.cos(theta);
            return this;
        };
        _proto.setFromMatrixPosition = function setFromMatrixPosition(m) {
            var e = m.elements;
            this.x = e[12];
            this.y = e[13];
            this.z = e[14];
            return this;
        };
        _proto.setFromMatrixScale = function setFromMatrixScale(m) {
            var sx = this.setFromMatrixColumn(m, 0).length();
            var sy = this.setFromMatrixColumn(m, 1).length();
            var sz = this.setFromMatrixColumn(m, 2).length();
            this.x = sx;
            this.y = sy;
            this.z = sz;
            return this;
        };
        _proto.setFromMatrixColumn = function setFromMatrixColumn(m, index) {
            return this.fromArray(m.elements, index * 4);
        };
        _proto.setFromMatrix3Column = function setFromMatrix3Column(m, index) {
            return this.fromArray(m.elements, index * 3);
        };
        _proto.equals = function equals(v) {
            return v.x === this.x && v.y === this.y && v.z === this.z;
        };
        _proto.fromArray = function fromArray(array, offset) {
            if (offset === void 0) offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
        };
        _proto.toArray = function toArray(array, offset) {
            if (array === void 0) array = [];
            if (offset === void 0) offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            return array;
        };
        _proto.fromBufferAttribute = function fromBufferAttribute(attribute, index, offset) {
            if (offset !== undefined) console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            return this;
        };
        _proto.random = function random() {
            this.x = Math.random();
            this.y = Math.random();
            this.z = Math.random();
            return this;
        };
        return Vector31;
    }();
    var _vector = /*@__PURE__*/ new Vector3();
    var _quaternion = /*@__PURE__*/ new Quaternion();
    var Box3 = /*#__PURE__*/ function() {
        function Box31(min, max) {
            Object.defineProperty(this, 'isBox3', {
                value: true
            });
            this.min = min !== undefined ? min : new Vector3(Infinity, Infinity, Infinity);
            this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
        }
        var _proto = Box31.prototype;
        _proto.set = function set(min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        };
        _proto.setFromArray = function setFromArray(array) {
            var minX = Infinity;
            var minY = Infinity;
            var minZ = Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for(var i2 = 0, l = array.length; i2 < l; i2 += 3){
                var x = array[i2];
                var y = array[i2 + 1];
                var z = array[i2 + 2];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (z < minZ) minZ = z;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                if (z > maxZ) maxZ = z;
            }
            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);
            return this;
        };
        _proto.setFromBufferAttribute = function setFromBufferAttribute(attribute) {
            var minX = Infinity;
            var minY = Infinity;
            var minZ = Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for(var i2 = 0, l = attribute.count; i2 < l; i2++){
                var x = attribute.getX(i2);
                var y = attribute.getY(i2);
                var z = attribute.getZ(i2);
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (z < minZ) minZ = z;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                if (z > maxZ) maxZ = z;
            }
            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);
            return this;
        };
        _proto.setFromPoints = function setFromPoints(points) {
            this.makeEmpty();
            for(var i2 = 0, il = points.length; i2 < il; i2++)this.expandByPoint(points[i2]);
            return this;
        };
        _proto.setFromCenterAndSize = function setFromCenterAndSize(center, size) {
            var halfSize = _vector$1.copy(size).multiplyScalar(0.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        };
        _proto.setFromObject = function setFromObject(object) {
            this.makeEmpty();
            return this.expandByObject(object);
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        };
        _proto.makeEmpty = function makeEmpty() {
            this.min.x = this.min.y = this.min.z = Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this;
        };
        _proto.isEmpty = function isEmpty() {
            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        };
        _proto.getCenter = function getCenter(target) {
            if (target === undefined) {
                console.warn('THREE.Box3: .getCenter() target is now required');
                target = new Vector3();
            }
            return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        };
        _proto.getSize = function getSize(target) {
            if (target === undefined) {
                console.warn('THREE.Box3: .getSize() target is now required');
                target = new Vector3();
            }
            return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
        };
        _proto.expandByPoint = function expandByPoint(point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        };
        _proto.expandByVector = function expandByVector(vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        };
        _proto.expandByScalar = function expandByScalar(scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        };
        _proto.expandByObject = function expandByObject(object) {
            // Computes the world-axis-aligned bounding box of an object (including its children),
            // accounting for both the object's, and children's, world transforms
            object.updateWorldMatrix(false, false);
            var geometry = object.geometry;
            if (geometry !== undefined) {
                if (geometry.boundingBox === null) geometry.computeBoundingBox();
                _box.copy(geometry.boundingBox);
                _box.applyMatrix4(object.matrixWorld);
                this.union(_box);
            }
            var children = object.children;
            for(var i2 = 0, l = children.length; i2 < l; i2++)this.expandByObject(children[i2]);
            return this;
        };
        _proto.containsPoint = function containsPoint(point) {
            return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        };
        _proto.containsBox = function containsBox(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        };
        _proto.getParameter = function getParameter(point, target) {
            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.
            if (target === undefined) {
                console.warn('THREE.Box3: .getParameter() target is now required');
                target = new Vector3();
            }
            return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        };
        _proto.intersectsBox = function intersectsBox(box) {
            // using 6 splitting planes to rule out intersections.
            return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        };
        _proto.intersectsSphere = function intersectsSphere(sphere) {
            // Find the point on the AABB closest to the sphere center.
            this.clampPoint(sphere.center, _vector$1); // If that point is inside the sphere, the AABB and sphere intersect.
            return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
        };
        _proto.intersectsPlane = function intersectsPlane(plane) {
            // We compute the minimum and maximum dot product values. If those values
            // are on the same side (back or front) of the plane, then there is no intersection.
            var min, max;
            if (plane.normal.x > 0) {
                min = plane.normal.x * this.min.x;
                max = plane.normal.x * this.max.x;
            } else {
                min = plane.normal.x * this.max.x;
                max = plane.normal.x * this.min.x;
            }
            if (plane.normal.y > 0) {
                min += plane.normal.y * this.min.y;
                max += plane.normal.y * this.max.y;
            } else {
                min += plane.normal.y * this.max.y;
                max += plane.normal.y * this.min.y;
            }
            if (plane.normal.z > 0) {
                min += plane.normal.z * this.min.z;
                max += plane.normal.z * this.max.z;
            } else {
                min += plane.normal.z * this.max.z;
                max += plane.normal.z * this.min.z;
            }
            return min <= -plane.constant && max >= -plane.constant;
        };
        _proto.intersectsTriangle = function intersectsTriangle(triangle) {
            if (this.isEmpty()) return false;
             // compute box center and extents
            this.getCenter(_center);
            _extents.subVectors(this.max, _center); // translate triangle to aabb origin
            _v0.subVectors(triangle.a, _center);
            _v1.subVectors(triangle.b, _center);
            _v2.subVectors(triangle.c, _center); // compute edge vectors for triangle
            _f0.subVectors(_v1, _v0);
            _f1.subVectors(_v2, _v1);
            _f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
            // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
            // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
            var axes = [
                0,
                -_f0.z,
                _f0.y,
                0,
                -_f1.z,
                _f1.y,
                0,
                -_f2.z,
                _f2.y,
                _f0.z,
                0,
                -_f0.x,
                _f1.z,
                0,
                -_f1.x,
                _f2.z,
                0,
                -_f2.x,
                -_f0.y,
                _f0.x,
                0,
                -_f1.y,
                _f1.x,
                0,
                -_f2.y,
                _f2.x,
                0
            ];
            if (!satForAxes(axes, _v0, _v1, _v2, _extents)) return false;
             // test 3 face normals from the aabb
            axes = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ];
            if (!satForAxes(axes, _v0, _v1, _v2, _extents)) return false;
             // finally testing the face normal of the triangle
            // use already existing triangle edge vectors here
            _triangleNormal.crossVectors(_f0, _f1);
            axes = [
                _triangleNormal.x,
                _triangleNormal.y,
                _triangleNormal.z
            ];
            return satForAxes(axes, _v0, _v1, _v2, _extents);
        };
        _proto.clampPoint = function clampPoint(point, target) {
            if (target === undefined) {
                console.warn('THREE.Box3: .clampPoint() target is now required');
                target = new Vector3();
            }
            return target.copy(point).clamp(this.min, this.max);
        };
        _proto.distanceToPoint = function distanceToPoint(point) {
            var clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
            return clampedPoint.sub(point).length();
        };
        _proto.getBoundingSphere = function getBoundingSphere(target) {
            if (target === undefined) console.error('THREE.Box3: .getBoundingSphere() target is now required'); //target = new Sphere(); // removed to avoid cyclic dependency
            this.getCenter(target.center);
            target.radius = this.getSize(_vector$1).length() * 0.5;
            return target;
        };
        _proto.intersect = function intersect(box) {
            this.min.max(box.min);
            this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
            if (this.isEmpty()) this.makeEmpty();
            return this;
        };
        _proto.union = function union(box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        };
        _proto.applyMatrix4 = function applyMatrix4(matrix) {
            // transform of empty box is an empty box.
            if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
            _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
            _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
            _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
            _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
            _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
            _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
            _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
            this.setFromPoints(_points);
            return this;
        };
        _proto.translate = function translate(offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        };
        _proto.equals = function equals(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        };
        return Box31;
    }();
    function satForAxes(axes, v0, v1, v2, extents) {
        for(var i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3){
            _testAxis.fromArray(axes, i2); // project the aabb onto the seperating axis
            var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis
            var p0 = v0.dot(_testAxis);
            var p1 = v1.dot(_testAxis);
            var p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r
            if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) // points of the projected triangle are outside the projected half-length of the aabb
            // the axis is seperating and we can exit
            return false;
        }
        return true;
    }
    var _points = [
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3(),
        /*@__PURE__*/ new Vector3()
    ];
    var _vector$1 = /*@__PURE__*/ new Vector3();
    var _box = /*@__PURE__*/ new Box3(); // triangle centered vertices
    var _v0 = /*@__PURE__*/ new Vector3();
    var _v1 = /*@__PURE__*/ new Vector3();
    var _v2 = /*@__PURE__*/ new Vector3(); // triangle edge vectors
    var _f0 = /*@__PURE__*/ new Vector3();
    var _f1 = /*@__PURE__*/ new Vector3();
    var _f2 = /*@__PURE__*/ new Vector3();
    var _center = /*@__PURE__*/ new Vector3();
    var _extents = /*@__PURE__*/ new Vector3();
    var _triangleNormal = /*@__PURE__*/ new Vector3();
    var _testAxis = /*@__PURE__*/ new Vector3();
    var _box$1 = /*@__PURE__*/ new Box3();
    var Sphere = /*#__PURE__*/ function() {
        function Sphere1(center, radius) {
            this.center = center !== undefined ? center : new Vector3();
            this.radius = radius !== undefined ? radius : -1;
        }
        var _proto = Sphere1.prototype;
        _proto.set = function set(center, radius) {
            this.center.copy(center);
            this.radius = radius;
            return this;
        };
        _proto.setFromPoints = function setFromPoints(points, optionalCenter) {
            var center = this.center;
            if (optionalCenter !== undefined) center.copy(optionalCenter);
            else _box$1.setFromPoints(points).getCenter(center);
            var maxRadiusSq = 0;
            for(var i2 = 0, il = points.length; i2 < il; i2++)maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
            this.radius = Math.sqrt(maxRadiusSq);
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(sphere) {
            this.center.copy(sphere.center);
            this.radius = sphere.radius;
            return this;
        };
        _proto.isEmpty = function isEmpty() {
            return this.radius < 0;
        };
        _proto.makeEmpty = function makeEmpty() {
            this.center.set(0, 0, 0);
            this.radius = -1;
            return this;
        };
        _proto.containsPoint = function containsPoint(point) {
            return point.distanceToSquared(this.center) <= this.radius * this.radius;
        };
        _proto.distanceToPoint = function distanceToPoint(point) {
            return point.distanceTo(this.center) - this.radius;
        };
        _proto.intersectsSphere = function intersectsSphere(sphere) {
            var radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        };
        _proto.intersectsBox = function intersectsBox(box) {
            return box.intersectsSphere(this);
        };
        _proto.intersectsPlane = function intersectsPlane(plane) {
            return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        };
        _proto.clampPoint = function clampPoint(point, target) {
            var deltaLengthSq = this.center.distanceToSquared(point);
            if (target === undefined) {
                console.warn('THREE.Sphere: .clampPoint() target is now required');
                target = new Vector3();
            }
            target.copy(point);
            if (deltaLengthSq > this.radius * this.radius) {
                target.sub(this.center).normalize();
                target.multiplyScalar(this.radius).add(this.center);
            }
            return target;
        };
        _proto.getBoundingBox = function getBoundingBox(target) {
            if (target === undefined) {
                console.warn('THREE.Sphere: .getBoundingBox() target is now required');
                target = new Box3();
            }
            if (this.isEmpty()) {
                // Empty sphere produces empty bounding box
                target.makeEmpty();
                return target;
            }
            target.set(this.center, this.center);
            target.expandByScalar(this.radius);
            return target;
        };
        _proto.applyMatrix4 = function applyMatrix4(matrix) {
            this.center.applyMatrix4(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        };
        _proto.translate = function translate(offset) {
            this.center.add(offset);
            return this;
        };
        _proto.equals = function equals(sphere) {
            return sphere.center.equals(this.center) && sphere.radius === this.radius;
        };
        return Sphere1;
    }();
    var _vector$2 = /*@__PURE__*/ new Vector3();
    var _segCenter = /*@__PURE__*/ new Vector3();
    var _segDir = /*@__PURE__*/ new Vector3();
    var _diff = /*@__PURE__*/ new Vector3();
    var _edge1 = /*@__PURE__*/ new Vector3();
    var _edge2 = /*@__PURE__*/ new Vector3();
    var _normal = /*@__PURE__*/ new Vector3();
    var Ray = /*#__PURE__*/ function() {
        function Ray1(origin, direction) {
            this.origin = origin !== undefined ? origin : new Vector3();
            this.direction = direction !== undefined ? direction : new Vector3(0, 0, -1);
        }
        var _proto = Ray1.prototype;
        _proto.set = function set(origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(ray) {
            this.origin.copy(ray.origin);
            this.direction.copy(ray.direction);
            return this;
        };
        _proto.at = function at(t, target) {
            if (target === undefined) {
                console.warn('THREE.Ray: .at() target is now required');
                target = new Vector3();
            }
            return target.copy(this.direction).multiplyScalar(t).add(this.origin);
        };
        _proto.lookAt = function lookAt(v) {
            this.direction.copy(v).sub(this.origin).normalize();
            return this;
        };
        _proto.recast = function recast(t) {
            this.origin.copy(this.at(t, _vector$2));
            return this;
        };
        _proto.closestPointToPoint = function closestPointToPoint(point, target) {
            if (target === undefined) {
                console.warn('THREE.Ray: .closestPointToPoint() target is now required');
                target = new Vector3();
            }
            target.subVectors(point, this.origin);
            var directionDistance = target.dot(this.direction);
            if (directionDistance < 0) return target.copy(this.origin);
            return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        };
        _proto.distanceToPoint = function distanceToPoint(point) {
            return Math.sqrt(this.distanceSqToPoint(point));
        };
        _proto.distanceSqToPoint = function distanceSqToPoint(point) {
            var directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction); // point behind the ray
            if (directionDistance < 0) return this.origin.distanceToSquared(point);
            _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
            return _vector$2.distanceToSquared(point);
        };
        _proto.distanceSqToSegment = function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
            // It returns the min distance between the ray and the segment
            // defined by v0 and v1
            // It can also set two optional targets :
            // - The closest point on the ray
            // - The closest point on the segment
            _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
            _segDir.copy(v1).sub(v0).normalize();
            _diff.copy(this.origin).sub(_segCenter);
            var segExtent = v0.distanceTo(v1) * 0.5;
            var a01 = -this.direction.dot(_segDir);
            var b0 = _diff.dot(this.direction);
            var b1 = -_diff.dot(_segDir);
            var c = _diff.lengthSq();
            var det = Math.abs(1 - a01 * a01);
            var s0, s1, sqrDist, extDet;
            if (det > 0) {
                // The ray and segment are not parallel.
                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;
                if (s0 >= 0) {
                    if (s1 >= -extDet) {
                        if (s1 <= extDet) {
                            // region 0
                            // Minimum at interior points of ray and segment.
                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                        } else {
                            // region 1
                            s1 = segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    } else {
                        // region 5
                        s1 = -segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    if (s1 <= -extDet) {
                        // region 4
                        s0 = Math.max(0, -(-a01 * segExtent + b0));
                        s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    } else if (s1 <= extDet) {
                        // region 3
                        s0 = 0;
                        s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = s1 * (s1 + 2 * b1) + c;
                    } else {
                        // region 2
                        s0 = Math.max(0, -(a01 * segExtent + b0));
                        s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
            } else {
                // Ray and segment are parallel.
                s1 = a01 > 0 ? -segExtent : segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
            if (optionalPointOnRay) optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
            if (optionalPointOnSegment) optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
            return sqrDist;
        };
        _proto.intersectSphere = function intersectSphere(sphere, target) {
            _vector$2.subVectors(sphere.center, this.origin);
            var tca = _vector$2.dot(this.direction);
            var d2 = _vector$2.dot(_vector$2) - tca * tca;
            var radius2 = sphere.radius * sphere.radius;
            if (d2 > radius2) return null;
            var thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null
            if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0
            return this.at(t0, target);
        };
        _proto.intersectsSphere = function intersectsSphere(sphere) {
            return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
        };
        _proto.distanceToPlane = function distanceToPlane(plane) {
            var denominator = plane.normal.dot(this.direction);
            if (denominator === 0) {
                // line is coplanar, return origin
                if (plane.distanceToPoint(this.origin) === 0) return 0;
                 // Null is preferable to undefined since undefined means.... it is undefined
                return null;
            }
            var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane
            return t >= 0 ? t : null;
        };
        _proto.intersectPlane = function intersectPlane(plane, target) {
            var t = this.distanceToPlane(plane);
            if (t === null) return null;
            return this.at(t, target);
        };
        _proto.intersectsPlane = function intersectsPlane(plane) {
            // check if the ray lies on the plane first
            var distToPoint = plane.distanceToPoint(this.origin);
            if (distToPoint === 0) return true;
            var denominator = plane.normal.dot(this.direction);
            if (denominator * distToPoint < 0) return true;
             // ray origin is behind the plane (and is pointing behind it)
            return false;
        };
        _proto.intersectBox = function intersectBox(box, target) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
            var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
            var origin = this.origin;
            if (invdirx >= 0) {
                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;
            } else {
                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
            }
            if (invdiry >= 0) {
                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;
            } else {
                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
            }
            if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
            // (result of 0 * Infinity). x !== x returns true if x is NaN
            if (tymin > tmin || tmin !== tmin) tmin = tymin;
            if (tymax < tmax || tmax !== tmax) tmax = tymax;
            if (invdirz >= 0) {
                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;
            } else {
                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
            }
            if (tmin > tzmax || tzmin > tmax) return null;
            if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
            if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)
            if (tmax < 0) return null;
            return this.at(tmin >= 0 ? tmin : tmax, target);
        };
        _proto.intersectsBox = function intersectsBox(box) {
            return this.intersectBox(box, _vector$2) !== null;
        };
        _proto.intersectTriangle = function intersectTriangle(a, b, c, backfaceCulling, target) {
            // Compute the offset origin, edges, and normal.
            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
            _edge1.subVectors(b, a);
            _edge2.subVectors(c, a);
            _normal.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //	 |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //	 |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //	 |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = this.direction.dot(_normal);
            var sign;
            if (DdN > 0) {
                if (backfaceCulling) return null;
                sign = 1;
            } else if (DdN < 0) {
                sign = -1;
                DdN = -DdN;
            } else return null;
            _diff.subVectors(this.origin, a);
            var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection
            if (DdQxE2 < 0) return null;
            var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection
            if (DdE1xQ < 0) return null;
             // b1+b2 > 1, no intersection
            if (DdQxE2 + DdE1xQ > DdN) return null;
             // Line intersects triangle, check if ray does.
            var QdN = -sign * _diff.dot(_normal); // t < 0, no intersection
            if (QdN < 0) return null;
             // Ray intersects triangle.
            return this.at(QdN / DdN, target);
        };
        _proto.applyMatrix4 = function applyMatrix4(matrix4) {
            this.origin.applyMatrix4(matrix4);
            this.direction.transformDirection(matrix4);
            return this;
        };
        _proto.equals = function equals(ray) {
            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        };
        return Ray1;
    }();
    var Matrix4 = /*#__PURE__*/ function() {
        function Matrix41() {
            Object.defineProperty(this, 'isMatrix4', {
                value: true
            });
            this.elements = [
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                1
            ];
            if (arguments.length > 0) console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
        }
        var _proto = Matrix41.prototype;
        _proto.set = function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements;
            te[0] = n11;
            te[4] = n12;
            te[8] = n13;
            te[12] = n14;
            te[1] = n21;
            te[5] = n22;
            te[9] = n23;
            te[13] = n24;
            te[2] = n31;
            te[6] = n32;
            te[10] = n33;
            te[14] = n34;
            te[3] = n41;
            te[7] = n42;
            te[11] = n43;
            te[15] = n44;
            return this;
        };
        _proto.identity = function identity() {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        };
        _proto.clone = function clone() {
            return new Matrix41().fromArray(this.elements);
        };
        _proto.copy = function copy(m) {
            var te = this.elements;
            var me = m.elements;
            te[0] = me[0];
            te[1] = me[1];
            te[2] = me[2];
            te[3] = me[3];
            te[4] = me[4];
            te[5] = me[5];
            te[6] = me[6];
            te[7] = me[7];
            te[8] = me[8];
            te[9] = me[9];
            te[10] = me[10];
            te[11] = me[11];
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            te[15] = me[15];
            return this;
        };
        _proto.copyPosition = function copyPosition(m) {
            var te = this.elements, me = m.elements;
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            return this;
        };
        _proto.setFromMatrix3 = function setFromMatrix3(m) {
            var me = m.elements;
            this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
            return this;
        };
        _proto.extractBasis = function extractBasis(xAxis, yAxis, zAxis) {
            xAxis.setFromMatrixColumn(this, 0);
            yAxis.setFromMatrixColumn(this, 1);
            zAxis.setFromMatrixColumn(this, 2);
            return this;
        };
        _proto.makeBasis = function makeBasis(xAxis, yAxis, zAxis) {
            this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
            return this;
        };
        _proto.extractRotation = function extractRotation(m) {
            // this method does not support reflection matrices
            var te = this.elements;
            var me = m.elements;
            var scaleX = 1 / _v1$1.setFromMatrixColumn(m, 0).length();
            var scaleY = 1 / _v1$1.setFromMatrixColumn(m, 1).length();
            var scaleZ = 1 / _v1$1.setFromMatrixColumn(m, 2).length();
            te[0] = me[0] * scaleX;
            te[1] = me[1] * scaleX;
            te[2] = me[2] * scaleX;
            te[3] = 0;
            te[4] = me[4] * scaleY;
            te[5] = me[5] * scaleY;
            te[6] = me[6] * scaleY;
            te[7] = 0;
            te[8] = me[8] * scaleZ;
            te[9] = me[9] * scaleZ;
            te[10] = me[10] * scaleZ;
            te[11] = 0;
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        };
        _proto.makeRotationFromEuler = function makeRotationFromEuler(euler) {
            if (!(euler && euler.isEuler)) console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
            var te = this.elements;
            var x = euler.x, y = euler.y, z = euler.z;
            var a = Math.cos(x), b = Math.sin(x);
            var c = Math.cos(y), d = Math.sin(y);
            var e = Math.cos(z), f = Math.sin(z);
            if (euler.order === 'XYZ') {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = -c * f;
                te[8] = d;
                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = -b * c;
                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
            } else if (euler.order === 'YXZ') {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;
                te[1] = a * f;
                te[5] = a * e;
                te[9] = -b;
                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
            } else if (euler.order === 'ZXY') {
                var _ce = c * e, _cf = c * f, _de = d * e, _df = d * f;
                te[0] = _ce - _df * b;
                te[4] = -a * f;
                te[8] = _de + _cf * b;
                te[1] = _cf + _de * b;
                te[5] = a * e;
                te[9] = _df - _ce * b;
                te[2] = -a * d;
                te[6] = b;
                te[10] = a * c;
            } else if (euler.order === 'ZYX') {
                var _ae = a * e, _af = a * f, _be = b * e, _bf = b * f;
                te[0] = c * e;
                te[4] = _be * d - _af;
                te[8] = _ae * d + _bf;
                te[1] = c * f;
                te[5] = _bf * d + _ae;
                te[9] = _af * d - _be;
                te[2] = -d;
                te[6] = b * c;
                te[10] = a * c;
            } else if (euler.order === 'YZX') {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;
                te[1] = f;
                te[5] = a * e;
                te[9] = -b * e;
                te[2] = -d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
            } else if (euler.order === 'XZY') {
                var _ac = a * c, _ad = a * d, _bc = b * c, _bd = b * d;
                te[0] = c * e;
                te[4] = -f;
                te[8] = d * e;
                te[1] = _ac * f + _bd;
                te[5] = a * e;
                te[9] = _ad * f - _bc;
                te[2] = _bc * f - _ad;
                te[6] = b * e;
                te[10] = _bd * f + _ac;
            } // bottom row
            te[3] = 0;
            te[7] = 0;
            te[11] = 0; // last column
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        };
        _proto.makeRotationFromQuaternion = function makeRotationFromQuaternion(q) {
            return this.compose(_zero, q, _one);
        };
        _proto.lookAt = function lookAt(eye, target, up) {
            var te = this.elements;
            _z.subVectors(eye, target);
            if (_z.lengthSq() === 0) // eye and target are in the same position
            _z.z = 1;
            _z.normalize();
            _x.crossVectors(up, _z);
            if (_x.lengthSq() === 0) {
                // up and z are parallel
                if (Math.abs(up.z) === 1) _z.x += 0.0001;
                else _z.z += 0.0001;
                _z.normalize();
                _x.crossVectors(up, _z);
            }
            _x.normalize();
            _y.crossVectors(_z, _x);
            te[0] = _x.x;
            te[4] = _y.x;
            te[8] = _z.x;
            te[1] = _x.y;
            te[5] = _y.y;
            te[9] = _z.y;
            te[2] = _x.z;
            te[6] = _y.z;
            te[10] = _z.z;
            return this;
        };
        _proto.multiply = function multiply(m, n) {
            if (n !== undefined) {
                console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
                return this.multiplyMatrices(m, n);
            }
            return this.multiplyMatrices(this, m);
        };
        _proto.premultiply = function premultiply(m) {
            return this.multiplyMatrices(m, this);
        };
        _proto.multiplyMatrices = function multiplyMatrices(a, b) {
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
            var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
            var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
            var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
            var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
            var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
            var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
            var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
            var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        };
        _proto.multiplyScalar = function multiplyScalar(s) {
            var te = this.elements;
            te[0] *= s;
            te[4] *= s;
            te[8] *= s;
            te[12] *= s;
            te[1] *= s;
            te[5] *= s;
            te[9] *= s;
            te[13] *= s;
            te[2] *= s;
            te[6] *= s;
            te[10] *= s;
            te[14] *= s;
            te[3] *= s;
            te[7] *= s;
            te[11] *= s;
            te[15] *= s;
            return this;
        };
        _proto.determinant = function determinant() {
            var te = this.elements;
            var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
            var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
            var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
            var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15]; //TODO: make this more efficient
            //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
            return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        };
        _proto.transpose = function transpose() {
            var te = this.elements;
            var tmp;
            tmp = te[1];
            te[1] = te[4];
            te[4] = tmp;
            tmp = te[2];
            te[2] = te[8];
            te[8] = tmp;
            tmp = te[6];
            te[6] = te[9];
            te[9] = tmp;
            tmp = te[3];
            te[3] = te[12];
            te[12] = tmp;
            tmp = te[7];
            te[7] = te[13];
            te[13] = tmp;
            tmp = te[11];
            te[11] = te[14];
            te[14] = tmp;
            return this;
        };
        _proto.setPosition = function setPosition(x, y, z) {
            var te = this.elements;
            if (x.isVector3) {
                te[12] = x.x;
                te[13] = x.y;
                te[14] = x.z;
            } else {
                te[12] = x;
                te[13] = y;
                te[14] = z;
            }
            return this;
        };
        _proto.invert = function invert() {
            // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
            var te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
            te[4] = t12 * detInv;
            te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            te[8] = t13 * detInv;
            te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            te[12] = t14 * detInv;
            te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
            return this;
        };
        _proto.scale = function scale(v) {
            var te = this.elements;
            var x = v.x, y = v.y, z = v.z;
            te[0] *= x;
            te[4] *= y;
            te[8] *= z;
            te[1] *= x;
            te[5] *= y;
            te[9] *= z;
            te[2] *= x;
            te[6] *= y;
            te[10] *= z;
            te[3] *= x;
            te[7] *= y;
            te[11] *= z;
            return this;
        };
        _proto.getMaxScaleOnAxis = function getMaxScaleOnAxis() {
            var te = this.elements;
            var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        };
        _proto.makeTranslation = function makeTranslation(x, y, z) {
            this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
            return this;
        };
        _proto.makeRotationX = function makeRotationX(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
            return this;
        };
        _proto.makeRotationY = function makeRotationY(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
            return this;
        };
        _proto.makeRotationZ = function makeRotationZ(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        };
        _proto.makeRotationAxis = function makeRotationAxis(axis, angle) {
            // Based on http://www.gamedev.net/reference/articles/article1199.asp
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var t = 1 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;
            this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
            return this;
        };
        _proto.makeScale = function makeScale(x, y, z) {
            this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
            return this;
        };
        _proto.makeShear = function makeShear(x, y, z) {
            this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
            return this;
        };
        _proto.compose = function compose(position, quaternion, scale1) {
            var te = this.elements;
            var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
            var x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2;
            var yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;
            var sx = scale1.x, sy = scale1.y, sz = scale1.z;
            te[0] = (1 - (yy + zz)) * sx;
            te[1] = (xy + wz) * sx;
            te[2] = (xz - wy) * sx;
            te[3] = 0;
            te[4] = (xy - wz) * sy;
            te[5] = (1 - (xx + zz)) * sy;
            te[6] = (yz + wx) * sy;
            te[7] = 0;
            te[8] = (xz + wy) * sz;
            te[9] = (yz - wx) * sz;
            te[10] = (1 - (xx + yy)) * sz;
            te[11] = 0;
            te[12] = position.x;
            te[13] = position.y;
            te[14] = position.z;
            te[15] = 1;
            return this;
        };
        _proto.decompose = function decompose(position, quaternion, scale1) {
            var te = this.elements;
            var sx = _v1$1.set(te[0], te[1], te[2]).length();
            var sy = _v1$1.set(te[4], te[5], te[6]).length();
            var sz = _v1$1.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale
            var det = this.determinant();
            if (det < 0) sx = -sx;
            position.x = te[12];
            position.y = te[13];
            position.z = te[14]; // scale the rotation part
            _m1.copy(this);
            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;
            _m1.elements[0] *= invSX;
            _m1.elements[1] *= invSX;
            _m1.elements[2] *= invSX;
            _m1.elements[4] *= invSY;
            _m1.elements[5] *= invSY;
            _m1.elements[6] *= invSY;
            _m1.elements[8] *= invSZ;
            _m1.elements[9] *= invSZ;
            _m1.elements[10] *= invSZ;
            quaternion.setFromRotationMatrix(_m1);
            scale1.x = sx;
            scale1.y = sy;
            scale1.z = sz;
            return this;
        };
        _proto.makePerspective = function makePerspective(left, right, top, bottom, near, far) {
            if (far === undefined) console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
            var te = this.elements;
            var x = 2 * near / (right - left);
            var y = 2 * near / (top - bottom);
            var a = (right + left) / (right - left);
            var b = (top + bottom) / (top - bottom);
            var c = -(far + near) / (far - near);
            var d = -2 * far * near / (far - near);
            te[0] = x;
            te[4] = 0;
            te[8] = a;
            te[12] = 0;
            te[1] = 0;
            te[5] = y;
            te[9] = b;
            te[13] = 0;
            te[2] = 0;
            te[6] = 0;
            te[10] = c;
            te[14] = d;
            te[3] = 0;
            te[7] = 0;
            te[11] = -1;
            te[15] = 0;
            return this;
        };
        _proto.makeOrthographic = function makeOrthographic(left, right, top, bottom, near, far) {
            var te = this.elements;
            var w = 1 / (right - left);
            var h = 1 / (top - bottom);
            var p = 1 / (far - near);
            var x = (right + left) * w;
            var y = (top + bottom) * h;
            var z = (far + near) * p;
            te[0] = 2 * w;
            te[4] = 0;
            te[8] = 0;
            te[12] = -x;
            te[1] = 0;
            te[5] = 2 * h;
            te[9] = 0;
            te[13] = -y;
            te[2] = 0;
            te[6] = 0;
            te[10] = -2 * p;
            te[14] = -z;
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[15] = 1;
            return this;
        };
        _proto.equals = function equals(matrix) {
            var te = this.elements;
            var me = matrix.elements;
            for(var i2 = 0; i2 < 16; i2++){
                if (te[i2] !== me[i2]) return false;
            }
            return true;
        };
        _proto.fromArray = function fromArray(array, offset) {
            if (offset === void 0) offset = 0;
            for(var i2 = 0; i2 < 16; i2++)this.elements[i2] = array[i2 + offset];
            return this;
        };
        _proto.toArray = function toArray(array, offset) {
            if (array === void 0) array = [];
            if (offset === void 0) offset = 0;
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            array[offset + 9] = te[9];
            array[offset + 10] = te[10];
            array[offset + 11] = te[11];
            array[offset + 12] = te[12];
            array[offset + 13] = te[13];
            array[offset + 14] = te[14];
            array[offset + 15] = te[15];
            return array;
        };
        return Matrix41;
    }();
    var _v1$1 = /*@__PURE__*/ new Vector3();
    var _m1 = /*@__PURE__*/ new Matrix4();
    var _zero = /*@__PURE__*/ new Vector3(0, 0, 0);
    var _one = /*@__PURE__*/ new Vector3(1, 1, 1);
    var _x = /*@__PURE__*/ new Vector3();
    var _y = /*@__PURE__*/ new Vector3();
    var _z = /*@__PURE__*/ new Vector3();
    var Euler = /*#__PURE__*/ function() {
        function Euler1(x, y, z, order) {
            if (x === void 0) x = 0;
            if (y === void 0) y = 0;
            if (z === void 0) z = 0;
            if (order === void 0) order = Euler1.DefaultOrder;
            Object.defineProperty(this, 'isEuler', {
                value: true
            });
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order;
        }
        var _proto = Euler1.prototype;
        _proto.set = function set(x, y, z, order) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order || this._order;
            this._onChangeCallback();
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        };
        _proto.copy = function copy(euler) {
            this._x = euler._x;
            this._y = euler._y;
            this._z = euler._z;
            this._order = euler._order;
            this._onChangeCallback();
            return this;
        };
        _proto.setFromRotationMatrix = function setFromRotationMatrix(m, order, update) {
            var clamp = MathUtils.clamp; // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var te = m.elements;
            var m11 = te[0], m12 = te[4], m13 = te[8];
            var m21 = te[1], m22 = te[5], m23 = te[9];
            var m31 = te[2], m32 = te[6], m33 = te[10];
            order = order || this._order;
            switch(order){
                case 'XYZ':
                    this._y = Math.asin(clamp(m13, -1, 1));
                    if (Math.abs(m13) < 0.9999999) {
                        this._x = Math.atan2(-m23, m33);
                        this._z = Math.atan2(-m12, m11);
                    } else {
                        this._x = Math.atan2(m32, m22);
                        this._z = 0;
                    }
                    break;
                case 'YXZ':
                    this._x = Math.asin(-clamp(m23, -1, 1));
                    if (Math.abs(m23) < 0.9999999) {
                        this._y = Math.atan2(m13, m33);
                        this._z = Math.atan2(m21, m22);
                    } else {
                        this._y = Math.atan2(-m31, m11);
                        this._z = 0;
                    }
                    break;
                case 'ZXY':
                    this._x = Math.asin(clamp(m32, -1, 1));
                    if (Math.abs(m32) < 0.9999999) {
                        this._y = Math.atan2(-m31, m33);
                        this._z = Math.atan2(-m12, m22);
                    } else {
                        this._y = 0;
                        this._z = Math.atan2(m21, m11);
                    }
                    break;
                case 'ZYX':
                    this._y = Math.asin(-clamp(m31, -1, 1));
                    if (Math.abs(m31) < 0.9999999) {
                        this._x = Math.atan2(m32, m33);
                        this._z = Math.atan2(m21, m11);
                    } else {
                        this._x = 0;
                        this._z = Math.atan2(-m12, m22);
                    }
                    break;
                case 'YZX':
                    this._z = Math.asin(clamp(m21, -1, 1));
                    if (Math.abs(m21) < 0.9999999) {
                        this._x = Math.atan2(-m23, m22);
                        this._y = Math.atan2(-m31, m11);
                    } else {
                        this._x = 0;
                        this._y = Math.atan2(m13, m33);
                    }
                    break;
                case 'XZY':
                    this._z = Math.asin(-clamp(m12, -1, 1));
                    if (Math.abs(m12) < 0.9999999) {
                        this._x = Math.atan2(m32, m22);
                        this._y = Math.atan2(m13, m11);
                    } else {
                        this._x = Math.atan2(-m23, m33);
                        this._y = 0;
                    }
                    break;
                default:
                    console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
            }
            this._order = order;
            if (update !== false) this._onChangeCallback();
            return this;
        };
        _proto.setFromQuaternion = function setFromQuaternion(q, order, update) {
            _matrix.makeRotationFromQuaternion(q);
            return this.setFromRotationMatrix(_matrix, order, update);
        };
        _proto.setFromVector3 = function setFromVector3(v, order) {
            return this.set(v.x, v.y, v.z, order || this._order);
        };
        _proto.reorder = function reorder(newOrder) {
            // WARNING: this discards revolution information -bhouston
            _quaternion$1.setFromEuler(this);
            return this.setFromQuaternion(_quaternion$1, newOrder);
        };
        _proto.equals = function equals(euler) {
            return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        };
        _proto.fromArray = function fromArray(array) {
            this._x = array[0];
            this._y = array[1];
            this._z = array[2];
            if (array[3] !== undefined) this._order = array[3];
            this._onChangeCallback();
            return this;
        };
        _proto.toArray = function toArray(array, offset) {
            if (array === void 0) array = [];
            if (offset === void 0) offset = 0;
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._order;
            return array;
        };
        _proto.toVector3 = function toVector3(optionalResult) {
            if (optionalResult) return optionalResult.set(this._x, this._y, this._z);
            else return new Vector3(this._x, this._y, this._z);
        };
        _proto._onChange = function _onChange(callback) {
            this._onChangeCallback = callback;
            return this;
        };
        _proto._onChangeCallback = function _onChangeCallback() {
        };
        _createClass(Euler1, [
            {
                key: "x",
                get: function get() {
                    return this._x;
                },
                set: function set1(value) {
                    this._x = value;
                    this._onChangeCallback();
                }
            },
            {
                key: "y",
                get: function get() {
                    return this._y;
                },
                set: function set1(value) {
                    this._y = value;
                    this._onChangeCallback();
                }
            },
            {
                key: "z",
                get: function get() {
                    return this._z;
                },
                set: function set1(value) {
                    this._z = value;
                    this._onChangeCallback();
                }
            },
            {
                key: "order",
                get: function get() {
                    return this._order;
                },
                set: function set1(value) {
                    this._order = value;
                    this._onChangeCallback();
                }
            }
        ]);
        return Euler1;
    }();
    Euler.DefaultOrder = 'XYZ';
    Euler.RotationOrders = [
        'XYZ',
        'YZX',
        'ZXY',
        'XZY',
        'YXZ',
        'ZYX'
    ];
    var _matrix = /*@__PURE__*/ new Matrix4();
    var _quaternion$1 = /*@__PURE__*/ new Quaternion();
    var Layers = /*#__PURE__*/ function() {
        function Layers1() {
            this.mask = 1;
        }
        var _proto = Layers1.prototype;
        _proto.set = function set(channel) {
            this.mask = 1 << channel | 0;
        };
        _proto.enable = function enable(channel) {
            this.mask |= 1 << channel | 0;
        };
        _proto.enableAll = function enableAll() {
            this.mask = -1;
        };
        _proto.toggle = function toggle(channel) {
            this.mask ^= 1 << channel | 0;
        };
        _proto.disable = function disable(channel) {
            this.mask &= ~(1 << channel | 0);
        };
        _proto.disableAll = function disableAll() {
            this.mask = 0;
        };
        _proto.test = function test(layers) {
            return (this.mask & layers.mask) !== 0;
        };
        return Layers1;
    }();
    var _object3DId = 0;
    var _v1$2 = new Vector3();
    var _q1 = new Quaternion();
    var _m1$1 = new Matrix4();
    var _target = new Vector3();
    var _position = new Vector3();
    var _scale = new Vector3();
    var _quaternion$2 = new Quaternion();
    var _xAxis = new Vector3(1, 0, 0);
    var _yAxis = new Vector3(0, 1, 0);
    var _zAxis = new Vector3(0, 0, 1);
    var _addedEvent = {
        type: 'added'
    };
    var _removedEvent = {
        type: 'removed'
    };
    function Object3D() {
        Object.defineProperty(this, 'id', {
            value: _object3DId++
        });
        this.uuid = MathUtils.generateUUID();
        this.name = '';
        this.type = 'Object3D';
        this.parent = null;
        this.children = [];
        this.up = Object3D.DefaultUp.clone();
        var position = new Vector3();
        var rotation = new Euler();
        var quaternion = new Quaternion();
        var scale = new Vector3(1, 1, 1);
        function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, undefined, false);
        }
        rotation._onChange(onRotationChange);
        quaternion._onChange(onQuaternionChange);
        Object.defineProperties(this, {
            position: {
                configurable: true,
                enumerable: true,
                value: position
            },
            rotation: {
                configurable: true,
                enumerable: true,
                value: rotation
            },
            quaternion: {
                configurable: true,
                enumerable: true,
                value: quaternion
            },
            scale: {
                configurable: true,
                enumerable: true,
                value: scale
            },
            modelViewMatrix: {
                value: new Matrix4()
            },
            normalMatrix: {
                value: new Matrix3()
            }
        });
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new Layers();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.animations = [];
        this.userData = {
        };
    }
    Object3D.DefaultUp = new Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;
    Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: Object3D,
        isObject3D: true,
        onBeforeRender: function onBeforeRender() {
        },
        onAfterRender: function onAfterRender() {
        },
        applyMatrix4: function applyMatrix4(matrix) {
            if (this.matrixAutoUpdate) this.updateMatrix();
            this.matrix.premultiply(matrix);
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        applyQuaternion: function applyQuaternion(q) {
            this.quaternion.premultiply(q);
            return this;
        },
        setRotationFromAxisAngle: function setRotationFromAxisAngle(axis, angle) {
            // assumes axis is normalized
            this.quaternion.setFromAxisAngle(axis, angle);
        },
        setRotationFromEuler: function setRotationFromEuler(euler) {
            this.quaternion.setFromEuler(euler, true);
        },
        setRotationFromMatrix: function setRotationFromMatrix(m) {
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            this.quaternion.setFromRotationMatrix(m);
        },
        setRotationFromQuaternion: function setRotationFromQuaternion(q) {
            // assumes q is normalized
            this.quaternion.copy(q);
        },
        rotateOnAxis: function rotateOnAxis(axis, angle) {
            // rotate object on axis in object space
            // axis is assumed to be normalized
            _q1.setFromAxisAngle(axis, angle);
            this.quaternion.multiply(_q1);
            return this;
        },
        rotateOnWorldAxis: function rotateOnWorldAxis(axis, angle) {
            // rotate object on axis in world space
            // axis is assumed to be normalized
            // method assumes no rotated parent
            _q1.setFromAxisAngle(axis, angle);
            this.quaternion.premultiply(_q1);
            return this;
        },
        rotateX: function rotateX(angle) {
            return this.rotateOnAxis(_xAxis, angle);
        },
        rotateY: function rotateY(angle) {
            return this.rotateOnAxis(_yAxis, angle);
        },
        rotateZ: function rotateZ(angle) {
            return this.rotateOnAxis(_zAxis, angle);
        },
        translateOnAxis: function translateOnAxis(axis, distance) {
            // translate object by distance along axis in object space
            // axis is assumed to be normalized
            _v1$2.copy(axis).applyQuaternion(this.quaternion);
            this.position.add(_v1$2.multiplyScalar(distance));
            return this;
        },
        translateX: function translateX(distance) {
            return this.translateOnAxis(_xAxis, distance);
        },
        translateY: function translateY(distance) {
            return this.translateOnAxis(_yAxis, distance);
        },
        translateZ: function translateZ(distance) {
            return this.translateOnAxis(_zAxis, distance);
        },
        localToWorld: function localToWorld(vector) {
            return vector.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function worldToLocal(vector) {
            return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
        },
        lookAt: function lookAt(x, y, z) {
            // This method does not support objects having non-uniformly-scaled parent(s)
            if (x.isVector3) _target.copy(x);
            else _target.set(x, y, z);
            var parent = this.parent;
            this.updateWorldMatrix(true, false);
            _position.setFromMatrixPosition(this.matrixWorld);
            if (this.isCamera || this.isLight) _m1$1.lookAt(_position, _target, this.up);
            else _m1$1.lookAt(_target, _position, this.up);
            this.quaternion.setFromRotationMatrix(_m1$1);
            if (parent) {
                _m1$1.extractRotation(parent.matrixWorld);
                _q1.setFromRotationMatrix(_m1$1);
                this.quaternion.premultiply(_q1.invert());
            }
        },
        add: function add(object) {
            if (arguments.length > 1) {
                for(var i2 = 0; i2 < arguments.length; i2++)this.add(arguments[i2]);
                return this;
            }
            if (object === this) {
                console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
                return this;
            }
            if (object && object.isObject3D) {
                if (object.parent !== null) object.parent.remove(object);
                object.parent = this;
                this.children.push(object);
                object.dispatchEvent(_addedEvent);
            } else console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
            return this;
        },
        remove: function remove(object) {
            if (arguments.length > 1) {
                for(var i3 = 0; i3 < arguments.length; i3++)this.remove(arguments[i3]);
                return this;
            }
            var index = this.children.indexOf(object);
            if (index !== -1) {
                object.parent = null;
                this.children.splice(index, 1);
                object.dispatchEvent(_removedEvent);
            }
            return this;
        },
        clear: function clear() {
            for(var i4 = 0; i4 < this.children.length; i4++){
                var object = this.children[i4];
                object.parent = null;
                object.dispatchEvent(_removedEvent);
            }
            this.children.length = 0;
            return this;
        },
        attach: function attach(object) {
            // adds object as a child of this, while maintaining the object's world transform
            this.updateWorldMatrix(true, false);
            _m1$1.copy(this.matrixWorld).invert();
            if (object.parent !== null) {
                object.parent.updateWorldMatrix(true, false);
                _m1$1.multiply(object.parent.matrixWorld);
            }
            object.applyMatrix4(_m1$1);
            object.updateWorldMatrix(false, false);
            this.add(object);
            return this;
        },
        getObjectById: function getObjectById(id) {
            return this.getObjectByProperty('id', id);
        },
        getObjectByName: function getObjectByName(name) {
            return this.getObjectByProperty('name', name);
        },
        getObjectByProperty: function getObjectByProperty(name, value) {
            if (this[name] === value) return this;
            for(var i4 = 0, l = this.children.length; i4 < l; i4++){
                var child = this.children[i4];
                var object = child.getObjectByProperty(name, value);
                if (object !== undefined) return object;
            }
            return undefined;
        },
        getWorldPosition: function getWorldPosition(target) {
            if (target === undefined) {
                console.warn('THREE.Object3D: .getWorldPosition() target is now required');
                target = new Vector3();
            }
            this.updateWorldMatrix(true, false);
            return target.setFromMatrixPosition(this.matrixWorld);
        },
        getWorldQuaternion: function getWorldQuaternion(target) {
            if (target === undefined) {
                console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
                target = new Quaternion();
            }
            this.updateWorldMatrix(true, false);
            this.matrixWorld.decompose(_position, target, _scale);
            return target;
        },
        getWorldScale: function getWorldScale(target) {
            if (target === undefined) {
                console.warn('THREE.Object3D: .getWorldScale() target is now required');
                target = new Vector3();
            }
            this.updateWorldMatrix(true, false);
            this.matrixWorld.decompose(_position, _quaternion$2, target);
            return target;
        },
        getWorldDirection: function getWorldDirection(target) {
            if (target === undefined) {
                console.warn('THREE.Object3D: .getWorldDirection() target is now required');
                target = new Vector3();
            }
            this.updateWorldMatrix(true, false);
            var e = this.matrixWorld.elements;
            return target.set(e[8], e[9], e[10]).normalize();
        },
        raycast: function raycast() {
        },
        traverse: function traverse(callback) {
            callback(this);
            var children = this.children;
            for(var i4 = 0, l = children.length; i4 < l; i4++)children[i4].traverse(callback);
        },
        traverseVisible: function traverseVisible(callback) {
            if (this.visible === false) return;
            callback(this);
            var children = this.children;
            for(var i4 = 0, l = children.length; i4 < l; i4++)children[i4].traverseVisible(callback);
        },
        traverseAncestors: function traverseAncestors(callback) {
            var parent = this.parent;
            if (parent !== null) {
                callback(parent);
                parent.traverseAncestors(callback);
            }
        },
        updateMatrix: function updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale);
            this.matrixWorldNeedsUpdate = true;
        },
        updateMatrixWorld: function updateMatrixWorld(force) {
            if (this.matrixAutoUpdate) this.updateMatrix();
            if (this.matrixWorldNeedsUpdate || force) {
                if (this.parent === null) this.matrixWorld.copy(this.matrix);
                else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                this.matrixWorldNeedsUpdate = false;
                force = true;
            } // update children
            var children = this.children;
            for(var i4 = 0, l = children.length; i4 < l; i4++)children[i4].updateMatrixWorld(force);
        },
        updateWorldMatrix: function updateWorldMatrix(updateParents, updateChildren) {
            var parent = this.parent;
            if (updateParents === true && parent !== null) parent.updateWorldMatrix(true, false);
            if (this.matrixAutoUpdate) this.updateMatrix();
            if (this.parent === null) this.matrixWorld.copy(this.matrix);
            else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
             // update children
            if (updateChildren === true) {
                var children = this.children;
                for(var i4 = 0, l = children.length; i4 < l; i4++)children[i4].updateWorldMatrix(false, true);
            }
        },
        toJSON: function toJSON(meta) {
            // meta is a string when called from JSON.stringify
            var isRootObject = meta === undefined || typeof meta === 'string';
            var output = {
            }; // meta is a hash used to collect geometries, materials.
            // not providing it implies that this is the root object
            // being serialized.
            if (isRootObject) {
                // initialize meta obj
                meta = {
                    geometries: {
                    },
                    materials: {
                    },
                    textures: {
                    },
                    images: {
                    },
                    shapes: {
                    },
                    skeletons: {
                    },
                    animations: {
                    }
                };
                output.metadata = {
                    version: 4.5,
                    type: 'Object',
                    generator: 'Object3D.toJSON'
                };
            } // standard Object3D serialization
            var object = {
            };
            object.uuid = this.uuid;
            object.type = this.type;
            if (this.name !== '') object.name = this.name;
            if (this.castShadow === true) object.castShadow = true;
            if (this.receiveShadow === true) object.receiveShadow = true;
            if (this.visible === false) object.visible = false;
            if (this.frustumCulled === false) object.frustumCulled = false;
            if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
            if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
            object.layers = this.layers.mask;
            object.matrix = this.matrix.toArray();
            if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties
            if (this.isInstancedMesh) {
                object.type = 'InstancedMesh';
                object.count = this.count;
                object.instanceMatrix = this.instanceMatrix.toJSON();
            } //
            function serialize(library, element) {
                if (library[element.uuid] === undefined) library[element.uuid] = element.toJSON(meta);
                return element.uuid;
            }
            if (this.isMesh || this.isLine || this.isPoints) {
                object.geometry = serialize(meta.geometries, this.geometry);
                var parameters = this.geometry.parameters;
                if (parameters !== undefined && parameters.shapes !== undefined) {
                    var shapes = parameters.shapes;
                    if (Array.isArray(shapes)) for(var i5 = 0, l = shapes.length; i5 < l; i5++){
                        var shape = shapes[i5];
                        serialize(meta.shapes, shape);
                    }
                    else serialize(meta.shapes, shapes);
                }
            }
            if (this.isSkinnedMesh) {
                object.bindMode = this.bindMode;
                object.bindMatrix = this.bindMatrix.toArray();
                if (this.skeleton !== undefined) {
                    serialize(meta.skeletons, this.skeleton);
                    object.skeleton = this.skeleton.uuid;
                }
            }
            if (this.material !== undefined) {
                if (Array.isArray(this.material)) {
                    var uuids = [];
                    for(var _i = 0, _l = this.material.length; _i < _l; _i++)uuids.push(serialize(meta.materials, this.material[_i]));
                    object.material = uuids;
                } else object.material = serialize(meta.materials, this.material);
            } //
            if (this.children.length > 0) {
                object.children = [];
                for(var _i2 = 0; _i2 < this.children.length; _i2++)object.children.push(this.children[_i2].toJSON(meta).object);
            } //
            if (this.animations.length > 0) {
                object.animations = [];
                for(var _i3 = 0; _i3 < this.animations.length; _i3++){
                    var animation = this.animations[_i3];
                    object.animations.push(serialize(meta.animations, animation));
                }
            }
            if (isRootObject) {
                var geometries = extractFromCache(meta.geometries);
                var materials = extractFromCache(meta.materials);
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                var _shapes = extractFromCache(meta.shapes);
                var skeletons = extractFromCache(meta.skeletons);
                var animations = extractFromCache(meta.animations);
                if (geometries.length > 0) output.geometries = geometries;
                if (materials.length > 0) output.materials = materials;
                if (textures.length > 0) output.textures = textures;
                if (images.length > 0) output.images = images;
                if (_shapes.length > 0) output.shapes = _shapes;
                if (skeletons.length > 0) output.skeletons = skeletons;
                if (animations.length > 0) output.animations = animations;
            }
            output.object = object;
            // remove metadata on each item
            // and return as array
            function extractFromCache(cache) {
                var values = [];
                for(var key2 in cache){
                    var data = cache[key2];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
            return output; // extract data from the cache hash
        },
        clone: function clone(recursive) {
            return new this.constructor().copy(this, recursive);
        },
        copy: function copy(source, recursive) {
            if (recursive === void 0) recursive = true;
            this.name = source.name;
            this.up.copy(source.up);
            this.position.copy(source.position);
            this.rotation.order = source.rotation.order;
            this.quaternion.copy(source.quaternion);
            this.scale.copy(source.scale);
            this.matrix.copy(source.matrix);
            this.matrixWorld.copy(source.matrixWorld);
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
            this.layers.mask = source.layers.mask;
            this.visible = source.visible;
            this.castShadow = source.castShadow;
            this.receiveShadow = source.receiveShadow;
            this.frustumCulled = source.frustumCulled;
            this.renderOrder = source.renderOrder;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            if (recursive === true) for(var i6 = 0; i6 < source.children.length; i6++){
                var child = source.children[i6];
                this.add(child.clone());
            }
            return this;
        }
    });
    var _vector1 = /*@__PURE__*/ new Vector3();
    var _vector2 = /*@__PURE__*/ new Vector3();
    var _normalMatrix = /*@__PURE__*/ new Matrix3();
    var Plane = /*#__PURE__*/ function() {
        function Plane1(normal, constant) {
            Object.defineProperty(this, 'isPlane', {
                value: true
            }); // normal is assumed to be normalized
            this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
            this.constant = constant !== undefined ? constant : 0;
        }
        var _proto = Plane1.prototype;
        _proto.set = function set(normal, constant) {
            this.normal.copy(normal);
            this.constant = constant;
            return this;
        };
        _proto.setComponents = function setComponents(x, y, z, w) {
            this.normal.set(x, y, z);
            this.constant = w;
            return this;
        };
        _proto.setFromNormalAndCoplanarPoint = function setFromNormalAndCoplanarPoint(normal, point) {
            this.normal.copy(normal);
            this.constant = -point.dot(this.normal);
            return this;
        };
        _proto.setFromCoplanarPoints = function setFromCoplanarPoints(a, b, c) {
            var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
            this.setFromNormalAndCoplanarPoint(normal, a);
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(plane) {
            this.normal.copy(plane.normal);
            this.constant = plane.constant;
            return this;
        };
        _proto.normalize = function normalize() {
            // Note: will lead to a divide by zero if the plane is invalid.
            var inverseNormalLength = 1 / this.normal.length();
            this.normal.multiplyScalar(inverseNormalLength);
            this.constant *= inverseNormalLength;
            return this;
        };
        _proto.negate = function negate() {
            this.constant *= -1;
            this.normal.negate();
            return this;
        };
        _proto.distanceToPoint = function distanceToPoint(point) {
            return this.normal.dot(point) + this.constant;
        };
        _proto.distanceToSphere = function distanceToSphere(sphere) {
            return this.distanceToPoint(sphere.center) - sphere.radius;
        };
        _proto.projectPoint = function projectPoint(point, target) {
            if (target === undefined) {
                console.warn('THREE.Plane: .projectPoint() target is now required');
                target = new Vector3();
            }
            return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        };
        _proto.intersectLine = function intersectLine(line, target) {
            if (target === undefined) {
                console.warn('THREE.Plane: .intersectLine() target is now required');
                target = new Vector3();
            }
            var direction = line.delta(_vector1);
            var denominator = this.normal.dot(direction);
            if (denominator === 0) {
                // line is coplanar, return origin
                if (this.distanceToPoint(line.start) === 0) return target.copy(line.start);
                 // Unsure if this is the correct method to handle this case.
                return undefined;
            }
            var t = -(line.start.dot(this.normal) + this.constant) / denominator;
            if (t < 0 || t > 1) return undefined;
            return target.copy(direction).multiplyScalar(t).add(line.start);
        };
        _proto.intersectsLine = function intersectsLine(line) {
            // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
            var startSign = this.distanceToPoint(line.start);
            var endSign = this.distanceToPoint(line.end);
            return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        };
        _proto.intersectsBox = function intersectsBox(box) {
            return box.intersectsPlane(this);
        };
        _proto.intersectsSphere = function intersectsSphere(sphere) {
            return sphere.intersectsPlane(this);
        };
        _proto.coplanarPoint = function coplanarPoint(target) {
            if (target === undefined) {
                console.warn('THREE.Plane: .coplanarPoint() target is now required');
                target = new Vector3();
            }
            return target.copy(this.normal).multiplyScalar(-this.constant);
        };
        _proto.applyMatrix4 = function applyMatrix4(matrix, optionalNormalMatrix) {
            var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
            var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
            var normal = this.normal.applyMatrix3(normalMatrix).normalize();
            this.constant = -referencePoint.dot(normal);
            return this;
        };
        _proto.translate = function translate(offset) {
            this.constant -= offset.dot(this.normal);
            return this;
        };
        _proto.equals = function equals(plane) {
            return plane.normal.equals(this.normal) && plane.constant === this.constant;
        };
        return Plane1;
    }();
    var _v0$1 = /*@__PURE__*/ new Vector3();
    var _v1$3 = /*@__PURE__*/ new Vector3();
    var _v2$1 = /*@__PURE__*/ new Vector3();
    var _v3 = /*@__PURE__*/ new Vector3();
    var _vab = /*@__PURE__*/ new Vector3();
    var _vac = /*@__PURE__*/ new Vector3();
    var _vbc = /*@__PURE__*/ new Vector3();
    var _vap = /*@__PURE__*/ new Vector3();
    var _vbp = /*@__PURE__*/ new Vector3();
    var _vcp = /*@__PURE__*/ new Vector3();
    var Triangle = /*#__PURE__*/ function() {
        function Triangle1(a, b, c) {
            this.a = a !== undefined ? a : new Vector3();
            this.b = b !== undefined ? b : new Vector3();
            this.c = c !== undefined ? c : new Vector3();
        }
        Triangle1.getNormal = function getNormal(a, b, c, target) {
            if (target === undefined) {
                console.warn('THREE.Triangle: .getNormal() target is now required');
                target = new Vector3();
            }
            target.subVectors(c, b);
            _v0$1.subVectors(a, b);
            target.cross(_v0$1);
            var targetLengthSq = target.lengthSq();
            if (targetLengthSq > 0) return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
            return target.set(0, 0, 0);
        };
        Triangle1.getBarycoord = function getBarycoord(point, a, b, c, target) {
            _v0$1.subVectors(c, a);
            _v1$3.subVectors(b, a);
            _v2$1.subVectors(point, a);
            var dot00 = _v0$1.dot(_v0$1);
            var dot01 = _v0$1.dot(_v1$3);
            var dot02 = _v0$1.dot(_v2$1);
            var dot11 = _v1$3.dot(_v1$3);
            var dot12 = _v1$3.dot(_v2$1);
            var denom = dot00 * dot11 - dot01 * dot01;
            if (target === undefined) {
                console.warn('THREE.Triangle: .getBarycoord() target is now required');
                target = new Vector3();
            } // collinear or singular triangle
            if (denom === 0) // arbitrary location outside of triangle?
            // not sure if this is the best idea, maybe should be returning undefined
            return target.set(-2, -1, -1);
            var invDenom = 1 / denom;
            var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
            var v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1
            return target.set(1 - u - v, v, u);
        };
        Triangle1.containsPoint = function containsPoint(point, a, b, c) {
            this.getBarycoord(point, a, b, c, _v3);
            return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
        };
        Triangle1.getUV = function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
            this.getBarycoord(point, p1, p2, p3, _v3);
            target.set(0, 0);
            target.addScaledVector(uv1, _v3.x);
            target.addScaledVector(uv2, _v3.y);
            target.addScaledVector(uv3, _v3.z);
            return target;
        };
        Triangle1.isFrontFacing = function isFrontFacing(a, b, c, direction) {
            _v0$1.subVectors(c, b);
            _v1$3.subVectors(a, b); // strictly front facing
            return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
        };
        var _proto = Triangle1.prototype;
        _proto.set = function set(a, b, c) {
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        };
        _proto.setFromPointsAndIndices = function setFromPointsAndIndices(points, i0, i11, i21) {
            this.a.copy(points[i0]);
            this.b.copy(points[i11]);
            this.c.copy(points[i21]);
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(triangle) {
            this.a.copy(triangle.a);
            this.b.copy(triangle.b);
            this.c.copy(triangle.c);
            return this;
        };
        _proto.getArea = function getArea() {
            _v0$1.subVectors(this.c, this.b);
            _v1$3.subVectors(this.a, this.b);
            return _v0$1.cross(_v1$3).length() * 0.5;
        };
        _proto.getMidpoint = function getMidpoint(target) {
            if (target === undefined) {
                console.warn('THREE.Triangle: .getMidpoint() target is now required');
                target = new Vector3();
            }
            return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        };
        _proto.getNormal = function getNormal1(target) {
            return Triangle1.getNormal(this.a, this.b, this.c, target);
        };
        _proto.getPlane = function getPlane(target) {
            if (target === undefined) {
                console.warn('THREE.Triangle: .getPlane() target is now required');
                target = new Plane();
            }
            return target.setFromCoplanarPoints(this.a, this.b, this.c);
        };
        _proto.getBarycoord = function getBarycoord1(point, target) {
            return Triangle1.getBarycoord(point, this.a, this.b, this.c, target);
        };
        _proto.getUV = function getUV1(point, uv1, uv2, uv3, target) {
            return Triangle1.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
        };
        _proto.containsPoint = function containsPoint1(point) {
            return Triangle1.containsPoint(point, this.a, this.b, this.c);
        };
        _proto.isFrontFacing = function isFrontFacing1(direction) {
            return Triangle1.isFrontFacing(this.a, this.b, this.c, direction);
        };
        _proto.intersectsBox = function intersectsBox(box) {
            return box.intersectsTriangle(this);
        };
        _proto.closestPointToPoint = function closestPointToPoint(p, target) {
            if (target === undefined) {
                console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
                target = new Vector3();
            }
            var a = this.a, b = this.b, c = this.c;
            var v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
            // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
            // under the accompanying license; see chapter 5.1.5 for detailed explanation.
            // basically, we're distinguishing which of the voronoi regions of the triangle
            // the point lies in with the minimum amount of redundant computation.
            _vab.subVectors(b, a);
            _vac.subVectors(c, a);
            _vap.subVectors(p, a);
            var d1 = _vab.dot(_vap);
            var d2 = _vac.dot(_vap);
            if (d1 <= 0 && d2 <= 0) // vertex region of A; barycentric coords (1, 0, 0)
            return target.copy(a);
            _vbp.subVectors(p, b);
            var d3 = _vab.dot(_vbp);
            var d4 = _vac.dot(_vbp);
            if (d3 >= 0 && d4 <= d3) // vertex region of B; barycentric coords (0, 1, 0)
            return target.copy(b);
            var vc = d1 * d4 - d3 * d2;
            if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)
                return target.copy(a).addScaledVector(_vab, v);
            }
            _vcp.subVectors(p, c);
            var d5 = _vab.dot(_vcp);
            var d6 = _vac.dot(_vcp);
            if (d6 >= 0 && d5 <= d6) // vertex region of C; barycentric coords (0, 0, 1)
            return target.copy(c);
            var vb = d5 * d2 - d1 * d6;
            if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)
                return target.copy(a).addScaledVector(_vac, w);
            }
            var va = d3 * d6 - d5 * d4;
            if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
                _vbc.subVectors(c, b);
                w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)
                return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
            } // face region
            var denom = 1 / (va + vb + vc); // u = va * denom
            v = vb * denom;
            w = vc * denom;
            return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
        };
        _proto.equals = function equals(triangle) {
            return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        };
        return Triangle1;
    }();
    var _colorKeywords = {
        'aliceblue': 15792383,
        'antiquewhite': 16444375,
        'aqua': 65535,
        'aquamarine': 8388564,
        'azure': 15794175,
        'beige': 16119260,
        'bisque': 16770244,
        'black': 0,
        'blanchedalmond': 16772045,
        'blue': 255,
        'blueviolet': 9055202,
        'brown': 10824234,
        'burlywood': 14596231,
        'cadetblue': 6266528,
        'chartreuse': 8388352,
        'chocolate': 13789470,
        'coral': 16744272,
        'cornflowerblue': 6591981,
        'cornsilk': 16775388,
        'crimson': 14423100,
        'cyan': 65535,
        'darkblue': 139,
        'darkcyan': 35723,
        'darkgoldenrod': 12092939,
        'darkgray': 11119017,
        'darkgreen': 25600,
        'darkgrey': 11119017,
        'darkkhaki': 12433259,
        'darkmagenta': 9109643,
        'darkolivegreen': 5597999,
        'darkorange': 16747520,
        'darkorchid': 10040012,
        'darkred': 9109504,
        'darksalmon': 15308410,
        'darkseagreen': 9419919,
        'darkslateblue': 4734347,
        'darkslategray': 3100495,
        'darkslategrey': 3100495,
        'darkturquoise': 52945,
        'darkviolet': 9699539,
        'deeppink': 16716947,
        'deepskyblue': 49151,
        'dimgray': 6908265,
        'dimgrey': 6908265,
        'dodgerblue': 2003199,
        'firebrick': 11674146,
        'floralwhite': 16775920,
        'forestgreen': 2263842,
        'fuchsia': 16711935,
        'gainsboro': 14474460,
        'ghostwhite': 16316671,
        'gold': 16766720,
        'goldenrod': 14329120,
        'gray': 8421504,
        'green': 32768,
        'greenyellow': 11403055,
        'grey': 8421504,
        'honeydew': 15794160,
        'hotpink': 16738740,
        'indianred': 13458524,
        'indigo': 4915330,
        'ivory': 16777200,
        'khaki': 15787660,
        'lavender': 15132410,
        'lavenderblush': 16773365,
        'lawngreen': 8190976,
        'lemonchiffon': 16775885,
        'lightblue': 11393254,
        'lightcoral': 15761536,
        'lightcyan': 14745599,
        'lightgoldenrodyellow': 16448210,
        'lightgray': 13882323,
        'lightgreen': 9498256,
        'lightgrey': 13882323,
        'lightpink': 16758465,
        'lightsalmon': 16752762,
        'lightseagreen': 2142890,
        'lightskyblue': 8900346,
        'lightslategray': 7833753,
        'lightslategrey': 7833753,
        'lightsteelblue': 11584734,
        'lightyellow': 16777184,
        'lime': 65280,
        'limegreen': 3329330,
        'linen': 16445670,
        'magenta': 16711935,
        'maroon': 8388608,
        'mediumaquamarine': 6737322,
        'mediumblue': 205,
        'mediumorchid': 12211667,
        'mediumpurple': 9662683,
        'mediumseagreen': 3978097,
        'mediumslateblue': 8087790,
        'mediumspringgreen': 64154,
        'mediumturquoise': 4772300,
        'mediumvioletred': 13047173,
        'midnightblue': 1644912,
        'mintcream': 16121850,
        'mistyrose': 16770273,
        'moccasin': 16770229,
        'navajowhite': 16768685,
        'navy': 128,
        'oldlace': 16643558,
        'olive': 8421376,
        'olivedrab': 7048739,
        'orange': 16753920,
        'orangered': 16729344,
        'orchid': 14315734,
        'palegoldenrod': 15657130,
        'palegreen': 10025880,
        'paleturquoise': 11529966,
        'palevioletred': 14381203,
        'papayawhip': 16773077,
        'peachpuff': 16767673,
        'peru': 13468991,
        'pink': 16761035,
        'plum': 14524637,
        'powderblue': 11591910,
        'purple': 8388736,
        'rebeccapurple': 6697881,
        'red': 16711680,
        'rosybrown': 12357519,
        'royalblue': 4286945,
        'saddlebrown': 9127187,
        'salmon': 16416882,
        'sandybrown': 16032864,
        'seagreen': 3050327,
        'seashell': 16774638,
        'sienna': 10506797,
        'silver': 12632256,
        'skyblue': 8900331,
        'slateblue': 6970061,
        'slategray': 7372944,
        'slategrey': 7372944,
        'snow': 16775930,
        'springgreen': 65407,
        'steelblue': 4620980,
        'tan': 13808780,
        'teal': 32896,
        'thistle': 14204888,
        'tomato': 16737095,
        'turquoise': 4251856,
        'violet': 15631086,
        'wheat': 16113331,
        'white': 16777215,
        'whitesmoke': 16119285,
        'yellow': 16776960,
        'yellowgreen': 10145074
    };
    var _hslA = {
        h: 0,
        s: 0,
        l: 0
    };
    var _hslB = {
        h: 0,
        s: 0,
        l: 0
    };
    function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 0.5) return q;
        if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
        return p;
    }
    function SRGBToLinear(c) {
        return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
    }
    function LinearToSRGB(c) {
        return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
    }
    var Color = /*#__PURE__*/ function() {
        function Color1(r, g, b) {
            Object.defineProperty(this, 'isColor', {
                value: true
            });
            if (g === undefined && b === undefined) // r is THREE.Color, hex or string
            return this.set(r);
            return this.setRGB(r, g, b);
        }
        var _proto = Color1.prototype;
        _proto.set = function set(value) {
            if (value && value.isColor) this.copy(value);
            else if (typeof value === 'number') this.setHex(value);
            else if (typeof value === 'string') this.setStyle(value);
            return this;
        };
        _proto.setScalar = function setScalar(scalar) {
            this.r = scalar;
            this.g = scalar;
            this.b = scalar;
            return this;
        };
        _proto.setHex = function setHex(hex) {
            hex = Math.floor(hex);
            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        };
        _proto.setRGB = function setRGB(r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
            return this;
        };
        _proto.setHSL = function setHSL(h, s, l) {
            // h,s,l ranges are in 0.0 - 1.0
            h = MathUtils.euclideanModulo(h, 1);
            s = MathUtils.clamp(s, 0, 1);
            l = MathUtils.clamp(l, 0, 1);
            if (s === 0) this.r = this.g = this.b = l;
            else {
                var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
                var q = 2 * l - p;
                this.r = hue2rgb(q, p, h + 1 / 3);
                this.g = hue2rgb(q, p, h);
                this.b = hue2rgb(q, p, h - 1 / 3);
            }
            return this;
        };
        _proto.setStyle = function setStyle(style) {
            function handleAlpha(string) {
                if (string === undefined) return;
                if (parseFloat(string) < 1) console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
            }
            var m;
            if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
                // rgb / hsl
                var color;
                var name = m[1];
                var components = m[2];
                switch(name){
                    case 'rgb':
                    case 'rgba':
                        if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                            // rgb(255,0,0) rgba(255,0,0,0.5)
                            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                            handleAlpha(color[4]);
                            return this;
                        }
                        if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                            handleAlpha(color[4]);
                            return this;
                        }
                        break;
                    case 'hsl':
                    case 'hsla':
                        if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                            var h = parseFloat(color[1]) / 360;
                            var s = parseInt(color[2], 10) / 100;
                            var l = parseInt(color[3], 10) / 100;
                            handleAlpha(color[4]);
                            return this.setHSL(h, s, l);
                        }
                        break;
                }
            } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
                // hex color
                var hex = m[1];
                var size = hex.length;
                if (size === 3) {
                    // #ff0
                    this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                    this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                    this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                    return this;
                } else if (size === 6) {
                    // #ff0000
                    this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                    this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                    this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                    return this;
                }
            }
            if (style && style.length > 0) return this.setColorName(style);
            return this;
        };
        _proto.setColorName = function setColorName(style) {
            // color keywords
            var hex = _colorKeywords[style];
            if (hex !== undefined) // red
            this.setHex(hex);
            else // unknown color
            console.warn('THREE.Color: Unknown color ' + style);
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor(this.r, this.g, this.b);
        };
        _proto.copy = function copy(color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            return this;
        };
        _proto.copyGammaToLinear = function copyGammaToLinear(color, gammaFactor) {
            if (gammaFactor === void 0) gammaFactor = 2;
            this.r = Math.pow(color.r, gammaFactor);
            this.g = Math.pow(color.g, gammaFactor);
            this.b = Math.pow(color.b, gammaFactor);
            return this;
        };
        _proto.copyLinearToGamma = function copyLinearToGamma(color, gammaFactor) {
            if (gammaFactor === void 0) gammaFactor = 2;
            var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
            this.r = Math.pow(color.r, safeInverse);
            this.g = Math.pow(color.g, safeInverse);
            this.b = Math.pow(color.b, safeInverse);
            return this;
        };
        _proto.convertGammaToLinear = function convertGammaToLinear(gammaFactor) {
            this.copyGammaToLinear(this, gammaFactor);
            return this;
        };
        _proto.convertLinearToGamma = function convertLinearToGamma(gammaFactor) {
            this.copyLinearToGamma(this, gammaFactor);
            return this;
        };
        _proto.copySRGBToLinear = function copySRGBToLinear(color) {
            this.r = SRGBToLinear(color.r);
            this.g = SRGBToLinear(color.g);
            this.b = SRGBToLinear(color.b);
            return this;
        };
        _proto.copyLinearToSRGB = function copyLinearToSRGB(color) {
            this.r = LinearToSRGB(color.r);
            this.g = LinearToSRGB(color.g);
            this.b = LinearToSRGB(color.b);
            return this;
        };
        _proto.convertSRGBToLinear = function convertSRGBToLinear() {
            this.copySRGBToLinear(this);
            return this;
        };
        _proto.convertLinearToSRGB = function convertLinearToSRGB() {
            this.copyLinearToSRGB(this);
            return this;
        };
        _proto.getHex = function getHex() {
            return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
        };
        _proto.getHexString = function getHexString() {
            return ('000000' + this.getHex().toString(16)).slice(-6);
        };
        _proto.getHSL = function getHSL(target) {
            // h,s,l ranges are in 0.0 - 1.0
            if (target === undefined) {
                console.warn('THREE.Color: .getHSL() target is now required');
                target = {
                    h: 0,
                    s: 0,
                    l: 0
                };
            }
            var r = this.r, g = this.g, b = this.b;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var hue, saturation;
            var lightness = (min + max) / 2;
            if (min === max) {
                hue = 0;
                saturation = 0;
            } else {
                var delta = max - min;
                saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                switch(max){
                    case r:
                        hue = (g - b) / delta + (g < b ? 6 : 0);
                        break;
                    case g:
                        hue = (b - r) / delta + 2;
                        break;
                    case b:
                        hue = (r - g) / delta + 4;
                        break;
                }
                hue /= 6;
            }
            target.h = hue;
            target.s = saturation;
            target.l = lightness;
            return target;
        };
        _proto.getStyle = function getStyle() {
            return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
        };
        _proto.offsetHSL = function offsetHSL(h, s, l) {
            this.getHSL(_hslA);
            _hslA.h += h;
            _hslA.s += s;
            _hslA.l += l;
            this.setHSL(_hslA.h, _hslA.s, _hslA.l);
            return this;
        };
        _proto.add = function add(color) {
            this.r += color.r;
            this.g += color.g;
            this.b += color.b;
            return this;
        };
        _proto.addColors = function addColors(color1, color2) {
            this.r = color1.r + color2.r;
            this.g = color1.g + color2.g;
            this.b = color1.b + color2.b;
            return this;
        };
        _proto.addScalar = function addScalar(s) {
            this.r += s;
            this.g += s;
            this.b += s;
            return this;
        };
        _proto.sub = function sub(color) {
            this.r = Math.max(0, this.r - color.r);
            this.g = Math.max(0, this.g - color.g);
            this.b = Math.max(0, this.b - color.b);
            return this;
        };
        _proto.multiply = function multiply(color) {
            this.r *= color.r;
            this.g *= color.g;
            this.b *= color.b;
            return this;
        };
        _proto.multiplyScalar = function multiplyScalar(s) {
            this.r *= s;
            this.g *= s;
            this.b *= s;
            return this;
        };
        _proto.lerp = function lerp(color, alpha) {
            this.r += (color.r - this.r) * alpha;
            this.g += (color.g - this.g) * alpha;
            this.b += (color.b - this.b) * alpha;
            return this;
        };
        _proto.lerpColors = function lerpColors(color1, color2, alpha) {
            this.r = color1.r + (color2.r - color1.r) * alpha;
            this.g = color1.g + (color2.g - color1.g) * alpha;
            this.b = color1.b + (color2.b - color1.b) * alpha;
            return this;
        };
        _proto.lerpHSL = function lerpHSL(color, alpha) {
            this.getHSL(_hslA);
            color.getHSL(_hslB);
            var h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
            var s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
            var l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
            this.setHSL(h, s, l);
            return this;
        };
        _proto.equals = function equals(c) {
            return c.r === this.r && c.g === this.g && c.b === this.b;
        };
        _proto.fromArray = function fromArray(array, offset) {
            if (offset === void 0) offset = 0;
            this.r = array[offset];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            return this;
        };
        _proto.toArray = function toArray(array, offset) {
            if (array === void 0) array = [];
            if (offset === void 0) offset = 0;
            array[offset] = this.r;
            array[offset + 1] = this.g;
            array[offset + 2] = this.b;
            return array;
        };
        _proto.fromBufferAttribute = function fromBufferAttribute(attribute, index) {
            this.r = attribute.getX(index);
            this.g = attribute.getY(index);
            this.b = attribute.getZ(index);
            if (attribute.normalized === true) {
                // assuming Uint8Array
                this.r /= 255;
                this.g /= 255;
                this.b /= 255;
            }
            return this;
        };
        _proto.toJSON = function toJSON() {
            return this.getHex();
        };
        return Color1;
    }();
    Color.NAMES = _colorKeywords;
    Color.prototype.r = 1;
    Color.prototype.g = 1;
    Color.prototype.b = 1;
    var Face3 = /*#__PURE__*/ function() {
        function Face31(a, b, c, normal, color, materialIndex) {
            if (materialIndex === void 0) materialIndex = 0;
            this.a = a;
            this.b = b;
            this.c = c;
            this.normal = normal && normal.isVector3 ? normal : new Vector3();
            this.vertexNormals = Array.isArray(normal) ? normal : [];
            this.color = color && color.isColor ? color : new Color();
            this.vertexColors = Array.isArray(color) ? color : [];
            this.materialIndex = materialIndex;
        }
        var _proto = Face31.prototype;
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(source) {
            this.a = source.a;
            this.b = source.b;
            this.c = source.c;
            this.normal.copy(source.normal);
            this.color.copy(source.color);
            this.materialIndex = source.materialIndex;
            for(var i6 = 0, il = source.vertexNormals.length; i6 < il; i6++)this.vertexNormals[i6] = source.vertexNormals[i6].clone();
            for(var _i = 0, _il = source.vertexColors.length; _i < _il; _i++)this.vertexColors[_i] = source.vertexColors[_i].clone();
            return this;
        };
        return Face31;
    }();
    var materialId = 0;
    function Material() {
        Object.defineProperty(this, 'id', {
            value: materialId++
        });
        this.uuid = MathUtils.generateUUID();
        this.name = '';
        this.type = 'Material';
        this.fog = true;
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.flatShading = false;
        this.vertexColors = false;
        this.opacity = 1;
        this.transparent = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.stencilWriteMask = 255;
        this.stencilFunc = AlwaysStencilFunc;
        this.stencilRef = 0;
        this.stencilFuncMask = 255;
        this.stencilFail = KeepStencilOp;
        this.stencilZFail = KeepStencilOp;
        this.stencilZPass = KeepStencilOp;
        this.stencilWrite = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null; // override the renderer's default precision for this material
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaTest = 0;
        this.premultipliedAlpha = false;
        this.visible = true;
        this.toneMapped = true;
        this.userData = {
        };
        this.version = 0;
    }
    Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: Material,
        isMaterial: true,
        onBeforeCompile: function onBeforeCompile() /* shaderobject, renderer */ {
        },
        customProgramCacheKey: function customProgramCacheKey() {
            return this.onBeforeCompile.toString();
        },
        setValues: function setValues(values) {
            if (values === undefined) return;
            for(var key2 in values){
                var newValue = values[key2];
                if (newValue === undefined) {
                    console.warn('THREE.Material: \'' + key2 + '\' parameter is undefined.');
                    continue;
                } // for backward compatability if shading is set in the constructor
                if (key2 === 'shading') {
                    console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                    this.flatShading = newValue === FlatShading ? true : false;
                    continue;
                }
                var currentValue = this[key2];
                if (currentValue === undefined) {
                    console.warn('THREE.' + this.type + ': \'' + key2 + '\' is not a property of this material.');
                    continue;
                }
                if (currentValue && currentValue.isColor) currentValue.set(newValue);
                else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) currentValue.copy(newValue);
                else this[key2] = newValue;
            }
        },
        toJSON: function toJSON(meta) {
            var isRoot = meta === undefined || typeof meta === 'string';
            if (isRoot) meta = {
                textures: {
                },
                images: {
                }
            };
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Material',
                    generator: 'Material.toJSON'
                }
            }; // standard Material serialization
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '') data.name = this.name;
            if (this.color && this.color.isColor) data.color = this.color.getHex();
            if (this.roughness !== undefined) data.roughness = this.roughness;
            if (this.metalness !== undefined) data.metalness = this.metalness;
            if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
            if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
            if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
            if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
            if (this.shininess !== undefined) data.shininess = this.shininess;
            if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
            if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
            if (this.clearcoatMap && this.clearcoatMap.isTexture) data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
            if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
            if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
                data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
                data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
            }
            if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
            if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
            if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
            if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
            if (this.aoMap && this.aoMap.isTexture) {
                data.aoMap = this.aoMap.toJSON(meta).uuid;
                data.aoMapIntensity = this.aoMapIntensity;
            }
            if (this.bumpMap && this.bumpMap.isTexture) {
                data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this.bumpScale;
            }
            if (this.normalMap && this.normalMap.isTexture) {
                data.normalMap = this.normalMap.toJSON(meta).uuid;
                data.normalMapType = this.normalMapType;
                data.normalScale = this.normalScale.toArray();
            }
            if (this.displacementMap && this.displacementMap.isTexture) {
                data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
            }
            if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
            if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
            if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
            if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
            if (this.envMap && this.envMap.isTexture) {
                data.envMap = this.envMap.toJSON(meta).uuid;
                data.reflectivity = this.reflectivity; // Scale behind envMap
                data.refractionRatio = this.refractionRatio;
                if (this.combine !== undefined) data.combine = this.combine;
                if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
            }
            if (this.gradientMap && this.gradientMap.isTexture) data.gradientMap = this.gradientMap.toJSON(meta).uuid;
            if (this.size !== undefined) data.size = this.size;
            if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
            if (this.blending !== NormalBlending) data.blending = this.blending;
            if (this.flatShading === true) data.flatShading = this.flatShading;
            if (this.side !== FrontSide) data.side = this.side;
            if (this.vertexColors) data.vertexColors = true;
            if (this.opacity < 1) data.opacity = this.opacity;
            if (this.transparent === true) data.transparent = this.transparent;
            data.depthFunc = this.depthFunc;
            data.depthTest = this.depthTest;
            data.depthWrite = this.depthWrite;
            data.stencilWrite = this.stencilWrite;
            data.stencilWriteMask = this.stencilWriteMask;
            data.stencilFunc = this.stencilFunc;
            data.stencilRef = this.stencilRef;
            data.stencilFuncMask = this.stencilFuncMask;
            data.stencilFail = this.stencilFail;
            data.stencilZFail = this.stencilZFail;
            data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)
            if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
            if (this.polygonOffset === true) data.polygonOffset = true;
            if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
            if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
            if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
            if (this.dashSize !== undefined) data.dashSize = this.dashSize;
            if (this.gapSize !== undefined) data.gapSize = this.gapSize;
            if (this.scale !== undefined) data.scale = this.scale;
            if (this.dithering === true) data.dithering = true;
            if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
            if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
            if (this.wireframe === true) data.wireframe = this.wireframe;
            if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
            if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
            if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
            if (this.morphTargets === true) data.morphTargets = true;
            if (this.morphNormals === true) data.morphNormals = true;
            if (this.skinning === true) data.skinning = true;
            if (this.visible === false) data.visible = false;
            if (this.toneMapped === false) data.toneMapped = false;
            if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON
            function extractFromCache(cache) {
                var values = [];
                for(var key2 in cache){
                    var _data = cache[key2];
                    delete _data.metadata;
                    values.push(_data);
                }
                return values;
            }
            if (isRoot) {
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                if (textures.length > 0) data.textures = textures;
                if (images.length > 0) data.images = images;
            }
            return data;
        },
        clone: function clone() {
            return new this.constructor().copy(this);
        },
        copy: function copy(source) {
            this.name = source.name;
            this.fog = source.fog;
            this.blending = source.blending;
            this.side = source.side;
            this.flatShading = source.flatShading;
            this.vertexColors = source.vertexColors;
            this.opacity = source.opacity;
            this.transparent = source.transparent;
            this.blendSrc = source.blendSrc;
            this.blendDst = source.blendDst;
            this.blendEquation = source.blendEquation;
            this.blendSrcAlpha = source.blendSrcAlpha;
            this.blendDstAlpha = source.blendDstAlpha;
            this.blendEquationAlpha = source.blendEquationAlpha;
            this.depthFunc = source.depthFunc;
            this.depthTest = source.depthTest;
            this.depthWrite = source.depthWrite;
            this.stencilWriteMask = source.stencilWriteMask;
            this.stencilFunc = source.stencilFunc;
            this.stencilRef = source.stencilRef;
            this.stencilFuncMask = source.stencilFuncMask;
            this.stencilFail = source.stencilFail;
            this.stencilZFail = source.stencilZFail;
            this.stencilZPass = source.stencilZPass;
            this.stencilWrite = source.stencilWrite;
            var srcPlanes = source.clippingPlanes;
            var dstPlanes = null;
            if (srcPlanes !== null) {
                var n = srcPlanes.length;
                dstPlanes = new Array(n);
                for(var i6 = 0; i6 !== n; ++i6)dstPlanes[i6] = srcPlanes[i6].clone();
            }
            this.clippingPlanes = dstPlanes;
            this.clipIntersection = source.clipIntersection;
            this.clipShadows = source.clipShadows;
            this.shadowSide = source.shadowSide;
            this.colorWrite = source.colorWrite;
            this.precision = source.precision;
            this.polygonOffset = source.polygonOffset;
            this.polygonOffsetFactor = source.polygonOffsetFactor;
            this.polygonOffsetUnits = source.polygonOffsetUnits;
            this.dithering = source.dithering;
            this.alphaTest = source.alphaTest;
            this.premultipliedAlpha = source.premultipliedAlpha;
            this.visible = source.visible;
            this.toneMapped = source.toneMapped;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            return this;
        },
        dispose: function dispose() {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });
    Object.defineProperty(Material.prototype, 'needsUpdate', {
        set: function set(value) {
            if (value === true) this.version++;
        }
    });
    /**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	depthTest: <bool>,
	 *	depthWrite: <bool>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>
	 * }
	 */ function MeshBasicMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshBasicMaterial';
        this.color = new Color(16777215); // emissive
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.setValues(parameters);
    }
    MeshBasicMaterial.prototype = Object.create(Material.prototype);
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
    MeshBasicMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        return this;
    };
    var _vector$3 = new Vector3();
    var _vector2$1 = new Vector2();
    function BufferAttribute(array, itemSize, normalized) {
        if (Array.isArray(array)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        this.name = '';
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== undefined ? array.length / itemSize : 0;
        this.normalized = normalized === true;
        this.usage = StaticDrawUsage;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0;
    }
    Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
        set: function set(value) {
            if (value === true) this.version++;
        }
    });
    Object.assign(BufferAttribute.prototype, {
        isBufferAttribute: true,
        onUploadCallback: function onUploadCallback() {
        },
        setUsage: function setUsage(value) {
            this.usage = value;
            return this;
        },
        copy: function copy(source) {
            this.name = source.name;
            this.array = new source.array.constructor(source.array);
            this.itemSize = source.itemSize;
            this.count = source.count;
            this.normalized = source.normalized;
            this.usage = source.usage;
            return this;
        },
        copyAt: function copyAt(index1, attribute, index2) {
            index1 *= this.itemSize;
            index2 *= attribute.itemSize;
            for(var i7 = 0, l = this.itemSize; i7 < l; i7++)this.array[index1 + i7] = attribute.array[index2 + i7];
            return this;
        },
        copyArray: function copyArray(array) {
            this.array.set(array);
            return this;
        },
        copyColorsArray: function copyColorsArray(colors) {
            var array = this.array;
            var offset = 0;
            for(var i7 = 0, l = colors.length; i7 < l; i7++){
                var color = colors[i7];
                if (color === undefined) {
                    console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i7);
                    color = new Color();
                }
                array[offset++] = color.r;
                array[offset++] = color.g;
                array[offset++] = color.b;
            }
            return this;
        },
        copyVector2sArray: function copyVector2sArray(vectors) {
            var array = this.array;
            var offset = 0;
            for(var i7 = 0, l = vectors.length; i7 < l; i7++){
                var vector = vectors[i7];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i7);
                    vector = new Vector2();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
            }
            return this;
        },
        copyVector3sArray: function copyVector3sArray(vectors) {
            var array = this.array;
            var offset = 0;
            for(var i7 = 0, l = vectors.length; i7 < l; i7++){
                var vector = vectors[i7];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i7);
                    vector = new Vector3();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
            }
            return this;
        },
        copyVector4sArray: function copyVector4sArray(vectors) {
            var array = this.array;
            var offset = 0;
            for(var i7 = 0, l = vectors.length; i7 < l; i7++){
                var vector = vectors[i7];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i7);
                    vector = new Vector4();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
                array[offset++] = vector.w;
            }
            return this;
        },
        applyMatrix3: function applyMatrix3(m) {
            if (this.itemSize === 2) for(var i7 = 0, l = this.count; i7 < l; i7++){
                _vector2$1.fromBufferAttribute(this, i7);
                _vector2$1.applyMatrix3(m);
                this.setXY(i7, _vector2$1.x, _vector2$1.y);
            }
            else if (this.itemSize === 3) for(var _i = 0, _l = this.count; _i < _l; _i++){
                _vector$3.fromBufferAttribute(this, _i);
                _vector$3.applyMatrix3(m);
                this.setXYZ(_i, _vector$3.x, _vector$3.y, _vector$3.z);
            }
            return this;
        },
        applyMatrix4: function applyMatrix4(m) {
            for(var i7 = 0, l = this.count; i7 < l; i7++){
                _vector$3.x = this.getX(i7);
                _vector$3.y = this.getY(i7);
                _vector$3.z = this.getZ(i7);
                _vector$3.applyMatrix4(m);
                this.setXYZ(i7, _vector$3.x, _vector$3.y, _vector$3.z);
            }
            return this;
        },
        applyNormalMatrix: function applyNormalMatrix(m) {
            for(var i7 = 0, l = this.count; i7 < l; i7++){
                _vector$3.x = this.getX(i7);
                _vector$3.y = this.getY(i7);
                _vector$3.z = this.getZ(i7);
                _vector$3.applyNormalMatrix(m);
                this.setXYZ(i7, _vector$3.x, _vector$3.y, _vector$3.z);
            }
            return this;
        },
        transformDirection: function transformDirection(m) {
            for(var i7 = 0, l = this.count; i7 < l; i7++){
                _vector$3.x = this.getX(i7);
                _vector$3.y = this.getY(i7);
                _vector$3.z = this.getZ(i7);
                _vector$3.transformDirection(m);
                this.setXYZ(i7, _vector$3.x, _vector$3.y, _vector$3.z);
            }
            return this;
        },
        set: function set(value, offset) {
            if (offset === void 0) offset = 0;
            this.array.set(value, offset);
            return this;
        },
        getX: function getX(index) {
            return this.array[index * this.itemSize];
        },
        setX: function setX(index, x) {
            this.array[index * this.itemSize] = x;
            return this;
        },
        getY: function getY(index) {
            return this.array[index * this.itemSize + 1];
        },
        setY: function setY(index, y) {
            this.array[index * this.itemSize + 1] = y;
            return this;
        },
        getZ: function getZ(index) {
            return this.array[index * this.itemSize + 2];
        },
        setZ: function setZ(index, z) {
            this.array[index * this.itemSize + 2] = z;
            return this;
        },
        getW: function getW(index) {
            return this.array[index * this.itemSize + 3];
        },
        setW: function setW(index, w) {
            this.array[index * this.itemSize + 3] = w;
            return this;
        },
        setXY: function setXY(index, x, y) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            return this;
        },
        setXYZ: function setXYZ(index, x, y, z) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            return this;
        },
        setXYZW: function setXYZW(index, x, y, z, w) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            this.array[index + 3] = w;
            return this;
        },
        onUpload: function onUpload(callback) {
            this.onUploadCallback = callback;
            return this;
        },
        clone: function clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        },
        toJSON: function toJSON() {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            };
        }
    }); //
    function Int8BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
    }
    Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
    function Uint8BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
    }
    Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
    function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
    }
    Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
    function Int16BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
    }
    Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
    function Uint16BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
    }
    Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
    function Int32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
    }
    Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
    function Uint32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
    }
    Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
    function Float16BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
    }
    Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
    Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
    function Float32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
    }
    Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
    function Float64BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
    }
    Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float64BufferAttribute.prototype.constructor = Float64BufferAttribute; //
    function arrayMax(array) {
        if (array.length === 0) return -Infinity;
        var max = array[0];
        for(var i7 = 1, l = array.length; i7 < l; ++i7)if (array[i7] > max) max = array[i7];
        return max;
    }
    var TYPED_ARRAYS = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        // Workaround for IE11 pre KB2929437. See #11440
        Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    function getTypedArray(type, buffer) {
        return new TYPED_ARRAYS[type](buffer);
    }
    var _id = 0;
    var _m1$2 = new Matrix4();
    var _obj = new Object3D();
    var _offset = new Vector3();
    var _box$2 = new Box3();
    var _boxMorphTargets = new Box3();
    var _vector$4 = new Vector3();
    function BufferGeometry() {
        Object.defineProperty(this, 'id', {
            value: _id++
        });
        this.uuid = MathUtils.generateUUID();
        this.name = '';
        this.type = 'BufferGeometry';
        this.index = null;
        this.attributes = {
        };
        this.morphAttributes = {
        };
        this.morphTargetsRelative = false;
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = {
            start: 0,
            count: Infinity
        };
        this.userData = {
        };
    }
    BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: BufferGeometry,
        isBufferGeometry: true,
        getIndex: function getIndex() {
            return this.index;
        },
        setIndex: function setIndex(index) {
            if (Array.isArray(index)) this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
            else this.index = index;
            return this;
        },
        getAttribute: function getAttribute(name) {
            return this.attributes[name];
        },
        setAttribute: function setAttribute(name, attribute) {
            this.attributes[name] = attribute;
            return this;
        },
        deleteAttribute: function deleteAttribute(name) {
            delete this.attributes[name];
            return this;
        },
        hasAttribute: function hasAttribute(name) {
            return this.attributes[name] !== undefined;
        },
        addGroup: function addGroup(start, count, materialIndex) {
            if (materialIndex === void 0) materialIndex = 0;
            this.groups.push({
                start: start,
                count: count,
                materialIndex: materialIndex
            });
        },
        clearGroups: function clearGroups() {
            this.groups = [];
        },
        setDrawRange: function setDrawRange(start, count) {
            this.drawRange.start = start;
            this.drawRange.count = count;
        },
        applyMatrix4: function applyMatrix4(matrix) {
            var position = this.attributes.position;
            if (position !== undefined) {
                position.applyMatrix4(matrix);
                position.needsUpdate = true;
            }
            var normal = this.attributes.normal;
            if (normal !== undefined) {
                var normalMatrix = new Matrix3().getNormalMatrix(matrix);
                normal.applyNormalMatrix(normalMatrix);
                normal.needsUpdate = true;
            }
            var tangent = this.attributes.tangent;
            if (tangent !== undefined) {
                tangent.transformDirection(matrix);
                tangent.needsUpdate = true;
            }
            if (this.boundingBox !== null) this.computeBoundingBox();
            if (this.boundingSphere !== null) this.computeBoundingSphere();
            return this;
        },
        rotateX: function rotateX(angle) {
            // rotate geometry around world x-axis
            _m1$2.makeRotationX(angle);
            this.applyMatrix4(_m1$2);
            return this;
        },
        rotateY: function rotateY(angle) {
            // rotate geometry around world y-axis
            _m1$2.makeRotationY(angle);
            this.applyMatrix4(_m1$2);
            return this;
        },
        rotateZ: function rotateZ(angle) {
            // rotate geometry around world z-axis
            _m1$2.makeRotationZ(angle);
            this.applyMatrix4(_m1$2);
            return this;
        },
        translate: function translate(x, y, z) {
            // translate geometry
            _m1$2.makeTranslation(x, y, z);
            this.applyMatrix4(_m1$2);
            return this;
        },
        scale: function scale(x, y, z) {
            // scale geometry
            _m1$2.makeScale(x, y, z);
            this.applyMatrix4(_m1$2);
            return this;
        },
        lookAt: function lookAt(vector) {
            _obj.lookAt(vector);
            _obj.updateMatrix();
            this.applyMatrix4(_obj.matrix);
            return this;
        },
        center: function center() {
            this.computeBoundingBox();
            this.boundingBox.getCenter(_offset).negate();
            this.translate(_offset.x, _offset.y, _offset.z);
            return this;
        },
        setFromPoints: function setFromPoints(points) {
            var position = [];
            for(var i7 = 0, l = points.length; i7 < l; i7++){
                var point = points[i7];
                position.push(point.x, point.y, point.z || 0);
            }
            this.setAttribute('position', new Float32BufferAttribute(position, 3));
            return this;
        },
        computeBoundingBox: function computeBoundingBox() {
            if (this.boundingBox === null) this.boundingBox = new Box3();
            var position = this.attributes.position;
            var morphAttributesPosition = this.morphAttributes.position;
            if (position && position.isGLBufferAttribute) {
                console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
                this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
                return;
            }
            if (position !== undefined) {
                this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present
                if (morphAttributesPosition) for(var i7 = 0, il = morphAttributesPosition.length; i7 < il; i7++){
                    var morphAttribute = morphAttributesPosition[i7];
                    _box$2.setFromBufferAttribute(morphAttribute);
                    if (this.morphTargetsRelative) {
                        _vector$4.addVectors(this.boundingBox.min, _box$2.min);
                        this.boundingBox.expandByPoint(_vector$4);
                        _vector$4.addVectors(this.boundingBox.max, _box$2.max);
                        this.boundingBox.expandByPoint(_vector$4);
                    } else {
                        this.boundingBox.expandByPoint(_box$2.min);
                        this.boundingBox.expandByPoint(_box$2.max);
                    }
                }
            } else this.boundingBox.makeEmpty();
            if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        },
        computeBoundingSphere: function computeBoundingSphere() {
            if (this.boundingSphere === null) this.boundingSphere = new Sphere();
            var position = this.attributes.position;
            var morphAttributesPosition = this.morphAttributes.position;
            if (position && position.isGLBufferAttribute) {
                console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
                this.boundingSphere.set(new Vector3(), Infinity);
                return;
            }
            if (position) {
                // first, find the center of the bounding sphere
                var center1 = this.boundingSphere.center;
                _box$2.setFromBufferAttribute(position); // process morph attributes if present
                if (morphAttributesPosition) for(var i8 = 0, il = morphAttributesPosition.length; i8 < il; i8++){
                    var morphAttribute = morphAttributesPosition[i8];
                    _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                    if (this.morphTargetsRelative) {
                        _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
                        _box$2.expandByPoint(_vector$4);
                        _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
                        _box$2.expandByPoint(_vector$4);
                    } else {
                        _box$2.expandByPoint(_boxMorphTargets.min);
                        _box$2.expandByPoint(_boxMorphTargets.max);
                    }
                }
                _box$2.getCenter(center1); // second, try to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
                var maxRadiusSq = 0;
                for(var _i = 0, _il = position.count; _i < _il; _i++){
                    _vector$4.fromBufferAttribute(position, _i);
                    maxRadiusSq = Math.max(maxRadiusSq, center1.distanceToSquared(_vector$4));
                } // process morph attributes if present
                if (morphAttributesPosition) for(var _i2 = 0, _il2 = morphAttributesPosition.length; _i2 < _il2; _i2++){
                    var _morphAttribute = morphAttributesPosition[_i2];
                    var morphTargetsRelative = this.morphTargetsRelative;
                    for(var j = 0, jl = _morphAttribute.count; j < jl; j++){
                        _vector$4.fromBufferAttribute(_morphAttribute, j);
                        if (morphTargetsRelative) {
                            _offset.fromBufferAttribute(position, j);
                            _vector$4.add(_offset);
                        }
                        maxRadiusSq = Math.max(maxRadiusSq, center1.distanceToSquared(_vector$4));
                    }
                }
                this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                if (isNaN(this.boundingSphere.radius)) console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
            }
        },
        computeFaceNormals: function computeFaceNormals() {
        },
        computeTangents: function computeTangents() {
            var index = this.index;
            var attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
            // (per vertex tangents)
            if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
                console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
                return;
            }
            var indices = index.array;
            var positions = attributes.position.array;
            var normals = attributes.normal.array;
            var uvs = attributes.uv.array;
            var nVertices = positions.length / 3;
            if (attributes.tangent === undefined) this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
            var tangents = attributes.tangent.array;
            var tan1 = [], tan2 = [];
            for(var i9 = 0; i9 < nVertices; i9++){
                tan1[i9] = new Vector3();
                tan2[i9] = new Vector3();
            }
            var vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
            function handleTriangle(a, b, c) {
                vA.fromArray(positions, a * 3);
                vB.fromArray(positions, b * 3);
                vC.fromArray(positions, c * 3);
                uvA.fromArray(uvs, a * 2);
                uvB.fromArray(uvs, b * 2);
                uvC.fromArray(uvs, c * 2);
                vB.sub(vA);
                vC.sub(vA);
                uvB.sub(uvA);
                uvC.sub(uvA);
                var r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices
                if (!isFinite(r)) return;
                sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
                tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
                tan1[a].add(sdir);
                tan1[b].add(sdir);
                tan1[c].add(sdir);
                tan2[a].add(tdir);
                tan2[b].add(tdir);
                tan2[c].add(tdir);
            }
            var groups = this.groups;
            if (groups.length === 0) groups = [
                {
                    start: 0,
                    count: indices.length
                }
            ];
            for(var _i3 = 0, il = groups.length; _i3 < il; ++_i3){
                var group = groups[_i3];
                var start = group.start;
                var count = group.count;
                for(var j = start, jl = start + count; j < jl; j += 3)handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
            }
            var tmp = new Vector3(), tmp2 = new Vector3();
            var n = new Vector3(), n2 = new Vector3();
            function handleVertex(v) {
                n.fromArray(normals, v * 3);
                n2.copy(n);
                var t = tan1[v]; // Gram-Schmidt orthogonalize
                tmp.copy(t);
                tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness
                tmp2.crossVectors(n2, t);
                var test = tmp2.dot(tan2[v]);
                var w = test < 0 ? -1 : 1;
                tangents[v * 4] = tmp.x;
                tangents[v * 4 + 1] = tmp.y;
                tangents[v * 4 + 2] = tmp.z;
                tangents[v * 4 + 3] = w;
            }
            for(var _i4 = 0, _il3 = groups.length; _i4 < _il3; ++_i4){
                var _group = groups[_i4];
                var _start = _group.start;
                var _count = _group.count;
                for(var _j = _start, _jl = _start + _count; _j < _jl; _j += 3){
                    handleVertex(indices[_j + 0]);
                    handleVertex(indices[_j + 1]);
                    handleVertex(indices[_j + 2]);
                }
            }
        },
        computeVertexNormals: function computeVertexNormals() {
            var index = this.index;
            var positionAttribute = this.getAttribute('position');
            if (positionAttribute !== undefined) {
                var normalAttribute = this.getAttribute('normal');
                if (normalAttribute === undefined) {
                    normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
                    this.setAttribute('normal', normalAttribute);
                } else // reset existing normals to zero
                for(var i9 = 0, il = normalAttribute.count; i9 < il; i9++)normalAttribute.setXYZ(i9, 0, 0, 0);
                var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
                var nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
                var cb = new Vector3(), ab = new Vector3(); // indexed elements
                if (index) for(var _i5 = 0, _il4 = index.count; _i5 < _il4; _i5 += 3){
                    var vA = index.getX(_i5 + 0);
                    var vB = index.getX(_i5 + 1);
                    var vC = index.getX(_i5 + 2);
                    pA.fromBufferAttribute(positionAttribute, vA);
                    pB.fromBufferAttribute(positionAttribute, vB);
                    pC.fromBufferAttribute(positionAttribute, vC);
                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);
                    nA.fromBufferAttribute(normalAttribute, vA);
                    nB.fromBufferAttribute(normalAttribute, vB);
                    nC.fromBufferAttribute(normalAttribute, vC);
                    nA.add(cb);
                    nB.add(cb);
                    nC.add(cb);
                    normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                    normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                    normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
                }
                else // non-indexed elements (unconnected triangle soup)
                for(var _i6 = 0, _il5 = positionAttribute.count; _i6 < _il5; _i6 += 3){
                    pA.fromBufferAttribute(positionAttribute, _i6 + 0);
                    pB.fromBufferAttribute(positionAttribute, _i6 + 1);
                    pC.fromBufferAttribute(positionAttribute, _i6 + 2);
                    cb.subVectors(pC, pB);
                    ab.subVectors(pA, pB);
                    cb.cross(ab);
                    normalAttribute.setXYZ(_i6 + 0, cb.x, cb.y, cb.z);
                    normalAttribute.setXYZ(_i6 + 1, cb.x, cb.y, cb.z);
                    normalAttribute.setXYZ(_i6 + 2, cb.x, cb.y, cb.z);
                }
                this.normalizeNormals();
                normalAttribute.needsUpdate = true;
            }
        },
        merge: function merge(geometry, offset) {
            if (!(geometry && geometry.isBufferGeometry)) {
                console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
                return;
            }
            if (offset === undefined) {
                offset = 0;
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
            }
            var attributes = this.attributes;
            for(var key2 in attributes){
                if (geometry.attributes[key2] === undefined) continue;
                var attribute1 = attributes[key2];
                var attributeArray1 = attribute1.array;
                var attribute2 = geometry.attributes[key2];
                var attributeArray2 = attribute2.array;
                var attributeOffset = attribute2.itemSize * offset;
                var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
                for(var i10 = 0, j = attributeOffset; i10 < length; i10++, j++)attributeArray1[j] = attributeArray2[i10];
            }
            return this;
        },
        normalizeNormals: function normalizeNormals() {
            var normals = this.attributes.normal;
            for(var i11 = 0, il = normals.count; i11 < il; i11++){
                _vector$4.fromBufferAttribute(normals, i11);
                _vector$4.normalize();
                normals.setXYZ(i11, _vector$4.x, _vector$4.y, _vector$4.z);
            }
        },
        toNonIndexed: function toNonIndexed() {
            function convertBufferAttribute(attribute, indices) {
                var array = attribute.array;
                var itemSize = attribute.itemSize;
                var normalized = attribute.normalized;
                var array2 = new array.constructor(indices.length * itemSize);
                var index = 0, index2 = 0;
                for(var i11 = 0, l = indices.length; i11 < l; i11++){
                    index = indices[i11] * itemSize;
                    for(var j = 0; j < itemSize; j++)array2[index2++] = array[index++];
                }
                return new BufferAttribute(array2, itemSize, normalized);
            } //
            if (this.index === null) {
                console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
                return this;
            }
            var geometry2 = new BufferGeometry();
            var indices = this.index.array;
            var attributes = this.attributes; // attributes
            for(var name in attributes){
                var attribute = attributes[name];
                var newAttribute = convertBufferAttribute(attribute, indices);
                geometry2.setAttribute(name, newAttribute);
            } // morph attributes
            var morphAttributes = this.morphAttributes;
            for(var _name in morphAttributes){
                var morphArray = [];
                var morphAttribute = morphAttributes[_name]; // morphAttribute: array of Float32BufferAttributes
                for(var i11 = 0, il = morphAttribute.length; i11 < il; i11++){
                    var _attribute = morphAttribute[i11];
                    var _newAttribute = convertBufferAttribute(_attribute, indices);
                    morphArray.push(_newAttribute);
                }
                geometry2.morphAttributes[_name] = morphArray;
            }
            geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups
            var groups = this.groups;
            for(var _i7 = 0, l = groups.length; _i7 < l; _i7++){
                var group = groups[_i7];
                geometry2.addGroup(group.start, group.count, group.materialIndex);
            }
            return geometry2;
        },
        toJSON: function toJSON() {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'BufferGeometry',
                    generator: 'BufferGeometry.toJSON'
                }
            }; // standard BufferGeometry serialization
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '') data.name = this.name;
            if (Object.keys(this.userData).length > 0) data.userData = this.userData;
            if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for(var key2 in parameters)if (parameters[key2] !== undefined) data[key2] = parameters[key2];
                return data;
            }
            data.data = {
                attributes: {
                }
            };
            var index = this.index;
            if (index !== null) data.data.index = {
                type: index.array.constructor.name,
                array: Array.prototype.slice.call(index.array)
            };
            var attributes = this.attributes;
            for(var _key in attributes){
                var attribute = attributes[_key];
                var attributeData = attribute.toJSON(data.data);
                if (attribute.name !== '') attributeData.name = attribute.name;
                data.data.attributes[_key] = attributeData;
            }
            var morphAttributes = {
            };
            var hasMorphAttributes = false;
            for(var _key2 in this.morphAttributes){
                var attributeArray = this.morphAttributes[_key2];
                var array = [];
                for(var i12 = 0, il = attributeArray.length; i12 < il; i12++){
                    var _attribute2 = attributeArray[i12];
                    var _attributeData = _attribute2.toJSON(data.data);
                    if (_attribute2.name !== '') _attributeData.name = _attribute2.name;
                    array.push(_attributeData);
                }
                if (array.length > 0) {
                    morphAttributes[_key2] = array;
                    hasMorphAttributes = true;
                }
            }
            if (hasMorphAttributes) {
                data.data.morphAttributes = morphAttributes;
                data.data.morphTargetsRelative = this.morphTargetsRelative;
            }
            var groups = this.groups;
            if (groups.length > 0) data.data.groups = JSON.parse(JSON.stringify(groups));
            var boundingSphere = this.boundingSphere;
            if (boundingSphere !== null) data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            };
            return data;
        },
        clone: function clone() {
            /*
			 // Handle primitives
				 const parameters = this.parameters;
				 if ( parameters !== undefined ) {
				 const values = [];
				 for ( const key in parameters ) {
				 values.push( parameters[ key ] );
				 }
				 const geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;
				 }
				 return new this.constructor().copy( this );
			 */ return new BufferGeometry().copy(this);
        },
        copy: function copy(source) {
            // reset
            this.index = null;
            this.attributes = {
            };
            this.morphAttributes = {
            };
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null; // used for storing cloned, shared data
            var data = {
            }; // name
            this.name = source.name; // index
            var index = source.index;
            if (index !== null) this.setIndex(index.clone(data));
             // attributes
            var attributes = source.attributes;
            for(var name in attributes){
                var attribute = attributes[name];
                this.setAttribute(name, attribute.clone(data));
            } // morph attributes
            var morphAttributes = source.morphAttributes;
            for(var _name2 in morphAttributes){
                var array = [];
                var morphAttribute = morphAttributes[_name2]; // morphAttribute: array of Float32BufferAttributes
                for(var i13 = 0, l = morphAttribute.length; i13 < l; i13++)array.push(morphAttribute[i13].clone(data));
                this.morphAttributes[_name2] = array;
            }
            this.morphTargetsRelative = source.morphTargetsRelative; // groups
            var groups = source.groups;
            for(var _i8 = 0, _l = groups.length; _i8 < _l; _i8++){
                var group = groups[_i8];
                this.addGroup(group.start, group.count, group.materialIndex);
            } // bounding box
            var boundingBox = source.boundingBox;
            if (boundingBox !== null) this.boundingBox = boundingBox.clone();
             // bounding sphere
            var boundingSphere = source.boundingSphere;
            if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
             // draw range
            this.drawRange.start = source.drawRange.start;
            this.drawRange.count = source.drawRange.count; // user data
            this.userData = source.userData;
            return this;
        },
        dispose: function dispose() {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });
    var _inverseMatrix = new Matrix4();
    var _ray = new Ray();
    var _sphere = new Sphere();
    var _vA = new Vector3();
    var _vB = new Vector3();
    var _vC = new Vector3();
    var _tempA = new Vector3();
    var _tempB = new Vector3();
    var _tempC = new Vector3();
    var _morphA = new Vector3();
    var _morphB = new Vector3();
    var _morphC = new Vector3();
    var _uvA = new Vector2();
    var _uvB = new Vector2();
    var _uvC = new Vector2();
    var _intersectionPoint = new Vector3();
    var _intersectionPointWorld = new Vector3();
    function Mesh(geometry, material) {
        if (geometry === void 0) geometry = new BufferGeometry();
        if (material === void 0) material = new MeshBasicMaterial();
        Object3D.call(this);
        this.type = 'Mesh';
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
    }
    Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Mesh,
        isMesh: true,
        copy: function copy(source) {
            Object3D.prototype.copy.call(this, source);
            if (source.morphTargetInfluences !== undefined) this.morphTargetInfluences = source.morphTargetInfluences.slice();
            if (source.morphTargetDictionary !== undefined) this.morphTargetDictionary = Object.assign({
            }, source.morphTargetDictionary);
            this.material = source.material;
            this.geometry = source.geometry;
            return this;
        },
        updateMorphTargets: function updateMorphTargets() {
            var geometry = this.geometry;
            if (geometry.isBufferGeometry) {
                var morphAttributes = geometry.morphAttributes;
                var keys = Object.keys(morphAttributes);
                if (keys.length > 0) {
                    var morphAttribute = morphAttributes[keys[0]];
                    if (morphAttribute !== undefined) {
                        this.morphTargetInfluences = [];
                        this.morphTargetDictionary = {
                        };
                        for(var m = 0, ml = morphAttribute.length; m < ml; m++){
                            var name = morphAttribute[m].name || String(m);
                            this.morphTargetInfluences.push(0);
                            this.morphTargetDictionary[name] = m;
                        }
                    }
                }
            } else {
                var morphTargets = geometry.morphTargets;
                if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
            }
        },
        raycast: function raycast(raycaster, intersects) {
            var geometry = this.geometry;
            var material = this.material;
            var matrixWorld = this.matrixWorld;
            if (material === undefined) return; // Checking boundingSphere distance to ray
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            _sphere.copy(geometry.boundingSphere);
            _sphere.applyMatrix4(matrixWorld);
            if (raycaster.ray.intersectsSphere(_sphere) === false) return; //
            _inverseMatrix.copy(matrixWorld).invert();
            _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing
            if (geometry.boundingBox !== null) {
                if (_ray.intersectsBox(geometry.boundingBox) === false) return;
            }
            var intersection;
            if (geometry.isBufferGeometry) {
                var index = geometry.index;
                var position = geometry.attributes.position;
                var morphPosition = geometry.morphAttributes.position;
                var morphTargetsRelative = geometry.morphTargetsRelative;
                var uv = geometry.attributes.uv;
                var uv2 = geometry.attributes.uv2;
                var groups = geometry.groups;
                var drawRange = geometry.drawRange;
                if (index !== null) {
                    // indexed buffer geometry
                    if (Array.isArray(material)) for(var i14 = 0, il = groups.length; i14 < il; i14++){
                        var group = groups[i14];
                        var groupMaterial = material[group.materialIndex];
                        var start = Math.max(group.start, drawRange.start);
                        var end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                        for(var j = start, jl = end; j < jl; j += 3){
                            var a = index.getX(j);
                            var b = index.getX(j + 1);
                            var c = index.getX(j + 2);
                            intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                                intersection.face.materialIndex = group.materialIndex;
                                intersects.push(intersection);
                            }
                        }
                    }
                    else {
                        var _start = Math.max(0, drawRange.start);
                        var _end = Math.min(index.count, drawRange.start + drawRange.count);
                        for(var _i = _start, _il = _end; _i < _il; _i += 3){
                            var _a = index.getX(_i);
                            var _b = index.getX(_i + 1);
                            var _c = index.getX(_i + 2);
                            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a, _b, _c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(_i / 3); // triangle number in indexed buffer semantics
                                intersects.push(intersection);
                            }
                        }
                    }
                } else if (position !== undefined) {
                    // non-indexed buffer geometry
                    if (Array.isArray(material)) for(var _i2 = 0, _il2 = groups.length; _i2 < _il2; _i2++){
                        var _group = groups[_i2];
                        var _groupMaterial = material[_group.materialIndex];
                        var _start2 = Math.max(_group.start, drawRange.start);
                        var _end2 = Math.min(_group.start + _group.count, drawRange.start + drawRange.count);
                        for(var _j = _start2, _jl = _end2; _j < _jl; _j += 3){
                            var _a2 = _j;
                            var _b2 = _j + 1;
                            var _c2 = _j + 2;
                            intersection = checkBufferGeometryIntersection(this, _groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a2, _b2, _c2);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(_j / 3); // triangle number in non-indexed buffer semantics
                                intersection.face.materialIndex = _group.materialIndex;
                                intersects.push(intersection);
                            }
                        }
                    }
                    else {
                        var _start3 = Math.max(0, drawRange.start);
                        var _end3 = Math.min(position.count, drawRange.start + drawRange.count);
                        for(var _i3 = _start3, _il3 = _end3; _i3 < _il3; _i3 += 3){
                            var _a3 = _i3;
                            var _b3 = _i3 + 1;
                            var _c3 = _i3 + 2;
                            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, _a3, _b3, _c3);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(_i3 / 3); // triangle number in non-indexed buffer semantics
                                intersects.push(intersection);
                            }
                        }
                    }
                }
            } else if (geometry.isGeometry) console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    });
    function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
        var intersect;
        if (material.side === BackSide) intersect = ray.intersectTriangle(pC, pB, pA, true, point);
        else intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
        if (intersect === null) return null;
        _intersectionPointWorld.copy(point);
        _intersectionPointWorld.applyMatrix4(object.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
        if (distance < raycaster.near || distance > raycaster.far) return null;
        return {
            distance: distance,
            point: _intersectionPointWorld.clone(),
            object: object
        };
    }
    function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
        _vA.fromBufferAttribute(position, a);
        _vB.fromBufferAttribute(position, b);
        _vC.fromBufferAttribute(position, c);
        var morphInfluences = object.morphTargetInfluences;
        if (material.morphTargets && morphPosition && morphInfluences) {
            _morphA.set(0, 0, 0);
            _morphB.set(0, 0, 0);
            _morphC.set(0, 0, 0);
            for(var i15 = 0, il = morphPosition.length; i15 < il; i15++){
                var influence = morphInfluences[i15];
                var morphAttribute = morphPosition[i15];
                if (influence === 0) continue;
                _tempA.fromBufferAttribute(morphAttribute, a);
                _tempB.fromBufferAttribute(morphAttribute, b);
                _tempC.fromBufferAttribute(morphAttribute, c);
                if (morphTargetsRelative) {
                    _morphA.addScaledVector(_tempA, influence);
                    _morphB.addScaledVector(_tempB, influence);
                    _morphC.addScaledVector(_tempC, influence);
                } else {
                    _morphA.addScaledVector(_tempA.sub(_vA), influence);
                    _morphB.addScaledVector(_tempB.sub(_vB), influence);
                    _morphC.addScaledVector(_tempC.sub(_vC), influence);
                }
            }
            _vA.add(_morphA);
            _vB.add(_morphB);
            _vC.add(_morphC);
        }
        if (object.isSkinnedMesh) {
            object.boneTransform(a, _vA);
            object.boneTransform(b, _vB);
            object.boneTransform(c, _vC);
        }
        var intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
        if (intersection) {
            if (uv) {
                _uvA.fromBufferAttribute(uv, a);
                _uvB.fromBufferAttribute(uv, b);
                _uvC.fromBufferAttribute(uv, c);
                intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
            }
            if (uv2) {
                _uvA.fromBufferAttribute(uv2, a);
                _uvB.fromBufferAttribute(uv2, b);
                _uvC.fromBufferAttribute(uv2, c);
                intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
            }
            var face = new Face3(a, b, c);
            Triangle.getNormal(_vA, _vB, _vC, face.normal);
            intersection.face = face;
        }
        return intersection;
    }
    var BoxGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(BoxGeometry2, _BufferGeometry);
        function BoxGeometry2(width, height, depth, widthSegments, heightSegments, depthSegments) {
            var _this;
            if (width === void 0) width = 1;
            if (height === void 0) height = 1;
            if (depth === void 0) depth = 1;
            if (widthSegments === void 0) widthSegments = 1;
            if (heightSegments === void 0) heightSegments = 1;
            if (depthSegments === void 0) depthSegments = 1;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'BoxGeometry';
            _this.parameters = {
                width: width,
                height: height,
                depth: depth,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                depthSegments: depthSegments
            };
            var scope = _assertThisInitialized(_this); // segments
            widthSegments = Math.floor(widthSegments);
            heightSegments = Math.floor(heightSegments);
            depthSegments = Math.floor(depthSegments); // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = []; // helper variables
            var numberOfVertices = 0;
            var groupStart = 0; // build each side of the box geometry
            buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
            buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
            buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
            buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
            buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
            buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
            // build geometry
            _this.setIndex(indices);
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            function buildPlane(u, v, w, udir, vdir, width1, height1, depth1, gridX, gridY, materialIndex) {
                var segmentWidth = width1 / gridX;
                var segmentHeight = height1 / gridY;
                var widthHalf = width1 / 2;
                var heightHalf = height1 / 2;
                var depthHalf = depth1 / 2;
                var gridX1 = gridX + 1;
                var gridY1 = gridY + 1;
                var vertexCounter = 0;
                var groupCount = 0;
                var vector = new Vector3(); // generate vertices, normals and uvs
                for(var iy = 0; iy < gridY1; iy++){
                    var y = iy * segmentHeight - heightHalf;
                    for(var ix = 0; ix < gridX1; ix++){
                        var x = ix * segmentWidth - widthHalf; // set values to correct vector component
                        vector[u] = x * udir;
                        vector[v] = y * vdir;
                        vector[w] = depthHalf; // now apply vector to vertex buffer
                        vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component
                        vector[u] = 0;
                        vector[v] = 0;
                        vector[w] = depth1 > 0 ? 1 : -1; // now apply vector to normal buffer
                        normals.push(vector.x, vector.y, vector.z); // uvs
                        uvs.push(ix / gridX);
                        uvs.push(1 - iy / gridY); // counters
                        vertexCounter += 1;
                    }
                } // indices
                // 1. you need three indices to draw a single face
                // 2. a single segment consists of two faces
                // 3. so we need to generate six (2*3) indices per segment
                for(var _iy = 0; _iy < gridY; _iy++)for(var _ix = 0; _ix < gridX; _ix++){
                    var a = numberOfVertices + _ix + gridX1 * _iy;
                    var b = numberOfVertices + _ix + gridX1 * (_iy + 1);
                    var c = numberOfVertices + (_ix + 1) + gridX1 * (_iy + 1);
                    var d = numberOfVertices + (_ix + 1) + gridX1 * _iy; // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d); // increase counter
                    groupCount += 6;
                }
                 // add a group to the geometry. this will ensure multi material support
                scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups
                groupStart += groupCount; // update total number of vertices
                numberOfVertices += vertexCounter;
            }
            return _this;
        }
        return BoxGeometry2;
    }(BufferGeometry);
    /**
	 * Uniform Utilities
	 */ function cloneUniforms(src) {
        var dst = {
        };
        for(var u in src){
            dst[u] = {
            };
            for(var p in src[u]){
                var property = src[u][p];
                if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) dst[u][p] = property.clone();
                else if (Array.isArray(property)) dst[u][p] = property.slice();
                else dst[u][p] = property;
            }
        }
        return dst;
    }
    function mergeUniforms(uniforms) {
        var merged = {
        };
        for(var u = 0; u < uniforms.length; u++){
            var tmp = cloneUniforms(uniforms[u]);
            for(var p in tmp)merged[p] = tmp[p];
        }
        return merged;
    } // Legacy
    var UniformsUtils = {
        clone: cloneUniforms,
        merge: mergeUniforms
    };
    var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    /**
	 * parameters = {
	 *	defines: { "label" : "value" },
	 *	uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *	fragmentShader: <string>,
	 *	vertexShader: <string>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	lights: <bool>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */ function ShaderMaterial(parameters) {
        Material.call(this);
        this.type = 'ShaderMaterial';
        this.defines = {
        };
        this.uniforms = {
        };
        this.vertexShader = default_vertex;
        this.fragmentShader = default_fragment;
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false; // set to use scene fog
        this.lights = false; // set to use scene lights
        this.clipping = false; // set to use user-defined clipping planes
        this.skinning = false; // set to use skinning attribute streams
        this.morphTargets = false; // set to use morph targets
        this.morphNormals = false; // set to use morph normals
        this.extensions = {
            derivatives: false,
            // set to use derivatives
            fragDepth: false,
            // set to use fragment depth values
            drawBuffers: false,
            // set to use draw buffers
            shaderTextureLOD: false
        }; // When rendered geometry doesn't include these attributes but the material does,
        // use these default values in WebGL. This avoids errors when buffer data is missing.
        this.defaultAttributeValues = {
            'color': [
                1,
                1,
                1
            ],
            'uv': [
                0,
                0
            ],
            'uv2': [
                0,
                0
            ]
        };
        this.index0AttributeName = undefined;
        this.uniformsNeedUpdate = false;
        this.glslVersion = null;
        if (parameters !== undefined) {
            if (parameters.attributes !== undefined) console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
            this.setValues(parameters);
        }
    }
    ShaderMaterial.prototype = Object.create(Material.prototype);
    ShaderMaterial.prototype.constructor = ShaderMaterial;
    ShaderMaterial.prototype.isShaderMaterial = true;
    ShaderMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = cloneUniforms(source.uniforms);
        this.defines = Object.assign({
        }, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.extensions = Object.assign({
        }, source.extensions);
        this.glslVersion = source.glslVersion;
        return this;
    };
    ShaderMaterial.prototype.toJSON = function(meta) {
        var data = Material.prototype.toJSON.call(this, meta);
        data.glslVersion = this.glslVersion;
        data.uniforms = {
        };
        for(var name in this.uniforms){
            var uniform = this.uniforms[name];
            var value = uniform.value;
            if (value && value.isTexture) data.uniforms[name] = {
                type: 't',
                value: value.toJSON(meta).uuid
            };
            else if (value && value.isColor) data.uniforms[name] = {
                type: 'c',
                value: value.getHex()
            };
            else if (value && value.isVector2) data.uniforms[name] = {
                type: 'v2',
                value: value.toArray()
            };
            else if (value && value.isVector3) data.uniforms[name] = {
                type: 'v3',
                value: value.toArray()
            };
            else if (value && value.isVector4) data.uniforms[name] = {
                type: 'v4',
                value: value.toArray()
            };
            else if (value && value.isMatrix3) data.uniforms[name] = {
                type: 'm3',
                value: value.toArray()
            };
            else if (value && value.isMatrix4) data.uniforms[name] = {
                type: 'm4',
                value: value.toArray()
            };
            else data.uniforms[name] = {
                value: value
            }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
        }
        if (Object.keys(this.defines).length > 0) data.defines = this.defines;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        var extensions = {
        };
        for(var key3 in this.extensions)if (this.extensions[key3] === true) extensions[key3] = true;
        if (Object.keys(extensions).length > 0) data.extensions = extensions;
        return data;
    };
    function Camera() {
        Object3D.call(this);
        this.type = 'Camera';
        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
        this.projectionMatrixInverse = new Matrix4();
    }
    Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Camera,
        isCamera: true,
        copy: function copy(source, recursive) {
            Object3D.prototype.copy.call(this, source, recursive);
            this.matrixWorldInverse.copy(source.matrixWorldInverse);
            this.projectionMatrix.copy(source.projectionMatrix);
            this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
            return this;
        },
        getWorldDirection: function getWorldDirection(target) {
            if (target === undefined) {
                console.warn('THREE.Camera: .getWorldDirection() target is now required');
                target = new Vector3();
            }
            this.updateWorldMatrix(true, false);
            var e = this.matrixWorld.elements;
            return target.set(-e[8], -e[9], -e[10]).normalize();
        },
        updateMatrixWorld: function updateMatrixWorld(force) {
            Object3D.prototype.updateMatrixWorld.call(this, force);
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        },
        updateWorldMatrix: function updateWorldMatrix(updateParents, updateChildren) {
            Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        },
        clone: function clone() {
            return new this.constructor().copy(this);
        }
    });
    function PerspectiveCamera(fov, aspect, near, far) {
        if (fov === void 0) fov = 50;
        if (aspect === void 0) aspect = 1;
        if (near === void 0) near = 0.1;
        if (far === void 0) far = 2000;
        Camera.call(this);
        this.type = 'PerspectiveCamera';
        this.fov = fov;
        this.zoom = 1;
        this.near = near;
        this.far = far;
        this.focus = 10;
        this.aspect = aspect;
        this.view = null;
        this.filmGauge = 35; // width of the film (default in millimeters)
        this.filmOffset = 0; // horizontal film offset (same unit as gauge)
        this.updateProjectionMatrix();
    }
    PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: PerspectiveCamera,
        isPerspectiveCamera: true,
        copy: function copy(source, recursive) {
            Camera.prototype.copy.call(this, source, recursive);
            this.fov = source.fov;
            this.zoom = source.zoom;
            this.near = source.near;
            this.far = source.far;
            this.focus = source.focus;
            this.aspect = source.aspect;
            this.view = source.view === null ? null : Object.assign({
            }, source.view);
            this.filmGauge = source.filmGauge;
            this.filmOffset = source.filmOffset;
            return this;
        },
        /**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */ setFocalLength: function setFocalLength(focalLength) {
            /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */ var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
            this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
            this.updateProjectionMatrix();
        },
        /**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */ getFocalLength: function getFocalLength() {
            var vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
            return 0.5 * this.getFilmHeight() / vExtentSlope;
        },
        getEffectiveFOV: function getEffectiveFOV() {
            return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
        },
        getFilmWidth: function getFilmWidth() {
            // film not completely covered in portrait format (aspect < 1)
            return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function getFilmHeight() {
            // film not completely covered in landscape format (aspect > 1)
            return this.filmGauge / Math.max(this.aspect, 1);
        },
        /**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *	 +---+---+---+
		 *	 | A | B | C |
		 *	 +---+---+---+
		 *	 | D | E | F |
		 *	 +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *	 const w = 1920;
		 *	 const h = 1080;
		 *	 const fullWidth = w * 3;
		 *	 const fullHeight = h * 2;
		 *
		 *	 --A--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *	 --B--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *	 --C--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *	 --D--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *	 --E--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *	 --F--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *	 Note there is no reason monitors have to be the same size or in a grid.
		 */ setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
            this.aspect = fullWidth / fullHeight;
            if (this.view === null) this.view = {
                enabled: true,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            };
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
            this.updateProjectionMatrix();
        },
        clearViewOffset: function clearViewOffset() {
            if (this.view !== null) this.view.enabled = false;
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function updateProjectionMatrix() {
            var near = this.near;
            var top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
            var height = 2 * top;
            var width = this.aspect * height;
            var left = -0.5 * width;
            var view = this.view;
            if (this.view !== null && this.view.enabled) {
                var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth;
                top -= view.offsetY * height / fullHeight;
                width *= view.width / fullWidth;
                height *= view.height / fullHeight;
            }
            var skew = this.filmOffset;
            if (skew !== 0) left += near * skew / this.getFilmWidth();
            this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        },
        toJSON: function toJSON(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.fov = this.fov;
            data.object.zoom = this.zoom;
            data.object.near = this.near;
            data.object.far = this.far;
            data.object.focus = this.focus;
            data.object.aspect = this.aspect;
            if (this.view !== null) data.object.view = Object.assign({
            }, this.view);
            data.object.filmGauge = this.filmGauge;
            data.object.filmOffset = this.filmOffset;
            return data;
        }
    });
    var fov = 90, aspect = 1;
    function CubeCamera(near, far, renderTarget) {
        Object3D.call(this);
        this.type = 'CubeCamera';
        if (renderTarget.isWebGLCubeRenderTarget !== true) {
            console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
            return;
        }
        this.renderTarget = renderTarget;
        var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        cameraPX.layers = this.layers;
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new Vector3(1, 0, 0));
        this.add(cameraPX);
        var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        cameraNX.layers = this.layers;
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new Vector3(-1, 0, 0));
        this.add(cameraNX);
        var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        cameraPY.layers = this.layers;
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new Vector3(0, 1, 0));
        this.add(cameraPY);
        var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        cameraNY.layers = this.layers;
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new Vector3(0, -1, 0));
        this.add(cameraNY);
        var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraPZ.layers = this.layers;
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new Vector3(0, 0, 1));
        this.add(cameraPZ);
        var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraNZ.layers = this.layers;
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new Vector3(0, 0, -1));
        this.add(cameraNZ);
        this.update = function(renderer, scene) {
            if (this.parent === null) this.updateMatrixWorld();
            var currentXrEnabled = renderer.xr.enabled;
            var currentRenderTarget = renderer.getRenderTarget();
            renderer.xr.enabled = false;
            var generateMipmaps = renderTarget.texture.generateMipmaps;
            renderTarget.texture.generateMipmaps = false;
            renderer.setRenderTarget(renderTarget, 0);
            renderer.render(scene, cameraPX);
            renderer.setRenderTarget(renderTarget, 1);
            renderer.render(scene, cameraNX);
            renderer.setRenderTarget(renderTarget, 2);
            renderer.render(scene, cameraPY);
            renderer.setRenderTarget(renderTarget, 3);
            renderer.render(scene, cameraNY);
            renderer.setRenderTarget(renderTarget, 4);
            renderer.render(scene, cameraPZ);
            renderTarget.texture.generateMipmaps = generateMipmaps;
            renderer.setRenderTarget(renderTarget, 5);
            renderer.render(scene, cameraNZ);
            renderer.setRenderTarget(currentRenderTarget);
            renderer.xr.enabled = currentXrEnabled;
        };
    }
    CubeCamera.prototype = Object.create(Object3D.prototype);
    CubeCamera.prototype.constructor = CubeCamera;
    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        images = images !== undefined ? images : [];
        mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
        format = format !== undefined ? format : RGBFormat;
        Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.flipY = false; // Why CubeTexture._needsFlipEnvMap is necessary:
        //
        // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
        // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
        // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
        // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
        // and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
        // when using WebGLCubeRenderTarget.texture as a cube texture.
        this._needsFlipEnvMap = true;
    }
    CubeTexture.prototype = Object.create(Texture.prototype);
    CubeTexture.prototype.constructor = CubeTexture;
    CubeTexture.prototype.isCubeTexture = true;
    Object.defineProperty(CubeTexture.prototype, 'images', {
        get: function get() {
            return this.image;
        },
        set: function set(value) {
            this.image = value;
        }
    });
    var WebGLCubeRenderTarget1 = /*#__PURE__*/ function(_WebGLRenderTarget) {
        _inheritsLoose(WebGLCubeRenderTarget2, _WebGLRenderTarget);
        function WebGLCubeRenderTarget2(size, options, dummy) {
            var _this;
            if (Number.isInteger(options)) {
                console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
                options = dummy;
            }
            _this = _WebGLRenderTarget.call(this, size, size, options) || this;
            Object.defineProperty(_assertThisInitialized(_this), 'isWebGLCubeRenderTarget', {
                value: true
            });
            options = options || {
            };
            _this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
            _this.texture._needsFlipEnvMap = false;
            return _this;
        }
        var _proto = WebGLCubeRenderTarget2.prototype;
        _proto.fromEquirectangularTexture = function fromEquirectangularTexture(renderer, texture) {
            this.texture.type = texture.type;
            this.texture.format = RGBAFormat; // see #18859
            this.texture.encoding = texture.encoding;
            this.texture.generateMipmaps = texture.generateMipmaps;
            this.texture.minFilter = texture.minFilter;
            this.texture.magFilter = texture.magFilter;
            var shader = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: /* glsl */ "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                fragmentShader: /* glsl */ "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
            };
            var geometry = new BoxGeometry1(5, 5, 5);
            var material = new ShaderMaterial({
                name: 'CubemapFromEquirect',
                uniforms: cloneUniforms(shader.uniforms),
                vertexShader: shader.vertexShader,
                fragmentShader: shader.fragmentShader,
                side: BackSide,
                blending: NoBlending
            });
            material.uniforms.tEquirect.value = texture;
            var mesh = new Mesh(geometry, material);
            var currentMinFilter = texture.minFilter; // Avoid blurred poles
            if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
            var camera = new CubeCamera(1, 10, this);
            camera.update(renderer, mesh);
            texture.minFilter = currentMinFilter;
            mesh.geometry.dispose();
            mesh.material.dispose();
            return this;
        };
        _proto.clear = function clear(renderer, color, depth, stencil) {
            var currentRenderTarget = renderer.getRenderTarget();
            for(var i16 = 0; i16 < 6; i16++){
                renderer.setRenderTarget(this, i16);
                renderer.clear(color, depth, stencil);
            }
            renderer.setRenderTarget(currentRenderTarget);
        };
        return WebGLCubeRenderTarget2;
    }(WebGLRenderTarget1);
    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = {
            data: data || null,
            width: width || 1,
            height: height || 1
        };
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.needsUpdate = true;
    }
    DataTexture.prototype = Object.create(Texture.prototype);
    DataTexture.prototype.constructor = DataTexture;
    DataTexture.prototype.isDataTexture = true;
    var _sphere$1 = /*@__PURE__*/ new Sphere();
    var _vector$5 = /*@__PURE__*/ new Vector3();
    var Frustum = /*#__PURE__*/ function() {
        function Frustum1(p0, p1, p2, p3, p4, p5) {
            this.planes = [
                p0 !== undefined ? p0 : new Plane(),
                p1 !== undefined ? p1 : new Plane(),
                p2 !== undefined ? p2 : new Plane(),
                p3 !== undefined ? p3 : new Plane(),
                p4 !== undefined ? p4 : new Plane(),
                p5 !== undefined ? p5 : new Plane()
            ];
        }
        var _proto = Frustum1.prototype;
        _proto.set = function set(p0, p1, p2, p3, p4, p5) {
            var planes = this.planes;
            planes[0].copy(p0);
            planes[1].copy(p1);
            planes[2].copy(p2);
            planes[3].copy(p3);
            planes[4].copy(p4);
            planes[5].copy(p5);
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(frustum) {
            var planes = this.planes;
            for(var i16 = 0; i16 < 6; i16++)planes[i16].copy(frustum.planes[i16]);
            return this;
        };
        _proto.setFromProjectionMatrix = function setFromProjectionMatrix(m) {
            var planes = this.planes;
            var me = m.elements;
            var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
            var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
            var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
            var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
            planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
            return this;
        };
        _proto.intersectsObject = function intersectsObject(object) {
            var geometry = object.geometry;
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
            return this.intersectsSphere(_sphere$1);
        };
        _proto.intersectsSprite = function intersectsSprite(sprite) {
            _sphere$1.center.set(0, 0, 0);
            _sphere$1.radius = 0.7071067811865476;
            _sphere$1.applyMatrix4(sprite.matrixWorld);
            return this.intersectsSphere(_sphere$1);
        };
        _proto.intersectsSphere = function intersectsSphere(sphere) {
            var planes = this.planes;
            var center2 = sphere.center;
            var negRadius = -sphere.radius;
            for(var i16 = 0; i16 < 6; i16++){
                var distance = planes[i16].distanceToPoint(center2);
                if (distance < negRadius) return false;
            }
            return true;
        };
        _proto.intersectsBox = function intersectsBox(box) {
            var planes = this.planes;
            for(var i16 = 0; i16 < 6; i16++){
                var plane = planes[i16]; // corner at max distance
                _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                if (plane.distanceToPoint(_vector$5) < 0) return false;
            }
            return true;
        };
        _proto.containsPoint = function containsPoint(point) {
            var planes = this.planes;
            for(var i16 = 0; i16 < 6; i16++){
                if (planes[i16].distanceToPoint(point) < 0) return false;
            }
            return true;
        };
        return Frustum1;
    }();
    function WebGLAnimation() {
        var context = null;
        var isAnimating = false;
        var animationLoop = null;
        var requestId = null;
        function onAnimationFrame(time, frame) {
            animationLoop(time, frame);
            requestId = context.requestAnimationFrame(onAnimationFrame);
        }
        return {
            start: function start() {
                if (isAnimating === true) return;
                if (animationLoop === null) return;
                requestId = context.requestAnimationFrame(onAnimationFrame);
                isAnimating = true;
            },
            stop: function stop() {
                context.cancelAnimationFrame(requestId);
                isAnimating = false;
            },
            setAnimationLoop: function setAnimationLoop(callback) {
                animationLoop = callback;
            },
            setContext: function setContext(value) {
                context = value;
            }
        };
    }
    function WebGLAttributes(gl, capabilities) {
        var isWebGL2 = capabilities.isWebGL2;
        var buffers = new WeakMap();
        function createBuffer(attribute, bufferType) {
            var array = attribute.array;
            var usage = attribute.usage;
            var buffer = gl.createBuffer();
            gl.bindBuffer(bufferType, buffer);
            gl.bufferData(bufferType, array, usage);
            attribute.onUploadCallback();
            var type = 5126;
            if (array instanceof Float32Array) type = 5126;
            else if (array instanceof Float64Array) console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
            else if (array instanceof Uint16Array) {
                if (attribute.isFloat16BufferAttribute) {
                    if (isWebGL2) type = 5131;
                    else console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
                } else type = 5123;
            } else if (array instanceof Int16Array) type = 5122;
            else if (array instanceof Uint32Array) type = 5125;
            else if (array instanceof Int32Array) type = 5124;
            else if (array instanceof Int8Array) type = 5120;
            else if (array instanceof Uint8Array) type = 5121;
            return {
                buffer: buffer,
                type: type,
                bytesPerElement: array.BYTES_PER_ELEMENT,
                version: attribute.version
            };
        }
        function updateBuffer(buffer, attribute, bufferType) {
            var array = attribute.array;
            var updateRange = attribute.updateRange;
            gl.bindBuffer(bufferType, buffer);
            if (updateRange.count === -1) // Not using update ranges
            gl.bufferSubData(bufferType, 0, array);
            else {
                if (isWebGL2) gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
                else gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
                updateRange.count = -1; // reset range
            }
        } //
        function get(attribute) {
            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
            return buffers.get(attribute);
        }
        function remove(attribute) {
            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
            var data = buffers.get(attribute);
            if (data) {
                gl.deleteBuffer(data.buffer);
                buffers.delete(attribute);
            }
        }
        function update(attribute, bufferType) {
            if (attribute.isGLBufferAttribute) {
                var cached = buffers.get(attribute);
                if (!cached || cached.version < attribute.version) buffers.set(attribute, {
                    buffer: attribute.buffer,
                    type: attribute.type,
                    bytesPerElement: attribute.elementSize,
                    version: attribute.version
                });
                return;
            }
            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
            var data = buffers.get(attribute);
            if (data === undefined) buffers.set(attribute, createBuffer(attribute, bufferType));
            else if (data.version < attribute.version) {
                updateBuffer(data.buffer, attribute, bufferType);
                data.version = attribute.version;
            }
        }
        return {
            get: get,
            remove: remove,
            update: update
        };
    }
    var PlaneGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(PlaneGeometry2, _BufferGeometry);
        function PlaneGeometry2(width, height, widthSegments, heightSegments) {
            var _this;
            if (width === void 0) width = 1;
            if (height === void 0) height = 1;
            if (widthSegments === void 0) widthSegments = 1;
            if (heightSegments === void 0) heightSegments = 1;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'PlaneGeometry';
            _this.parameters = {
                width: width,
                height: height,
                widthSegments: widthSegments,
                heightSegments: heightSegments
            };
            var width_half = width / 2;
            var height_half = height / 2;
            var gridX = Math.floor(widthSegments);
            var gridY = Math.floor(heightSegments);
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var segment_width = width / gridX;
            var segment_height = height / gridY; //
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
            for(var iy = 0; iy < gridY1; iy++){
                var y = iy * segment_height - height_half;
                for(var ix = 0; ix < gridX1; ix++){
                    var x = ix * segment_width - width_half;
                    vertices.push(x, -y, 0);
                    normals.push(0, 0, 1);
                    uvs.push(ix / gridX);
                    uvs.push(1 - iy / gridY);
                }
            }
            for(var _iy = 0; _iy < gridY; _iy++)for(var _ix = 0; _ix < gridX; _ix++){
                var a = _ix + gridX1 * _iy;
                var b = _ix + gridX1 * (_iy + 1);
                var c = _ix + 1 + gridX1 * (_iy + 1);
                var d = _ix + 1 + gridX1 * _iy;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
            _this.setIndex(indices);
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            return _this;
        }
        return PlaneGeometry2;
    }(BufferGeometry);
    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
    var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
    var begin_vertex = "vec3 transformed = vec3( position );";
    var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
    var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
    var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
    var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
    var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
    var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
    var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
    var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
    var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
    var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
    var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
    var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";
    var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
    var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
    var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
    var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
    var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
    var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(		0, 1,		0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
    var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
    var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
    var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
    var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
    var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
    var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
    var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
    var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
    var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";
    var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
    var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";
    var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
    var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
    var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
    var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
    var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(	1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,	1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,	1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
    var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
    var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif";
    var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
    var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
    var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
    var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
    var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
    var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
    var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
    var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
    var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
    var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
    var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
    var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
    var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
    var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
    var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
    var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
    var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
    var ShaderChunk = {
        alphamap_fragment: alphamap_fragment,
        alphamap_pars_fragment: alphamap_pars_fragment,
        alphatest_fragment: alphatest_fragment,
        aomap_fragment: aomap_fragment,
        aomap_pars_fragment: aomap_pars_fragment,
        begin_vertex: begin_vertex,
        beginnormal_vertex: beginnormal_vertex,
        bsdfs: bsdfs,
        bumpmap_pars_fragment: bumpmap_pars_fragment,
        clipping_planes_fragment: clipping_planes_fragment,
        clipping_planes_pars_fragment: clipping_planes_pars_fragment,
        clipping_planes_pars_vertex: clipping_planes_pars_vertex,
        clipping_planes_vertex: clipping_planes_vertex,
        color_fragment: color_fragment,
        color_pars_fragment: color_pars_fragment,
        color_pars_vertex: color_pars_vertex,
        color_vertex: color_vertex,
        common: common,
        cube_uv_reflection_fragment: cube_uv_reflection_fragment,
        defaultnormal_vertex: defaultnormal_vertex,
        displacementmap_pars_vertex: displacementmap_pars_vertex,
        displacementmap_vertex: displacementmap_vertex,
        emissivemap_fragment: emissivemap_fragment,
        emissivemap_pars_fragment: emissivemap_pars_fragment,
        encodings_fragment: encodings_fragment,
        encodings_pars_fragment: encodings_pars_fragment,
        envmap_fragment: envmap_fragment,
        envmap_common_pars_fragment: envmap_common_pars_fragment,
        envmap_pars_fragment: envmap_pars_fragment,
        envmap_pars_vertex: envmap_pars_vertex,
        envmap_physical_pars_fragment: envmap_physical_pars_fragment,
        envmap_vertex: envmap_vertex,
        fog_vertex: fog_vertex,
        fog_pars_vertex: fog_pars_vertex,
        fog_fragment: fog_fragment,
        fog_pars_fragment: fog_pars_fragment,
        gradientmap_pars_fragment: gradientmap_pars_fragment,
        lightmap_fragment: lightmap_fragment,
        lightmap_pars_fragment: lightmap_pars_fragment,
        lights_lambert_vertex: lights_lambert_vertex,
        lights_pars_begin: lights_pars_begin,
        lights_toon_fragment: lights_toon_fragment,
        lights_toon_pars_fragment: lights_toon_pars_fragment,
        lights_phong_fragment: lights_phong_fragment,
        lights_phong_pars_fragment: lights_phong_pars_fragment,
        lights_physical_fragment: lights_physical_fragment,
        lights_physical_pars_fragment: lights_physical_pars_fragment,
        lights_fragment_begin: lights_fragment_begin,
        lights_fragment_maps: lights_fragment_maps,
        lights_fragment_end: lights_fragment_end,
        logdepthbuf_fragment: logdepthbuf_fragment,
        logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
        logdepthbuf_vertex: logdepthbuf_vertex,
        map_fragment: map_fragment,
        map_pars_fragment: map_pars_fragment,
        map_particle_fragment: map_particle_fragment,
        map_particle_pars_fragment: map_particle_pars_fragment,
        metalnessmap_fragment: metalnessmap_fragment,
        metalnessmap_pars_fragment: metalnessmap_pars_fragment,
        morphnormal_vertex: morphnormal_vertex,
        morphtarget_pars_vertex: morphtarget_pars_vertex,
        morphtarget_vertex: morphtarget_vertex,
        normal_fragment_begin: normal_fragment_begin,
        normal_fragment_maps: normal_fragment_maps,
        normalmap_pars_fragment: normalmap_pars_fragment,
        clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
        clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
        clearcoat_pars_fragment: clearcoat_pars_fragment,
        packing: packing,
        premultiplied_alpha_fragment: premultiplied_alpha_fragment,
        project_vertex: project_vertex,
        dithering_fragment: dithering_fragment,
        dithering_pars_fragment: dithering_pars_fragment,
        roughnessmap_fragment: roughnessmap_fragment,
        roughnessmap_pars_fragment: roughnessmap_pars_fragment,
        shadowmap_pars_fragment: shadowmap_pars_fragment,
        shadowmap_pars_vertex: shadowmap_pars_vertex,
        shadowmap_vertex: shadowmap_vertex,
        shadowmask_pars_fragment: shadowmask_pars_fragment,
        skinbase_vertex: skinbase_vertex,
        skinning_pars_vertex: skinning_pars_vertex,
        skinning_vertex: skinning_vertex,
        skinnormal_vertex: skinnormal_vertex,
        specularmap_fragment: specularmap_fragment,
        specularmap_pars_fragment: specularmap_pars_fragment,
        tonemapping_fragment: tonemapping_fragment,
        tonemapping_pars_fragment: tonemapping_pars_fragment,
        transmissionmap_fragment: transmissionmap_fragment,
        transmissionmap_pars_fragment: transmissionmap_pars_fragment,
        uv_pars_fragment: uv_pars_fragment,
        uv_pars_vertex: uv_pars_vertex,
        uv_vertex: uv_vertex,
        uv2_pars_fragment: uv2_pars_fragment,
        uv2_pars_vertex: uv2_pars_vertex,
        uv2_vertex: uv2_vertex,
        worldpos_vertex: worldpos_vertex,
        background_frag: background_frag,
        background_vert: background_vert,
        cube_frag: cube_frag,
        cube_vert: cube_vert,
        depth_frag: depth_frag,
        depth_vert: depth_vert,
        distanceRGBA_frag: distanceRGBA_frag,
        distanceRGBA_vert: distanceRGBA_vert,
        equirect_frag: equirect_frag,
        equirect_vert: equirect_vert,
        linedashed_frag: linedashed_frag,
        linedashed_vert: linedashed_vert,
        meshbasic_frag: meshbasic_frag,
        meshbasic_vert: meshbasic_vert,
        meshlambert_frag: meshlambert_frag,
        meshlambert_vert: meshlambert_vert,
        meshmatcap_frag: meshmatcap_frag,
        meshmatcap_vert: meshmatcap_vert,
        meshtoon_frag: meshtoon_frag,
        meshtoon_vert: meshtoon_vert,
        meshphong_frag: meshphong_frag,
        meshphong_vert: meshphong_vert,
        meshphysical_frag: meshphysical_frag,
        meshphysical_vert: meshphysical_vert,
        normal_frag: normal_frag,
        normal_vert: normal_vert,
        points_frag: points_frag,
        points_vert: points_vert,
        shadow_frag: shadow_frag,
        shadow_vert: shadow_vert,
        sprite_frag: sprite_frag,
        sprite_vert: sprite_vert
    };
    /**
	 * Uniforms library for shared webgl shaders
	 */ var UniformsLib = {
        common: {
            diffuse: {
                value: new Color(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Matrix3()
            },
            uv2Transform: {
                value: new Matrix3()
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: 0.98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Vector2(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 0.00025
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2000
            },
            fogColor: {
                value: new Color(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {
                    },
                    color: {
                    }
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {
                    },
                    shadowNormalBias: {
                    },
                    shadowRadius: {
                    },
                    shadowMapSize: {
                    }
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {
                    },
                    position: {
                    },
                    direction: {
                    },
                    distance: {
                    },
                    coneCos: {
                    },
                    penumbraCos: {
                    },
                    decay: {
                    }
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {
                    },
                    shadowNormalBias: {
                    },
                    shadowRadius: {
                    },
                    shadowMapSize: {
                    }
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {
                    },
                    position: {
                    },
                    decay: {
                    },
                    distance: {
                    }
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {
                    },
                    shadowNormalBias: {
                    },
                    shadowRadius: {
                    },
                    shadowMapSize: {
                    },
                    shadowCameraNear: {
                    },
                    shadowCameraFar: {
                    }
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {
                    },
                    skyColor: {
                    },
                    groundColor: {
                    }
                }
            },
            // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
            rectAreaLights: {
                value: [],
                properties: {
                    color: {
                    },
                    position: {
                    },
                    width: {
                    },
                    height: {
                    }
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new Color(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new Matrix3()
            }
        },
        sprite: {
            diffuse: {
                value: new Color(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Vector2(0.5, 0.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new Matrix3()
            }
        }
    };
    var ShaderLib = {
        basic: {
            uniforms: mergeUniforms([
                UniformsLib.common,
                UniformsLib.specularmap,
                UniformsLib.envmap,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.fog
            ]),
            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
            uniforms: mergeUniforms([
                UniformsLib.common,
                UniformsLib.specularmap,
                UniformsLib.envmap,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.emissivemap,
                UniformsLib.fog,
                UniformsLib.lights,
                {
                    emissive: {
                        value: new Color(0)
                    }
                }
            ]),
            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
            uniforms: mergeUniforms([
                UniformsLib.common,
                UniformsLib.specularmap,
                UniformsLib.envmap,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.emissivemap,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                UniformsLib.fog,
                UniformsLib.lights,
                {
                    emissive: {
                        value: new Color(0)
                    },
                    specular: {
                        value: new Color(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }
            ]),
            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
            uniforms: mergeUniforms([
                UniformsLib.common,
                UniformsLib.envmap,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.emissivemap,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                UniformsLib.roughnessmap,
                UniformsLib.metalnessmap,
                UniformsLib.fog,
                UniformsLib.lights,
                {
                    emissive: {
                        value: new Color(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
        },
        toon: {
            uniforms: mergeUniforms([
                UniformsLib.common,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.emissivemap,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                UniformsLib.gradientmap,
                UniformsLib.fog,
                UniformsLib.lights,
                {
                    emissive: {
                        value: new Color(0)
                    }
                }
            ]),
            vertexShader: ShaderChunk.meshtoon_vert,
            fragmentShader: ShaderChunk.meshtoon_frag
        },
        matcap: {
            uniforms: mergeUniforms([
                UniformsLib.common,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                UniformsLib.fog,
                {
                    matcap: {
                        value: null
                    }
                }
            ]),
            vertexShader: ShaderChunk.meshmatcap_vert,
            fragmentShader: ShaderChunk.meshmatcap_frag
        },
        points: {
            uniforms: mergeUniforms([
                UniformsLib.points,
                UniformsLib.fog
            ]),
            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
            uniforms: mergeUniforms([
                UniformsLib.common,
                UniformsLib.fog,
                {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }
            ]),
            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
            uniforms: mergeUniforms([
                UniformsLib.common,
                UniformsLib.displacementmap
            ]),
            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
            uniforms: mergeUniforms([
                UniformsLib.common,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                {
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: ShaderChunk.normal_vert,
            fragmentShader: ShaderChunk.normal_frag
        },
        sprite: {
            uniforms: mergeUniforms([
                UniformsLib.sprite,
                UniformsLib.fog
            ]),
            vertexShader: ShaderChunk.sprite_vert,
            fragmentShader: ShaderChunk.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new Matrix3()
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: ShaderChunk.background_vert,
            fragmentShader: ShaderChunk.background_frag
        },
        /* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */ cube: {
            uniforms: mergeUniforms([
                UniformsLib.envmap,
                {
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
            uniforms: mergeUniforms([
                UniformsLib.common,
                UniformsLib.displacementmap,
                {
                    referencePosition: {
                        value: new Vector3()
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1000
                    }
                }
            ]),
            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
            uniforms: mergeUniforms([
                UniformsLib.lights,
                UniformsLib.fog,
                {
                    color: {
                        value: new Color(0)
                    },
                    opacity: {
                        value: 1
                    }
                }
            ]),
            vertexShader: ShaderChunk.shadow_vert,
            fragmentShader: ShaderChunk.shadow_frag
        }
    };
    ShaderLib.physical = {
        uniforms: mergeUniforms([
            ShaderLib.standard.uniforms,
            {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatNormalScale: {
                    value: new Vector2(1, 1)
                },
                clearcoatNormalMap: {
                    value: null
                },
                sheen: {
                    value: new Color(0)
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    };
    function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
        var clearColor = new Color(0);
        var clearAlpha = 0;
        var planeMesh;
        var boxMesh;
        var currentBackground = null;
        var currentBackgroundVersion = 0;
        var currentTonemapping = null;
        function render(renderList, scene, camera, forceClear) {
            var background = scene.isScene === true ? scene.background : null;
            if (background && background.isTexture) background = cubemaps.get(background);
             // Ignore background in AR
            // TODO: Reconsider this.
            var xr = renderer.xr;
            var session = xr.getSession && xr.getSession();
            if (session && session.environmentBlendMode === 'additive') background = null;
            if (background === null) setClear(clearColor, clearAlpha);
            else if (background && background.isColor) {
                setClear(background, 1);
                forceClear = true;
            }
            if (renderer.autoClear || forceClear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
            if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
                if (boxMesh === undefined) {
                    boxMesh = new Mesh(new BoxGeometry1(1, 1, 1), new ShaderMaterial({
                        name: 'BackgroundCubeMaterial',
                        uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                        vertexShader: ShaderLib.cube.vertexShader,
                        fragmentShader: ShaderLib.cube.fragmentShader,
                        side: BackSide,
                        depthTest: false,
                        depthWrite: false,
                        fog: false
                    }));
                    boxMesh.geometry.deleteAttribute('normal');
                    boxMesh.geometry.deleteAttribute('uv');
                    boxMesh.onBeforeRender = function(renderer1, scene1, camera1) {
                        this.matrixWorld.copyPosition(camera1.matrixWorld);
                    }; // enable code injection for non-built-in material
                    Object.defineProperty(boxMesh.material, 'envMap', {
                        get: function get() {
                            return this.uniforms.envMap.value;
                        }
                    });
                    objects.update(boxMesh);
                }
                if (background.isWebGLCubeRenderTarget) // TODO Deprecate
                background = background.texture;
                boxMesh.material.uniforms.envMap.value = background;
                boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
                if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                    boxMesh.material.needsUpdate = true;
                    currentBackground = background;
                    currentBackgroundVersion = background.version;
                    currentTonemapping = renderer.toneMapping;
                } // push to the pre-sorted opaque render list
                renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
            } else if (background && background.isTexture) {
                if (planeMesh === undefined) {
                    planeMesh = new Mesh(new PlaneGeometry1(2, 2), new ShaderMaterial({
                        name: 'BackgroundMaterial',
                        uniforms: cloneUniforms(ShaderLib.background.uniforms),
                        vertexShader: ShaderLib.background.vertexShader,
                        fragmentShader: ShaderLib.background.fragmentShader,
                        side: FrontSide,
                        depthTest: false,
                        depthWrite: false,
                        fog: false
                    }));
                    planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material
                    Object.defineProperty(planeMesh.material, 'map', {
                        get: function get() {
                            return this.uniforms.t2D.value;
                        }
                    });
                    objects.update(planeMesh);
                }
                planeMesh.material.uniforms.t2D.value = background;
                if (background.matrixAutoUpdate === true) background.updateMatrix();
                planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
                if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                    planeMesh.material.needsUpdate = true;
                    currentBackground = background;
                    currentBackgroundVersion = background.version;
                    currentTonemapping = renderer.toneMapping;
                } // push to the pre-sorted opaque render list
                renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
            }
        }
        function setClear(color, alpha) {
            state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
        }
        return {
            getClearColor: function getClearColor() {
                return clearColor;
            },
            setClearColor: function setClearColor(color, alpha) {
                if (alpha === void 0) alpha = 1;
                clearColor.set(color);
                clearAlpha = alpha;
                setClear(clearColor, clearAlpha);
            },
            getClearAlpha: function getClearAlpha() {
                return clearAlpha;
            },
            setClearAlpha: function setClearAlpha(alpha) {
                clearAlpha = alpha;
                setClear(clearColor, clearAlpha);
            },
            render: render
        };
    }
    function WebGLBindingStates(gl, extensions, attributes, capabilities) {
        var maxVertexAttributes = gl.getParameter(34921);
        var extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
        var vaoAvailable = capabilities.isWebGL2 || extension !== null;
        var bindingStates = {
        };
        var defaultState = createBindingState(null);
        var currentState = defaultState;
        function setup(object, material, program, geometry, index) {
            var updateBuffers = false;
            if (vaoAvailable) {
                var state = getBindingState(geometry, program, material);
                if (currentState !== state) {
                    currentState = state;
                    bindVertexArrayObject(currentState.object);
                }
                updateBuffers = needsUpdate(geometry, index);
                if (updateBuffers) saveCache(geometry, index);
            } else {
                var wireframe = material.wireframe === true;
                if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
                    currentState.geometry = geometry.id;
                    currentState.program = program.id;
                    currentState.wireframe = wireframe;
                    updateBuffers = true;
                }
            }
            if (object.isInstancedMesh === true) updateBuffers = true;
            if (index !== null) attributes.update(index, 34963);
            if (updateBuffers) {
                setupVertexAttributes(object, material, program, geometry);
                if (index !== null) gl.bindBuffer(34963, attributes.get(index).buffer);
            }
        }
        function createVertexArrayObject() {
            if (capabilities.isWebGL2) return gl.createVertexArray();
            return extension.createVertexArrayOES();
        }
        function bindVertexArrayObject(vao) {
            if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
            return extension.bindVertexArrayOES(vao);
        }
        function deleteVertexArrayObject(vao) {
            if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
            return extension.deleteVertexArrayOES(vao);
        }
        function getBindingState(geometry, program, material) {
            var wireframe = material.wireframe === true;
            var programMap = bindingStates[geometry.id];
            if (programMap === undefined) {
                programMap = {
                };
                bindingStates[geometry.id] = programMap;
            }
            var stateMap = programMap[program.id];
            if (stateMap === undefined) {
                stateMap = {
                };
                programMap[program.id] = stateMap;
            }
            var state = stateMap[wireframe];
            if (state === undefined) {
                state = createBindingState(createVertexArrayObject());
                stateMap[wireframe] = state;
            }
            return state;
        }
        function createBindingState(vao) {
            var newAttributes = [];
            var enabledAttributes = [];
            var attributeDivisors = [];
            for(var i16 = 0; i16 < maxVertexAttributes; i16++){
                newAttributes[i16] = 0;
                enabledAttributes[i16] = 0;
                attributeDivisors[i16] = 0;
            }
            return {
                // for backward compatibility on non-VAO support browser
                geometry: null,
                program: null,
                wireframe: false,
                newAttributes: newAttributes,
                enabledAttributes: enabledAttributes,
                attributeDivisors: attributeDivisors,
                object: vao,
                attributes: {
                },
                index: null
            };
        }
        function needsUpdate(geometry, index) {
            var cachedAttributes = currentState.attributes;
            var geometryAttributes = geometry.attributes;
            var attributesNum = 0;
            for(var key3 in geometryAttributes){
                var cachedAttribute = cachedAttributes[key3];
                var geometryAttribute = geometryAttributes[key3];
                if (cachedAttribute === undefined) return true;
                if (cachedAttribute.attribute !== geometryAttribute) return true;
                if (cachedAttribute.data !== geometryAttribute.data) return true;
                attributesNum++;
            }
            if (currentState.attributesNum !== attributesNum) return true;
            if (currentState.index !== index) return true;
            return false;
        }
        function saveCache(geometry, index) {
            var cache = {
            };
            var attributes1 = geometry.attributes;
            var attributesNum = 0;
            for(var key3 in attributes1){
                var attribute = attributes1[key3];
                var data = {
                };
                data.attribute = attribute;
                if (attribute.data) data.data = attribute.data;
                cache[key3] = data;
                attributesNum++;
            }
            currentState.attributes = cache;
            currentState.attributesNum = attributesNum;
            currentState.index = index;
        }
        function initAttributes() {
            var newAttributes = currentState.newAttributes;
            for(var i16 = 0, il = newAttributes.length; i16 < il; i16++)newAttributes[i16] = 0;
        }
        function enableAttribute(attribute) {
            enableAttributeAndDivisor(attribute, 0);
        }
        function enableAttributeAndDivisor(attribute, meshPerAttribute) {
            var newAttributes = currentState.newAttributes;
            var enabledAttributes = currentState.enabledAttributes;
            var attributeDivisors = currentState.attributeDivisors;
            newAttributes[attribute] = 1;
            if (enabledAttributes[attribute] === 0) {
                gl.enableVertexAttribArray(attribute);
                enabledAttributes[attribute] = 1;
            }
            if (attributeDivisors[attribute] !== meshPerAttribute) {
                var _extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
                _extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
                attributeDivisors[attribute] = meshPerAttribute;
            }
        }
        function disableUnusedAttributes() {
            var newAttributes = currentState.newAttributes;
            var enabledAttributes = currentState.enabledAttributes;
            for(var i16 = 0, il = enabledAttributes.length; i16 < il; i16++)if (enabledAttributes[i16] !== newAttributes[i16]) {
                gl.disableVertexAttribArray(i16);
                enabledAttributes[i16] = 0;
            }
        }
        function vertexAttribPointer(index, size, type, normalized, stride, offset) {
            if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) gl.vertexAttribIPointer(index, size, type, stride, offset);
            else gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
        }
        function setupVertexAttributes(object, material, program, geometry) {
            if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
                if (extensions.get('ANGLE_instanced_arrays') === null) return;
            }
            initAttributes();
            var geometryAttributes = geometry.attributes;
            var programAttributes = program.getAttributes();
            var materialDefaultAttributeValues = material.defaultAttributeValues;
            for(var name in programAttributes){
                var programAttribute = programAttributes[name];
                if (programAttribute >= 0) {
                    var geometryAttribute = geometryAttributes[name];
                    if (geometryAttribute !== undefined) {
                        var normalized = geometryAttribute.normalized;
                        var size = geometryAttribute.itemSize;
                        var attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore
                        if (attribute === undefined) continue;
                        var buffer = attribute.buffer;
                        var type = attribute.type;
                        var bytesPerElement = attribute.bytesPerElement;
                        if (geometryAttribute.isInterleavedBufferAttribute) {
                            var data = geometryAttribute.data;
                            var stride = data.stride;
                            var offset = geometryAttribute.offset;
                            if (data && data.isInstancedInterleavedBuffer) {
                                enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                                if (geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                            } else enableAttribute(programAttribute);
                            gl.bindBuffer(34962, buffer);
                            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                        } else {
                            if (geometryAttribute.isInstancedBufferAttribute) {
                                enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                                if (geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                            } else enableAttribute(programAttribute);
                            gl.bindBuffer(34962, buffer);
                            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
                        }
                    } else if (name === 'instanceMatrix') {
                        var _attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore
                        if (_attribute === undefined) continue;
                        var _buffer = _attribute.buffer;
                        var _type = _attribute.type;
                        enableAttributeAndDivisor(programAttribute + 0, 1);
                        enableAttributeAndDivisor(programAttribute + 1, 1);
                        enableAttributeAndDivisor(programAttribute + 2, 1);
                        enableAttributeAndDivisor(programAttribute + 3, 1);
                        gl.bindBuffer(34962, _buffer);
                        gl.vertexAttribPointer(programAttribute + 0, 4, _type, false, 64, 0);
                        gl.vertexAttribPointer(programAttribute + 1, 4, _type, false, 64, 16);
                        gl.vertexAttribPointer(programAttribute + 2, 4, _type, false, 64, 32);
                        gl.vertexAttribPointer(programAttribute + 3, 4, _type, false, 64, 48);
                    } else if (name === 'instanceColor') {
                        var _attribute2 = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore
                        if (_attribute2 === undefined) continue;
                        var _buffer2 = _attribute2.buffer;
                        var _type2 = _attribute2.type;
                        enableAttributeAndDivisor(programAttribute, 1);
                        gl.bindBuffer(34962, _buffer2);
                        gl.vertexAttribPointer(programAttribute, 3, _type2, false, 12, 0);
                    } else if (materialDefaultAttributeValues !== undefined) {
                        var value = materialDefaultAttributeValues[name];
                        if (value !== undefined) switch(value.length){
                            case 2:
                                gl.vertexAttrib2fv(programAttribute, value);
                                break;
                            case 3:
                                gl.vertexAttrib3fv(programAttribute, value);
                                break;
                            case 4:
                                gl.vertexAttrib4fv(programAttribute, value);
                                break;
                            default:
                                gl.vertexAttrib1fv(programAttribute, value);
                        }
                    }
                }
            }
            disableUnusedAttributes();
        }
        function dispose() {
            reset();
            for(var geometryId in bindingStates){
                var programMap = bindingStates[geometryId];
                for(var programId in programMap){
                    var stateMap = programMap[programId];
                    for(var wireframe in stateMap){
                        deleteVertexArrayObject(stateMap[wireframe].object);
                        delete stateMap[wireframe];
                    }
                    delete programMap[programId];
                }
                delete bindingStates[geometryId];
            }
        }
        function releaseStatesOfGeometry(geometry) {
            if (bindingStates[geometry.id] === undefined) return;
            var programMap = bindingStates[geometry.id];
            for(var programId in programMap){
                var stateMap = programMap[programId];
                for(var wireframe in stateMap){
                    deleteVertexArrayObject(stateMap[wireframe].object);
                    delete stateMap[wireframe];
                }
                delete programMap[programId];
            }
            delete bindingStates[geometry.id];
        }
        function releaseStatesOfProgram(program) {
            for(var geometryId in bindingStates){
                var programMap = bindingStates[geometryId];
                if (programMap[program.id] === undefined) continue;
                var stateMap = programMap[program.id];
                for(var wireframe in stateMap){
                    deleteVertexArrayObject(stateMap[wireframe].object);
                    delete stateMap[wireframe];
                }
                delete programMap[program.id];
            }
        }
        function reset() {
            resetDefaultState();
            if (currentState === defaultState) return;
            currentState = defaultState;
            bindVertexArrayObject(currentState.object);
        } // for backward-compatilibity
        function resetDefaultState() {
            defaultState.geometry = null;
            defaultState.program = null;
            defaultState.wireframe = false;
        }
        return {
            setup: setup,
            reset: reset,
            resetDefaultState: resetDefaultState,
            dispose: dispose,
            releaseStatesOfGeometry: releaseStatesOfGeometry,
            releaseStatesOfProgram: releaseStatesOfProgram,
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            disableUnusedAttributes: disableUnusedAttributes
        };
    }
    function WebGLBufferRenderer(gl, extensions, info, capabilities) {
        var isWebGL2 = capabilities.isWebGL2;
        var mode;
        function setMode(value) {
            mode = value;
        }
        function render(start, count) {
            gl.drawArrays(mode, start, count);
            info.update(count, mode, 1);
        }
        function renderInstances(start, count, primcount) {
            if (primcount === 0) return;
            var extension, methodName;
            if (isWebGL2) {
                extension = gl;
                methodName = 'drawArraysInstanced';
            } else {
                extension = extensions.get('ANGLE_instanced_arrays');
                methodName = 'drawArraysInstancedANGLE';
                if (extension === null) {
                    console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;
                }
            }
            extension[methodName](mode, start, count, primcount);
            info.update(count, mode, primcount);
        } //
        this.setMode = setMode;
        this.render = render;
        this.renderInstances = renderInstances;
    }
    function WebGLCapabilities(gl, extensions, parameters) {
        var maxAnisotropy;
        function getMaxAnisotropy() {
            if (maxAnisotropy !== undefined) return maxAnisotropy;
            var extension = extensions.get('EXT_texture_filter_anisotropic');
            if (extension !== null) maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            else maxAnisotropy = 0;
            return maxAnisotropy;
        }
        function getMaxPrecision(precision) {
            if (precision === 'highp') {
                if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) return 'highp';
                precision = 'mediump';
            }
            if (precision === 'mediump') {
                if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) return 'mediump';
            }
            return 'lowp';
        }
        /* eslint-disable no-undef */ var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
        /* eslint-enable no-undef */ var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
        var maxPrecision = getMaxPrecision(precision);
        if (maxPrecision !== precision) {
            console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
            precision = maxPrecision;
        }
        var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
        var maxTextures = gl.getParameter(34930);
        var maxVertexTextures = gl.getParameter(35660);
        var maxTextureSize = gl.getParameter(3379);
        var maxCubemapSize = gl.getParameter(34076);
        var maxAttributes = gl.getParameter(34921);
        var maxVertexUniforms = gl.getParameter(36347);
        var maxVaryings = gl.getParameter(36348);
        var maxFragmentUniforms = gl.getParameter(36349);
        var vertexTextures = maxVertexTextures > 0;
        var floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
        var floatVertexTextures = vertexTextures && floatFragmentTextures;
        var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
        return {
            isWebGL2: isWebGL2,
            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,
            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,
            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,
            vertexTextures: vertexTextures,
            floatFragmentTextures: floatFragmentTextures,
            floatVertexTextures: floatVertexTextures,
            maxSamples: maxSamples
        };
    }
    function WebGLClipping(properties) {
        var scope = this;
        var globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
        var plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
            value: null,
            needsUpdate: false
        };
        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;
        this.init = function(planes, enableLocalClipping, camera) {
            var enabled = planes.length !== 0 || enableLocalClipping || // run another frame in order to reset the state:
            numGlobalPlanes !== 0 || localClippingEnabled;
            localClippingEnabled = enableLocalClipping;
            globalState = projectPlanes(planes, camera, 0);
            numGlobalPlanes = planes.length;
            return enabled;
        };
        this.beginShadows = function() {
            renderingShadows = true;
            projectPlanes(null);
        };
        this.endShadows = function() {
            renderingShadows = false;
            resetGlobalState();
        };
        this.setState = function(material, camera, useCache) {
            var planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
            var materialProperties = properties.get(material);
            if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
                // there's no local clipping
                if (renderingShadows) // there's no global clipping
                projectPlanes(null);
                else resetGlobalState();
            } else {
                var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
                var dstArray = materialProperties.clippingState || null;
                uniform.value = dstArray; // ensure unique state
                dstArray = projectPlanes(planes, camera, lGlobal, useCache);
                for(var i16 = 0; i16 !== lGlobal; ++i16)dstArray[i16] = globalState[i16];
                materialProperties.clippingState = dstArray;
                this.numIntersection = clipIntersection ? this.numPlanes : 0;
                this.numPlanes += nGlobal;
            }
        };
        function resetGlobalState() {
            if (uniform.value !== globalState) {
                uniform.value = globalState;
                uniform.needsUpdate = numGlobalPlanes > 0;
            }
            scope.numPlanes = numGlobalPlanes;
            scope.numIntersection = 0;
        }
        function projectPlanes(planes, camera, dstOffset, skipTransform) {
            var nPlanes = planes !== null ? planes.length : 0;
            var dstArray = null;
            if (nPlanes !== 0) {
                dstArray = uniform.value;
                if (skipTransform !== true || dstArray === null) {
                    var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                    viewNormalMatrix.getNormalMatrix(viewMatrix);
                    if (dstArray === null || dstArray.length < flatSize) dstArray = new Float32Array(flatSize);
                    for(var i17 = 0, i41 = dstOffset; i17 !== nPlanes; ++i17, i41 += 4){
                        plane.copy(planes[i17]).applyMatrix4(viewMatrix, viewNormalMatrix);
                        plane.normal.toArray(dstArray, i41);
                        dstArray[i41 + 3] = plane.constant;
                    }
                }
                uniform.value = dstArray;
                uniform.needsUpdate = true;
            }
            scope.numPlanes = nPlanes;
            scope.numIntersection = 0;
            return dstArray;
        }
    }
    function WebGLCubeMaps(renderer) {
        var cubemaps = new WeakMap();
        function mapTextureMapping(texture, mapping) {
            if (mapping === EquirectangularReflectionMapping) texture.mapping = CubeReflectionMapping;
            else if (mapping === EquirectangularRefractionMapping) texture.mapping = CubeRefractionMapping;
            return texture;
        }
        function get(texture) {
            if (texture && texture.isTexture) {
                var mapping = texture.mapping;
                if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
                    if (cubemaps.has(texture)) {
                        var cubemap = cubemaps.get(texture).texture;
                        return mapTextureMapping(cubemap, texture.mapping);
                    } else {
                        var image = texture.image;
                        if (image && image.height > 0) {
                            var currentRenderList = renderer.getRenderList();
                            var currentRenderTarget = renderer.getRenderTarget();
                            var renderTarget = new WebGLCubeRenderTarget1(image.height / 2);
                            renderTarget.fromEquirectangularTexture(renderer, texture);
                            cubemaps.set(texture, renderTarget);
                            renderer.setRenderTarget(currentRenderTarget);
                            renderer.setRenderList(currentRenderList);
                            texture.addEventListener('dispose', onTextureDispose);
                            return mapTextureMapping(renderTarget.texture, texture.mapping);
                        } else // image not yet ready. try the conversion next frame
                        return null;
                    }
                }
            }
            return texture;
        }
        function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener('dispose', onTextureDispose);
            var cubemap = cubemaps.get(texture);
            if (cubemap !== undefined) {
                cubemaps.delete(texture);
                cubemap.dispose();
            }
        }
        function dispose() {
            cubemaps = new WeakMap();
        }
        return {
            get: get,
            dispose: dispose
        };
    }
    function WebGLExtensions(gl) {
        var extensions = {
        };
        function getExtension(name) {
            if (extensions[name] !== undefined) return extensions[name];
            var extension;
            switch(name){
                case 'WEBGL_depth_texture':
                    extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                    break;
                case 'EXT_texture_filter_anisotropic':
                    extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                    break;
                case 'WEBGL_compressed_texture_s3tc':
                    extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                    break;
                case 'WEBGL_compressed_texture_pvrtc':
                    extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                    break;
                default:
                    extension = gl.getExtension(name);
            }
            extensions[name] = extension;
            return extension;
        }
        return {
            has: function has(name) {
                return getExtension(name) !== null;
            },
            init: function init(capabilities) {
                if (capabilities.isWebGL2) getExtension('EXT_color_buffer_float');
                else {
                    getExtension('WEBGL_depth_texture');
                    getExtension('OES_texture_float');
                    getExtension('OES_texture_half_float');
                    getExtension('OES_texture_half_float_linear');
                    getExtension('OES_standard_derivatives');
                    getExtension('OES_element_index_uint');
                    getExtension('OES_vertex_array_object');
                    getExtension('ANGLE_instanced_arrays');
                }
                getExtension('OES_texture_float_linear');
                getExtension('EXT_color_buffer_half_float');
            },
            get: function get(name) {
                var extension = getExtension(name);
                if (extension === null) console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
                return extension;
            }
        };
    }
    function WebGLGeometries(gl, attributes, info, bindingStates) {
        var geometries = {
        };
        var wireframeAttributes = new WeakMap();
        function onGeometryDispose(event) {
            var geometry = event.target;
            if (geometry.index !== null) attributes.remove(geometry.index);
            for(var name in geometry.attributes)attributes.remove(geometry.attributes[name]);
            geometry.removeEventListener('dispose', onGeometryDispose);
            delete geometries[geometry.id];
            var attribute = wireframeAttributes.get(geometry);
            if (attribute) {
                attributes.remove(attribute);
                wireframeAttributes.delete(geometry);
            }
            bindingStates.releaseStatesOfGeometry(geometry);
            if (geometry.isInstancedBufferGeometry === true) delete geometry._maxInstanceCount;
             //
            info.memory.geometries--;
        }
        function get(object, geometry) {
            if (geometries[geometry.id] === true) return geometry;
            geometry.addEventListener('dispose', onGeometryDispose);
            geometries[geometry.id] = true;
            info.memory.geometries++;
            return geometry;
        }
        function update(geometry) {
            var geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.
            for(var name in geometryAttributes)attributes.update(geometryAttributes[name], 34962);
             // morph targets
            var morphAttributes = geometry.morphAttributes;
            for(var _name in morphAttributes){
                var array = morphAttributes[_name];
                for(var i18 = 0, l = array.length; i18 < l; i18++)attributes.update(array[i18], 34962);
            }
        }
        function updateWireframeAttribute(geometry) {
            var indices = [];
            var geometryIndex = geometry.index;
            var geometryPosition = geometry.attributes.position;
            var version = 0;
            if (geometryIndex !== null) {
                var array = geometryIndex.array;
                version = geometryIndex.version;
                for(var i19 = 0, l = array.length; i19 < l; i19 += 3){
                    var a = array[i19 + 0];
                    var b = array[i19 + 1];
                    var c = array[i19 + 2];
                    indices.push(a, b, b, c, c, a);
                }
            } else {
                var _array = geometryPosition.array;
                version = geometryPosition.version;
                for(var _i = 0, _l = _array.length / 3 - 1; _i < _l; _i += 3){
                    var _a = _i + 0;
                    var _b = _i + 1;
                    var _c = _i + 2;
                    indices.push(_a, _b, _b, _c, _c, _a);
                }
            }
            var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
            attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
            //
            var previousAttribute = wireframeAttributes.get(geometry);
            if (previousAttribute) attributes.remove(previousAttribute); //
            wireframeAttributes.set(geometry, attribute);
        }
        function getWireframeAttribute(geometry) {
            var currentAttribute = wireframeAttributes.get(geometry);
            if (currentAttribute) {
                var geometryIndex = geometry.index;
                if (geometryIndex !== null) // if the attribute is obsolete, create a new one
                {
                    if (currentAttribute.version < geometryIndex.version) updateWireframeAttribute(geometry);
                }
            } else updateWireframeAttribute(geometry);
            return wireframeAttributes.get(geometry);
        }
        return {
            get: get,
            update: update,
            getWireframeAttribute: getWireframeAttribute
        };
    }
    function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
        var isWebGL2 = capabilities.isWebGL2;
        var mode;
        function setMode(value) {
            mode = value;
        }
        var type, bytesPerElement;
        function setIndex(value) {
            type = value.type;
            bytesPerElement = value.bytesPerElement;
        }
        function render(start, count) {
            gl.drawElements(mode, count, type, start * bytesPerElement);
            info.update(count, mode, 1);
        }
        function renderInstances(start, count, primcount) {
            if (primcount === 0) return;
            var extension, methodName;
            if (isWebGL2) {
                extension = gl;
                methodName = 'drawElementsInstanced';
            } else {
                extension = extensions.get('ANGLE_instanced_arrays');
                methodName = 'drawElementsInstancedANGLE';
                if (extension === null) {
                    console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;
                }
            }
            extension[methodName](mode, count, type, start * bytesPerElement, primcount);
            info.update(count, mode, primcount);
        } //
        this.setMode = setMode;
        this.setIndex = setIndex;
        this.render = render;
        this.renderInstances = renderInstances;
    }
    function WebGLInfo(gl) {
        var memory = {
            geometries: 0,
            textures: 0
        };
        var render = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        function update(count, mode, instanceCount) {
            render.calls++;
            switch(mode){
                case 4:
                    render.triangles += instanceCount * (count / 3);
                    break;
                case 1:
                    render.lines += instanceCount * (count / 2);
                    break;
                case 3:
                    render.lines += instanceCount * (count - 1);
                    break;
                case 2:
                    render.lines += instanceCount * count;
                    break;
                case 0:
                    render.points += instanceCount * count;
                    break;
                default:
                    console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                    break;
            }
        }
        function reset() {
            render.frame++;
            render.calls = 0;
            render.triangles = 0;
            render.points = 0;
            render.lines = 0;
        }
        return {
            memory: memory,
            render: render,
            programs: null,
            autoReset: true,
            reset: reset,
            update: update
        };
    }
    function numericalSort(a, b) {
        return a[0] - b[0];
    }
    function absNumericalSort(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
    }
    function WebGLMorphtargets(gl) {
        var influencesList = {
        };
        var morphInfluences = new Float32Array(8);
        var workInfluences = [];
        for(var i20 = 0; i20 < 8; i20++)workInfluences[i20] = [
            i20,
            0
        ];
        function update(object, geometry, material, program) {
            var objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array
            // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
            var length = objectInfluences === undefined ? 0 : objectInfluences.length;
            var influences = influencesList[geometry.id];
            if (influences === undefined) {
                // initialise list
                influences = [];
                for(var _i = 0; _i < length; _i++)influences[_i] = [
                    _i,
                    0
                ];
                influencesList[geometry.id] = influences;
            } // Collect influences
            for(var _i2 = 0; _i2 < length; _i2++){
                var influence = influences[_i2];
                influence[0] = _i2;
                influence[1] = objectInfluences[_i2];
            }
            influences.sort(absNumericalSort);
            for(var _i3 = 0; _i3 < 8; _i3++)if (_i3 < length && influences[_i3][1]) {
                workInfluences[_i3][0] = influences[_i3][0];
                workInfluences[_i3][1] = influences[_i3][1];
            } else {
                workInfluences[_i3][0] = Number.MAX_SAFE_INTEGER;
                workInfluences[_i3][1] = 0;
            }
            workInfluences.sort(numericalSort);
            var morphTargets = material.morphTargets && geometry.morphAttributes.position;
            var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
            var morphInfluencesSum = 0;
            for(var _i4 = 0; _i4 < 8; _i4++){
                var _influence = workInfluences[_i4];
                var index = _influence[0];
                var value = _influence[1];
                if (index !== Number.MAX_SAFE_INTEGER && value) {
                    if (morphTargets && geometry.getAttribute('morphTarget' + _i4) !== morphTargets[index]) geometry.setAttribute('morphTarget' + _i4, morphTargets[index]);
                    if (morphNormals && geometry.getAttribute('morphNormal' + _i4) !== morphNormals[index]) geometry.setAttribute('morphNormal' + _i4, morphNormals[index]);
                    morphInfluences[_i4] = value;
                    morphInfluencesSum += value;
                } else {
                    if (morphTargets && geometry.hasAttribute('morphTarget' + _i4) === true) geometry.deleteAttribute('morphTarget' + _i4);
                    if (morphNormals && geometry.hasAttribute('morphNormal' + _i4) === true) geometry.deleteAttribute('morphNormal' + _i4);
                    morphInfluences[_i4] = 0;
                }
            } // GLSL shader uses formula baseinfluence * base + sum(target * influence)
            // This allows us to switch between absolute morphs and relative morphs without changing shader code
            // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
            var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
            program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
            program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
        }
        return {
            update: update
        };
    }
    function WebGLObjects(gl, geometries, attributes, info) {
        var updateMap = new WeakMap();
        function update(object) {
            var frame = info.render.frame;
            var geometry = object.geometry;
            var buffergeometry = geometries.get(object, geometry); // Update once per frame
            if (updateMap.get(buffergeometry) !== frame) {
                geometries.update(buffergeometry);
                updateMap.set(buffergeometry, frame);
            }
            if (object.isInstancedMesh) {
                if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) object.addEventListener('dispose', onInstancedMeshDispose);
                attributes.update(object.instanceMatrix, 34962);
                if (object.instanceColor !== null) attributes.update(object.instanceColor, 34962);
            }
            return buffergeometry;
        }
        function dispose() {
            updateMap = new WeakMap();
        }
        function onInstancedMeshDispose(event) {
            var instancedMesh = event.target;
            instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
            attributes.remove(instancedMesh.instanceMatrix);
            if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
        }
        return {
            update: update,
            dispose: dispose
        };
    }
    function DataTexture2DArray(data, width, height, depth) {
        if (data === void 0) data = null;
        if (width === void 0) width = 1;
        if (height === void 0) height = 1;
        if (depth === void 0) depth = 1;
        Texture.call(this, null);
        this.image = {
            data: data,
            width: width,
            height: height,
            depth: depth
        };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.needsUpdate = true;
    }
    DataTexture2DArray.prototype = Object.create(Texture.prototype);
    DataTexture2DArray.prototype.constructor = DataTexture2DArray;
    DataTexture2DArray.prototype.isDataTexture2DArray = true;
    function DataTexture3D(data, width, height, depth) {
        if (data === void 0) data = null;
        if (width === void 0) width = 1;
        if (height === void 0) height = 1;
        if (depth === void 0) depth = 1;
        // We're going to add .setXXX() methods for setting properties later.
        // Users can still set in DataTexture3D directly.
        //
        //	const texture = new THREE.DataTexture3D( data, width, height, depth );
        // 	texture.anisotropy = 16;
        //
        // See #14839
        Texture.call(this, null);
        this.image = {
            data: data,
            width: width,
            height: height,
            depth: depth
        };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.needsUpdate = true;
    }
    DataTexture3D.prototype = Object.create(Texture.prototype);
    DataTexture3D.prototype.constructor = DataTexture3D;
    DataTexture3D.prototype.isDataTexture3D = true;
    /**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *		the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with	name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */ var emptyTexture = new Texture();
    var emptyTexture2dArray = new DataTexture2DArray();
    var emptyTexture3d = new DataTexture3D();
    var emptyCubeTexture = new CubeTexture(); // --- Utilities ---
    // Array Caches (provide typed arrays for temporary by size)
    var arrayCacheF32 = [];
    var arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms
    var mat4array = new Float32Array(16);
    var mat3array = new Float32Array(9);
    var mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices
    function flatten(array, nBlocks, blockSize) {
        var firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
        // see http://jacksondunstan.com/articles/983
        var n = nBlocks * blockSize;
        var r = arrayCacheF32[n];
        if (r === undefined) {
            r = new Float32Array(n);
            arrayCacheF32[n] = r;
        }
        if (nBlocks !== 0) {
            firstElem.toArray(r, 0);
            for(var i20 = 1, offset = 0; i20 !== nBlocks; ++i20){
                offset += blockSize;
                array[i20].toArray(r, offset);
            }
        }
        return r;
    }
    function arraysEqual(a, b) {
        if (a.length !== b.length) return false;
        for(var i21 = 0, l = a.length; i21 < l; i21++){
            if (a[i21] !== b[i21]) return false;
        }
        return true;
    }
    function copyArray(a, b) {
        for(var i21 = 0, l = b.length; i21 < l; i21++)a[i21] = b[i21];
    } // Texture unit allocation
    function allocTexUnits(textures, n) {
        var r = arrayCacheI32[n];
        if (r === undefined) {
            r = new Int32Array(n);
            arrayCacheI32[n] = r;
        }
        for(var i21 = 0; i21 !== n; ++i21)r[i21] = textures.allocateTextureUnit();
        return r;
    } // --- Setters ---
    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.
    // Single scalar
    function setValueV1f(gl, v) {
        var cache = this.cache;
        if (cache[0] === v) return;
        gl.uniform1f(this.addr, v);
        cache[0] = v;
    } // Single float vector (from flat array or THREE.VectorN)
    function setValueV2f(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y) {
                gl.uniform2f(this.addr, v.x, v.y);
                cache[0] = v.x;
                cache[1] = v.y;
            }
        } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform2fv(this.addr, v);
            copyArray(cache, v);
        }
    }
    function setValueV3f(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
                gl.uniform3f(this.addr, v.x, v.y, v.z);
                cache[0] = v.x;
                cache[1] = v.y;
                cache[2] = v.z;
            }
        } else if (v.r !== undefined) {
            if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
                gl.uniform3f(this.addr, v.r, v.g, v.b);
                cache[0] = v.r;
                cache[1] = v.g;
                cache[2] = v.b;
            }
        } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform3fv(this.addr, v);
            copyArray(cache, v);
        }
    }
    function setValueV4f(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
                gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
                cache[0] = v.x;
                cache[1] = v.y;
                cache[2] = v.z;
                cache[3] = v.w;
            }
        } else {
            if (arraysEqual(cache, v)) return;
            gl.uniform4fv(this.addr, v);
            copyArray(cache, v);
        }
    } // Single matrix (from flat array or MatrixN)
    function setValueM2(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v)) return;
            gl.uniformMatrix2fv(this.addr, false, v);
            copyArray(cache, v);
        } else {
            if (arraysEqual(cache, elements)) return;
            mat2array.set(elements);
            gl.uniformMatrix2fv(this.addr, false, mat2array);
            copyArray(cache, elements);
        }
    }
    function setValueM3(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v)) return;
            gl.uniformMatrix3fv(this.addr, false, v);
            copyArray(cache, v);
        } else {
            if (arraysEqual(cache, elements)) return;
            mat3array.set(elements);
            gl.uniformMatrix3fv(this.addr, false, mat3array);
            copyArray(cache, elements);
        }
    }
    function setValueM4(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v)) return;
            gl.uniformMatrix4fv(this.addr, false, v);
            copyArray(cache, v);
        } else {
            if (arraysEqual(cache, elements)) return;
            mat4array.set(elements);
            gl.uniformMatrix4fv(this.addr, false, mat4array);
            copyArray(cache, elements);
        }
    } // Single texture (2D / Cube)
    function setValueT1(gl, v, textures) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
        }
        textures.safeSetTexture2D(v || emptyTexture, unit);
    }
    function setValueT2DArray1(gl, v, textures) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
        }
        textures.setTexture2DArray(v || emptyTexture2dArray, unit);
    }
    function setValueT3D1(gl, v, textures) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
        }
        textures.setTexture3D(v || emptyTexture3d, unit);
    }
    function setValueT6(gl, v, textures) {
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
        if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
        }
        textures.safeSetTextureCube(v || emptyCubeTexture, unit);
    } // Integer / Boolean vectors or arrays thereof (always flat arrays)
    function setValueV1i(gl, v) {
        var cache = this.cache;
        if (cache[0] === v) return;
        gl.uniform1i(this.addr, v);
        cache[0] = v;
    }
    function setValueV2i(gl, v) {
        var cache = this.cache;
        if (arraysEqual(cache, v)) return;
        gl.uniform2iv(this.addr, v);
        copyArray(cache, v);
    }
    function setValueV3i(gl, v) {
        var cache = this.cache;
        if (arraysEqual(cache, v)) return;
        gl.uniform3iv(this.addr, v);
        copyArray(cache, v);
    }
    function setValueV4i(gl, v) {
        var cache = this.cache;
        if (arraysEqual(cache, v)) return;
        gl.uniform4iv(this.addr, v);
        copyArray(cache, v);
    } // uint
    function setValueV1ui(gl, v) {
        var cache = this.cache;
        if (cache[0] === v) return;
        gl.uniform1ui(this.addr, v);
        cache[0] = v;
    } // Helper to pick the right setter for the singular case
    function getSingularSetter(type) {
        switch(type){
            case 5126:
                return setValueV1f;
            // FLOAT
            case 35664:
                return setValueV2f;
            // _VEC2
            case 35665:
                return setValueV3f;
            // _VEC3
            case 35666:
                return setValueV4f;
            // _VEC4
            case 35674:
                return setValueM2;
            // _MAT2
            case 35675:
                return setValueM3;
            // _MAT3
            case 35676:
                return setValueM4;
            // _MAT4
            case 5124:
            case 35670:
                return setValueV1i;
            // INT, BOOL
            case 35667:
            case 35671:
                return setValueV2i;
            // _VEC2
            case 35668:
            case 35672:
                return setValueV3i;
            // _VEC3
            case 35669:
            case 35673:
                return setValueV4i;
            // _VEC4
            case 5125:
                return setValueV1ui;
            // UINT
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                // SAMPLER_2D_SHADOW
                return setValueT1;
            case 35679:
            case 36299:
            case 36307:
                // UNSIGNED_INT_SAMPLER_3D
                return setValueT3D1;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                // SAMPLER_CUBE_SHADOW
                return setValueT6;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                // SAMPLER_2D_ARRAY_SHADOW
                return setValueT2DArray1;
        }
    } // Array of scalars
    function setValueV1fArray(gl, v) {
        gl.uniform1fv(this.addr, v);
    } // Integer / Boolean vectors or arrays thereof (always flat arrays)
    function setValueV1iArray(gl, v) {
        gl.uniform1iv(this.addr, v);
    }
    function setValueV2iArray(gl, v) {
        gl.uniform2iv(this.addr, v);
    }
    function setValueV3iArray(gl, v) {
        gl.uniform3iv(this.addr, v);
    }
    function setValueV4iArray(gl, v) {
        gl.uniform4iv(this.addr, v);
    } // Array of vectors (flat or from THREE classes)
    function setValueV2fArray(gl, v) {
        var data = flatten(v, this.size, 2);
        gl.uniform2fv(this.addr, data);
    }
    function setValueV3fArray(gl, v) {
        var data = flatten(v, this.size, 3);
        gl.uniform3fv(this.addr, data);
    }
    function setValueV4fArray(gl, v) {
        var data = flatten(v, this.size, 4);
        gl.uniform4fv(this.addr, data);
    } // Array of matrices (flat or from THREE clases)
    function setValueM2Array(gl, v) {
        var data = flatten(v, this.size, 4);
        gl.uniformMatrix2fv(this.addr, false, data);
    }
    function setValueM3Array(gl, v) {
        var data = flatten(v, this.size, 9);
        gl.uniformMatrix3fv(this.addr, false, data);
    }
    function setValueM4Array(gl, v) {
        var data = flatten(v, this.size, 16);
        gl.uniformMatrix4fv(this.addr, false, data);
    } // Array of textures (2D / Cube)
    function setValueT1Array(gl, v, textures) {
        var n = v.length;
        var units = allocTexUnits(textures, n);
        gl.uniform1iv(this.addr, units);
        for(var i21 = 0; i21 !== n; ++i21)textures.safeSetTexture2D(v[i21] || emptyTexture, units[i21]);
    }
    function setValueT6Array(gl, v, textures) {
        var n = v.length;
        var units = allocTexUnits(textures, n);
        gl.uniform1iv(this.addr, units);
        for(var i21 = 0; i21 !== n; ++i21)textures.safeSetTextureCube(v[i21] || emptyCubeTexture, units[i21]);
    } // Helper to pick the right setter for a pure (bottom-level) array
    function getPureArraySetter(type) {
        switch(type){
            case 5126:
                return setValueV1fArray;
            // FLOAT
            case 35664:
                return setValueV2fArray;
            // _VEC2
            case 35665:
                return setValueV3fArray;
            // _VEC3
            case 35666:
                return setValueV4fArray;
            // _VEC4
            case 35674:
                return setValueM2Array;
            // _MAT2
            case 35675:
                return setValueM3Array;
            // _MAT3
            case 35676:
                return setValueM4Array;
            // _MAT4
            case 5124:
            case 35670:
                return setValueV1iArray;
            // INT, BOOL
            case 35667:
            case 35671:
                return setValueV2iArray;
            // _VEC2
            case 35668:
            case 35672:
                return setValueV3iArray;
            // _VEC3
            case 35669:
            case 35673:
                return setValueV4iArray;
            // _VEC4
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                // SAMPLER_2D_SHADOW
                return setValueT1Array;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                // SAMPLER_CUBE_SHADOW
                return setValueT6Array;
        }
    } // --- Uniform Classes ---
    function SingleUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
    }
    function PureArrayUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
    }
    PureArrayUniform.prototype.updateCache = function(data) {
        var cache = this.cache;
        if (data instanceof Float32Array && cache.length !== data.length) this.cache = new Float32Array(data.length);
        copyArray(cache, data);
    };
    function StructuredUniform(id) {
        this.id = id;
        this.seq = [];
        this.map = {
        };
    }
    StructuredUniform.prototype.setValue = function(gl, value, textures) {
        var seq = this.seq;
        for(var i21 = 0, n = seq.length; i21 !== n; ++i21){
            var u = seq[i21];
            u.setValue(gl, value[u.id], textures);
        }
    }; // --- Top-level ---
    // Parser - builds up the property tree from the path strings
    var RePathPart = /(\w+)(\])?(\[|\.)?/g; // extracts
    // 	- the identifier (member name or array index)
    //	- followed by an optional right bracket (found when array index)
    //	- followed by an optional left bracket or dot (type of subscript)
    //
    // Note: These portions can be read in a non-overlapping fashion and
    // allow straightforward parsing of the hierarchy that WebGL encodes
    // in the uniform names.
    function addUniform(container, uniformObject) {
        container.seq.push(uniformObject);
        container.map[uniformObject.id] = uniformObject;
    }
    function parseUniform(activeInfo, addr, container) {
        var path = activeInfo.name, pathLength = path.length; // reset RegExp object, because of the early exit of a previous run
        RePathPart.lastIndex = 0;
        while(true){
            var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
            var id = match[1];
            var idIsIndex = match[2] === ']', subscript = match[3];
            if (idIsIndex) id = id | 0; // convert to integer
            if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
                // bare name or "pure" bottom-level array "[0]" suffix
                addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                break;
            } else {
                // step into inner node / create it in case it doesn't exist
                var map = container.map;
                var next = map[id];
                if (next === undefined) {
                    next = new StructuredUniform(id);
                    addUniform(container, next);
                }
                container = next;
            }
        }
    } // Root Container
    function WebGLUniforms(gl, program) {
        this.seq = [];
        this.map = {
        };
        var n = gl.getProgramParameter(program, 35718);
        for(var i21 = 0; i21 < n; ++i21){
            var info = gl.getActiveUniform(program, i21), addr = gl.getUniformLocation(program, info.name);
            parseUniform(info, addr, this);
        }
    }
    WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
        var u = this.map[name];
        if (u !== undefined) u.setValue(gl, value, textures);
    };
    WebGLUniforms.prototype.setOptional = function(gl, object, name) {
        var v = object[name];
        if (v !== undefined) this.setValue(gl, name, v);
    }; // Static interface
    WebGLUniforms.upload = function(gl, seq, values, textures) {
        for(var i21 = 0, n = seq.length; i21 !== n; ++i21){
            var u = seq[i21], v = values[u.id];
            if (v.needsUpdate !== false) // note: always updating when .needsUpdate is undefined
            u.setValue(gl, v.value, textures);
        }
    };
    WebGLUniforms.seqWithValue = function(seq, values) {
        var r = [];
        for(var i21 = 0, n = seq.length; i21 !== n; ++i21){
            var u = seq[i21];
            if (u.id in values) r.push(u);
        }
        return r;
    };
    function WebGLShader1(gl, type, string) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        return shader;
    }
    var programIdCount = 0;
    function addLineNumbers(string) {
        var lines = string.split('\n');
        for(var i21 = 0; i21 < lines.length; i21++)lines[i21] = i21 + 1 + ': ' + lines[i21];
        return lines.join('\n');
    }
    function getEncodingComponents(encoding) {
        switch(encoding){
            case LinearEncoding:
                return [
                    'Linear',
                    '( value )'
                ];
            case sRGBEncoding:
                return [
                    'sRGB',
                    '( value )'
                ];
            case RGBEEncoding:
                return [
                    'RGBE',
                    '( value )'
                ];
            case RGBM7Encoding:
                return [
                    'RGBM',
                    '( value, 7.0 )'
                ];
            case RGBM16Encoding:
                return [
                    'RGBM',
                    '( value, 16.0 )'
                ];
            case RGBDEncoding:
                return [
                    'RGBD',
                    '( value, 256.0 )'
                ];
            case GammaEncoding:
                return [
                    'Gamma',
                    '( value, float( GAMMA_FACTOR ) )'
                ];
            case LogLuvEncoding:
                return [
                    'LogLuv',
                    '( value )'
                ];
            default:
                console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
                return [
                    'Linear',
                    '( value )'
                ];
        }
    }
    function getShaderErrors(gl, shader, type) {
        var status = gl.getShaderParameter(shader, 35713);
        var log = gl.getShaderInfoLog(shader).trim();
        if (status && log === '') return ''; // --enable-privileged-webgl-extension
        // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
        var source = gl.getShaderSource(shader);
        return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
    }
    function getTexelDecodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
    }
    function getTexelEncodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
    }
    function getToneMappingFunction(functionName, toneMapping) {
        var toneMappingName;
        switch(toneMapping){
            case LinearToneMapping:
                toneMappingName = 'Linear';
                break;
            case ReinhardToneMapping:
                toneMappingName = 'Reinhard';
                break;
            case CineonToneMapping:
                toneMappingName = 'OptimizedCineon';
                break;
            case ACESFilmicToneMapping:
                toneMappingName = 'ACESFilmic';
                break;
            case CustomToneMapping:
                toneMappingName = 'Custom';
                break;
            default:
                console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
                toneMappingName = 'Linear';
        }
        return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
    }
    function generateExtensions(parameters) {
        var chunks = [
            parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '',
            (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
            parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '',
            (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
        ];
        return chunks.filter(filterEmptyLine).join('\n');
    }
    function generateDefines(defines) {
        var chunks = [];
        for(var name in defines){
            var value = defines[name];
            if (value === false) continue;
            chunks.push('#define ' + name + ' ' + value);
        }
        return chunks.join('\n');
    }
    function fetchAttributeLocations(gl, program) {
        var attributes = {
        };
        var n = gl.getProgramParameter(program, 35721);
        for(var i21 = 0; i21 < n; i21++){
            var info = gl.getActiveAttrib(program, i21);
            var name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
            attributes[name] = gl.getAttribLocation(program, name);
        }
        return attributes;
    }
    function filterEmptyLine(string) {
        return string !== '';
    }
    function replaceLightNums(string, parameters) {
        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
    }
    function replaceClippingPlaneNums(string, parameters) {
        return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
    } // Resolve Includes
    var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function resolveIncludes(string) {
        return string.replace(includePattern, includeReplacer);
    }
    function includeReplacer(match, include) {
        var string = ShaderChunk[include];
        if (string === undefined) throw new Error('Can not resolve #include <' + include + '>');
        return resolveIncludes(string);
    } // Unroll Loops
    var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function unrollLoops(string) {
        return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
    }
    function deprecatedLoopReplacer(match, start, end, snippet) {
        console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
        return loopReplacer(match, start, end, snippet);
    }
    function loopReplacer(match, start, end, snippet) {
        var string = '';
        for(var i21 = parseInt(start); i21 < parseInt(end); i21++)string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i21 + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i21);
        return string;
    } //
    function generatePrecision(parameters) {
        var precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';
        if (parameters.precision === 'highp') precisionstring += '\n#define HIGH_PRECISION';
        else if (parameters.precision === 'mediump') precisionstring += '\n#define MEDIUM_PRECISION';
        else if (parameters.precision === 'lowp') precisionstring += '\n#define LOW_PRECISION';
        return precisionstring;
    }
    function generateShadowMapTypeDefine(parameters) {
        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
        if (parameters.shadowMapType === PCFShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
        else if (parameters.shadowMapType === PCFSoftShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
        else if (parameters.shadowMapType === VSMShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
        return shadowMapTypeDefine;
    }
    function generateEnvMapTypeDefine(parameters) {
        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        if (parameters.envMap) switch(parameters.envMapMode){
            case CubeReflectionMapping:
            case CubeRefractionMapping:
                envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                break;
            case CubeUVReflectionMapping:
            case CubeUVRefractionMapping:
                envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                break;
        }
        return envMapTypeDefine;
    }
    function generateEnvMapModeDefine(parameters) {
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        if (parameters.envMap) switch(parameters.envMapMode){
            case CubeRefractionMapping:
            case CubeUVRefractionMapping:
                envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                break;
        }
        return envMapModeDefine;
    }
    function generateEnvMapBlendingDefine(parameters) {
        var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
        if (parameters.envMap) switch(parameters.combine){
            case MultiplyOperation:
                envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                break;
            case MixOperation:
                envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                break;
            case AddOperation:
                envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                break;
        }
        return envMapBlendingDefine;
    }
    function WebGLProgram1(renderer, cacheKey, parameters, bindingStates) {
        var gl = renderer.getContext();
        var defines = parameters.defines;
        var vertexShader = parameters.vertexShader;
        var fragmentShader = parameters.fragmentShader;
        var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
        var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
        var envMapModeDefine = generateEnvMapModeDefine(parameters);
        var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
        var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
        var customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
        var customDefines = generateDefines(defines);
        var program = gl.createProgram();
        var prefixVertex, prefixFragment;
        var versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
        if (parameters.isRawShaderMaterial) {
            prefixVertex = [
                customDefines
            ].filter(filterEmptyLine).join('\n');
            if (prefixVertex.length > 0) prefixVertex += '\n';
            prefixFragment = [
                customExtensions,
                customDefines
            ].filter(filterEmptyLine).join('\n');
            if (prefixFragment.length > 0) prefixFragment += '\n';
        } else {
            prefixVertex = [
                generatePrecision(parameters),
                '#define SHADER_NAME ' + parameters.shaderName,
                customDefines,
                parameters.instancing ? '#define USE_INSTANCING' : '',
                parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
                parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,
                '#define MAX_BONES ' + parameters.maxBones,
                parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
                parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
                parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
                parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
                parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                parameters.vertexTangents ? '#define USE_TANGENT' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',
                parameters.vertexUvs ? '#define USE_UV' : '',
                parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                parameters.flatShading ? '#define FLAT_SHADED' : '',
                parameters.skinning ? '#define USE_SKINNING' : '',
                parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
                parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',
                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
                '#ifdef USE_INSTANCING',
                '	attribute mat4 instanceMatrix;',
                '#endif',
                '#ifdef USE_INSTANCING_COLOR',
                '	attribute vec3 instanceColor;',
                '#endif',
                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',
                '#ifdef USE_TANGENT',
                '	attribute vec4 tangent;',
                '#endif',
                '#ifdef USE_COLOR',
                '	attribute vec3 color;',
                '#endif',
                '#ifdef USE_MORPHTARGETS',
                '	attribute vec3 morphTarget0;',
                '	attribute vec3 morphTarget1;',
                '	attribute vec3 morphTarget2;',
                '	attribute vec3 morphTarget3;',
                '	#ifdef USE_MORPHNORMALS',
                '		attribute vec3 morphNormal0;',
                '		attribute vec3 morphNormal1;',
                '		attribute vec3 morphNormal2;',
                '		attribute vec3 morphNormal3;',
                '	#else',
                '		attribute vec3 morphTarget4;',
                '		attribute vec3 morphTarget5;',
                '		attribute vec3 morphTarget6;',
                '		attribute vec3 morphTarget7;',
                '	#endif',
                '#endif',
                '#ifdef USE_SKINNING',
                '	attribute vec4 skinIndex;',
                '	attribute vec4 skinWeight;',
                '#endif',
                '\n'
            ].filter(filterEmptyLine).join('\n');
            prefixFragment = [
                customExtensions,
                generatePrecision(parameters),
                '#define SHADER_NAME ' + parameters.shaderName,
                customDefines,
                parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '',
                '#define GAMMA_FACTOR ' + gammaFactorDefine,
                parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
                parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
                parameters.map ? '#define USE_MAP' : '',
                parameters.matcap ? '#define USE_MATCAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapTypeDefine : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
                parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
                parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
                parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                parameters.sheen ? '#define USE_SHEEN' : '',
                parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                parameters.vertexTangents ? '#define USE_TANGENT' : '',
                parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
                parameters.vertexUvs ? '#define USE_UV' : '',
                parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
                parameters.flatShading ? '#define FLAT_SHADED' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',
                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
                parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
                (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '',
                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
                parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '',
                parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
                parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
                parameters.dithering ? '#define DITHERING' : '',
                ShaderChunk['encodings_pars_fragment'],
                parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
                parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '',
                parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
                parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
                parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '',
                getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding),
                parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',
                '\n'
            ].filter(filterEmptyLine).join('\n');
        }
        vertexShader = resolveIncludes(vertexShader);
        vertexShader = replaceLightNums(vertexShader, parameters);
        vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
        fragmentShader = resolveIncludes(fragmentShader);
        fragmentShader = replaceLightNums(fragmentShader, parameters);
        fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
        vertexShader = unrollLoops(vertexShader);
        fragmentShader = unrollLoops(fragmentShader);
        if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
            // GLSL 3.0 conversion for built-in materials and ShaderMaterial
            versionString = '#version 300 es\n';
            prefixVertex = [
                '#define attribute in',
                '#define varying out',
                '#define texture2D texture'
            ].join('\n') + '\n' + prefixVertex;
            prefixFragment = [
                '#define varying in',
                parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;',
                parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor',
                '#define gl_FragDepthEXT gl_FragDepth',
                '#define texture2D texture',
                '#define textureCube texture',
                '#define texture2DProj textureProj',
                '#define texture2DLodEXT textureLod',
                '#define texture2DProjLodEXT textureProjLod',
                '#define textureCubeLodEXT textureLod',
                '#define texture2DGradEXT textureGrad',
                '#define texture2DProjGradEXT textureProjGrad',
                '#define textureCubeGradEXT textureGrad'
            ].join('\n') + '\n' + prefixFragment;
        }
        var vertexGlsl = versionString + prefixVertex + vertexShader;
        var fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
        // console.log( '*FRAGMENT*', fragmentGlsl );
        var glVertexShader = WebGLShader1(gl, 35633, vertexGlsl);
        var glFragmentShader = WebGLShader1(gl, 35632, fragmentGlsl);
        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.
        if (parameters.index0AttributeName !== undefined) gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
        else if (parameters.morphTargets === true) // programs with morphTargets displace position out of attribute 0
        gl.bindAttribLocation(program, 0, 'position');
        gl.linkProgram(program); // check for link errors
        if (renderer.debug.checkShaderErrors) {
            var programLog = gl.getProgramInfoLog(program).trim();
            var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
            var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
            var runnable = true;
            var haveDiagnostics = true;
            if (gl.getProgramParameter(program, 35714) === false) {
                runnable = false;
                var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
                var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
                console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
            } else if (programLog !== '') console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
            else if (vertexLog === '' || fragmentLog === '') haveDiagnostics = false;
            if (haveDiagnostics) this.diagnostics = {
                runnable: runnable,
                programLog: programLog,
                vertexShader: {
                    log: vertexLog,
                    prefix: prefixVertex
                },
                fragmentShader: {
                    log: fragmentLog,
                    prefix: prefixFragment
                }
            };
        } // Clean up
        // Crashes in iOS9 and iOS10. #18402
        // gl.detachShader( program, glVertexShader );
        // gl.detachShader( program, glFragmentShader );
        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader); // set up caching for uniform locations
        var cachedUniforms;
        this.getUniforms = function() {
            if (cachedUniforms === undefined) cachedUniforms = new WebGLUniforms(gl, program);
            return cachedUniforms;
        }; // set up caching for attribute locations
        var cachedAttributes;
        this.getAttributes = function() {
            if (cachedAttributes === undefined) cachedAttributes = fetchAttributeLocations(gl, program);
            return cachedAttributes;
        }; // free resource
        this.destroy = function() {
            bindingStates.releaseStatesOfProgram(this);
            gl.deleteProgram(program);
            this.program = undefined;
        }; //
        this.name = parameters.shaderName;
        this.id = programIdCount++;
        this.cacheKey = cacheKey;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
    }
    function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
        var programs = [];
        var isWebGL2 = capabilities.isWebGL2;
        var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
        var floatVertexTextures = capabilities.floatVertexTextures;
        var maxVertexUniforms = capabilities.maxVertexUniforms;
        var vertexTextures = capabilities.vertexTextures;
        var precision = capabilities.precision;
        var shaderIDs = {
            MeshDepthMaterial: 'depth',
            MeshDistanceMaterial: 'distanceRGBA',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'toon',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            MeshMatcapMaterial: 'matcap',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points',
            ShadowMaterial: 'shadow',
            SpriteMaterial: 'sprite'
        };
        var parameterNames = [
            'precision',
            'isWebGL2',
            'supportsVertexTextures',
            'outputEncoding',
            'instancing',
            'instancingColor',
            'map',
            'mapEncoding',
            'matcap',
            'matcapEncoding',
            'envMap',
            'envMapMode',
            'envMapEncoding',
            'envMapCubeUV',
            'lightMap',
            'lightMapEncoding',
            'aoMap',
            'emissiveMap',
            'emissiveMapEncoding',
            'bumpMap',
            'normalMap',
            'objectSpaceNormalMap',
            'tangentSpaceNormalMap',
            'clearcoatMap',
            'clearcoatRoughnessMap',
            'clearcoatNormalMap',
            'displacementMap',
            'specularMap',
            'roughnessMap',
            'metalnessMap',
            'gradientMap',
            'alphaMap',
            'combine',
            'vertexColors',
            'vertexTangents',
            'vertexUvs',
            'uvsVertexOnly',
            'fog',
            'useFog',
            'fogExp2',
            'flatShading',
            'sizeAttenuation',
            'logarithmicDepthBuffer',
            'skinning',
            'maxBones',
            'useVertexTexture',
            'morphTargets',
            'morphNormals',
            'maxMorphTargets',
            'maxMorphNormals',
            'premultipliedAlpha',
            'numDirLights',
            'numPointLights',
            'numSpotLights',
            'numHemiLights',
            'numRectAreaLights',
            'numDirLightShadows',
            'numPointLightShadows',
            'numSpotLightShadows',
            'shadowMapEnabled',
            'shadowMapType',
            'toneMapping',
            'physicallyCorrectLights',
            'alphaTest',
            'doubleSided',
            'flipSided',
            'numClippingPlanes',
            'numClipIntersection',
            'depthPacking',
            'dithering',
            'sheen',
            'transmissionMap'
        ];
        function getMaxBones(object) {
            var skeleton = object.skeleton;
            var bones = skeleton.bones;
            if (floatVertexTextures) return 1024;
            else {
                // default for when object is not specified
                // ( for example when prebuilding shader to be used with multiple objects )
                //
                //	- leave some extra space for other uniforms
                //	- limit here is ANGLE's 254 max uniform vectors
                //		(up to 54 should be safe)
                var nVertexUniforms = maxVertexUniforms;
                var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
                var maxBones = Math.min(nVertexMatrices, bones.length);
                if (maxBones < bones.length) {
                    console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                    return 0;
                }
                return maxBones;
            }
        }
        function getTextureEncodingFromMap(map) {
            var encoding;
            if (map && map.isTexture) encoding = map.encoding;
            else if (map && map.isWebGLRenderTarget) {
                console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
                encoding = map.texture.encoding;
            } else encoding = LinearEncoding;
            return encoding;
        }
        function getParameters(material, lights, shadows, scene, object) {
            var fog = scene.fog;
            var environment = material.isMeshStandardMaterial ? scene.environment : null;
            var envMap = cubemaps.get(material.envMap || environment);
            var shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
            // (not to blow over maxLights budget)
            var maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
            if (material.precision !== null) {
                precision = capabilities.getMaxPrecision(material.precision);
                if (precision !== material.precision) console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
            }
            var vertexShader, fragmentShader;
            if (shaderID) {
                var shader = ShaderLib[shaderID];
                vertexShader = shader.vertexShader;
                fragmentShader = shader.fragmentShader;
            } else {
                vertexShader = material.vertexShader;
                fragmentShader = material.fragmentShader;
            }
            var currentRenderTarget = renderer.getRenderTarget();
            var parameters = {
                isWebGL2: isWebGL2,
                shaderID: shaderID,
                shaderName: material.type,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                defines: material.defines,
                isRawShaderMaterial: material.isRawShaderMaterial === true,
                glslVersion: material.glslVersion,
                precision: precision,
                instancing: object.isInstancedMesh === true,
                instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
                supportsVertexTextures: vertexTextures,
                outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
                map: !!material.map,
                mapEncoding: getTextureEncodingFromMap(material.map),
                matcap: !!material.matcap,
                matcapEncoding: getTextureEncodingFromMap(material.matcap),
                envMap: !!envMap,
                envMapMode: envMap && envMap.mapping,
                envMapEncoding: getTextureEncodingFromMap(envMap),
                envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
                lightMap: !!material.lightMap,
                lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
                tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
                clearcoatMap: !!material.clearcoatMap,
                clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
                clearcoatNormalMap: !!material.clearcoatNormalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,
                gradientMap: !!material.gradientMap,
                sheen: !!material.sheen,
                transmissionMap: !!material.transmissionMap,
                combine: material.combine,
                vertexTangents: material.normalMap && material.vertexTangents,
                vertexColors: material.vertexColors,
                vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
                uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
                fog: !!fog,
                useFog: material.fog,
                fogExp2: fog && fog.isFogExp2,
                flatShading: material.flatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: logarithmicDepthBuffer,
                skinning: material.skinning && maxBones > 0,
                maxBones: maxBones,
                useVertexTexture: floatVertexTextures,
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,
                numDirLightShadows: lights.directionalShadowMap.length,
                numPointLightShadows: lights.pointShadowMap.length,
                numSpotLightShadows: lights.spotShadowMap.length,
                numClippingPlanes: clipping.numPlanes,
                numClipIntersection: clipping.numIntersection,
                dithering: material.dithering,
                shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                alphaTest: material.alphaTest,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
                depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
                index0AttributeName: material.index0AttributeName,
                extensionDerivatives: material.extensions && material.extensions.derivatives,
                extensionFragDepth: material.extensions && material.extensions.fragDepth,
                extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
                extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
                rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
                rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
                customProgramCacheKey: material.customProgramCacheKey()
            };
            return parameters;
        }
        function getProgramCacheKey(parameters) {
            var array = [];
            if (parameters.shaderID) array.push(parameters.shaderID);
            else {
                array.push(parameters.fragmentShader);
                array.push(parameters.vertexShader);
            }
            if (parameters.defines !== undefined) for(var name in parameters.defines){
                array.push(name);
                array.push(parameters.defines[name]);
            }
            if (parameters.isRawShaderMaterial === false) {
                for(var i21 = 0; i21 < parameterNames.length; i21++)array.push(parameters[parameterNames[i21]]);
                array.push(renderer.outputEncoding);
                array.push(renderer.gammaFactor);
            }
            array.push(parameters.customProgramCacheKey);
            return array.join();
        }
        function getUniforms(material) {
            var shaderID = shaderIDs[material.type];
            var uniforms;
            if (shaderID) {
                var shader = ShaderLib[shaderID];
                uniforms = UniformsUtils.clone(shader.uniforms);
            } else uniforms = material.uniforms;
            return uniforms;
        }
        function acquireProgram(parameters, cacheKey) {
            var program; // Check if code has been already compiled
            for(var p = 0, pl = programs.length; p < pl; p++){
                var preexistingProgram = programs[p];
                if (preexistingProgram.cacheKey === cacheKey) {
                    program = preexistingProgram;
                    ++program.usedTimes;
                    break;
                }
            }
            if (program === undefined) {
                program = new WebGLProgram1(renderer, cacheKey, parameters, bindingStates);
                programs.push(program);
            }
            return program;
        }
        function releaseProgram(program) {
            if ((--program.usedTimes) === 0) {
                // Remove from unordered set
                var i22 = programs.indexOf(program);
                programs[i22] = programs[programs.length - 1];
                programs.pop(); // Free WebGL resources
                program.destroy();
            }
        }
        return {
            getParameters: getParameters,
            getProgramCacheKey: getProgramCacheKey,
            getUniforms: getUniforms,
            acquireProgram: acquireProgram,
            releaseProgram: releaseProgram,
            // Exposed for resource monitoring & error feedback via renderer.info:
            programs: programs
        };
    }
    function WebGLProperties() {
        var properties = new WeakMap();
        function get(object) {
            var map = properties.get(object);
            if (map === undefined) {
                map = {
                };
                properties.set(object, map);
            }
            return map;
        }
        function remove(object) {
            properties.delete(object);
        }
        function update(object, key3, value) {
            properties.get(object)[key3] = value;
        }
        function dispose() {
            properties = new WeakMap();
        }
        return {
            get: get,
            remove: remove,
            update: update,
            dispose: dispose
        };
    }
    function painterSortStable(a, b) {
        if (a.groupOrder !== b.groupOrder) return a.groupOrder - b.groupOrder;
        else if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
        else if (a.program !== b.program) return a.program.id - b.program.id;
        else if (a.material.id !== b.material.id) return a.material.id - b.material.id;
        else if (a.z !== b.z) return a.z - b.z;
        else return a.id - b.id;
    }
    function reversePainterSortStable(a, b) {
        if (a.groupOrder !== b.groupOrder) return a.groupOrder - b.groupOrder;
        else if (a.renderOrder !== b.renderOrder) return a.renderOrder - b.renderOrder;
        else if (a.z !== b.z) return b.z - a.z;
        else return a.id - b.id;
    }
    function WebGLRenderList(properties) {
        var renderItems = [];
        var renderItemsIndex = 0;
        var opaque = [];
        var transparent = [];
        var defaultProgram = {
            id: -1
        };
        function init() {
            renderItemsIndex = 0;
            opaque.length = 0;
            transparent.length = 0;
        }
        function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
            var renderItem = renderItems[renderItemsIndex];
            var materialProperties = properties.get(material);
            if (renderItem === undefined) {
                renderItem = {
                    id: object.id,
                    object: object,
                    geometry: geometry,
                    material: material,
                    program: materialProperties.program || defaultProgram,
                    groupOrder: groupOrder,
                    renderOrder: object.renderOrder,
                    z: z,
                    group: group
                };
                renderItems[renderItemsIndex] = renderItem;
            } else {
                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.program = materialProperties.program || defaultProgram;
                renderItem.groupOrder = groupOrder;
                renderItem.renderOrder = object.renderOrder;
                renderItem.z = z;
                renderItem.group = group;
            }
            renderItemsIndex++;
            return renderItem;
        }
        function push(object, geometry, material, groupOrder, z, group) {
            var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
            (material.transparent === true ? transparent : opaque).push(renderItem);
        }
        function unshift(object, geometry, material, groupOrder, z, group) {
            var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
            (material.transparent === true ? transparent : opaque).unshift(renderItem);
        }
        function sort(customOpaqueSort, customTransparentSort) {
            if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
            if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
        }
        function finish() {
            // Clear references from inactive renderItems in the list
            for(var i23 = renderItemsIndex, il = renderItems.length; i23 < il; i23++){
                var renderItem = renderItems[i23];
                if (renderItem.id === null) break;
                renderItem.id = null;
                renderItem.object = null;
                renderItem.geometry = null;
                renderItem.material = null;
                renderItem.program = null;
                renderItem.group = null;
            }
        }
        return {
            opaque: opaque,
            transparent: transparent,
            init: init,
            push: push,
            unshift: unshift,
            finish: finish,
            sort: sort
        };
    }
    function WebGLRenderLists(properties) {
        var lists = new WeakMap();
        function get(scene, camera) {
            var cameras = lists.get(scene);
            var list;
            if (cameras === undefined) {
                list = new WebGLRenderList(properties);
                lists.set(scene, new WeakMap());
                lists.get(scene).set(camera, list);
            } else {
                list = cameras.get(camera);
                if (list === undefined) {
                    list = new WebGLRenderList(properties);
                    cameras.set(camera, list);
                }
            }
            return list;
        }
        function dispose() {
            lists = new WeakMap();
        }
        return {
            get: get,
            dispose: dispose
        };
    }
    function UniformsCache() {
        var lights = {
        };
        return {
            get: function get(light) {
                if (lights[light.id] !== undefined) return lights[light.id];
                var uniforms;
                switch(light.type){
                    case 'DirectionalLight':
                        uniforms = {
                            direction: new Vector3(),
                            color: new Color()
                        };
                        break;
                    case 'SpotLight':
                        uniforms = {
                            position: new Vector3(),
                            direction: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case 'PointLight':
                        uniforms = {
                            position: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case 'HemisphereLight':
                        uniforms = {
                            direction: new Vector3(),
                            skyColor: new Color(),
                            groundColor: new Color()
                        };
                        break;
                    case 'RectAreaLight':
                        uniforms = {
                            color: new Color(),
                            position: new Vector3(),
                            halfWidth: new Vector3(),
                            halfHeight: new Vector3()
                        };
                        break;
                }
                lights[light.id] = uniforms;
                return uniforms;
            }
        };
    }
    function ShadowUniformsCache() {
        var lights = {
        };
        return {
            get: function get(light) {
                if (lights[light.id] !== undefined) return lights[light.id];
                var uniforms;
                switch(light.type){
                    case 'DirectionalLight':
                        uniforms = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;
                    case 'SpotLight':
                        uniforms = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;
                    case 'PointLight':
                        uniforms = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2(),
                            shadowCameraNear: 1,
                            shadowCameraFar: 1000
                        };
                        break;
                }
                lights[light.id] = uniforms;
                return uniforms;
            }
        };
    }
    var nextVersion = 0;
    function shadowCastingLightsFirst(lightA, lightB) {
        return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
    }
    function WebGLLights(extensions, capabilities) {
        var cache = new UniformsCache();
        var shadowCache = ShadowUniformsCache();
        var state = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            },
            ambient: [
                0,
                0,
                0
            ],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        };
        for(var i23 = 0; i23 < 9; i23++)state.probe.push(new Vector3());
        var vector3 = new Vector3();
        var matrix4 = new Matrix4();
        var matrix42 = new Matrix4();
        function setup(lights) {
            var r = 0, g = 0, b = 0;
            for(var _i = 0; _i < 9; _i++)state.probe[_i].set(0, 0, 0);
            var directionalLength = 0;
            var pointLength = 0;
            var spotLength = 0;
            var rectAreaLength = 0;
            var hemiLength = 0;
            var numDirectionalShadows = 0;
            var numPointShadows = 0;
            var numSpotShadows = 0;
            lights.sort(shadowCastingLightsFirst);
            for(var _i2 = 0, l = lights.length; _i2 < l; _i2++){
                var light = lights[_i2];
                var color = light.color;
                var intensity = light.intensity;
                var distance = light.distance;
                var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
                if (light.isAmbientLight) {
                    r += color.r * intensity;
                    g += color.g * intensity;
                    b += color.b * intensity;
                } else if (light.isLightProbe) for(var j = 0; j < 9; j++)state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
                else if (light.isDirectionalLight) {
                    var uniforms = cache.get(light);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        var shadowUniforms = shadowCache.get(light);
                        shadowUniforms.shadowBias = shadow.bias;
                        shadowUniforms.shadowNormalBias = shadow.normalBias;
                        shadowUniforms.shadowRadius = shadow.radius;
                        shadowUniforms.shadowMapSize = shadow.mapSize;
                        state.directionalShadow[directionalLength] = shadowUniforms;
                        state.directionalShadowMap[directionalLength] = shadowMap;
                        state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                        numDirectionalShadows++;
                    }
                    state.directional[directionalLength] = uniforms;
                    directionalLength++;
                } else if (light.isSpotLight) {
                    var _uniforms = cache.get(light);
                    _uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    _uniforms.color.copy(color).multiplyScalar(intensity);
                    _uniforms.distance = distance;
                    _uniforms.coneCos = Math.cos(light.angle);
                    _uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                    _uniforms.decay = light.decay;
                    if (light.castShadow) {
                        var _shadow = light.shadow;
                        var _shadowUniforms = shadowCache.get(light);
                        _shadowUniforms.shadowBias = _shadow.bias;
                        _shadowUniforms.shadowNormalBias = _shadow.normalBias;
                        _shadowUniforms.shadowRadius = _shadow.radius;
                        _shadowUniforms.shadowMapSize = _shadow.mapSize;
                        state.spotShadow[spotLength] = _shadowUniforms;
                        state.spotShadowMap[spotLength] = shadowMap;
                        state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                        numSpotShadows++;
                    }
                    state.spot[spotLength] = _uniforms;
                    spotLength++;
                } else if (light.isRectAreaLight) {
                    var _uniforms2 = cache.get(light); // (a) intensity is the total visible light emitted
                    //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                    // (b) intensity is the brightness of the light
                    _uniforms2.color.copy(color).multiplyScalar(intensity);
                    _uniforms2.halfWidth.set(light.width * 0.5, 0, 0);
                    _uniforms2.halfHeight.set(0, light.height * 0.5, 0);
                    state.rectArea[rectAreaLength] = _uniforms2;
                    rectAreaLength++;
                } else if (light.isPointLight) {
                    var _uniforms3 = cache.get(light);
                    _uniforms3.color.copy(light.color).multiplyScalar(light.intensity);
                    _uniforms3.distance = light.distance;
                    _uniforms3.decay = light.decay;
                    if (light.castShadow) {
                        var _shadow2 = light.shadow;
                        var _shadowUniforms2 = shadowCache.get(light);
                        _shadowUniforms2.shadowBias = _shadow2.bias;
                        _shadowUniforms2.shadowNormalBias = _shadow2.normalBias;
                        _shadowUniforms2.shadowRadius = _shadow2.radius;
                        _shadowUniforms2.shadowMapSize = _shadow2.mapSize;
                        _shadowUniforms2.shadowCameraNear = _shadow2.camera.near;
                        _shadowUniforms2.shadowCameraFar = _shadow2.camera.far;
                        state.pointShadow[pointLength] = _shadowUniforms2;
                        state.pointShadowMap[pointLength] = shadowMap;
                        state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                        numPointShadows++;
                    }
                    state.point[pointLength] = _uniforms3;
                    pointLength++;
                } else if (light.isHemisphereLight) {
                    var _uniforms4 = cache.get(light);
                    _uniforms4.skyColor.copy(light.color).multiplyScalar(intensity);
                    _uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                    state.hemi[hemiLength] = _uniforms4;
                    hemiLength++;
                }
            }
            if (rectAreaLength > 0) {
                if (capabilities.isWebGL2) {
                    // WebGL 2
                    state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                    state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
                } else {
                    // WebGL 1
                    if (extensions.has('OES_texture_float_linear') === true) {
                        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
                    } else if (extensions.has('OES_texture_half_float_linear') === true) {
                        state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
                        state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
                    } else console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
                }
            }
            state.ambient[0] = r;
            state.ambient[1] = g;
            state.ambient[2] = b;
            var hash = state.hash;
            if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
                state.directional.length = directionalLength;
                state.spot.length = spotLength;
                state.rectArea.length = rectAreaLength;
                state.point.length = pointLength;
                state.hemi.length = hemiLength;
                state.directionalShadow.length = numDirectionalShadows;
                state.directionalShadowMap.length = numDirectionalShadows;
                state.pointShadow.length = numPointShadows;
                state.pointShadowMap.length = numPointShadows;
                state.spotShadow.length = numSpotShadows;
                state.spotShadowMap.length = numSpotShadows;
                state.directionalShadowMatrix.length = numDirectionalShadows;
                state.pointShadowMatrix.length = numPointShadows;
                state.spotShadowMatrix.length = numSpotShadows;
                hash.directionalLength = directionalLength;
                hash.pointLength = pointLength;
                hash.spotLength = spotLength;
                hash.rectAreaLength = rectAreaLength;
                hash.hemiLength = hemiLength;
                hash.numDirectionalShadows = numDirectionalShadows;
                hash.numPointShadows = numPointShadows;
                hash.numSpotShadows = numSpotShadows;
                state.version = nextVersion++;
            }
        }
        function setupView(lights, camera) {
            var directionalLength = 0;
            var pointLength = 0;
            var spotLength = 0;
            var rectAreaLength = 0;
            var hemiLength = 0;
            var viewMatrix = camera.matrixWorldInverse;
            for(var _i3 = 0, l = lights.length; _i3 < l; _i3++){
                var light = lights[_i3];
                if (light.isDirectionalLight) {
                    var uniforms = state.directional[directionalLength];
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    directionalLength++;
                } else if (light.isSpotLight) {
                    var _uniforms5 = state.spot[spotLength];
                    _uniforms5.position.setFromMatrixPosition(light.matrixWorld);
                    _uniforms5.position.applyMatrix4(viewMatrix);
                    _uniforms5.direction.setFromMatrixPosition(light.matrixWorld);
                    vector3.setFromMatrixPosition(light.target.matrixWorld);
                    _uniforms5.direction.sub(vector3);
                    _uniforms5.direction.transformDirection(viewMatrix);
                    spotLength++;
                } else if (light.isRectAreaLight) {
                    var _uniforms6 = state.rectArea[rectAreaLength];
                    _uniforms6.position.setFromMatrixPosition(light.matrixWorld);
                    _uniforms6.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors
                    matrix42.identity();
                    matrix4.copy(light.matrixWorld);
                    matrix4.premultiply(viewMatrix);
                    matrix42.extractRotation(matrix4);
                    _uniforms6.halfWidth.set(light.width * 0.5, 0, 0);
                    _uniforms6.halfHeight.set(0, light.height * 0.5, 0);
                    _uniforms6.halfWidth.applyMatrix4(matrix42);
                    _uniforms6.halfHeight.applyMatrix4(matrix42);
                    rectAreaLength++;
                } else if (light.isPointLight) {
                    var _uniforms7 = state.point[pointLength];
                    _uniforms7.position.setFromMatrixPosition(light.matrixWorld);
                    _uniforms7.position.applyMatrix4(viewMatrix);
                    pointLength++;
                } else if (light.isHemisphereLight) {
                    var _uniforms8 = state.hemi[hemiLength];
                    _uniforms8.direction.setFromMatrixPosition(light.matrixWorld);
                    _uniforms8.direction.transformDirection(viewMatrix);
                    _uniforms8.direction.normalize();
                    hemiLength++;
                }
            }
        }
        return {
            setup: setup,
            setupView: setupView,
            state: state
        };
    }
    function WebGLRenderState(extensions, capabilities) {
        var lights = new WebGLLights(extensions, capabilities);
        var lightsArray = [];
        var shadowsArray = [];
        function init() {
            lightsArray.length = 0;
            shadowsArray.length = 0;
        }
        function pushLight(light) {
            lightsArray.push(light);
        }
        function pushShadow(shadowLight) {
            shadowsArray.push(shadowLight);
        }
        function setupLights() {
            lights.setup(lightsArray);
        }
        function setupLightsView(camera) {
            lights.setupView(lightsArray, camera);
        }
        var state = {
            lightsArray: lightsArray,
            shadowsArray: shadowsArray,
            lights: lights
        };
        return {
            init: init,
            state: state,
            setupLights: setupLights,
            setupLightsView: setupLightsView,
            pushLight: pushLight,
            pushShadow: pushShadow
        };
    }
    function WebGLRenderStates(extensions, capabilities) {
        var renderStates = new WeakMap();
        function get(scene, renderCallDepth) {
            if (renderCallDepth === void 0) renderCallDepth = 0;
            var renderState;
            if (renderStates.has(scene) === false) {
                renderState = new WebGLRenderState(extensions, capabilities);
                renderStates.set(scene, []);
                renderStates.get(scene).push(renderState);
            } else if (renderCallDepth >= renderStates.get(scene).length) {
                renderState = new WebGLRenderState(extensions, capabilities);
                renderStates.get(scene).push(renderState);
            } else renderState = renderStates.get(scene)[renderCallDepth];
            return renderState;
        }
        function dispose() {
            renderStates = new WeakMap();
        }
        return {
            get: get,
            dispose: dispose
        };
    }
    /**
	 * parameters = {
	 *
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 * }
	 */ function MeshDepthMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshDepthMaterial';
        this.depthPacking = BasicDepthPacking;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.setValues(parameters);
    }
    MeshDepthMaterial.prototype = Object.create(Material.prototype);
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
    MeshDepthMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.depthPacking = source.depthPacking;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
    };
    /**
	 * parameters = {
	 *
	 *	referencePosition: <float>,
	 *	nearDistance: <float>,
	 *	farDistance: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>
	 *
	 * }
	 */ function MeshDistanceMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshDistanceMaterial';
        this.referencePosition = new Vector3();
        this.nearDistance = 1;
        this.farDistance = 1000;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.fog = false;
        this.setValues(parameters);
    }
    MeshDistanceMaterial.prototype = Object.create(Material.prototype);
    MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
    MeshDistanceMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.referencePosition.copy(source.referencePosition);
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
    };
    var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
    var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
    function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
        var _frustum = new Frustum();
        var _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {
        };
        var shadowSide = {
            0: BackSide,
            1: FrontSide,
            2: DoubleSide
        };
        var shadowMaterialVertical = new ShaderMaterial({
            defines: {
                SAMPLE_RATE: 0.25,
                HALF_SAMPLE_RATE: 0.125
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Vector2()
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: vsm_vert,
            fragmentShader: vsm_frag
        });
        var shadowMaterialHorizontal = shadowMaterialVertical.clone();
        shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
        var fullScreenTri = new BufferGeometry();
        fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([
            -1,
            -1,
            0.5,
            3,
            -1,
            0.5,
            -1,
            3,
            0.5
        ]), 3));
        var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
        var scope = this;
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = PCFShadowMap;
        this.render = function(lights, scene, camera) {
            if (scope.enabled === false) return;
            if (scope.autoUpdate === false && scope.needsUpdate === false) return;
            if (lights.length === 0) return;
            var currentRenderTarget = _renderer.getRenderTarget();
            var activeCubeFace = _renderer.getActiveCubeFace();
            var activeMipmapLevel = _renderer.getActiveMipmapLevel();
            var _state = _renderer.state; // Set GL state for depth map.
            _state.setBlending(NoBlending);
            _state.buffers.color.setClear(1, 1, 1, 1);
            _state.buffers.depth.setTest(true);
            _state.setScissorTest(false); // render depth map
            for(var i23 = 0, il = lights.length; i23 < il; i23++){
                var light = lights[i23];
                var shadow = light.shadow;
                if (shadow === undefined) {
                    console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                    continue;
                }
                if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
                _shadowMapSize.copy(shadow.mapSize);
                var shadowFrameExtents = shadow.getFrameExtents();
                _shadowMapSize.multiply(shadowFrameExtents);
                _viewportSize.copy(shadow.mapSize);
                if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
                    if (_shadowMapSize.x > maxTextureSize) {
                        _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
                        _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                        shadow.mapSize.x = _viewportSize.x;
                    }
                    if (_shadowMapSize.y > maxTextureSize) {
                        _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
                        _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                        shadow.mapSize.y = _viewportSize.y;
                    }
                }
                if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
                    var pars = {
                        minFilter: LinearFilter,
                        magFilter: LinearFilter,
                        format: RGBAFormat
                    };
                    shadow.map = new WebGLRenderTarget1(_shadowMapSize.x, _shadowMapSize.y, pars);
                    shadow.map.texture.name = light.name + '.shadowMap';
                    shadow.mapPass = new WebGLRenderTarget1(_shadowMapSize.x, _shadowMapSize.y, pars);
                    shadow.camera.updateProjectionMatrix();
                }
                if (shadow.map === null) {
                    var _pars = {
                        minFilter: NearestFilter,
                        magFilter: NearestFilter,
                        format: RGBAFormat
                    };
                    shadow.map = new WebGLRenderTarget1(_shadowMapSize.x, _shadowMapSize.y, _pars);
                    shadow.map.texture.name = light.name + '.shadowMap';
                    shadow.camera.updateProjectionMatrix();
                }
                _renderer.setRenderTarget(shadow.map);
                _renderer.clear();
                var viewportCount = shadow.getViewportCount();
                for(var vp = 0; vp < viewportCount; vp++){
                    var viewport = shadow.getViewport(vp);
                    _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                    _state.viewport(_viewport);
                    shadow.updateMatrices(light, vp);
                    _frustum = shadow.getFrustum();
                    renderObject(scene, camera, shadow.camera, light, this.type);
                } // do blur pass for VSM
                if (!shadow.isPointLightShadow && this.type === VSMShadowMap) VSMPass(shadow, camera);
                shadow.needsUpdate = false;
            }
            scope.needsUpdate = false;
            _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
        };
        function VSMPass(shadow, camera) {
            var geometry = _objects.update(fullScreenMesh); // vertical pass
            shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
            shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
            shadowMaterialVertical.uniforms.radius.value = shadow.radius;
            _renderer.setRenderTarget(shadow.mapPass);
            _renderer.clear();
            _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass
            shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
            shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
            shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
        }
        function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
            var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
            var material = _depthMaterials[index];
            if (material === undefined) {
                material = new MeshDepthMaterial({
                    depthPacking: RGBADepthPacking,
                    morphTargets: useMorphing,
                    skinning: useSkinning
                });
                _depthMaterials[index] = material;
            }
            return material;
        }
        function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
            var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
            var material = _distanceMaterials[index];
            if (material === undefined) {
                material = new MeshDistanceMaterial({
                    morphTargets: useMorphing,
                    skinning: useSkinning
                });
                _distanceMaterials[index] = material;
            }
            return material;
        }
        function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
            var result = null;
            var getMaterialVariant = getDepthMaterialVariant;
            var customMaterial = object.customDepthMaterial;
            if (light.isPointLight === true) {
                getMaterialVariant = getDistanceMaterialVariant;
                customMaterial = object.customDistanceMaterial;
            }
            if (customMaterial === undefined) {
                var useMorphing = false;
                if (material.morphTargets === true) useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                var useSkinning = false;
                if (object.isSkinnedMesh === true) {
                    if (material.skinning === true) useSkinning = true;
                    else console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
                }
                var useInstancing = object.isInstancedMesh === true;
                result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
            } else result = customMaterial;
            if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
                // in this case we need a unique material instance reflecting the
                // appropriate state
                var keyA = result.uuid, keyB = material.uuid;
                var materialsForVariant = _materialCache[keyA];
                if (materialsForVariant === undefined) {
                    materialsForVariant = {
                    };
                    _materialCache[keyA] = materialsForVariant;
                }
                var cachedMaterial = materialsForVariant[keyB];
                if (cachedMaterial === undefined) {
                    cachedMaterial = result.clone();
                    materialsForVariant[keyB] = cachedMaterial;
                }
                result = cachedMaterial;
            }
            result.visible = material.visible;
            result.wireframe = material.wireframe;
            if (type === VSMShadowMap) result.side = material.shadowSide !== null ? material.shadowSide : material.side;
            else result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
            result.clipShadows = material.clipShadows;
            result.clippingPlanes = material.clippingPlanes;
            result.clipIntersection = material.clipIntersection;
            result.wireframeLinewidth = material.wireframeLinewidth;
            result.linewidth = material.linewidth;
            if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
                result.referencePosition.setFromMatrixPosition(light.matrixWorld);
                result.nearDistance = shadowCameraNear;
                result.farDistance = shadowCameraFar;
            }
            return result;
        }
        function renderObject(object, camera, shadowCamera, light, type) {
            if (object.visible === false) return;
            var visible = object.layers.test(camera.layers);
            if (visible && (object.isMesh || object.isLine || object.isPoints)) {
                if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    var geometry = _objects.update(object);
                    var material = object.material;
                    if (Array.isArray(material)) {
                        var groups = geometry.groups;
                        for(var k = 0, kl = groups.length; k < kl; k++){
                            var group = groups[k];
                            var groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) {
                                var depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                            }
                        }
                    } else if (material.visible) {
                        var _depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
                        _renderer.renderBufferDirect(shadowCamera, null, geometry, _depthMaterial, object, null);
                    }
                }
            }
            var children = object.children;
            for(var i23 = 0, l = children.length; i23 < l; i23++)renderObject(children[i23], camera, shadowCamera, light, type);
        }
    }
    function WebGLState(gl, extensions, capabilities) {
        var _equationToGL, _factorToGL;
        var isWebGL2 = capabilities.isWebGL2;
        function ColorBuffer() {
            var locked = false;
            var color = new Vector4();
            var currentColorMask = null;
            var currentColorClear = new Vector4(0, 0, 0, 0);
            return {
                setMask: function setMask(colorMask) {
                    if (currentColorMask !== colorMask && !locked) {
                        gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                        currentColorMask = colorMask;
                    }
                },
                setLocked: function setLocked(lock) {
                    locked = lock;
                },
                setClear: function setClear(r, g, b, a, premultipliedAlpha) {
                    if (premultipliedAlpha === true) {
                        r *= a;
                        g *= a;
                        b *= a;
                    }
                    color.set(r, g, b, a);
                    if (currentColorClear.equals(color) === false) {
                        gl.clearColor(r, g, b, a);
                        currentColorClear.copy(color);
                    }
                },
                reset: function reset() {
                    locked = false;
                    currentColorMask = null;
                    currentColorClear.set(-1, 0, 0, 0); // set to invalid state
                }
            };
        }
        function DepthBuffer() {
            var locked = false;
            var currentDepthMask = null;
            var currentDepthFunc = null;
            var currentDepthClear = null;
            return {
                setTest: function setTest(depthTest) {
                    if (depthTest) enable(2929);
                    else disable(2929);
                },
                setMask: function setMask(depthMask) {
                    if (currentDepthMask !== depthMask && !locked) {
                        gl.depthMask(depthMask);
                        currentDepthMask = depthMask;
                    }
                },
                setFunc: function setFunc(depthFunc) {
                    if (currentDepthFunc !== depthFunc) {
                        if (depthFunc) switch(depthFunc){
                            case NeverDepth:
                                gl.depthFunc(512);
                                break;
                            case AlwaysDepth:
                                gl.depthFunc(519);
                                break;
                            case LessDepth:
                                gl.depthFunc(513);
                                break;
                            case LessEqualDepth:
                                gl.depthFunc(515);
                                break;
                            case EqualDepth:
                                gl.depthFunc(514);
                                break;
                            case GreaterEqualDepth:
                                gl.depthFunc(518);
                                break;
                            case GreaterDepth:
                                gl.depthFunc(516);
                                break;
                            case NotEqualDepth:
                                gl.depthFunc(517);
                                break;
                            default:
                                gl.depthFunc(515);
                        }
                        else gl.depthFunc(515);
                        currentDepthFunc = depthFunc;
                    }
                },
                setLocked: function setLocked(lock) {
                    locked = lock;
                },
                setClear: function setClear(depth) {
                    if (currentDepthClear !== depth) {
                        gl.clearDepth(depth);
                        currentDepthClear = depth;
                    }
                },
                reset: function reset() {
                    locked = false;
                    currentDepthMask = null;
                    currentDepthFunc = null;
                    currentDepthClear = null;
                }
            };
        }
        function StencilBuffer() {
            var locked = false;
            var currentStencilMask = null;
            var currentStencilFunc = null;
            var currentStencilRef = null;
            var currentStencilFuncMask = null;
            var currentStencilFail = null;
            var currentStencilZFail = null;
            var currentStencilZPass = null;
            var currentStencilClear = null;
            return {
                setTest: function setTest(stencilTest) {
                    if (!locked) {
                        if (stencilTest) enable(2960);
                        else disable(2960);
                    }
                },
                setMask: function setMask(stencilMask) {
                    if (currentStencilMask !== stencilMask && !locked) {
                        gl.stencilMask(stencilMask);
                        currentStencilMask = stencilMask;
                    }
                },
                setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {
                    if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                        gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                        currentStencilFunc = stencilFunc;
                        currentStencilRef = stencilRef;
                        currentStencilFuncMask = stencilMask;
                    }
                },
                setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {
                    if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                        gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                        currentStencilFail = stencilFail;
                        currentStencilZFail = stencilZFail;
                        currentStencilZPass = stencilZPass;
                    }
                },
                setLocked: function setLocked(lock) {
                    locked = lock;
                },
                setClear: function setClear(stencil) {
                    if (currentStencilClear !== stencil) {
                        gl.clearStencil(stencil);
                        currentStencilClear = stencil;
                    }
                },
                reset: function reset() {
                    locked = false;
                    currentStencilMask = null;
                    currentStencilFunc = null;
                    currentStencilRef = null;
                    currentStencilFuncMask = null;
                    currentStencilFail = null;
                    currentStencilZFail = null;
                    currentStencilZPass = null;
                    currentStencilClear = null;
                }
            };
        } //
        var colorBuffer = new ColorBuffer();
        var depthBuffer = new DepthBuffer();
        var stencilBuffer = new StencilBuffer();
        var enabledCapabilities = {
        };
        var currentProgram = null;
        var currentBlendingEnabled = null;
        var currentBlending = null;
        var currentBlendEquation = null;
        var currentBlendSrc = null;
        var currentBlendDst = null;
        var currentBlendEquationAlpha = null;
        var currentBlendSrcAlpha = null;
        var currentBlendDstAlpha = null;
        var currentPremultipledAlpha = false;
        var currentFlipSided = null;
        var currentCullFace = null;
        var currentLineWidth = null;
        var currentPolygonOffsetFactor = null;
        var currentPolygonOffsetUnits = null;
        var maxTextures = gl.getParameter(35661);
        var lineWidthAvailable = false;
        var version = 0;
        var glVersion = gl.getParameter(7938);
        if (glVersion.indexOf('WebGL') !== -1) {
            version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
            lineWidthAvailable = version >= 1;
        } else if (glVersion.indexOf('OpenGL ES') !== -1) {
            version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
            lineWidthAvailable = version >= 2;
        }
        var currentTextureSlot = null;
        var currentBoundTextures = {
        };
        var currentScissor = new Vector4();
        var currentViewport = new Vector4();
        function createTexture(type, target, count) {
            var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
            var texture = gl.createTexture();
            gl.bindTexture(type, texture);
            gl.texParameteri(type, 10241, 9728);
            gl.texParameteri(type, 10240, 9728);
            for(var i23 = 0; i23 < count; i23++)gl.texImage2D(target + i23, 0, 6408, 1, 1, 0, 6408, 5121, data);
            return texture;
        }
        var emptyTextures = {
        };
        emptyTextures[3553] = createTexture(3553, 3553, 1);
        emptyTextures[34067] = createTexture(34067, 34069, 6); // init
        colorBuffer.setClear(0, 0, 0, 1);
        depthBuffer.setClear(1);
        stencilBuffer.setClear(0);
        enable(2929);
        depthBuffer.setFunc(LessEqualDepth);
        setFlipSided(false);
        setCullFace(CullFaceBack);
        enable(2884);
        setBlending(NoBlending); //
        function enable(id) {
            if (enabledCapabilities[id] !== true) {
                gl.enable(id);
                enabledCapabilities[id] = true;
            }
        }
        function disable(id) {
            if (enabledCapabilities[id] !== false) {
                gl.disable(id);
                enabledCapabilities[id] = false;
            }
        }
        function useProgram(program) {
            if (currentProgram !== program) {
                gl.useProgram(program);
                currentProgram = program;
                return true;
            }
            return false;
        }
        var equationToGL = (_equationToGL = {
        }, _equationToGL[AddEquation] = 32774, _equationToGL[SubtractEquation] = 32778, _equationToGL[ReverseSubtractEquation] = 32779, _equationToGL);
        if (isWebGL2) {
            equationToGL[MinEquation] = 32775;
            equationToGL[MaxEquation] = 32776;
        } else {
            var extension = extensions.get('EXT_blend_minmax');
            if (extension !== null) {
                equationToGL[MinEquation] = extension.MIN_EXT;
                equationToGL[MaxEquation] = extension.MAX_EXT;
            }
        }
        var factorToGL = (_factorToGL = {
        }, _factorToGL[ZeroFactor] = 0, _factorToGL[OneFactor] = 1, _factorToGL[SrcColorFactor] = 768, _factorToGL[SrcAlphaFactor] = 770, _factorToGL[SrcAlphaSaturateFactor] = 776, _factorToGL[DstColorFactor] = 774, _factorToGL[DstAlphaFactor] = 772, _factorToGL[OneMinusSrcColorFactor] = 769, _factorToGL[OneMinusSrcAlphaFactor] = 771, _factorToGL[OneMinusDstColorFactor] = 775, _factorToGL[OneMinusDstAlphaFactor] = 773, _factorToGL);
        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
            if (blending === NoBlending) {
                if (currentBlendingEnabled) {
                    disable(3042);
                    currentBlendingEnabled = false;
                }
                return;
            }
            if (!currentBlendingEnabled) {
                enable(3042);
                currentBlendingEnabled = true;
            }
            if (blending !== CustomBlending) {
                if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                    if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                        gl.blendEquation(32774);
                        currentBlendEquation = AddEquation;
                        currentBlendEquationAlpha = AddEquation;
                    }
                    if (premultipliedAlpha) switch(blending){
                        case NormalBlending:
                            gl.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case AdditiveBlending:
                            gl.blendFunc(1, 1);
                            break;
                        case SubtractiveBlending:
                            gl.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case MultiplyBlending:
                            gl.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error('THREE.WebGLState: Invalid blending: ', blending);
                            break;
                    }
                    else switch(blending){
                        case NormalBlending:
                            gl.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case AdditiveBlending:
                            gl.blendFunc(770, 1);
                            break;
                        case SubtractiveBlending:
                            gl.blendFunc(0, 769);
                            break;
                        case MultiplyBlending:
                            gl.blendFunc(0, 768);
                            break;
                        default:
                            console.error('THREE.WebGLState: Invalid blending: ', blending);
                            break;
                    }
                    currentBlendSrc = null;
                    currentBlendDst = null;
                    currentBlendSrcAlpha = null;
                    currentBlendDstAlpha = null;
                    currentBlending = blending;
                    currentPremultipledAlpha = premultipliedAlpha;
                }
                return;
            } // custom blending
            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;
            if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
                currentBlendEquation = blendEquation;
                currentBlendEquationAlpha = blendEquationAlpha;
            }
            if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
                currentBlendSrc = blendSrc;
                currentBlendDst = blendDst;
                currentBlendSrcAlpha = blendSrcAlpha;
                currentBlendDstAlpha = blendDstAlpha;
            }
            currentBlending = blending;
            currentPremultipledAlpha = null;
        }
        function setMaterial(material, frontFaceCW) {
            material.side === DoubleSide ? disable(2884) : enable(2884);
            var flipSided = material.side === BackSide;
            if (frontFaceCW) flipSided = !flipSided;
            setFlipSided(flipSided);
            material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
            depthBuffer.setFunc(material.depthFunc);
            depthBuffer.setTest(material.depthTest);
            depthBuffer.setMask(material.depthWrite);
            colorBuffer.setMask(material.colorWrite);
            var stencilWrite = material.stencilWrite;
            stencilBuffer.setTest(stencilWrite);
            if (stencilWrite) {
                stencilBuffer.setMask(material.stencilWriteMask);
                stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
                stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
            }
            setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        } //
        function setFlipSided(flipSided) {
            if (currentFlipSided !== flipSided) {
                if (flipSided) gl.frontFace(2304);
                else gl.frontFace(2305);
                currentFlipSided = flipSided;
            }
        }
        function setCullFace(cullFace) {
            if (cullFace !== CullFaceNone) {
                enable(2884);
                if (cullFace !== currentCullFace) {
                    if (cullFace === CullFaceBack) gl.cullFace(1029);
                    else if (cullFace === CullFaceFront) gl.cullFace(1028);
                    else gl.cullFace(1032);
                }
            } else disable(2884);
            currentCullFace = cullFace;
        }
        function setLineWidth(width) {
            if (width !== currentLineWidth) {
                if (lineWidthAvailable) gl.lineWidth(width);
                currentLineWidth = width;
            }
        }
        function setPolygonOffset(polygonOffset, factor, units) {
            if (polygonOffset) {
                enable(32823);
                if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                    gl.polygonOffset(factor, units);
                    currentPolygonOffsetFactor = factor;
                    currentPolygonOffsetUnits = units;
                }
            } else disable(32823);
        }
        function setScissorTest(scissorTest) {
            if (scissorTest) enable(3089);
            else disable(3089);
        } // texture
        function activeTexture(webglSlot) {
            if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;
            if (currentTextureSlot !== webglSlot) {
                gl.activeTexture(webglSlot);
                currentTextureSlot = webglSlot;
            }
        }
        function bindTexture(webglType, webglTexture) {
            if (currentTextureSlot === null) activeTexture();
            var boundTexture = currentBoundTextures[currentTextureSlot];
            if (boundTexture === undefined) {
                boundTexture = {
                    type: undefined,
                    texture: undefined
                };
                currentBoundTextures[currentTextureSlot] = boundTexture;
            }
            if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
            }
        }
        function unbindTexture() {
            var boundTexture = currentBoundTextures[currentTextureSlot];
            if (boundTexture !== undefined && boundTexture.type !== undefined) {
                gl.bindTexture(boundTexture.type, null);
                boundTexture.type = undefined;
                boundTexture.texture = undefined;
            }
        }
        function compressedTexImage2D() {
            try {
                gl.compressedTexImage2D.apply(gl, arguments);
            } catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        }
        function texImage2D() {
            try {
                gl.texImage2D.apply(gl, arguments);
            } catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        }
        function texImage3D() {
            try {
                gl.texImage3D.apply(gl, arguments);
            } catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        } //
        function scissor(scissor1) {
            if (currentScissor.equals(scissor1) === false) {
                gl.scissor(scissor1.x, scissor1.y, scissor1.z, scissor1.w);
                currentScissor.copy(scissor1);
            }
        }
        function viewport(viewport1) {
            if (currentViewport.equals(viewport1) === false) {
                gl.viewport(viewport1.x, viewport1.y, viewport1.z, viewport1.w);
                currentViewport.copy(viewport1);
            }
        } //
        function reset() {
            enabledCapabilities = {
            };
            currentTextureSlot = null;
            currentBoundTextures = {
            };
            currentProgram = null;
            currentBlendingEnabled = null;
            currentBlending = null;
            currentBlendEquation = null;
            currentBlendSrc = null;
            currentBlendDst = null;
            currentBlendEquationAlpha = null;
            currentBlendSrcAlpha = null;
            currentBlendDstAlpha = null;
            currentPremultipledAlpha = false;
            currentFlipSided = null;
            currentCullFace = null;
            currentLineWidth = null;
            currentPolygonOffsetFactor = null;
            currentPolygonOffsetUnits = null;
            colorBuffer.reset();
            depthBuffer.reset();
            stencilBuffer.reset();
        }
        return {
            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },
            enable: enable,
            disable: disable,
            useProgram: useProgram,
            setBlending: setBlending,
            setMaterial: setMaterial,
            setFlipSided: setFlipSided,
            setCullFace: setCullFace,
            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,
            setScissorTest: setScissorTest,
            activeTexture: activeTexture,
            bindTexture: bindTexture,
            unbindTexture: unbindTexture,
            compressedTexImage2D: compressedTexImage2D,
            texImage2D: texImage2D,
            texImage3D: texImage3D,
            scissor: scissor,
            viewport: viewport,
            reset: reset
        };
    }
    function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
        var _wrappingToGL, _filterToGL;
        var isWebGL2 = capabilities.isWebGL2;
        var maxTextures = capabilities.maxTextures;
        var maxCubemapSize = capabilities.maxCubemapSize;
        var maxTextureSize = capabilities.maxTextureSize;
        var maxSamples = capabilities.maxSamples;
        var _videoTextures = new WeakMap();
        var _canvas1; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
        // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
        // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
        var useOffscreenCanvas = false;
        try {
            useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
        } catch (err) {
        }
        function createCanvas(width, height) {
            // Use OffscreenCanvas when available. Specially needed in web workers
            return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        }
        function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
            var scale = 1; // handle case if texture exceeds max size
            if (image.width > maxSize || image.height > maxSize) scale = maxSize / Math.max(image.width, image.height);
             // only perform resize if necessary
            if (scale < 1 || needsPowerOfTwo === true) {
                // only perform resize for certain image types
                if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
                    var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
                    var width = floor(scale * image.width);
                    var height = floor(scale * image.height);
                    if (_canvas1 === undefined) _canvas1 = createCanvas(width, height); // cube textures can't reuse the same canvas
                    var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas1;
                    canvas.width = width;
                    canvas.height = height;
                    var context = canvas.getContext('2d');
                    context.drawImage(image, 0, 0, width, height);
                    console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
                    return canvas;
                } else {
                    if ('data' in image) console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
                    return image;
                }
            }
            return image;
        }
        function isPowerOfTwo(image) {
            return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
        }
        function textureNeedsPowerOfTwo(texture) {
            if (isWebGL2) return false;
            return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function textureNeedsGenerateMipmaps(texture, supportsMips) {
            return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function generateMipmap(target, texture, width, height) {
            _gl.generateMipmap(target);
            var textureProperties = properties.get(texture); // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
            textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
        }
        function getInternalFormat(internalFormatName, glFormat, glType) {
            if (isWebGL2 === false) return glFormat;
            if (internalFormatName !== null) {
                if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
                console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
            }
            var internalFormat = glFormat;
            if (glFormat === 6403) {
                if (glType === 5126) internalFormat = 33326;
                if (glType === 5131) internalFormat = 33325;
                if (glType === 5121) internalFormat = 33321;
            }
            if (glFormat === 6407) {
                if (glType === 5126) internalFormat = 34837;
                if (glType === 5131) internalFormat = 34843;
                if (glType === 5121) internalFormat = 32849;
            }
            if (glFormat === 6408) {
                if (glType === 5126) internalFormat = 34836;
                if (glType === 5131) internalFormat = 34842;
                if (glType === 5121) internalFormat = 32856;
            }
            if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) extensions.get('EXT_color_buffer_float');
            return internalFormat;
        } // Fallback filters for non-power-of-2 textures
        function filterFallback(f) {
            if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) return 9728;
            return 9729;
        } //
        function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener('dispose', onTextureDispose);
            deallocateTexture(texture);
            if (texture.isVideoTexture) _videoTextures.delete(texture);
            info.memory.textures--;
        }
        function onRenderTargetDispose(event) {
            var renderTarget = event.target;
            renderTarget.removeEventListener('dispose', onRenderTargetDispose);
            deallocateRenderTarget(renderTarget);
            info.memory.textures--;
        } //
        function deallocateTexture(texture) {
            var textureProperties = properties.get(texture);
            if (textureProperties.__webglInit === undefined) return;
            _gl.deleteTexture(textureProperties.__webglTexture);
            properties.remove(texture);
        }
        function deallocateRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            if (!renderTarget) return;
            if (textureProperties.__webglTexture !== undefined) _gl.deleteTexture(textureProperties.__webglTexture);
            if (renderTarget.depthTexture) renderTarget.depthTexture.dispose();
            if (renderTarget.isWebGLCubeRenderTarget) for(var i23 = 0; i23 < 6; i23++){
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i23]);
                if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i23]);
            }
            else {
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
                if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
                if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
                if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
            }
            properties.remove(renderTarget.texture);
            properties.remove(renderTarget);
        } //
        var textureUnits = 0;
        function resetTextureUnits() {
            textureUnits = 0;
        }
        function allocateTextureUnit() {
            var textureUnit = textureUnits;
            if (textureUnit >= maxTextures) console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
            textureUnits += 1;
            return textureUnit;
        } //
        function setTexture2D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.isVideoTexture) updateVideoTexture(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                var image = texture.image;
                if (image === undefined) console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
                else if (image.complete === false) console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
                else {
                    uploadTexture(textureProperties, texture, slot);
                    return;
                }
            }
            state.activeTexture(33984 + slot);
            state.bindTexture(3553, textureProperties.__webglTexture);
        }
        function setTexture2DArray(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
            state.activeTexture(33984 + slot);
            state.bindTexture(35866, textureProperties.__webglTexture);
        }
        function setTexture3D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
            state.activeTexture(33984 + slot);
            state.bindTexture(32879, textureProperties.__webglTexture);
        }
        function setTextureCube(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                uploadCubeTexture(textureProperties, texture, slot);
                return;
            }
            state.activeTexture(33984 + slot);
            state.bindTexture(34067, textureProperties.__webglTexture);
        }
        var wrappingToGL = (_wrappingToGL = {
        }, _wrappingToGL[RepeatWrapping] = 10497, _wrappingToGL[ClampToEdgeWrapping] = 33071, _wrappingToGL[MirroredRepeatWrapping] = 33648, _wrappingToGL);
        var filterToGL = (_filterToGL = {
        }, _filterToGL[NearestFilter] = 9728, _filterToGL[NearestMipmapNearestFilter] = 9984, _filterToGL[NearestMipmapLinearFilter] = 9986, _filterToGL[LinearFilter] = 9729, _filterToGL[LinearMipmapNearestFilter] = 9985, _filterToGL[LinearMipmapLinearFilter] = 9987, _filterToGL);
        function setTextureParameters(textureType, texture, supportsMips) {
            if (supportsMips) {
                _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
                _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
                if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
                _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
                _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
            } else {
                _gl.texParameteri(textureType, 10242, 33071);
                _gl.texParameteri(textureType, 10243, 33071);
                if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, 33071);
                if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
                _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
                _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
                if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
            }
            var extension = extensions.get('EXT_texture_filter_anisotropic');
            if (extension) {
                if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
                if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;
                if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                    _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                    properties.get(texture).__currentAnisotropy = texture.anisotropy;
                }
            }
        }
        function initTexture(textureProperties, texture) {
            if (textureProperties.__webglInit === undefined) {
                textureProperties.__webglInit = true;
                texture.addEventListener('dispose', onTextureDispose);
                textureProperties.__webglTexture = _gl.createTexture();
                info.memory.textures++;
            }
        }
        function uploadTexture(textureProperties, texture, slot) {
            var textureType = 3553;
            if (texture.isDataTexture2DArray) textureType = 35866;
            if (texture.isDataTexture3D) textureType = 32879;
            initTexture(textureProperties, texture);
            state.activeTexture(33984 + slot);
            state.bindTexture(textureType, textureProperties.__webglTexture);
            _gl.pixelStorei(37440, texture.flipY);
            _gl.pixelStorei(37441, texture.premultiplyAlpha);
            _gl.pixelStorei(3317, texture.unpackAlignment);
            var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
            var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
            var supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
            var glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
            setTextureParameters(textureType, texture, supportsMips);
            var mipmap;
            var mipmaps = texture.mipmaps;
            if (texture.isDepthTexture) {
                // populate depth texture with dummy data
                glInternalFormat = 6402;
                if (isWebGL2) {
                    if (texture.type === FloatType) glInternalFormat = 36012;
                    else if (texture.type === UnsignedIntType) glInternalFormat = 33190;
                    else if (texture.type === UnsignedInt248Type) glInternalFormat = 35056;
                    else glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
                } else if (texture.type === FloatType) console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
                 // validation checks for WebGL 1
                if (texture.format === DepthFormat && glInternalFormat === 6402) // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                {
                    if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                        console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                        texture.type = UnsignedShortType;
                        glType = utils.convert(texture.type);
                    }
                }
                if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
                    // Depth stencil textures need the DEPTH_STENCIL internal format
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                    // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    if (texture.type !== UnsignedInt248Type) {
                        console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                        texture.type = UnsignedInt248Type;
                        glType = utils.convert(texture.type);
                    }
                } //
                state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
            } else if (texture.isDataTexture) {
                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels
                if (mipmaps.length > 0 && supportsMips) {
                    for(var i23 = 0, il = mipmaps.length; i23 < il; i23++){
                        mipmap = mipmaps[i23];
                        state.texImage2D(3553, i23, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                    texture.generateMipmaps = false;
                    textureProperties.__maxMipLevel = mipmaps.length - 1;
                } else {
                    state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                    textureProperties.__maxMipLevel = 0;
                }
            } else if (texture.isCompressedTexture) {
                for(var _i = 0, _il = mipmaps.length; _i < _il; _i++){
                    mipmap = mipmaps[_i];
                    if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                        if (glFormat !== null) state.compressedTexImage2D(3553, _i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                    } else state.texImage2D(3553, _i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else if (texture.isDataTexture2DArray) {
                state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                textureProperties.__maxMipLevel = 0;
            } else if (texture.isDataTexture3D) {
                state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                textureProperties.__maxMipLevel = 0;
            } else // regular Texture (image, video, canvas)
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps.length > 0 && supportsMips) {
                for(var _i2 = 0, _il2 = mipmaps.length; _i2 < _il2; _i2++){
                    mipmap = mipmaps[_i2];
                    state.texImage2D(3553, _i2, glInternalFormat, glFormat, glType, mipmap);
                }
                texture.generateMipmaps = false;
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
                textureProperties.__maxMipLevel = 0;
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(textureType, texture, image.width, image.height);
            textureProperties.__version = texture.version;
            if (texture.onUpdate) texture.onUpdate(texture);
        }
        function uploadCubeTexture(textureProperties, texture, slot) {
            if (texture.image.length !== 6) return;
            initTexture(textureProperties, texture);
            state.activeTexture(33984 + slot);
            state.bindTexture(34067, textureProperties.__webglTexture);
            _gl.pixelStorei(37440, texture.flipY);
            _gl.pixelStorei(37441, texture.premultiplyAlpha);
            _gl.pixelStorei(3317, texture.unpackAlignment);
            var isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
            var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
            var cubeImage = [];
            for(var i24 = 0; i24 < 6; i24++)if (!isCompressed && !isDataTexture) cubeImage[i24] = resizeImage(texture.image[i24], false, true, maxCubemapSize);
            else cubeImage[i24] = isDataTexture ? texture.image[i24].image : texture.image[i24];
            var image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
            setTextureParameters(34067, texture, supportsMips);
            var mipmaps;
            if (isCompressed) {
                for(var _i3 = 0; _i3 < 6; _i3++){
                    mipmaps = cubeImage[_i3].mipmaps;
                    for(var j = 0; j < mipmaps.length; j++){
                        var mipmap = mipmaps[j];
                        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                            if (glFormat !== null) state.compressedTexImage2D(34069 + _i3, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                            else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                        } else state.texImage2D(34069 + _i3, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                mipmaps = texture.mipmaps;
                for(var _i4 = 0; _i4 < 6; _i4++)if (isDataTexture) {
                    state.texImage2D(34069 + _i4, 0, glInternalFormat, cubeImage[_i4].width, cubeImage[_i4].height, 0, glFormat, glType, cubeImage[_i4].data);
                    for(var _j = 0; _j < mipmaps.length; _j++){
                        var _mipmap = mipmaps[_j];
                        var mipmapImage = _mipmap.image[_i4].image;
                        state.texImage2D(34069 + _i4, _j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                    }
                } else {
                    state.texImage2D(34069 + _i4, 0, glInternalFormat, glFormat, glType, cubeImage[_i4]);
                    for(var _j2 = 0; _j2 < mipmaps.length; _j2++){
                        var _mipmap2 = mipmaps[_j2];
                        state.texImage2D(34069 + _i4, _j2 + 1, glInternalFormat, glFormat, glType, _mipmap2.image[_i4]);
                    }
                }
                textureProperties.__maxMipLevel = mipmaps.length;
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) // We assume images for cube map have the same size.
            generateMipmap(34067, texture, image.width, image.height);
            textureProperties.__version = texture.version;
            if (texture.onUpdate) texture.onUpdate(texture);
        } // Render targets
        // Setup storage for target texture and bind it to correct framebuffer
        function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
            var glFormat = utils.convert(renderTarget.texture.format);
            var glType = utils.convert(renderTarget.texture.type);
            var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
            state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            _gl.bindFramebuffer(36160, framebuffer);
            _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
            _gl.bindFramebuffer(36160, null);
        } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
        function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
            _gl.bindRenderbuffer(36161, renderbuffer);
            if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                var glInternalFormat = 33189;
                if (isMultisample) {
                    var depthTexture = renderTarget.depthTexture;
                    if (depthTexture && depthTexture.isDepthTexture) {
                        if (depthTexture.type === FloatType) glInternalFormat = 36012;
                        else if (depthTexture.type === UnsignedIntType) glInternalFormat = 33190;
                    }
                    var samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                } else _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
            } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                if (isMultisample) {
                    var _samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(36161, _samples, 35056, renderTarget.width, renderTarget.height);
                } else _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
            } else {
                var glFormat = utils.convert(renderTarget.texture.format);
                var glType = utils.convert(renderTarget.texture.type);
                var _glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                if (isMultisample) {
                    var _samples2 = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(36161, _samples2, _glInternalFormat, renderTarget.width, renderTarget.height);
                } else _gl.renderbufferStorage(36161, _glInternalFormat, renderTarget.width, renderTarget.height);
            }
            _gl.bindRenderbuffer(36161, null);
        } // Setup resources for a Depth Texture for a FBO (needs an extension)
        function setupDepthTexture(framebuffer, renderTarget) {
            var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
            if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
            _gl.bindFramebuffer(36160, framebuffer);
            if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
             // upload an empty depth texture with framebuffer size
            if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
                renderTarget.depthTexture.image.width = renderTarget.width;
                renderTarget.depthTexture.image.height = renderTarget.height;
                renderTarget.depthTexture.needsUpdate = true;
            }
            setTexture2D(renderTarget.depthTexture, 0);
            var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
            if (renderTarget.depthTexture.format === DepthFormat) _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
            else if (renderTarget.depthTexture.format === DepthStencilFormat) _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
            else throw new Error('Unknown depthTexture format');
        } // Setup GL resources for a non-texture depth buffer
        function setupDepthRenderbuffer(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var isCube = renderTarget.isWebGLCubeRenderTarget === true;
            if (renderTarget.depthTexture) {
                if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            } else if (isCube) {
                renderTargetProperties.__webglDepthbuffer = [];
                for(var i24 = 0; i24 < 6; i24++){
                    _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i24]);
                    renderTargetProperties.__webglDepthbuffer[i24] = _gl.createRenderbuffer();
                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i24], renderTarget, false);
                }
            } else {
                _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
                renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
            }
            _gl.bindFramebuffer(36160, null);
        } // Set up GL resources for the render target
        function setupRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            renderTarget.addEventListener('dispose', onRenderTargetDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
            var isCube = renderTarget.isWebGLCubeRenderTarget === true;
            var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
            var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858
            if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {
                renderTarget.texture.format = RGBAFormat;
                console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
            } // Setup framebuffer
            if (isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for(var i25 = 0; i25 < 6; i25++)renderTargetProperties.__webglFramebuffer[i25] = _gl.createFramebuffer();
            } else {
                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
                if (isMultisample) {
                    if (isWebGL2) {
                        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                        renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                        _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
                        var glFormat = utils.convert(renderTarget.texture.format);
                        var glType = utils.convert(renderTarget.texture.type);
                        var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                        var samples = getRenderTargetSamples(renderTarget);
                        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                        _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
                        _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
                        _gl.bindRenderbuffer(36161, null);
                        if (renderTarget.depthBuffer) {
                            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                        }
                        _gl.bindFramebuffer(36160, null);
                    } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
                }
            } // Setup color buffer
            if (isCube) {
                state.bindTexture(34067, textureProperties.__webglTexture);
                setTextureParameters(34067, renderTarget.texture, supportsMips);
                for(var _i5 = 0; _i5 < 6; _i5++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i5], renderTarget, 36064, 34069 + _i5);
                if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
                state.bindTexture(34067, null);
            } else {
                state.bindTexture(3553, textureProperties.__webglTexture);
                setTextureParameters(3553, renderTarget.texture, supportsMips);
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);
                if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
                state.bindTexture(3553, null);
            } // Setup depth and stencil buffers
            if (renderTarget.depthBuffer) setupDepthRenderbuffer(renderTarget);
        }
        function updateRenderTargetMipmap(renderTarget) {
            var texture = renderTarget.texture;
            var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
                var webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture);
                generateMipmap(target, texture, renderTarget.width, renderTarget.height);
                state.bindTexture(target, null);
            }
        }
        function updateMultisampleRenderTarget(renderTarget) {
            if (renderTarget.isWebGLMultisampleRenderTarget) {
                if (isWebGL2) {
                    var renderTargetProperties = properties.get(renderTarget);
                    _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
                    _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
                    var width = renderTarget.width;
                    var height = renderTarget.height;
                    var mask = 16384;
                    if (renderTarget.depthBuffer) mask |= 256;
                    if (renderTarget.stencilBuffer) mask |= 1024;
                    _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
                    _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer); // see #18905
                } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
            }
        }
        function getRenderTargetSamples(renderTarget) {
            return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
        }
        function updateVideoTexture(texture) {
            var frame = info.render.frame; // Check the last frame we updated the VideoTexture
            if (_videoTextures.get(texture) !== frame) {
                _videoTextures.set(texture, frame);
                texture.update();
            }
        } // backwards compatibility
        var warnedTexture2D = false;
        var warnedTextureCube = false;
        function safeSetTexture2D(texture, slot) {
            if (texture && texture.isWebGLRenderTarget) {
                if (warnedTexture2D === false) {
                    console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
                    warnedTexture2D = true;
                }
                texture = texture.texture;
            }
            setTexture2D(texture, slot);
        }
        function safeSetTextureCube(texture, slot) {
            if (texture && texture.isWebGLCubeRenderTarget) {
                if (warnedTextureCube === false) {
                    console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
                    warnedTextureCube = true;
                }
                texture = texture.texture;
            }
            setTextureCube(texture, slot);
        } //
        this.allocateTextureUnit = allocateTextureUnit;
        this.resetTextureUnits = resetTextureUnits;
        this.setTexture2D = setTexture2D;
        this.setTexture2DArray = setTexture2DArray;
        this.setTexture3D = setTexture3D;
        this.setTextureCube = setTextureCube;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
        this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
        this.safeSetTexture2D = safeSetTexture2D;
        this.safeSetTextureCube = safeSetTextureCube;
    }
    function WebGLUtils(gl, extensions, capabilities) {
        var isWebGL2 = capabilities.isWebGL2;
        function convert(p) {
            var extension;
            if (p === UnsignedByteType) return 5121;
            if (p === UnsignedShort4444Type) return 32819;
            if (p === UnsignedShort5551Type) return 32820;
            if (p === UnsignedShort565Type) return 33635;
            if (p === ByteType) return 5120;
            if (p === ShortType) return 5122;
            if (p === UnsignedShortType) return 5123;
            if (p === IntType) return 5124;
            if (p === UnsignedIntType) return 5125;
            if (p === FloatType) return 5126;
            if (p === HalfFloatType) {
                if (isWebGL2) return 5131;
                extension = extensions.get('OES_texture_half_float');
                if (extension !== null) return extension.HALF_FLOAT_OES;
                else return null;
            }
            if (p === AlphaFormat) return 6406;
            if (p === RGBFormat) return 6407;
            if (p === RGBAFormat) return 6408;
            if (p === LuminanceFormat) return 6409;
            if (p === LuminanceAlphaFormat) return 6410;
            if (p === DepthFormat) return 6402;
            if (p === DepthStencilFormat) return 34041;
            if (p === RedFormat) return 6403; // WebGL2 formats.
            if (p === RedIntegerFormat) return 36244;
            if (p === RGFormat) return 33319;
            if (p === RGIntegerFormat) return 33320;
            if (p === RGBIntegerFormat) return 36248;
            if (p === RGBAIntegerFormat) return 36249;
            if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
                extension = extensions.get('WEBGL_compressed_texture_s3tc');
                if (extension !== null) {
                    if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                } else return null;
            }
            if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
                extension = extensions.get('WEBGL_compressed_texture_pvrtc');
                if (extension !== null) {
                    if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                } else return null;
            }
            if (p === RGB_ETC1_Format) {
                extension = extensions.get('WEBGL_compressed_texture_etc1');
                if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
                else return null;
            }
            if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
                extension = extensions.get('WEBGL_compressed_texture_etc');
                if (extension !== null) {
                    if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
                    if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
                }
            }
            if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
                extension = extensions.get('WEBGL_compressed_texture_astc');
                if (extension !== null) // TODO Complete?
                return p;
                else return null;
            }
            if (p === RGBA_BPTC_Format) {
                extension = extensions.get('EXT_texture_compression_bptc');
                if (extension !== null) // TODO Complete?
                return p;
                else return null;
            }
            if (p === UnsignedInt248Type) {
                if (isWebGL2) return 34042;
                extension = extensions.get('WEBGL_depth_texture');
                if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
                else return null;
            }
        }
        return {
            convert: convert
        };
    }
    function ArrayCamera(array) {
        if (array === void 0) array = [];
        PerspectiveCamera.call(this);
        this.cameras = array;
    }
    ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
        constructor: ArrayCamera,
        isArrayCamera: true
    });
    function Group() {
        Object3D.call(this);
        this.type = 'Group';
    }
    Group.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Group,
        isGroup: true
    });
    function WebXRController() {
        this._targetRay = null;
        this._grip = null;
        this._hand = null;
    }
    Object.assign(WebXRController.prototype, {
        constructor: WebXRController,
        getHandSpace: function getHandSpace() {
            if (this._hand === null) {
                this._hand = new Group();
                this._hand.matrixAutoUpdate = false;
                this._hand.visible = false;
                this._hand.joints = {
                };
                this._hand.inputState = {
                    pinching: false
                };
            }
            return this._hand;
        },
        getTargetRaySpace: function getTargetRaySpace() {
            if (this._targetRay === null) {
                this._targetRay = new Group();
                this._targetRay.matrixAutoUpdate = false;
                this._targetRay.visible = false;
            }
            return this._targetRay;
        },
        getGripSpace: function getGripSpace() {
            if (this._grip === null) {
                this._grip = new Group();
                this._grip.matrixAutoUpdate = false;
                this._grip.visible = false;
            }
            return this._grip;
        },
        dispatchEvent: function dispatchEvent(event) {
            if (this._targetRay !== null) this._targetRay.dispatchEvent(event);
            if (this._grip !== null) this._grip.dispatchEvent(event);
            if (this._hand !== null) this._hand.dispatchEvent(event);
            return this;
        },
        disconnect: function disconnect(inputSource) {
            this.dispatchEvent({
                type: 'disconnected',
                data: inputSource
            });
            if (this._targetRay !== null) this._targetRay.visible = false;
            if (this._grip !== null) this._grip.visible = false;
            if (this._hand !== null) this._hand.visible = false;
            return this;
        },
        update: function update(inputSource, frame, referenceSpace) {
            var inputPose = null;
            var gripPose = null;
            var handPose = null;
            var targetRay = this._targetRay;
            var grip = this._grip;
            var hand = this._hand;
            if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
                if (hand && inputSource.hand) {
                    handPose = true;
                    for(var _iterator = _createForOfIteratorHelperLoose(inputSource.hand.values()), _step; !(_step = _iterator()).done;){
                        var inputjoint = _step.value;
                        // Update the joints groups with the XRJoint poses
                        var jointPose = frame.getJointPose(inputjoint, referenceSpace);
                        if (hand.joints[inputjoint.jointName] === undefined) {
                            // The transform of this joint will be updated with the joint pose on each frame
                            var _joint = new Group();
                            _joint.matrixAutoUpdate = false;
                            _joint.visible = false;
                            hand.joints[inputjoint.jointName] = _joint; // ??
                            hand.add(_joint);
                        }
                        var joint = hand.joints[inputjoint.jointName];
                        if (jointPose !== null) {
                            joint.matrix.fromArray(jointPose.transform.matrix);
                            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                            joint.jointRadius = jointPose.radius;
                        }
                        joint.visible = jointPose !== null;
                    } // Custom events
                    // Check pinchz
                    var indexTip = hand.joints['index-finger-tip'];
                    var thumbTip = hand.joints['thumb-tip'];
                    var distance = indexTip.position.distanceTo(thumbTip.position);
                    var distanceToPinch = 0.02;
                    var threshold = 0.005;
                    if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                        hand.inputState.pinching = false;
                        this.dispatchEvent({
                            type: 'pinchend',
                            handedness: inputSource.handedness,
                            target: this
                        });
                    } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                        hand.inputState.pinching = true;
                        this.dispatchEvent({
                            type: 'pinchstart',
                            handedness: inputSource.handedness,
                            target: this
                        });
                    }
                } else {
                    if (targetRay !== null) {
                        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                        if (inputPose !== null) {
                            targetRay.matrix.fromArray(inputPose.transform.matrix);
                            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                        }
                    }
                    if (grip !== null && inputSource.gripSpace) {
                        gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                        if (gripPose !== null) {
                            grip.matrix.fromArray(gripPose.transform.matrix);
                            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                        }
                    }
                }
            }
            if (targetRay !== null) targetRay.visible = inputPose !== null;
            if (grip !== null) grip.visible = gripPose !== null;
            if (hand !== null) hand.visible = handPose !== null;
            return this;
        }
    });
    function WebXRManager(renderer, gl) {
        var scope = this;
        var session = null;
        var framebufferScaleFactor = 1;
        var referenceSpace = null;
        var referenceSpaceType = 'local-floor';
        var pose = null;
        var controllers = [];
        var inputSourcesMap = new Map(); //
        var cameraL = new PerspectiveCamera();
        cameraL.layers.enable(1);
        cameraL.viewport = new Vector4();
        var cameraR = new PerspectiveCamera();
        cameraR.layers.enable(2);
        cameraR.viewport = new Vector4();
        var cameras = [
            cameraL,
            cameraR
        ];
        var cameraVR = new ArrayCamera();
        cameraVR.layers.enable(1);
        cameraVR.layers.enable(2);
        var _currentDepthNear = null;
        var _currentDepthFar = null; //
        this.enabled = false;
        this.isPresenting = false;
        this.getController = function(index) {
            var controller = controllers[index];
            if (controller === undefined) {
                controller = new WebXRController();
                controllers[index] = controller;
            }
            return controller.getTargetRaySpace();
        };
        this.getControllerGrip = function(index) {
            var controller = controllers[index];
            if (controller === undefined) {
                controller = new WebXRController();
                controllers[index] = controller;
            }
            return controller.getGripSpace();
        };
        this.getHand = function(index) {
            var controller = controllers[index];
            if (controller === undefined) {
                controller = new WebXRController();
                controllers[index] = controller;
            }
            return controller.getHandSpace();
        }; //
        function onSessionEvent(event) {
            var controller = inputSourcesMap.get(event.inputSource);
            if (controller) controller.dispatchEvent({
                type: event.type,
                data: event.inputSource
            });
        }
        function onSessionEnd() {
            inputSourcesMap.forEach(function(controller, inputSource) {
                controller.disconnect(inputSource);
            });
            inputSourcesMap.clear();
            _currentDepthNear = null;
            _currentDepthFar = null; //
            renderer.setFramebuffer(null);
            renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830
            animation.stop();
            scope.isPresenting = false;
            scope.dispatchEvent({
                type: 'sessionend'
            });
        }
        this.setFramebufferScaleFactor = function(value) {
            framebufferScaleFactor = value;
            if (scope.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
        };
        this.setReferenceSpaceType = function(value) {
            referenceSpaceType = value;
            if (scope.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
        };
        this.getReferenceSpace = function() {
            return referenceSpace;
        };
        this.getSession = function() {
            return session;
        };
        this.setSession = /*#__PURE__*/ (function() {
            var _ref = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee(value) {
                var attributes, layerInit, baseLayer;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                    while(true)switch(_context.prev = _context.next){
                        case 0:
                            session = value;
                            if (!(session !== null)) {
                                _context.next = 24;
                                break;
                            }
                            session.addEventListener('select', onSessionEvent);
                            session.addEventListener('selectstart', onSessionEvent);
                            session.addEventListener('selectend', onSessionEvent);
                            session.addEventListener('squeeze', onSessionEvent);
                            session.addEventListener('squeezestart', onSessionEvent);
                            session.addEventListener('squeezeend', onSessionEvent);
                            session.addEventListener('end', onSessionEnd);
                            session.addEventListener('inputsourceschange', onInputSourcesChange);
                            attributes = gl.getContextAttributes();
                            if (!(attributes.xrCompatible !== true)) {
                                _context.next = 14;
                                break;
                            }
                            _context.next = 14;
                            return gl.makeXRCompatible();
                        case 14:
                            layerInit = {
                                antialias: attributes.antialias,
                                alpha: attributes.alpha,
                                depth: attributes.depth,
                                stencil: attributes.stencil,
                                framebufferScaleFactor: framebufferScaleFactor
                            }; // eslint-disable-next-line no-undef
                            baseLayer = new XRWebGLLayer(session, gl, layerInit);
                            session.updateRenderState({
                                baseLayer: baseLayer
                            });
                            _context.next = 19;
                            return session.requestReferenceSpace(referenceSpaceType);
                        case 19:
                            referenceSpace = _context.sent;
                            animation.setContext(session);
                            animation.start();
                            scope.isPresenting = true;
                            scope.dispatchEvent({
                                type: 'sessionstart'
                            });
                        case 24:
                        case "end":
                            return _context.stop();
                    }
                }, _callee);
            }));
            return function(_x1) {
                return _ref.apply(this, arguments);
            };
        })();
        function onInputSourcesChange(event) {
            var inputSources = session.inputSources; // Assign inputSources to available controllers
            for(var i26 = 0; i26 < controllers.length; i26++)inputSourcesMap.set(inputSources[i26], controllers[i26]);
             // Notify disconnected
            for(var _i = 0; _i < event.removed.length; _i++){
                var inputSource = event.removed[_i];
                var controller = inputSourcesMap.get(inputSource);
                if (controller) {
                    controller.dispatchEvent({
                        type: 'disconnected',
                        data: inputSource
                    });
                    inputSourcesMap.delete(inputSource);
                }
            } // Notify connected
            for(var _i2 = 0; _i2 < event.added.length; _i2++){
                var _inputSource = event.added[_i2];
                var _controller = inputSourcesMap.get(_inputSource);
                if (_controller) _controller.dispatchEvent({
                    type: 'connected',
                    data: _inputSource
                });
            }
        } //
        var cameraLPos = new Vector3();
        var cameraRPos = new Vector3();
        /**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */ function setProjectionFromUnion(camera, cameraL1, cameraR1) {
            cameraLPos.setFromMatrixPosition(cameraL1.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR1.matrixWorld);
            var ipd = cameraLPos.distanceTo(cameraRPos);
            var projL = cameraL1.projectionMatrix.elements;
            var projR = cameraR1.projectionMatrix.elements; // VR systems will have identical far and near planes, and
            // most likely identical top and bottom frustum extents.
            // Use the left camera for these values.
            var near = projL[14] / (projL[10] - 1);
            var far = projL[14] / (projL[10] + 1);
            var topFov = (projL[9] + 1) / projL[5];
            var bottomFov = (projL[9] - 1) / projL[5];
            var leftFov = (projL[8] - 1) / projL[0];
            var rightFov = (projR[8] + 1) / projR[0];
            var left = near * leftFov;
            var right = near * rightFov; // Calculate the new camera's position offset from the
            // left camera. xOffset should be roughly half `ipd`.
            var zOffset = ipd / (-leftFov + rightFov);
            var xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?
            cameraL1.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale
            // the values so that the near plane's position does not change in world space,
            // although must now be relative to the new union camera.
            var near2 = near + zOffset;
            var far2 = far + zOffset;
            var left2 = left - xOffset;
            var right2 = right + (ipd - xOffset);
            var top2 = topFov * far / far2 * near2;
            var bottom2 = bottomFov * far / far2 * near2;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        }
        function updateCamera(camera, parent) {
            if (parent === null) camera.matrixWorld.copy(camera.matrix);
            else camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        }
        this.getCamera = function(camera) {
            cameraVR.near = cameraR.near = cameraL.near = camera.near;
            cameraVR.far = cameraR.far = cameraL.far = camera.far;
            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
                // Note that the new renderState won't apply until the next frame. See #18320
                session.updateRenderState({
                    depthNear: cameraVR.near,
                    depthFar: cameraVR.far
                });
                _currentDepthNear = cameraVR.near;
                _currentDepthFar = cameraVR.far;
            }
            var parent = camera.parent;
            var cameras1 = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for(var i26 = 0; i26 < cameras1.length; i26++)updateCamera(cameras1[i26], parent);
             // update camera and its children
            camera.matrixWorld.copy(cameraVR.matrixWorld);
            camera.matrix.copy(cameraVR.matrix);
            camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
            var children = camera.children;
            for(var _i3 = 0, l = children.length; _i3 < l; _i3++)children[_i3].updateMatrixWorld(true);
             // update projection matrix for proper view frustum culling
            if (cameras1.length === 2) setProjectionFromUnion(cameraVR, cameraL, cameraR);
            else // assume single camera setup (AR)
            cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
            return cameraVR;
        }; // Animation Loop
        var onAnimationFrameCallback = null;
        function onAnimationFrame(time, frame) {
            pose = frame.getViewerPose(referenceSpace);
            if (pose !== null) {
                var views = pose.views;
                var baseLayer = session.renderState.baseLayer;
                renderer.setFramebuffer(baseLayer.framebuffer);
                var cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list
                if (views.length !== cameraVR.cameras.length) {
                    cameraVR.cameras.length = 0;
                    cameraVRNeedsUpdate = true;
                }
                for(var i26 = 0; i26 < views.length; i26++){
                    var view = views[i26];
                    var viewport = baseLayer.getViewport(view);
                    var camera = cameras[i26];
                    camera.matrix.fromArray(view.transform.matrix);
                    camera.projectionMatrix.fromArray(view.projectionMatrix);
                    camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                    if (i26 === 0) cameraVR.matrix.copy(camera.matrix);
                    if (cameraVRNeedsUpdate === true) cameraVR.cameras.push(camera);
                }
            } //
            var inputSources = session.inputSources;
            for(var _i4 = 0; _i4 < controllers.length; _i4++){
                var controller = controllers[_i4];
                var inputSource = inputSources[_i4];
                controller.update(inputSource, frame, referenceSpace);
            }
            if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
        }
        var animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
        };
        this.dispose = function() {
        };
    }
    Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
    function WebGLMaterials(properties) {
        function refreshFogUniforms(uniforms, fog) {
            uniforms.fogColor.value.copy(fog.color);
            if (fog.isFog) {
                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
            } else if (fog.isFogExp2) uniforms.fogDensity.value = fog.density;
        }
        function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
            if (material.isMeshBasicMaterial) refreshUniformsCommon(uniforms, material);
            else if (material.isMeshLambertMaterial) {
                refreshUniformsCommon(uniforms, material);
                refreshUniformsLambert(uniforms, material);
            } else if (material.isMeshToonMaterial) {
                refreshUniformsCommon(uniforms, material);
                refreshUniformsToon(uniforms, material);
            } else if (material.isMeshPhongMaterial) {
                refreshUniformsCommon(uniforms, material);
                refreshUniformsPhong(uniforms, material);
            } else if (material.isMeshStandardMaterial) {
                refreshUniformsCommon(uniforms, material);
                if (material.isMeshPhysicalMaterial) refreshUniformsPhysical(uniforms, material);
                else refreshUniformsStandard(uniforms, material);
            } else if (material.isMeshMatcapMaterial) {
                refreshUniformsCommon(uniforms, material);
                refreshUniformsMatcap(uniforms, material);
            } else if (material.isMeshDepthMaterial) {
                refreshUniformsCommon(uniforms, material);
                refreshUniformsDepth(uniforms, material);
            } else if (material.isMeshDistanceMaterial) {
                refreshUniformsCommon(uniforms, material);
                refreshUniformsDistance(uniforms, material);
            } else if (material.isMeshNormalMaterial) {
                refreshUniformsCommon(uniforms, material);
                refreshUniformsNormal(uniforms, material);
            } else if (material.isLineBasicMaterial) {
                refreshUniformsLine(uniforms, material);
                if (material.isLineDashedMaterial) refreshUniformsDash(uniforms, material);
            } else if (material.isPointsMaterial) refreshUniformsPoints(uniforms, material, pixelRatio, height);
            else if (material.isSpriteMaterial) refreshUniformsSprites(uniforms, material);
            else if (material.isShadowMaterial) {
                uniforms.color.value.copy(material.color);
                uniforms.opacity.value = material.opacity;
            } else if (material.isShaderMaterial) material.uniformsNeedUpdate = false; // #15581
        }
        function refreshUniformsCommon(uniforms, material) {
            uniforms.opacity.value = material.opacity;
            if (material.color) uniforms.diffuse.value.copy(material.color);
            if (material.emissive) uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
            if (material.map) uniforms.map.value = material.map;
            if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
            if (material.specularMap) uniforms.specularMap.value = material.specularMap;
            var envMap = properties.get(material).envMap;
            if (envMap) {
                uniforms.envMap.value = envMap;
                uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
                uniforms.reflectivity.value = material.reflectivity;
                uniforms.refractionRatio.value = material.refractionRatio;
                var maxMipLevel = properties.get(envMap).__maxMipLevel;
                if (maxMipLevel !== undefined) uniforms.maxMipLevel.value = maxMipLevel;
            }
            if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
            }
            if (material.aoMap) {
                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
            } // uv repeat and offset setting priorities
            // 1. color map
            // 2. specular map
            // 3. displacementMap map
            // 4. normal map
            // 5. bump map
            // 6. roughnessMap map
            // 7. metalnessMap map
            // 8. alphaMap map
            // 9. emissiveMap map
            // 10. clearcoat map
            // 11. clearcoat normal map
            // 12. clearcoat roughnessMap map
            var uvScaleMap;
            if (material.map) uvScaleMap = material.map;
            else if (material.specularMap) uvScaleMap = material.specularMap;
            else if (material.displacementMap) uvScaleMap = material.displacementMap;
            else if (material.normalMap) uvScaleMap = material.normalMap;
            else if (material.bumpMap) uvScaleMap = material.bumpMap;
            else if (material.roughnessMap) uvScaleMap = material.roughnessMap;
            else if (material.metalnessMap) uvScaleMap = material.metalnessMap;
            else if (material.alphaMap) uvScaleMap = material.alphaMap;
            else if (material.emissiveMap) uvScaleMap = material.emissiveMap;
            else if (material.clearcoatMap) uvScaleMap = material.clearcoatMap;
            else if (material.clearcoatNormalMap) uvScaleMap = material.clearcoatNormalMap;
            else if (material.clearcoatRoughnessMap) uvScaleMap = material.clearcoatRoughnessMap;
            if (uvScaleMap !== undefined) {
                // backwards compatibility
                if (uvScaleMap.isWebGLRenderTarget) uvScaleMap = uvScaleMap.texture;
                if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
                uniforms.uvTransform.value.copy(uvScaleMap.matrix);
            } // uv repeat and offset setting priorities for uv2
            // 1. ao map
            // 2. light map
            var uv2ScaleMap;
            if (material.aoMap) uv2ScaleMap = material.aoMap;
            else if (material.lightMap) uv2ScaleMap = material.lightMap;
            if (uv2ScaleMap !== undefined) {
                // backwards compatibility
                if (uv2ScaleMap.isWebGLRenderTarget) uv2ScaleMap = uv2ScaleMap.texture;
                if (uv2ScaleMap.matrixAutoUpdate === true) uv2ScaleMap.updateMatrix();
                uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
            }
        }
        function refreshUniformsLine(uniforms, material) {
            uniforms.diffuse.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
        }
        function refreshUniformsDash(uniforms, material) {
            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
        }
        function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
            uniforms.diffuse.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * pixelRatio;
            uniforms.scale.value = height * 0.5;
            if (material.map) uniforms.map.value = material.map;
            if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
             // uv repeat and offset setting priorities
            // 1. color map
            // 2. alpha map
            var uvScaleMap;
            if (material.map) uvScaleMap = material.map;
            else if (material.alphaMap) uvScaleMap = material.alphaMap;
            if (uvScaleMap !== undefined) {
                if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
                uniforms.uvTransform.value.copy(uvScaleMap.matrix);
            }
        }
        function refreshUniformsSprites(uniforms, material) {
            uniforms.diffuse.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
            uniforms.rotation.value = material.rotation;
            if (material.map) uniforms.map.value = material.map;
            if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
             // uv repeat and offset setting priorities
            // 1. color map
            // 2. alpha map
            var uvScaleMap;
            if (material.map) uvScaleMap = material.map;
            else if (material.alphaMap) uvScaleMap = material.alphaMap;
            if (uvScaleMap !== undefined) {
                if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
                uniforms.uvTransform.value.copy(uvScaleMap.matrix);
            }
        }
        function refreshUniformsLambert(uniforms, material) {
            if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        }
        function refreshUniformsPhong(uniforms, material) {
            uniforms.specular.value.copy(material.specular);
            uniforms.shininess.value = Math.max(material.shininess, 0.0001); // to prevent pow( 0.0, 0.0 )
            if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide) uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide) uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function refreshUniformsToon(uniforms, material) {
            if (material.gradientMap) uniforms.gradientMap.value = material.gradientMap;
            if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide) uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide) uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function refreshUniformsStandard(uniforms, material) {
            uniforms.roughness.value = material.roughness;
            uniforms.metalness.value = material.metalness;
            if (material.roughnessMap) uniforms.roughnessMap.value = material.roughnessMap;
            if (material.metalnessMap) uniforms.metalnessMap.value = material.metalnessMap;
            if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide) uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide) uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            var envMap = properties.get(material).envMap;
            if (envMap) //uniforms.envMap.value = material.envMap; // part of uniforms common
            uniforms.envMapIntensity.value = material.envMapIntensity;
        }
        function refreshUniformsPhysical(uniforms, material) {
            refreshUniformsStandard(uniforms, material);
            uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common
            uniforms.clearcoat.value = material.clearcoat;
            uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
            if (material.sheen) uniforms.sheen.value.copy(material.sheen);
            if (material.clearcoatMap) uniforms.clearcoatMap.value = material.clearcoatMap;
            if (material.clearcoatRoughnessMap) uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
            if (material.clearcoatNormalMap) {
                uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
                uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
                if (material.side === BackSide) uniforms.clearcoatNormalScale.value.negate();
            }
            uniforms.transmission.value = material.transmission;
            if (material.transmissionMap) uniforms.transmissionMap.value = material.transmissionMap;
        }
        function refreshUniformsMatcap(uniforms, material) {
            if (material.matcap) uniforms.matcap.value = material.matcap;
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide) uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide) uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function refreshUniformsDepth(uniforms, material) {
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function refreshUniformsDistance(uniforms, material) {
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            uniforms.referencePosition.value.copy(material.referencePosition);
            uniforms.nearDistance.value = material.nearDistance;
            uniforms.farDistance.value = material.farDistance;
        }
        function refreshUniformsNormal(uniforms, material) {
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide) uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide) uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        return {
            refreshFogUniforms: refreshFogUniforms,
            refreshMaterialUniforms: refreshMaterialUniforms
        };
    }
    function createCanvasElement() {
        var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        canvas.style.display = 'block';
        return canvas;
    }
    function WebGLRenderer(parameters) {
        parameters = parameters || {
        };
        var _canvas1 = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default', _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
        var currentRenderList = null;
        var currentRenderState = null; // render() can be called from within a callback triggered by another render.
        // We track this so that the nested render call gets its state isolated from the parent render call.
        var renderStateStack = []; // public properties
        this.domElement = _canvas1; // Debug configuration container
        this.debug = {
            /**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */ checkShaderErrors: true
        }; // clearing
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true; // scene graph
        this.sortObjects = true; // user-defined clipping
        this.clippingPlanes = [];
        this.localClippingEnabled = false; // physically based shading
        this.gammaFactor = 2; // for backwards compatibility
        this.outputEncoding = LinearEncoding; // physical lights
        this.physicallyCorrectLights = false; // tone mapping
        this.toneMapping = NoToneMapping;
        this.toneMappingExposure = 1; // morphs
        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4; // internal properties
        var _this = this;
        var _isContextLost = false; // internal state cache
        var _framebuffer = null;
        var _currentActiveCubeFace = 0;
        var _currentActiveMipmapLevel = 0;
        var _currentRenderTarget = null;
        var _currentFramebuffer = null;
        var _currentMaterialId = -1;
        var _currentCamera = null;
        var _currentViewport = new Vector4();
        var _currentScissor = new Vector4();
        var _currentScissorTest = null; //
        var _width = _canvas1.width;
        var _height = _canvas1.height;
        var _pixelRatio = 1;
        var _opaqueSort = null;
        var _transparentSort = null;
        var _viewport = new Vector4(0, 0, _width, _height);
        var _scissor = new Vector4(0, 0, _width, _height);
        var _scissorTest = false; // frustum
        var _frustum = new Frustum(); // clipping
        var _clippingEnabled = false;
        var _localClippingEnabled = false; // camera matrices cache
        var _projScreenMatrix = new Matrix4();
        var _vector3 = new Vector3();
        var _emptyScene = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: true
        };
        function getTargetPixelRatio() {
            return _currentRenderTarget === null ? _pixelRatio : 1;
        } // initialize
        var _gl = _context;
        function getContext(contextNames, contextAttributes) {
            for(var i27 = 0; i27 < contextNames.length; i27++){
                var contextName = contextNames[i27];
                var context = _canvas1.getContext(contextName, contextAttributes);
                if (context !== null) return context;
            }
            return null;
        }
        try {
            var contextAttributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer,
                powerPreference: _powerPreference,
                failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
            }; // event listeners must be registered before WebGL context is created, see #12753
            _canvas1.addEventListener('webglcontextlost', onContextLost, false);
            _canvas1.addEventListener('webglcontextrestored', onContextRestore, false);
            if (_gl === null) {
                var contextNames = [
                    'webgl2',
                    'webgl',
                    'experimental-webgl'
                ];
                if (_this.isWebGL1Renderer === true) contextNames.shift();
                _gl = getContext(contextNames, contextAttributes);
                if (_gl === null) {
                    if (getContext(contextNames)) throw new Error('Error creating WebGL context with your selected attributes.');
                    else throw new Error('Error creating WebGL context.');
                }
            } // Some experimental-webgl implementations do not have getShaderPrecisionFormat
            if (_gl.getShaderPrecisionFormat === undefined) _gl.getShaderPrecisionFormat = function() {
                return {
                    'rangeMin': 1,
                    'rangeMax': 1,
                    'precision': 1
                };
            };
        } catch (error) {
            console.error('THREE.WebGLRenderer: ' + error.message);
            throw error;
        }
        var extensions, capabilities, state, info;
        var properties, textures, cubemaps, attributes, geometries, objects;
        var programCache, materials, renderLists, renderStates, clipping;
        var background, morphtargets, bufferRenderer, indexedBufferRenderer;
        var utils, bindingStates;
        function initGLContext() {
            extensions = new WebGLExtensions(_gl);
            capabilities = new WebGLCapabilities(_gl, extensions, parameters);
            extensions.init(capabilities);
            utils = new WebGLUtils(_gl, extensions, capabilities);
            state = new WebGLState(_gl, extensions, capabilities);
            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
            info = new WebGLInfo(_gl);
            properties = new WebGLProperties();
            textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
            cubemaps = new WebGLCubeMaps(_this);
            attributes = new WebGLAttributes(_gl, capabilities);
            bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
            geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
            objects = new WebGLObjects(_gl, geometries, attributes, info);
            morphtargets = new WebGLMorphtargets(_gl);
            clipping = new WebGLClipping(properties);
            programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
            materials = new WebGLMaterials(properties);
            renderLists = new WebGLRenderLists(properties);
            renderStates = new WebGLRenderStates(extensions, capabilities);
            background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
            bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
            indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
            info.programs = programCache.programs;
            _this.capabilities = capabilities;
            _this.extensions = extensions;
            _this.properties = properties;
            _this.renderLists = renderLists;
            _this.state = state;
            _this.info = info;
        }
        initGLContext(); // xr
        var xr = new WebXRManager(_this, _gl);
        this.xr = xr; // shadow map
        var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
        this.shadowMap = shadowMap; // API
        this.getContext = function() {
            return _gl;
        };
        this.getContextAttributes = function() {
            return _gl.getContextAttributes();
        };
        this.forceContextLoss = function() {
            var extension = extensions.get('WEBGL_lose_context');
            if (extension) extension.loseContext();
        };
        this.forceContextRestore = function() {
            var extension = extensions.get('WEBGL_lose_context');
            if (extension) extension.restoreContext();
        };
        this.getPixelRatio = function() {
            return _pixelRatio;
        };
        this.setPixelRatio = function(value) {
            if (value === undefined) return;
            _pixelRatio = value;
            this.setSize(_width, _height, false);
        };
        this.getSize = function(target) {
            if (target === undefined) {
                console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
                target = new Vector2();
            }
            return target.set(_width, _height);
        };
        this.setSize = function(width, height, updateStyle) {
            if (xr.isPresenting) {
                console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
                return;
            }
            _width = width;
            _height = height;
            _canvas1.width = Math.floor(width * _pixelRatio);
            _canvas1.height = Math.floor(height * _pixelRatio);
            if (updateStyle !== false) {
                _canvas1.style.width = width + 'px';
                _canvas1.style.height = height + 'px';
            }
            this.setViewport(0, 0, width, height);
        };
        this.getDrawingBufferSize = function(target) {
            if (target === undefined) {
                console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
                target = new Vector2();
            }
            return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
        };
        this.setDrawingBufferSize = function(width, height, pixelRatio) {
            _width = width;
            _height = height;
            _pixelRatio = pixelRatio;
            _canvas1.width = Math.floor(width * pixelRatio);
            _canvas1.height = Math.floor(height * pixelRatio);
            this.setViewport(0, 0, width, height);
        };
        this.getCurrentViewport = function(target) {
            if (target === undefined) {
                console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
                target = new Vector4();
            }
            return target.copy(_currentViewport);
        };
        this.getViewport = function(target) {
            return target.copy(_viewport);
        };
        this.setViewport = function(x, y, width, height) {
            if (x.isVector4) _viewport.set(x.x, x.y, x.z, x.w);
            else _viewport.set(x, y, width, height);
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissor = function(target) {
            return target.copy(_scissor);
        };
        this.setScissor = function(x, y, width, height) {
            if (x.isVector4) _scissor.set(x.x, x.y, x.z, x.w);
            else _scissor.set(x, y, width, height);
            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        };
        this.getScissorTest = function() {
            return _scissorTest;
        };
        this.setScissorTest = function(boolean) {
            state.setScissorTest(_scissorTest = boolean);
        };
        this.setOpaqueSort = function(method) {
            _opaqueSort = method;
        };
        this.setTransparentSort = function(method) {
            _transparentSort = method;
        }; // Clearing
        this.getClearColor = function(target) {
            if (target === undefined) {
                console.warn('WebGLRenderer: .getClearColor() now requires a Color as an argument');
                target = new Color();
            }
            return target.copy(background.getClearColor());
        };
        this.setClearColor = function() {
            background.setClearColor.apply(background, arguments);
        };
        this.getClearAlpha = function() {
            return background.getClearAlpha();
        };
        this.setClearAlpha = function() {
            background.setClearAlpha.apply(background, arguments);
        };
        this.clear = function(color, depth, stencil) {
            var bits = 0;
            if (color === undefined || color) bits |= 16384;
            if (depth === undefined || depth) bits |= 256;
            if (stencil === undefined || stencil) bits |= 1024;
            _gl.clear(bits);
        };
        this.clearColor = function() {
            this.clear(true, false, false);
        };
        this.clearDepth = function() {
            this.clear(false, true, false);
        };
        this.clearStencil = function() {
            this.clear(false, false, true);
        }; //
        this.dispose = function() {
            _canvas1.removeEventListener('webglcontextlost', onContextLost, false);
            _canvas1.removeEventListener('webglcontextrestored', onContextRestore, false);
            renderLists.dispose();
            renderStates.dispose();
            properties.dispose();
            cubemaps.dispose();
            objects.dispose();
            bindingStates.dispose();
            xr.dispose();
            animation.stop();
        }; // Events
        function onContextLost(event) {
            event.preventDefault();
            console.log('THREE.WebGLRenderer: Context Lost.');
            _isContextLost = true;
        }
        function onContextRestore() /* event */ {
            console.log('THREE.WebGLRenderer: Context Restored.');
            _isContextLost = false;
            initGLContext();
        }
        function onMaterialDispose(event) {
            var material = event.target;
            material.removeEventListener('dispose', onMaterialDispose);
            deallocateMaterial(material);
        } // Buffer deallocation
        function deallocateMaterial(material) {
            releaseMaterialProgramReference(material);
            properties.remove(material);
        }
        function releaseMaterialProgramReference(material) {
            var programInfo = properties.get(material).program;
            if (programInfo !== undefined) programCache.releaseProgram(programInfo);
        } // Buffer rendering
        function renderObjectImmediate(object, program) {
            object.render(function(object1) {
                _this.renderBufferImmediate(object1, program);
            });
        }
        this.renderBufferImmediate = function(object, program) {
            bindingStates.initAttributes();
            var buffers = properties.get(object);
            if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
            if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
            if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
            if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
            var programAttributes = program.getAttributes();
            if (object.hasPositions) {
                _gl.bindBuffer(34962, buffers.position);
                _gl.bufferData(34962, object.positionArray, 35048);
                bindingStates.enableAttribute(programAttributes.position);
                _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
            }
            if (object.hasNormals) {
                _gl.bindBuffer(34962, buffers.normal);
                _gl.bufferData(34962, object.normalArray, 35048);
                bindingStates.enableAttribute(programAttributes.normal);
                _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
            }
            if (object.hasUvs) {
                _gl.bindBuffer(34962, buffers.uv);
                _gl.bufferData(34962, object.uvArray, 35048);
                bindingStates.enableAttribute(programAttributes.uv);
                _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
            }
            if (object.hasColors) {
                _gl.bindBuffer(34962, buffers.color);
                _gl.bufferData(34962, object.colorArray, 35048);
                bindingStates.enableAttribute(programAttributes.color);
                _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
            }
            bindingStates.disableUnusedAttributes();
            _gl.drawArrays(4, 0, object.count);
            object.count = 0;
        };
        this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
            if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)
            var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
            var program = setProgram(camera, scene, material, object);
            state.setMaterial(material, frontFaceCW); //
            var index = geometry.index;
            var position = geometry.attributes.position; //
            if (index === null) {
                if (position === undefined || position.count === 0) return;
            } else if (index.count === 0) return;
             //
            var rangeFactor = 1;
            if (material.wireframe === true) {
                index = geometries.getWireframeAttribute(geometry);
                rangeFactor = 2;
            }
            if (material.morphTargets || material.morphNormals) morphtargets.update(object, geometry, material, program);
            bindingStates.setup(object, material, program, geometry, index);
            var attribute;
            var renderer = bufferRenderer;
            if (index !== null) {
                attribute = attributes.get(index);
                renderer = indexedBufferRenderer;
                renderer.setIndex(attribute);
            } //
            var dataCount = index !== null ? index.count : position.count;
            var rangeStart = geometry.drawRange.start * rangeFactor;
            var rangeCount = geometry.drawRange.count * rangeFactor;
            var groupStart = group !== null ? group.start * rangeFactor : 0;
            var groupCount = group !== null ? group.count * rangeFactor : Infinity;
            var drawStart = Math.max(rangeStart, groupStart);
            var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
            var drawCount = Math.max(0, drawEnd - drawStart + 1);
            if (drawCount === 0) return; //
            if (object.isMesh) {
                if (material.wireframe === true) {
                    state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                    renderer.setMode(1);
                } else renderer.setMode(4);
            } else if (object.isLine) {
                var lineWidth = material.linewidth;
                if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material
                state.setLineWidth(lineWidth * getTargetPixelRatio());
                if (object.isLineSegments) renderer.setMode(1);
                else if (object.isLineLoop) renderer.setMode(2);
                else renderer.setMode(3);
            } else if (object.isPoints) renderer.setMode(0);
            else if (object.isSprite) renderer.setMode(4);
            if (object.isInstancedMesh) renderer.renderInstances(drawStart, drawCount, object.count);
            else if (geometry.isInstancedBufferGeometry) {
                var instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
                renderer.renderInstances(drawStart, drawCount, instanceCount);
            } else renderer.render(drawStart, drawCount);
        }; // Compile
        this.compile = function(scene, camera) {
            currentRenderState = renderStates.get(scene);
            currentRenderState.init();
            scene.traverseVisible(function(object) {
                if (object.isLight && object.layers.test(camera.layers)) {
                    currentRenderState.pushLight(object);
                    if (object.castShadow) currentRenderState.pushShadow(object);
                }
            });
            currentRenderState.setupLights();
            var compiled = new WeakMap();
            scene.traverse(function(object) {
                var material = object.material;
                if (material) {
                    if (Array.isArray(material)) for(var i27 = 0; i27 < material.length; i27++){
                        var material2 = material[i27];
                        if (compiled.has(material2) === false) {
                            initMaterial(material2, scene, object);
                            compiled.set(material2);
                        }
                    }
                    else if (compiled.has(material) === false) {
                        initMaterial(material, scene, object);
                        compiled.set(material);
                    }
                }
            });
        }; // Animation Loop
        var onAnimationFrameCallback = null;
        function onAnimationFrame(time) {
            if (xr.isPresenting) return;
            if (onAnimationFrameCallback) onAnimationFrameCallback(time);
        }
        var animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        if (typeof window !== 'undefined') animation.setContext(window);
        this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
            xr.setAnimationLoop(callback);
            callback === null ? animation.stop() : animation.start();
        }; // Rendering
        this.render = function(scene, camera) {
            var renderTarget, forceClear;
            if (arguments[2] !== undefined) {
                console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
                renderTarget = arguments[2];
            }
            if (arguments[3] !== undefined) {
                console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
                forceClear = arguments[3];
            }
            if (camera !== undefined && camera.isCamera !== true) {
                console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                return;
            }
            if (_isContextLost === true) return; // reset caching for this frame
            bindingStates.resetDefaultState();
            _currentMaterialId = -1;
            _currentCamera = null; // update scene graph
            if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum
            if (camera.parent === null) camera.updateMatrixWorld();
            if (xr.enabled === true && xr.isPresenting === true) camera = xr.getCamera(camera);
             //
            if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
            currentRenderState = renderStates.get(scene, renderStateStack.length);
            currentRenderState.init();
            renderStateStack.push(currentRenderState);
            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            _frustum.setFromProjectionMatrix(_projScreenMatrix);
            _localClippingEnabled = this.localClippingEnabled;
            _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
            currentRenderList = renderLists.get(scene, camera);
            currentRenderList.init();
            projectObject(scene, camera, 0, _this.sortObjects);
            currentRenderList.finish();
            if (_this.sortObjects === true) currentRenderList.sort(_opaqueSort, _transparentSort);
             //
            if (_clippingEnabled === true) clipping.beginShadows();
            var shadowsArray = currentRenderState.state.shadowsArray;
            shadowMap.render(shadowsArray, scene, camera);
            currentRenderState.setupLights();
            currentRenderState.setupLightsView(camera);
            if (_clippingEnabled === true) clipping.endShadows(); //
            if (this.info.autoReset === true) this.info.reset();
            if (renderTarget !== undefined) this.setRenderTarget(renderTarget);
             //
            background.render(currentRenderList, scene, camera, forceClear); // render scene
            var opaqueObjects = currentRenderList.opaque;
            var transparentObjects = currentRenderList.transparent;
            if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
            if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //
            if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); //
            if (_currentRenderTarget !== null) {
                // Generate mipmap if we're using any kind of mipmap filtering
                textures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary
                textures.updateMultisampleRenderTarget(_currentRenderTarget);
            } // Ensure depth buffer writing is enabled so it can be cleared on next render
            state.buffers.depth.setTest(true);
            state.buffers.depth.setMask(true);
            state.buffers.color.setMask(true);
            state.setPolygonOffset(false); // _gl.finish();
            renderStateStack.pop();
            if (renderStateStack.length > 0) currentRenderState = renderStateStack[renderStateStack.length - 1];
            else currentRenderState = null;
            currentRenderList = null;
        };
        function projectObject(object, camera, groupOrder, sortObjects) {
            if (object.visible === false) return;
            var visible = object.layers.test(camera.layers);
            if (visible) {
                if (object.isGroup) groupOrder = object.renderOrder;
                else if (object.isLOD) {
                    if (object.autoUpdate === true) object.update(camera);
                } else if (object.isLight) {
                    currentRenderState.pushLight(object);
                    if (object.castShadow) currentRenderState.pushShadow(object);
                } else if (object.isSprite) {
                    if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                        if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                        var geometry = objects.update(object);
                        var material = object.material;
                        if (material.visible) currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                    }
                } else if (object.isImmediateRenderObject) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
                } else if (object.isMesh || object.isLine || object.isPoints) {
                    if (object.isSkinnedMesh) // update skeleton only once in a frame
                    {
                        if (object.skeleton.frame !== info.render.frame) {
                            object.skeleton.update();
                            object.skeleton.frame = info.render.frame;
                        }
                    }
                    if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                        if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                        var _geometry = objects.update(object);
                        var _material = object.material;
                        if (Array.isArray(_material)) {
                            var groups = _geometry.groups;
                            for(var i28 = 0, l = groups.length; i28 < l; i28++){
                                var group = groups[i28];
                                var groupMaterial = _material[group.materialIndex];
                                if (groupMaterial && groupMaterial.visible) currentRenderList.push(object, _geometry, groupMaterial, groupOrder, _vector3.z, group);
                            }
                        } else if (_material.visible) currentRenderList.push(object, _geometry, _material, groupOrder, _vector3.z, null);
                    }
                }
            }
            var children = object.children;
            for(var _i = 0, _l = children.length; _i < _l; _i++)projectObject(children[_i], camera, groupOrder, sortObjects);
        }
        function renderObjects(renderList, scene, camera) {
            var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
            for(var i29 = 0, l = renderList.length; i29 < l; i29++){
                var renderItem = renderList[i29];
                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === null ? renderItem.material : overrideMaterial;
                var group = renderItem.group;
                if (camera.isArrayCamera) {
                    var cameras = camera.cameras;
                    for(var j = 0, jl = cameras.length; j < jl; j++){
                        var camera2 = cameras[j];
                        if (object.layers.test(camera2.layers)) {
                            state.viewport(_currentViewport.copy(camera2.viewport));
                            currentRenderState.setupLightsView(camera2);
                            renderObject(object, scene, camera2, geometry, material, group);
                        }
                    }
                } else renderObject(object, scene, camera, geometry, material, group);
            }
        }
        function renderObject(object, scene, camera, geometry, material, group) {
            object.onBeforeRender(_this, scene, camera, geometry, material, group);
            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
            if (object.isImmediateRenderObject) {
                var program = setProgram(camera, scene, material, object);
                state.setMaterial(material);
                bindingStates.reset();
                renderObjectImmediate(object, program);
            } else _this.renderBufferDirect(camera, scene, geometry, material, object, group);
            object.onAfterRender(_this, scene, camera, geometry, material, group);
        }
        function initMaterial(material, scene, object) {
            if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
            var materialProperties = properties.get(material);
            var lights = currentRenderState.state.lights;
            var shadowsArray = currentRenderState.state.shadowsArray;
            var lightsStateVersion = lights.state.version;
            var parameters1 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
            var programCacheKey = programCache.getProgramCacheKey(parameters1);
            var program = materialProperties.program;
            var programChange = true; // always update environment and fog - changing these trigger an initMaterial call, but it's possible that the program doesn't change
            materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
            materialProperties.fog = scene.fog;
            materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
            if (program === undefined) // new material
            material.addEventListener('dispose', onMaterialDispose);
            else if (program.cacheKey !== programCacheKey) // changed glsl or parameters
            releaseMaterialProgramReference(material);
            else if (materialProperties.lightsStateVersion !== lightsStateVersion) programChange = false;
            else if (parameters1.shaderID !== undefined) // same glsl and uniform list
            return;
            else // only rebuild uniform list
            programChange = false;
            if (programChange) {
                parameters1.uniforms = programCache.getUniforms(material);
                material.onBeforeCompile(parameters1, _this);
                program = programCache.acquireProgram(parameters1, programCacheKey);
                materialProperties.program = program;
                materialProperties.uniforms = parameters1.uniforms;
                materialProperties.outputEncoding = parameters1.outputEncoding;
            }
            var uniforms = materialProperties.uniforms;
            if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
                materialProperties.numClippingPlanes = clipping.numPlanes;
                materialProperties.numIntersection = clipping.numIntersection;
                uniforms.clippingPlanes = clipping.uniform;
            } // store the light setup it was created for
            materialProperties.needsLights = materialNeedsLights(material);
            materialProperties.lightsStateVersion = lightsStateVersion;
            if (materialProperties.needsLights) {
                // wire up the material to this renderer's lighting state
                uniforms.ambientLightColor.value = lights.state.ambient;
                uniforms.lightProbe.value = lights.state.probe;
                uniforms.directionalLights.value = lights.state.directional;
                uniforms.directionalLightShadows.value = lights.state.directionalShadow;
                uniforms.spotLights.value = lights.state.spot;
                uniforms.spotLightShadows.value = lights.state.spotShadow;
                uniforms.rectAreaLights.value = lights.state.rectArea;
                uniforms.ltc_1.value = lights.state.rectAreaLTC1;
                uniforms.ltc_2.value = lights.state.rectAreaLTC2;
                uniforms.pointLights.value = lights.state.point;
                uniforms.pointLightShadows.value = lights.state.pointShadow;
                uniforms.hemisphereLights.value = lights.state.hemi;
                uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
                uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
            }
            var progUniforms = materialProperties.program.getUniforms();
            var uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
            materialProperties.uniformsList = uniformsList;
        }
        function setProgram(camera, scene, material, object) {
            if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
            textures.resetTextureUnits();
            var fog = scene.fog;
            var environment = material.isMeshStandardMaterial ? scene.environment : null;
            var encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
            var envMap = cubemaps.get(material.envMap || environment);
            var materialProperties = properties.get(material);
            var lights = currentRenderState.state.lights;
            if (_clippingEnabled === true) {
                if (_localClippingEnabled === true || camera !== _currentCamera) {
                    var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
                    // object instead of the material, once it becomes feasible
                    // (#8465, #8379)
                    clipping.setState(material, camera, useCache);
                }
            }
            if (material.version === materialProperties.__version) {
                if (material.fog && materialProperties.fog !== fog) initMaterial(material, scene, object);
                else if (materialProperties.environment !== environment) initMaterial(material, scene, object);
                else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) initMaterial(material, scene, object);
                else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) initMaterial(material, scene, object);
                else if (materialProperties.outputEncoding !== encoding) initMaterial(material, scene, object);
                else if (materialProperties.envMap !== envMap) initMaterial(material, scene, object);
            } else {
                initMaterial(material, scene, object);
                materialProperties.__version = material.version;
            }
            var refreshProgram = false;
            var refreshMaterial = false;
            var refreshLights = false;
            var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
            if (state.useProgram(program.program)) {
                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
            }
            if (material.id !== _currentMaterialId) {
                _currentMaterialId = material.id;
                refreshMaterial = true;
            }
            if (refreshProgram || _currentCamera !== camera) {
                p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
                if (capabilities.logarithmicDepthBuffer) p_uniforms.setValue(_gl, 'logDepthBufFC', 2 / (Math.log(camera.far + 1) / Math.LN2));
                if (_currentCamera !== camera) {
                    _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
                    // now, in case this material supports lights - or later, when
                    // the next material that does gets activated:
                    refreshMaterial = true; // set to true on material change
                    refreshLights = true; // remains set until update done
                } // load material specific uniforms
                // (shader material also gets them for the sake of genericity)
                if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
                    var uCamPos = p_uniforms.map.cameraPosition;
                    if (uCamPos !== undefined) uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                }
                if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
                if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
            } // skinning uniforms must be set even if material didn't change
            // auto-setting of texture unit for bone texture must go before other textures
            // otherwise textures used for skinning can take over texture units reserved for other material textures
            if (material.skinning) {
                p_uniforms.setOptional(_gl, object, 'bindMatrix');
                p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
                var skeleton = object.skeleton;
                if (skeleton) {
                    var bones = skeleton.bones;
                    if (capabilities.floatVertexTextures) {
                        if (skeleton.boneTexture === null) {
                            // layout (1 matrix = 4 pixels)
                            //			RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                            //	with	8x8	pixel texture max	 16 bones * 4 pixels =	(8 * 8)
                            //			 16x16 pixel texture max	 64 bones * 4 pixels = (16 * 16)
                            //			 32x32 pixel texture max	256 bones * 4 pixels = (32 * 32)
                            //			 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
                            var size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                            size = MathUtils.ceilPowerOfTwo(size);
                            size = Math.max(size, 4);
                            var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                            boneMatrices.set(skeleton.boneMatrices); // copy current values
                            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                            skeleton.boneMatrices = boneMatrices;
                            skeleton.boneTexture = boneTexture;
                            skeleton.boneTextureSize = size;
                        }
                        p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                        p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                    } else p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
                }
            }
            if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
                materialProperties.receiveShadow = object.receiveShadow;
                p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
            }
            if (refreshMaterial) {
                p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
                if (materialProperties.needsLights) // the current material requires lighting info
                // note: all lighting uniforms are always set correctly
                // they simply reference the renderer's state for their
                // values
                //
                // use the current material's .needsUpdate flags to set
                // the GL state when required
                markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                 // refresh uniforms common to several materials
                if (fog && material.fog) materials.refreshFogUniforms(m_uniforms, fog);
                materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            }
            if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
                material.uniformsNeedUpdate = false;
            }
            if (material.isSpriteMaterial) p_uniforms.setValue(_gl, 'center', object.center);
             // common matrices
            p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
            p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
            p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
            return program;
        } // If uniforms are marked as clean, they don't need to be loaded to the GPU.
        function markUniformsLightsNeedsUpdate(uniforms, value) {
            uniforms.ambientLightColor.needsUpdate = value;
            uniforms.lightProbe.needsUpdate = value;
            uniforms.directionalLights.needsUpdate = value;
            uniforms.directionalLightShadows.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.pointLightShadows.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.spotLightShadows.needsUpdate = value;
            uniforms.rectAreaLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
        }
        function materialNeedsLights(material) {
            return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
        } //
        this.setFramebuffer = function(value) {
            if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(36160, value);
            _framebuffer = value;
        };
        this.getActiveCubeFace = function() {
            return _currentActiveCubeFace;
        };
        this.getActiveMipmapLevel = function() {
            return _currentActiveMipmapLevel;
        };
        this.getRenderList = function() {
            return currentRenderList;
        };
        this.setRenderList = function(renderList) {
            currentRenderList = renderList;
        };
        this.getRenderTarget = function() {
            return _currentRenderTarget;
        };
        this.setRenderTarget = function(renderTarget, activeCubeFace, activeMipmapLevel) {
            if (activeCubeFace === void 0) activeCubeFace = 0;
            if (activeMipmapLevel === void 0) activeMipmapLevel = 0;
            _currentRenderTarget = renderTarget;
            _currentActiveCubeFace = activeCubeFace;
            _currentActiveMipmapLevel = activeMipmapLevel;
            if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) textures.setupRenderTarget(renderTarget);
            var framebuffer = _framebuffer;
            var isCube = false;
            if (renderTarget) {
                var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
                if (renderTarget.isWebGLCubeRenderTarget) {
                    framebuffer = __webglFramebuffer[activeCubeFace];
                    isCube = true;
                } else if (renderTarget.isWebGLMultisampleRenderTarget) framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
                else framebuffer = __webglFramebuffer;
                _currentViewport.copy(renderTarget.viewport);
                _currentScissor.copy(renderTarget.scissor);
                _currentScissorTest = renderTarget.scissorTest;
            } else {
                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
                _currentScissorTest = _scissorTest;
            }
            if (_currentFramebuffer !== framebuffer) {
                _gl.bindFramebuffer(36160, framebuffer);
                _currentFramebuffer = framebuffer;
            }
            state.viewport(_currentViewport);
            state.scissor(_currentScissor);
            state.setScissorTest(_currentScissorTest);
            if (isCube) {
                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
            }
        };
        this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
            if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                return;
            }
            var framebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) framebuffer = framebuffer[activeCubeFaceIndex];
            if (framebuffer) {
                var restore = false;
                if (framebuffer !== _currentFramebuffer) {
                    _gl.bindFramebuffer(36160, framebuffer);
                    restore = true;
                }
                try {
                    var texture = renderTarget.texture;
                    var textureFormat = texture.format;
                    var textureType = texture.type;
                    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                        return;
                    }
                    var halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));
                    if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && !halfFloatSupportedByExt) {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                        return;
                    }
                    if (_gl.checkFramebufferStatus(36160) === 36053) // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                    {
                        if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                    } else console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                } finally{
                    if (restore) _gl.bindFramebuffer(36160, _currentFramebuffer);
                }
            }
        };
        this.copyFramebufferToTexture = function(position, texture, level) {
            if (level === void 0) level = 0;
            var levelScale = Math.pow(2, -level);
            var width = Math.floor(texture.image.width * levelScale);
            var height = Math.floor(texture.image.height * levelScale);
            var glFormat = utils.convert(texture.format);
            textures.setTexture2D(texture, 0);
            _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
            state.unbindTexture();
        };
        this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
            if (level === void 0) level = 0;
            var width = srcTexture.image.width;
            var height = srcTexture.image.height;
            var glFormat = utils.convert(dstTexture.format);
            var glType = utils.convert(dstTexture.type);
            textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei
            // parameters, make sure they are correct for the dstTexture
            _gl.pixelStorei(37440, dstTexture.flipY);
            _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
            _gl.pixelStorei(3317, dstTexture.unpackAlignment);
            if (srcTexture.isDataTexture) _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
            else if (srcTexture.isCompressedTexture) _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
            else _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
             // Generate mipmaps only when copying level 0
            if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
            state.unbindTexture();
        };
        this.initTexture = function(texture) {
            textures.setTexture2D(texture, 0);
            state.unbindTexture();
        };
        this.resetState = function() {
            state.reset();
            bindingStates.reset();
        };
        if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
            detail: this
        })); // eslint-disable-line no-undef
    }
    function WebGL1Renderer(parameters) {
        WebGLRenderer.call(this, parameters);
    }
    WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {
        constructor: WebGL1Renderer,
        isWebGL1Renderer: true
    });
    var FogExp2 = /*#__PURE__*/ function() {
        function FogExp21(color, density) {
            Object.defineProperty(this, 'isFogExp2', {
                value: true
            });
            this.name = '';
            this.color = new Color(color);
            this.density = density !== undefined ? density : 0.00025;
        }
        var _proto = FogExp21.prototype;
        _proto.clone = function clone() {
            return new FogExp21(this.color, this.density);
        };
        _proto.toJSON = function toJSON() /* meta */ {
            return {
                type: 'FogExp2',
                color: this.color.getHex(),
                density: this.density
            };
        };
        return FogExp21;
    }();
    var Fog = /*#__PURE__*/ function() {
        function Fog1(color, near, far) {
            Object.defineProperty(this, 'isFog', {
                value: true
            });
            this.name = '';
            this.color = new Color(color);
            this.near = near !== undefined ? near : 1;
            this.far = far !== undefined ? far : 1000;
        }
        var _proto = Fog1.prototype;
        _proto.clone = function clone() {
            return new Fog1(this.color, this.near, this.far);
        };
        _proto.toJSON = function toJSON() /* meta */ {
            return {
                type: 'Fog',
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            };
        };
        return Fog1;
    }();
    var Scene1 = /*#__PURE__*/ function(_Object3D) {
        _inheritsLoose(Scene2, _Object3D);
        function Scene2() {
            var _this;
            _this = _Object3D.call(this) || this;
            Object.defineProperty(_assertThisInitialized(_this), 'isScene', {
                value: true
            });
            _this.type = 'Scene';
            _this.background = null;
            _this.environment = null;
            _this.fog = null;
            _this.overrideMaterial = null;
            _this.autoUpdate = true; // checked by the renderer
            if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
                detail: _assertThisInitialized(_this)
            })); // eslint-disable-line no-undef
            return _this;
        }
        var _proto = Scene2.prototype;
        _proto.copy = function copy(source, recursive) {
            _Object3D.prototype.copy.call(this, source, recursive);
            if (source.background !== null) this.background = source.background.clone();
            if (source.environment !== null) this.environment = source.environment.clone();
            if (source.fog !== null) this.fog = source.fog.clone();
            if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
            this.autoUpdate = source.autoUpdate;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            return this;
        };
        _proto.toJSON = function toJSON(meta) {
            var data = _Object3D.prototype.toJSON.call(this, meta);
            if (this.background !== null) data.object.background = this.background.toJSON(meta);
            if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
            if (this.fog !== null) data.object.fog = this.fog.toJSON();
            return data;
        };
        return Scene2;
    }(Object3D);
    function InterleavedBuffer(array, stride) {
        this.array = array;
        this.stride = stride;
        this.count = array !== undefined ? array.length / stride : 0;
        this.usage = StaticDrawUsage;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0;
        this.uuid = MathUtils.generateUUID();
    }
    Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
        set: function set(value) {
            if (value === true) this.version++;
        }
    });
    Object.assign(InterleavedBuffer.prototype, {
        isInterleavedBuffer: true,
        onUploadCallback: function onUploadCallback() {
        },
        setUsage: function setUsage(value) {
            this.usage = value;
            return this;
        },
        copy: function copy(source) {
            this.array = new source.array.constructor(source.array);
            this.count = source.count;
            this.stride = source.stride;
            this.usage = source.usage;
            return this;
        },
        copyAt: function copyAt(index1, attribute, index2) {
            index1 *= this.stride;
            index2 *= attribute.stride;
            for(var i29 = 0, l = this.stride; i29 < l; i29++)this.array[index1 + i29] = attribute.array[index2 + i29];
            return this;
        },
        set: function set(value, offset) {
            if (offset === void 0) offset = 0;
            this.array.set(value, offset);
            return this;
        },
        clone: function clone(data) {
            if (data.arrayBuffers === undefined) data.arrayBuffers = {
            };
            if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = MathUtils.generateUUID();
            if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
            var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
            var ib = new InterleavedBuffer(array, this.stride);
            ib.setUsage(this.usage);
            return ib;
        },
        onUpload: function onUpload(callback) {
            this.onUploadCallback = callback;
            return this;
        },
        toJSON: function toJSON(data) {
            if (data.arrayBuffers === undefined) data.arrayBuffers = {
            };
             // generate UUID for array buffer if necessary
            if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = MathUtils.generateUUID();
            if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
             //
            return {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            };
        }
    });
    var _vector$6 = new Vector3();
    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
        this.name = '';
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.normalized = normalized === true;
    }
    Object.defineProperties(InterleavedBufferAttribute.prototype, {
        count: {
            get: function get() {
                return this.data.count;
            }
        },
        array: {
            get: function get() {
                return this.data.array;
            }
        },
        needsUpdate: {
            set: function set(value) {
                this.data.needsUpdate = value;
            }
        }
    });
    Object.assign(InterleavedBufferAttribute.prototype, {
        isInterleavedBufferAttribute: true,
        applyMatrix4: function applyMatrix4(m) {
            for(var i29 = 0, l = this.data.count; i29 < l; i29++){
                _vector$6.x = this.getX(i29);
                _vector$6.y = this.getY(i29);
                _vector$6.z = this.getZ(i29);
                _vector$6.applyMatrix4(m);
                this.setXYZ(i29, _vector$6.x, _vector$6.y, _vector$6.z);
            }
            return this;
        },
        setX: function setX(index, x) {
            this.data.array[index * this.data.stride + this.offset] = x;
            return this;
        },
        setY: function setY(index, y) {
            this.data.array[index * this.data.stride + this.offset + 1] = y;
            return this;
        },
        setZ: function setZ(index, z) {
            this.data.array[index * this.data.stride + this.offset + 2] = z;
            return this;
        },
        setW: function setW(index, w) {
            this.data.array[index * this.data.stride + this.offset + 3] = w;
            return this;
        },
        getX: function getX(index) {
            return this.data.array[index * this.data.stride + this.offset];
        },
        getY: function getY(index) {
            return this.data.array[index * this.data.stride + this.offset + 1];
        },
        getZ: function getZ(index) {
            return this.data.array[index * this.data.stride + this.offset + 2];
        },
        getW: function getW(index) {
            return this.data.array[index * this.data.stride + this.offset + 3];
        },
        setXY: function setXY(index, x, y) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            return this;
        },
        setXYZ: function setXYZ(index, x, y, z) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            return this;
        },
        setXYZW: function setXYZW(index, x, y, z, w) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            this.data.array[index + 3] = w;
            return this;
        },
        clone: function clone(data) {
            if (data === undefined) {
                console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
                var array = [];
                for(var i29 = 0; i29 < this.count; i29++){
                    var index = i29 * this.data.stride + this.offset;
                    for(var j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
                }
                return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
            } else {
                if (data.interleavedBuffers === undefined) data.interleavedBuffers = {
                };
                if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
                return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
            }
        },
        toJSON: function toJSON(data) {
            if (data === undefined) {
                console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
                var array = [];
                for(var i30 = 0; i30 < this.count; i30++){
                    var index = i30 * this.data.stride + this.offset;
                    for(var j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
                } // deinterleave data and save it as an ordinary buffer attribute for now
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: array,
                    normalized: this.normalized
                };
            } else {
                // save as true interlaved attribtue
                if (data.interleavedBuffers === undefined) data.interleavedBuffers = {
                };
                if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
                return {
                    isInterleavedBufferAttribute: true,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                };
            }
        }
    });
    /**
	 * parameters = {
	 *	color: <hex>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *	rotation: <float>,
	 *	sizeAttenuation: <bool>
	 * }
	 */ function SpriteMaterial(parameters) {
        Material.call(this);
        this.type = 'SpriteMaterial';
        this.color = new Color(16777215);
        this.map = null;
        this.alphaMap = null;
        this.rotation = 0;
        this.sizeAttenuation = true;
        this.transparent = true;
        this.setValues(parameters);
    }
    SpriteMaterial.prototype = Object.create(Material.prototype);
    SpriteMaterial.prototype.constructor = SpriteMaterial;
    SpriteMaterial.prototype.isSpriteMaterial = true;
    SpriteMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.rotation = source.rotation;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
    };
    var _geometry;
    var _intersectPoint = new Vector3();
    var _worldScale = new Vector3();
    var _mvPosition = new Vector3();
    var _alignedPosition = new Vector2();
    var _rotatedPosition = new Vector2();
    var _viewWorldMatrix = new Matrix4();
    var _vA$1 = new Vector3();
    var _vB$1 = new Vector3();
    var _vC$1 = new Vector3();
    var _uvA$1 = new Vector2();
    var _uvB$1 = new Vector2();
    var _uvC$1 = new Vector2();
    function Sprite(material) {
        Object3D.call(this);
        this.type = 'Sprite';
        if (_geometry === undefined) {
            _geometry = new BufferGeometry();
            var float32Array = new Float32Array([
                -0.5,
                -0.5,
                0,
                0,
                0,
                0.5,
                -0.5,
                0,
                1,
                0,
                0.5,
                0.5,
                0,
                1,
                1,
                -0.5,
                0.5,
                0,
                0,
                1
            ]);
            var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
            _geometry.setIndex([
                0,
                1,
                2,
                0,
                2,
                3
            ]);
            _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
            _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
        }
        this.geometry = _geometry;
        this.material = material !== undefined ? material : new SpriteMaterial();
        this.center = new Vector2(0.5, 0.5);
    }
    Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Sprite,
        isSprite: true,
        raycast: function raycast(raycaster, intersects) {
            if (raycaster.camera === null) console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
            _worldScale.setFromMatrixScale(this.matrixWorld);
            _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
            this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
            _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
            if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) _worldScale.multiplyScalar(-_mvPosition.z);
            var rotation = this.material.rotation;
            var sin, cos;
            if (rotation !== 0) {
                cos = Math.cos(rotation);
                sin = Math.sin(rotation);
            }
            var center2 = this.center;
            transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
            transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
            transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
            _uvA$1.set(0, 0);
            _uvB$1.set(1, 0);
            _uvC$1.set(1, 1); // check first triangle
            var intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
            if (intersect === null) {
                // check second triangle
                transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
                _uvB$1.set(0, 1);
                intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
                if (intersect === null) return;
            }
            var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far) return;
            intersects.push({
                distance: distance,
                point: _intersectPoint.clone(),
                uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
                face: null,
                object: this
            });
        },
        copy: function copy(source) {
            Object3D.prototype.copy.call(this, source);
            if (source.center !== undefined) this.center.copy(source.center);
            this.material = source.material;
            return this;
        }
    });
    function transformVertex(vertexPosition, mvPosition, center2, scale, sin, cos) {
        // compute position in camera space
        _alignedPosition.subVectors(vertexPosition, center2).addScalar(0.5).multiply(scale); // to check if rotation is not zero
        if (sin !== undefined) {
            _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
            _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
        } else _rotatedPosition.copy(_alignedPosition);
        vertexPosition.copy(mvPosition);
        vertexPosition.x += _rotatedPosition.x;
        vertexPosition.y += _rotatedPosition.y; // transform to world space
        vertexPosition.applyMatrix4(_viewWorldMatrix);
    }
    var _v1$4 = new Vector3();
    var _v2$2 = new Vector3();
    function LOD() {
        Object3D.call(this);
        this._currentLevel = 0;
        this.type = 'LOD';
        Object.defineProperties(this, {
            levels: {
                enumerable: true,
                value: []
            }
        });
        this.autoUpdate = true;
    }
    LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LOD,
        isLOD: true,
        copy: function copy(source) {
            Object3D.prototype.copy.call(this, source, false);
            var levels = source.levels;
            for(var i31 = 0, l = levels.length; i31 < l; i31++){
                var level = levels[i31];
                this.addLevel(level.object.clone(), level.distance);
            }
            this.autoUpdate = source.autoUpdate;
            return this;
        },
        addLevel: function addLevel(object, distance) {
            if (distance === void 0) distance = 0;
            distance = Math.abs(distance);
            var levels = this.levels;
            var l;
            for(l = 0; l < levels.length; l++){
                if (distance < levels[l].distance) break;
            }
            levels.splice(l, 0, {
                distance: distance,
                object: object
            });
            this.add(object);
            return this;
        },
        getCurrentLevel: function getCurrentLevel() {
            return this._currentLevel;
        },
        getObjectForDistance: function getObjectForDistance(distance) {
            var levels = this.levels;
            if (levels.length > 0) {
                var i31, l;
                for(i31 = 1, l = levels.length; i31 < l; i31++){
                    if (distance < levels[i31].distance) break;
                }
                return levels[i31 - 1].object;
            }
            return null;
        },
        raycast: function raycast(raycaster, intersects) {
            var levels = this.levels;
            if (levels.length > 0) {
                _v1$4.setFromMatrixPosition(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(_v1$4);
                this.getObjectForDistance(distance).raycast(raycaster, intersects);
            }
        },
        update: function update(camera) {
            var levels = this.levels;
            if (levels.length > 1) {
                _v1$4.setFromMatrixPosition(camera.matrixWorld);
                _v2$2.setFromMatrixPosition(this.matrixWorld);
                var distance = _v1$4.distanceTo(_v2$2) / camera.zoom;
                levels[0].object.visible = true;
                var i32, l;
                for(i32 = 1, l = levels.length; i32 < l; i32++){
                    if (distance >= levels[i32].distance) {
                        levels[i32 - 1].object.visible = false;
                        levels[i32].object.visible = true;
                    } else break;
                }
                this._currentLevel = i32 - 1;
                for(; i32 < l; i32++)levels[i32].object.visible = false;
            }
        },
        toJSON: function toJSON(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            if (this.autoUpdate === false) data.object.autoUpdate = false;
            data.object.levels = [];
            var levels = this.levels;
            for(var i33 = 0, l = levels.length; i33 < l; i33++){
                var level = levels[i33];
                data.object.levels.push({
                    object: level.object.uuid,
                    distance: level.distance
                });
            }
            return data;
        }
    });
    var _basePosition = new Vector3();
    var _skinIndex = new Vector4();
    var _skinWeight = new Vector4();
    var _vector$7 = new Vector3();
    var _matrix$1 = new Matrix4();
    function SkinnedMesh(geometry, material) {
        if (geometry && geometry.isGeometry) console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        Mesh.call(this, geometry, material);
        this.type = 'SkinnedMesh';
        this.bindMode = 'attached';
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();
    }
    SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
        constructor: SkinnedMesh,
        isSkinnedMesh: true,
        copy: function copy(source) {
            Mesh.prototype.copy.call(this, source);
            this.bindMode = source.bindMode;
            this.bindMatrix.copy(source.bindMatrix);
            this.bindMatrixInverse.copy(source.bindMatrixInverse);
            this.skeleton = source.skeleton;
            return this;
        },
        bind: function bind(skeleton, bindMatrix) {
            this.skeleton = skeleton;
            if (bindMatrix === undefined) {
                this.updateMatrixWorld(true);
                this.skeleton.calculateInverses();
                bindMatrix = this.matrixWorld;
            }
            this.bindMatrix.copy(bindMatrix);
            this.bindMatrixInverse.copy(bindMatrix).invert();
        },
        pose: function pose() {
            this.skeleton.pose();
        },
        normalizeSkinWeights: function normalizeSkinWeights() {
            var vector = new Vector4();
            var skinWeight = this.geometry.attributes.skinWeight;
            for(var i33 = 0, l = skinWeight.count; i33 < l; i33++){
                vector.x = skinWeight.getX(i33);
                vector.y = skinWeight.getY(i33);
                vector.z = skinWeight.getZ(i33);
                vector.w = skinWeight.getW(i33);
                var scale = 1 / vector.manhattanLength();
                if (scale !== Infinity) vector.multiplyScalar(scale);
                else vector.set(1, 0, 0, 0); // do something reasonable
                skinWeight.setXYZW(i33, vector.x, vector.y, vector.z, vector.w);
            }
        },
        updateMatrixWorld: function updateMatrixWorld(force) {
            Mesh.prototype.updateMatrixWorld.call(this, force);
            if (this.bindMode === 'attached') this.bindMatrixInverse.copy(this.matrixWorld).invert();
            else if (this.bindMode === 'detached') this.bindMatrixInverse.copy(this.bindMatrix).invert();
            else console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
        },
        boneTransform: function boneTransform(index, target) {
            var skeleton = this.skeleton;
            var geometry = this.geometry;
            _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
            _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
            _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
            target.set(0, 0, 0);
            for(var i33 = 0; i33 < 4; i33++){
                var weight = _skinWeight.getComponent(i33);
                if (weight !== 0) {
                    var boneIndex = _skinIndex.getComponent(i33);
                    _matrix$1.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                    target.addScaledVector(_vector$7.copy(_basePosition).applyMatrix4(_matrix$1), weight);
                }
            }
            return target.applyMatrix4(this.bindMatrixInverse);
        }
    });
    function Bone() {
        Object3D.call(this);
        this.type = 'Bone';
    }
    Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Bone,
        isBone: true
    });
    var _offsetMatrix = new Matrix4();
    var _identityMatrix = new Matrix4();
    function Skeleton(bones, boneInverses) {
        if (bones === void 0) bones = [];
        if (boneInverses === void 0) boneInverses = [];
        this.uuid = MathUtils.generateUUID();
        this.bones = bones.slice(0);
        this.boneInverses = boneInverses;
        this.boneMatrices = null;
        this.boneTexture = null;
        this.boneTextureSize = 0;
        this.frame = -1;
        this.init();
    }
    Object.assign(Skeleton.prototype, {
        init: function init() {
            var bones = this.bones;
            var boneInverses = this.boneInverses;
            this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary
            if (boneInverses.length === 0) this.calculateInverses();
            else // handle special case
            if (bones.length !== boneInverses.length) {
                console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
                this.boneInverses = [];
                for(var i33 = 0, il = this.bones.length; i33 < il; i33++)this.boneInverses.push(new Matrix4());
            }
        },
        calculateInverses: function calculateInverses() {
            this.boneInverses.length = 0;
            for(var i34 = 0, il = this.bones.length; i34 < il; i34++){
                var inverse = new Matrix4();
                if (this.bones[i34]) inverse.copy(this.bones[i34].matrixWorld).invert();
                this.boneInverses.push(inverse);
            }
        },
        pose: function pose() {
            // recover the bind-time world matrices
            for(var i34 = 0, il = this.bones.length; i34 < il; i34++){
                var bone = this.bones[i34];
                if (bone) bone.matrixWorld.copy(this.boneInverses[i34]).invert();
            } // compute the local matrices, positions, rotations and scales
            for(var _i = 0, _il = this.bones.length; _i < _il; _i++){
                var _bone = this.bones[_i];
                if (_bone) {
                    if (_bone.parent && _bone.parent.isBone) {
                        _bone.matrix.copy(_bone.parent.matrixWorld).invert();
                        _bone.matrix.multiply(_bone.matrixWorld);
                    } else _bone.matrix.copy(_bone.matrixWorld);
                    _bone.matrix.decompose(_bone.position, _bone.quaternion, _bone.scale);
                }
            }
        },
        update: function update() {
            var bones = this.bones;
            var boneInverses = this.boneInverses;
            var boneMatrices = this.boneMatrices;
            var boneTexture = this.boneTexture; // flatten bone matrices to array
            for(var i34 = 0, il = bones.length; i34 < il; i34++){
                // compute the offset between the current and the original transform
                var matrix = bones[i34] ? bones[i34].matrixWorld : _identityMatrix;
                _offsetMatrix.multiplyMatrices(matrix, boneInverses[i34]);
                _offsetMatrix.toArray(boneMatrices, i34 * 16);
            }
            if (boneTexture !== null) boneTexture.needsUpdate = true;
        },
        clone: function clone() {
            return new Skeleton(this.bones, this.boneInverses);
        },
        getBoneByName: function getBoneByName(name) {
            for(var i34 = 0, il = this.bones.length; i34 < il; i34++){
                var bone = this.bones[i34];
                if (bone.name === name) return bone;
            }
            return undefined;
        },
        dispose: function dispose() {
            if (this.boneTexture !== null) {
                this.boneTexture.dispose();
                this.boneTexture = null;
            }
        },
        fromJSON: function fromJSON(json, bones) {
            this.uuid = json.uuid;
            for(var i34 = 0, l = json.bones.length; i34 < l; i34++){
                var uuid = json.bones[i34];
                var bone = bones[uuid];
                if (bone === undefined) {
                    console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
                    bone = new Bone();
                }
                this.bones.push(bone);
                this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i34]));
            }
            this.init();
            return this;
        },
        toJSON: function toJSON() {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Skeleton',
                    generator: 'Skeleton.toJSON'
                },
                bones: [],
                boneInverses: []
            };
            data.uuid = this.uuid;
            var bones = this.bones;
            var boneInverses = this.boneInverses;
            for(var i34 = 0, l = bones.length; i34 < l; i34++){
                var bone = bones[i34];
                data.bones.push(bone.uuid);
                var boneInverse = boneInverses[i34];
                data.boneInverses.push(boneInverse.toArray());
            }
            return data;
        }
    });
    var _instanceLocalMatrix = new Matrix4();
    var _instanceWorldMatrix = new Matrix4();
    var _instanceIntersects = [];
    var _mesh = new Mesh();
    function InstancedMesh(geometry, material, count) {
        Mesh.call(this, geometry, material);
        this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
        this.instanceColor = null;
        this.count = count;
        this.frustumCulled = false;
    }
    InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
        constructor: InstancedMesh,
        isInstancedMesh: true,
        copy: function copy(source) {
            Mesh.prototype.copy.call(this, source);
            this.instanceMatrix.copy(source.instanceMatrix);
            if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
            this.count = source.count;
            return this;
        },
        getColorAt: function getColorAt(index, color) {
            color.fromArray(this.instanceColor.array, index * 3);
        },
        getMatrixAt: function getMatrixAt(index, matrix) {
            matrix.fromArray(this.instanceMatrix.array, index * 16);
        },
        raycast: function raycast(raycaster, intersects) {
            var matrixWorld = this.matrixWorld;
            var raycastTimes = this.count;
            _mesh.geometry = this.geometry;
            _mesh.material = this.material;
            if (_mesh.material === undefined) return;
            for(var instanceId = 0; instanceId < raycastTimes; instanceId++){
                // calculate the world matrix for each instance
                this.getMatrixAt(instanceId, _instanceLocalMatrix);
                _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance
                _mesh.matrixWorld = _instanceWorldMatrix;
                _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast
                for(var i34 = 0, l = _instanceIntersects.length; i34 < l; i34++){
                    var intersect = _instanceIntersects[i34];
                    intersect.instanceId = instanceId;
                    intersect.object = this;
                    intersects.push(intersect);
                }
                _instanceIntersects.length = 0;
            }
        },
        setColorAt: function setColorAt(index, color) {
            if (this.instanceColor === null) this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
            color.toArray(this.instanceColor.array, index * 3);
        },
        setMatrixAt: function setMatrixAt(index, matrix) {
            matrix.toArray(this.instanceMatrix.array, index * 16);
        },
        updateMorphTargets: function updateMorphTargets() {
        },
        dispose: function dispose() {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });
    /**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *	linecap: "round",
	 *	linejoin: "round"
	 * }
	 */ function LineBasicMaterial(parameters) {
        Material.call(this);
        this.type = 'LineBasicMaterial';
        this.color = new Color(16777215);
        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';
        this.morphTargets = false;
        this.setValues(parameters);
    }
    LineBasicMaterial.prototype = Object.create(Material.prototype);
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;
    LineBasicMaterial.prototype.isLineBasicMaterial = true;
    LineBasicMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        this.morphTargets = source.morphTargets;
        return this;
    };
    var _start = new Vector3();
    var _end = new Vector3();
    var _inverseMatrix$1 = new Matrix4();
    var _ray$1 = new Ray();
    var _sphere$2 = new Sphere();
    function Line(geometry, material) {
        if (geometry === void 0) geometry = new BufferGeometry();
        if (material === void 0) material = new LineBasicMaterial();
        Object3D.call(this);
        this.type = 'Line';
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
    }
    Line.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Line,
        isLine: true,
        copy: function copy(source) {
            Object3D.prototype.copy.call(this, source);
            this.material = source.material;
            this.geometry = source.geometry;
            return this;
        },
        computeLineDistances: function computeLineDistances() {
            var geometry = this.geometry;
            if (geometry.isBufferGeometry) {
                // we assume non-indexed geometry
                if (geometry.index === null) {
                    var positionAttribute = geometry.attributes.position;
                    var lineDistances = [
                        0
                    ];
                    for(var i35 = 1, l = positionAttribute.count; i35 < l; i35++){
                        _start.fromBufferAttribute(positionAttribute, i35 - 1);
                        _end.fromBufferAttribute(positionAttribute, i35);
                        lineDistances[i35] = lineDistances[i35 - 1];
                        lineDistances[i35] += _start.distanceTo(_end);
                    }
                    geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
                } else console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
            } else if (geometry.isGeometry) console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
            return this;
        },
        raycast: function raycast(raycaster, intersects) {
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            var threshold = raycaster.params.Line.threshold; // Checking boundingSphere distance to ray
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            _sphere$2.copy(geometry.boundingSphere);
            _sphere$2.applyMatrix4(matrixWorld);
            _sphere$2.radius += threshold;
            if (raycaster.ray.intersectsSphere(_sphere$2) === false) return; //
            _inverseMatrix$1.copy(matrixWorld).invert();
            _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
            var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
            var localThresholdSq = localThreshold * localThreshold;
            var vStart = new Vector3();
            var vEnd = new Vector3();
            var interSegment = new Vector3();
            var interRay = new Vector3();
            var step = this.isLineSegments ? 2 : 1;
            if (geometry.isBufferGeometry) {
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positionAttribute = attributes.position;
                if (index !== null) {
                    var indices = index.array;
                    for(var i36 = 0, l = indices.length - 1; i36 < l; i36 += step){
                        var a = indices[i36];
                        var b = indices[i36 + 1];
                        vStart.fromBufferAttribute(positionAttribute, a);
                        vEnd.fromBufferAttribute(positionAttribute, b);
                        var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                        if (distSq > localThresholdSq) continue;
                        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                        var distance = raycaster.ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far) continue;
                        intersects.push({
                            distance: distance,
                            // What do we want? intersection point on the ray or on the segment??
                            // point: raycaster.ray.at( distance ),
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i36,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                } else for(var _i = 0, _l = positionAttribute.count - 1; _i < _l; _i += step){
                    vStart.fromBufferAttribute(positionAttribute, _i);
                    vEnd.fromBufferAttribute(positionAttribute, _i + 1);
                    var _distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (_distSq > localThresholdSq) continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    var _distance = raycaster.ray.origin.distanceTo(interRay);
                    if (_distance < raycaster.near || _distance > raycaster.far) continue;
                    intersects.push({
                        distance: _distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: _i,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            } else if (geometry.isGeometry) console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        },
        updateMorphTargets: function updateMorphTargets() {
            var geometry = this.geometry;
            if (geometry.isBufferGeometry) {
                var morphAttributes = geometry.morphAttributes;
                var keys = Object.keys(morphAttributes);
                if (keys.length > 0) {
                    var morphAttribute = morphAttributes[keys[0]];
                    if (morphAttribute !== undefined) {
                        this.morphTargetInfluences = [];
                        this.morphTargetDictionary = {
                        };
                        for(var m = 0, ml = morphAttribute.length; m < ml; m++){
                            var name = morphAttribute[m].name || String(m);
                            this.morphTargetInfluences.push(0);
                            this.morphTargetDictionary[name] = m;
                        }
                    }
                }
            } else {
                var morphTargets = geometry.morphTargets;
                if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
            }
        }
    });
    var _start$1 = new Vector3();
    var _end$1 = new Vector3();
    function LineSegments(geometry, material) {
        Line.call(this, geometry, material);
        this.type = 'LineSegments';
    }
    LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineSegments,
        isLineSegments: true,
        computeLineDistances: function computeLineDistances() {
            var geometry = this.geometry;
            if (geometry.isBufferGeometry) {
                // we assume non-indexed geometry
                if (geometry.index === null) {
                    var positionAttribute = geometry.attributes.position;
                    var lineDistances = [];
                    for(var i37 = 0, l = positionAttribute.count; i37 < l; i37 += 2){
                        _start$1.fromBufferAttribute(positionAttribute, i37);
                        _end$1.fromBufferAttribute(positionAttribute, i37 + 1);
                        lineDistances[i37] = i37 === 0 ? 0 : lineDistances[i37 - 1];
                        lineDistances[i37 + 1] = lineDistances[i37] + _start$1.distanceTo(_end$1);
                    }
                    geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
                } else console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
            } else if (geometry.isGeometry) console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
            return this;
        }
    });
    function LineLoop(geometry, material) {
        Line.call(this, geometry, material);
        this.type = 'LineLoop';
    }
    LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineLoop,
        isLineLoop: true
    });
    /**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	size: <float>,
	 *	sizeAttenuation: <bool>
	 *
	 *	morphTargets: <bool>
	 * }
	 */ function PointsMaterial(parameters) {
        Material.call(this);
        this.type = 'PointsMaterial';
        this.color = new Color(16777215);
        this.map = null;
        this.alphaMap = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.morphTargets = false;
        this.setValues(parameters);
    }
    PointsMaterial.prototype = Object.create(Material.prototype);
    PointsMaterial.prototype.constructor = PointsMaterial;
    PointsMaterial.prototype.isPointsMaterial = true;
    PointsMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        this.morphTargets = source.morphTargets;
        return this;
    };
    var _inverseMatrix$2 = new Matrix4();
    var _ray$2 = new Ray();
    var _sphere$3 = new Sphere();
    var _position$1 = new Vector3();
    function Points(geometry, material) {
        if (geometry === void 0) geometry = new BufferGeometry();
        if (material === void 0) material = new PointsMaterial();
        Object3D.call(this);
        this.type = 'Points';
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
    }
    Points.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Points,
        isPoints: true,
        copy: function copy(source) {
            Object3D.prototype.copy.call(this, source);
            this.material = source.material;
            this.geometry = source.geometry;
            return this;
        },
        raycast: function raycast(raycaster, intersects) {
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            var threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            _sphere$3.copy(geometry.boundingSphere);
            _sphere$3.applyMatrix4(matrixWorld);
            _sphere$3.radius += threshold;
            if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //
            _inverseMatrix$2.copy(matrixWorld).invert();
            _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
            var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
            var localThresholdSq = localThreshold * localThreshold;
            if (geometry.isBufferGeometry) {
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positionAttribute = attributes.position;
                if (index !== null) {
                    var indices = index.array;
                    for(var i38 = 0, il = indices.length; i38 < il; i38++){
                        var a = indices[i38];
                        _position$1.fromBufferAttribute(positionAttribute, a);
                        testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
                    }
                } else for(var _i = 0, l = positionAttribute.count; _i < l; _i++){
                    _position$1.fromBufferAttribute(positionAttribute, _i);
                    testPoint(_position$1, _i, localThresholdSq, matrixWorld, raycaster, intersects, this);
                }
            } else console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        },
        updateMorphTargets: function updateMorphTargets() {
            var geometry = this.geometry;
            if (geometry.isBufferGeometry) {
                var morphAttributes = geometry.morphAttributes;
                var keys = Object.keys(morphAttributes);
                if (keys.length > 0) {
                    var morphAttribute = morphAttributes[keys[0]];
                    if (morphAttribute !== undefined) {
                        this.morphTargetInfluences = [];
                        this.morphTargetDictionary = {
                        };
                        for(var m = 0, ml = morphAttribute.length; m < ml; m++){
                            var name = morphAttribute[m].name || String(m);
                            this.morphTargetInfluences.push(0);
                            this.morphTargetDictionary[name] = m;
                        }
                    }
                }
            } else {
                var morphTargets = geometry.morphTargets;
                if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
            }
        }
    });
    function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
        var rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
            var intersectPoint = new Vector3();
            _ray$2.closestPointToPoint(point, intersectPoint);
            intersectPoint.applyMatrix4(matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far) return;
            intersects.push({
                distance: distance,
                distanceToRay: Math.sqrt(rayPointDistanceSq),
                point: intersectPoint,
                index: index,
                face: null,
                object: object
            });
        }
    }
    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.format = format !== undefined ? format : RGBFormat;
        this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
        this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
        this.generateMipmaps = false;
        var scope = this;
        function updateVideo() {
            scope.needsUpdate = true;
            video.requestVideoFrameCallback(updateVideo);
        }
        if ('requestVideoFrameCallback' in video) video.requestVideoFrameCallback(updateVideo);
    }
    VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
        constructor: VideoTexture,
        clone: function clone() {
            return new this.constructor(this.image).copy(this);
        },
        isVideoTexture: true,
        update: function update() {
            var video = this.image;
            var hasVideoFrameCallback = 'requestVideoFrameCallback' in video;
            if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) this.needsUpdate = true;
        }
    });
    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = {
            width: width,
            height: height
        };
        this.mipmaps = mipmaps; // no flipping for cube textures
        // (also flipping doesn't work for compressed textures )
        this.flipY = false; // can't generate mipmaps for compressed textures
        // mips must be embedded in DDS files
        this.generateMipmaps = false;
    }
    CompressedTexture.prototype = Object.create(Texture.prototype);
    CompressedTexture.prototype.constructor = CompressedTexture;
    CompressedTexture.prototype.isCompressedTexture = true;
    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
    }
    CanvasTexture.prototype = Object.create(Texture.prototype);
    CanvasTexture.prototype.constructor = CanvasTexture;
    CanvasTexture.prototype.isCanvasTexture = true;
    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        format = format !== undefined ? format : DepthFormat;
        if (format !== DepthFormat && format !== DepthStencilFormat) throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
        if (type === undefined && format === DepthFormat) type = UnsignedShortType;
        if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.image = {
            width: width,
            height: height
        };
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
        this.flipY = false;
        this.generateMipmaps = false;
    }
    DepthTexture.prototype = Object.create(Texture.prototype);
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;
    var CircleGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(CircleGeometry2, _BufferGeometry);
        function CircleGeometry2(radius, segments, thetaStart, thetaLength) {
            var _this;
            if (radius === void 0) radius = 1;
            if (segments === void 0) segments = 8;
            if (thetaStart === void 0) thetaStart = 0;
            if (thetaLength === void 0) thetaLength = Math.PI * 2;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'CircleGeometry';
            _this.parameters = {
                radius: radius,
                segments: segments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            segments = Math.max(3, segments); // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = []; // helper variables
            var vertex = new Vector3();
            var uv = new Vector2(); // center point
            vertices.push(0, 0, 0);
            normals.push(0, 0, 1);
            uvs.push(0.5, 0.5);
            for(var s = 0, i39 = 3; s <= segments; s++, i39 += 3){
                var segment = thetaStart + s / segments * thetaLength; // vertex
                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);
                vertices.push(vertex.x, vertex.y, vertex.z); // normal
                normals.push(0, 0, 1); // uvs
                uv.x = (vertices[i39] / radius + 1) / 2;
                uv.y = (vertices[i39 + 1] / radius + 1) / 2;
                uvs.push(uv.x, uv.y);
            } // indices
            for(var _i = 1; _i <= segments; _i++)indices.push(_i, _i + 1, 0);
             // build geometry
            _this.setIndex(indices);
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            return _this;
        }
        return CircleGeometry2;
    }(BufferGeometry);
    var CylinderGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(CylinderGeometry2, _BufferGeometry);
        function CylinderGeometry2(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            var _this;
            if (radiusTop === void 0) radiusTop = 1;
            if (radiusBottom === void 0) radiusBottom = 1;
            if (height === void 0) height = 1;
            if (radialSegments === void 0) radialSegments = 8;
            if (heightSegments === void 0) heightSegments = 1;
            if (openEnded === void 0) openEnded = false;
            if (thetaStart === void 0) thetaStart = 0;
            if (thetaLength === void 0) thetaLength = Math.PI * 2;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'CylinderGeometry';
            _this.parameters = {
                radiusTop: radiusTop,
                radiusBottom: radiusBottom,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            var scope = _assertThisInitialized(_this);
            radialSegments = Math.floor(radialSegments);
            heightSegments = Math.floor(heightSegments); // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = []; // helper variables
            var index = 0;
            var indexArray = [];
            var halfHeight = height / 2;
            var groupStart = 0; // generate geometry
            generateTorso();
            if (openEnded === false) {
                if (radiusTop > 0) generateCap(true);
                if (radiusBottom > 0) generateCap(false);
            } // build geometry
            _this.setIndex(indices);
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            function generateTorso() {
                var normal = new Vector3();
                var vertex = new Vector3();
                var groupCount = 0; // this will be used to calculate the normal
                var slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs
                for(var y = 0; y <= heightSegments; y++){
                    var indexRow = [];
                    var v = y / heightSegments; // calculate the radius of the current row
                    var radius = v * (radiusBottom - radiusTop) + radiusTop;
                    for(var x = 0; x <= radialSegments; x++){
                        var u = x / radialSegments;
                        var theta = u * thetaLength + thetaStart;
                        var sinTheta = Math.sin(theta);
                        var cosTheta = Math.cos(theta); // vertex
                        vertex.x = radius * sinTheta;
                        vertex.y = -v * height + halfHeight;
                        vertex.z = radius * cosTheta;
                        vertices.push(vertex.x, vertex.y, vertex.z); // normal
                        normal.set(sinTheta, slope, cosTheta).normalize();
                        normals.push(normal.x, normal.y, normal.z); // uv
                        uvs.push(u, 1 - v); // save index of vertex in respective row
                        indexRow.push(index++);
                    } // now save vertices of the row in our index array
                    indexArray.push(indexRow);
                } // generate indices
                for(var _x1 = 0; _x1 < radialSegments; _x1++)for(var _y1 = 0; _y1 < heightSegments; _y1++){
                    // we use the index array to access the correct indices
                    var a = indexArray[_y1][_x1];
                    var b = indexArray[_y1 + 1][_x1];
                    var c = indexArray[_y1 + 1][_x1 + 1];
                    var d = indexArray[_y1][_x1 + 1]; // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d); // update group counter
                    groupCount += 6;
                }
                 // add a group to the geometry. this will ensure multi material support
                scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups
                groupStart += groupCount;
            }
            function generateCap(top) {
                // save the index of the first center vertex
                var centerIndexStart = index;
                var uv = new Vector2();
                var vertex = new Vector3();
                var groupCount = 0;
                var radius = top === true ? radiusTop : radiusBottom;
                var sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
                // because the geometry needs one set of uvs per face,
                // we must generate a center vertex per face/segment
                for(var x = 1; x <= radialSegments; x++){
                    // vertex
                    vertices.push(0, halfHeight * sign, 0); // normal
                    normals.push(0, sign, 0); // uv
                    uvs.push(0.5, 0.5); // increase index
                    index++;
                } // save the index of the last center vertex
                var centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs
                for(var _x2 = 0; _x2 <= radialSegments; _x2++){
                    var u = _x2 / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var cosTheta = Math.cos(theta);
                    var sinTheta = Math.sin(theta); // vertex
                    vertex.x = radius * sinTheta;
                    vertex.y = halfHeight * sign;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z); // normal
                    normals.push(0, sign, 0); // uv
                    uv.x = cosTheta * 0.5 + 0.5;
                    uv.y = sinTheta * 0.5 * sign + 0.5;
                    uvs.push(uv.x, uv.y); // increase index
                    index++;
                } // generate indices
                for(var _x3 = 0; _x3 < radialSegments; _x3++){
                    var c = centerIndexStart + _x3;
                    var i39 = centerIndexEnd + _x3;
                    if (top === true) // face top
                    indices.push(i39, i39 + 1, c);
                    else // face bottom
                    indices.push(i39 + 1, i39, c);
                    groupCount += 3;
                } // add a group to the geometry. this will ensure multi material support
                scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups
                groupStart += groupCount;
            }
            return _this;
        }
        return CylinderGeometry2;
    }(BufferGeometry);
    var ConeGeometry1 = /*#__PURE__*/ function(_CylinderGeometry) {
        _inheritsLoose(ConeGeometry2, _CylinderGeometry);
        function ConeGeometry2(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
            var _this;
            if (radius === void 0) radius = 1;
            if (height === void 0) height = 1;
            if (radialSegments === void 0) radialSegments = 8;
            if (heightSegments === void 0) heightSegments = 1;
            if (openEnded === void 0) openEnded = false;
            if (thetaStart === void 0) thetaStart = 0;
            if (thetaLength === void 0) thetaLength = Math.PI * 2;
            _this = _CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) || this;
            _this.type = 'ConeGeometry';
            _this.parameters = {
                radius: radius,
                height: height,
                radialSegments: radialSegments,
                heightSegments: heightSegments,
                openEnded: openEnded,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            return _this;
        }
        return ConeGeometry2;
    }(CylinderGeometry1);
    var PolyhedronGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(PolyhedronGeometry2, _BufferGeometry);
        function PolyhedronGeometry2(vertices, indices, radius, detail) {
            var _this;
            if (radius === void 0) radius = 1;
            if (detail === void 0) detail = 0;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'PolyhedronGeometry';
            _this.parameters = {
                vertices: vertices,
                indices: indices,
                radius: radius,
                detail: detail
            }; // default buffer data
            var vertexBuffer = [];
            var uvBuffer = []; // the subdivision creates the vertex buffer data
            subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius
            applyRadius(radius); // finally, create the uv data
            generateUVs(); // build non-indexed geometry
            _this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
            _this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
            if (detail === 0) _this.computeVertexNormals(); // flat normals
            else _this.normalizeNormals(); // smooth normals
             // helper functions
            function subdivide(detail1) {
                var a = new Vector3();
                var b = new Vector3();
                var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value
                for(var i40 = 0; i40 < indices.length; i40 += 3){
                    // get the vertices of the face
                    getVertexByIndex(indices[i40 + 0], a);
                    getVertexByIndex(indices[i40 + 1], b);
                    getVertexByIndex(indices[i40 + 2], c); // perform subdivision
                    subdivideFace(a, b, c, detail1);
                }
            }
            function subdivideFace(a, b, c, detail1) {
                var cols = detail1 + 1; // we use this multidimensional array as a data structure for creating the subdivision
                var v = []; // construct all of the vertices for this subdivision
                for(var i40 = 0; i40 <= cols; i40++){
                    v[i40] = [];
                    var aj = a.clone().lerp(c, i40 / cols);
                    var bj = b.clone().lerp(c, i40 / cols);
                    var rows = cols - i40;
                    for(var j = 0; j <= rows; j++)if (j === 0 && i40 === cols) v[i40][j] = aj;
                    else v[i40][j] = aj.clone().lerp(bj, j / rows);
                } // construct all of the faces
                for(var _i = 0; _i < cols; _i++)for(var _j = 0; _j < 2 * (cols - _i) - 1; _j++){
                    var k = Math.floor(_j / 2);
                    if (_j % 2 === 0) {
                        pushVertex(v[_i][k + 1]);
                        pushVertex(v[_i + 1][k]);
                        pushVertex(v[_i][k]);
                    } else {
                        pushVertex(v[_i][k + 1]);
                        pushVertex(v[_i + 1][k + 1]);
                        pushVertex(v[_i + 1][k]);
                    }
                }
            }
            function applyRadius(radius1) {
                var vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex
                for(var i40 = 0; i40 < vertexBuffer.length; i40 += 3){
                    vertex.x = vertexBuffer[i40 + 0];
                    vertex.y = vertexBuffer[i40 + 1];
                    vertex.z = vertexBuffer[i40 + 2];
                    vertex.normalize().multiplyScalar(radius1);
                    vertexBuffer[i40 + 0] = vertex.x;
                    vertexBuffer[i40 + 1] = vertex.y;
                    vertexBuffer[i40 + 2] = vertex.z;
                }
            }
            function generateUVs() {
                var vertex = new Vector3();
                for(var i40 = 0; i40 < vertexBuffer.length; i40 += 3){
                    vertex.x = vertexBuffer[i40 + 0];
                    vertex.y = vertexBuffer[i40 + 1];
                    vertex.z = vertexBuffer[i40 + 2];
                    var u = azimuth(vertex) / 2 / Math.PI + 0.5;
                    var v = inclination(vertex) / Math.PI + 0.5;
                    uvBuffer.push(u, 1 - v);
                }
                correctUVs();
                correctSeam();
            }
            function correctSeam() {
                // handle case when face straddles the seam, see #3269
                for(var i40 = 0; i40 < uvBuffer.length; i40 += 6){
                    // uv data of a single face
                    var x0 = uvBuffer[i40 + 0];
                    var x1 = uvBuffer[i40 + 2];
                    var x2 = uvBuffer[i40 + 4];
                    var max = Math.max(x0, x1, x2);
                    var min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary
                    if (max > 0.9 && min < 0.1) {
                        if (x0 < 0.2) uvBuffer[i40 + 0] += 1;
                        if (x1 < 0.2) uvBuffer[i40 + 2] += 1;
                        if (x2 < 0.2) uvBuffer[i40 + 4] += 1;
                    }
                }
            }
            function pushVertex(vertex) {
                vertexBuffer.push(vertex.x, vertex.y, vertex.z);
            }
            function getVertexByIndex(index, vertex) {
                var stride = index * 3;
                vertex.x = vertices[stride + 0];
                vertex.y = vertices[stride + 1];
                vertex.z = vertices[stride + 2];
            }
            function correctUVs() {
                var a = new Vector3();
                var b = new Vector3();
                var c = new Vector3();
                var centroid = new Vector3();
                var uvA = new Vector2();
                var uvB = new Vector2();
                var uvC = new Vector2();
                for(var i40 = 0, j = 0; i40 < vertexBuffer.length; i40 += 9, j += 6){
                    a.set(vertexBuffer[i40 + 0], vertexBuffer[i40 + 1], vertexBuffer[i40 + 2]);
                    b.set(vertexBuffer[i40 + 3], vertexBuffer[i40 + 4], vertexBuffer[i40 + 5]);
                    c.set(vertexBuffer[i40 + 6], vertexBuffer[i40 + 7], vertexBuffer[i40 + 8]);
                    uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                    uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                    uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                    centroid.copy(a).add(b).add(c).divideScalar(3);
                    var azi = azimuth(centroid);
                    correctUV(uvA, j + 0, a, azi);
                    correctUV(uvB, j + 2, b, azi);
                    correctUV(uvC, j + 4, c, azi);
                }
            }
            function correctUV(uv, stride, vector, azimuth) {
                if (azimuth < 0 && uv.x === 1) uvBuffer[stride] = uv.x - 1;
                if (vector.x === 0 && vector.z === 0) uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
            } // Angle around the Y axis, counter-clockwise when looking from above.
            function azimuth(vector) {
                return Math.atan2(vector.z, -vector.x);
            } // Angle above the XZ plane.
            function inclination(vector) {
                return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
            }
            return _this;
        }
        return PolyhedronGeometry2;
    }(BufferGeometry);
    var DodecahedronGeometry1 = /*#__PURE__*/ function(_PolyhedronGeometry) {
        _inheritsLoose(DodecahedronGeometry2, _PolyhedronGeometry);
        function DodecahedronGeometry2(radius, detail) {
            var _this;
            if (radius === void 0) radius = 1;
            if (detail === void 0) detail = 0;
            var t = (1 + Math.sqrt(5)) / 2;
            var r = 1 / t;
            var vertices = [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -r,
                -t,
                0,
                -r,
                t,
                0,
                r,
                -t,
                0,
                r,
                t,
                -r,
                -t,
                0,
                -r,
                t,
                0,
                r,
                -t,
                0,
                r,
                t,
                0,
                -t,
                0,
                -r,
                t,
                0,
                -r,
                -t,
                0,
                r,
                t,
                0,
                r
            ];
            var indices = [
                3,
                11,
                7,
                3,
                7,
                15,
                3,
                15,
                13,
                7,
                19,
                17,
                7,
                17,
                6,
                7,
                6,
                15,
                17,
                4,
                8,
                17,
                8,
                10,
                17,
                10,
                6,
                8,
                0,
                16,
                8,
                16,
                2,
                8,
                2,
                10,
                0,
                12,
                1,
                0,
                1,
                18,
                0,
                18,
                16,
                6,
                10,
                2,
                6,
                2,
                13,
                6,
                13,
                15,
                2,
                16,
                18,
                2,
                18,
                3,
                2,
                3,
                13,
                18,
                1,
                9,
                18,
                9,
                11,
                18,
                11,
                3,
                4,
                14,
                12,
                4,
                12,
                0,
                4,
                0,
                8,
                11,
                9,
                5,
                11,
                5,
                19,
                11,
                19,
                7,
                19,
                5,
                14,
                19,
                14,
                4,
                19,
                4,
                17,
                1,
                12,
                14,
                1,
                14,
                5,
                1,
                5,
                9
            ];
            _this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
            _this.type = 'DodecahedronGeometry';
            _this.parameters = {
                radius: radius,
                detail: detail
            };
            return _this;
        }
        return DodecahedronGeometry2;
    }(PolyhedronGeometry1);
    var _v0$2 = new Vector3();
    var _v1$5 = new Vector3();
    var _normal$1 = new Vector3();
    var _triangle = new Triangle();
    var EdgesGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(EdgesGeometry2, _BufferGeometry);
        function EdgesGeometry2(geometry, thresholdAngle) {
            var _this;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'EdgesGeometry';
            _this.parameters = {
                thresholdAngle: thresholdAngle
            };
            thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
            if (geometry.isGeometry === true) {
                console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
                return _assertThisInitialized(_this);
            }
            var precisionPoints = 4;
            var precision = Math.pow(10, precisionPoints);
            var thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
            var indexAttr = geometry.getIndex();
            var positionAttr = geometry.getAttribute('position');
            var indexCount = indexAttr ? indexAttr.count : positionAttr.count;
            var indexArr = [
                0,
                0,
                0
            ];
            var vertKeys = [
                'a',
                'b',
                'c'
            ];
            var hashes = new Array(3);
            var edgeData = {
            };
            var vertices = [];
            for(var i40 = 0; i40 < indexCount; i40 += 3){
                if (indexAttr) {
                    indexArr[0] = indexAttr.getX(i40);
                    indexArr[1] = indexAttr.getX(i40 + 1);
                    indexArr[2] = indexAttr.getX(i40 + 2);
                } else {
                    indexArr[0] = i40;
                    indexArr[1] = i40 + 1;
                    indexArr[2] = i40 + 2;
                }
                var a = _triangle.a, b = _triangle.b, c = _triangle.c;
                a.fromBufferAttribute(positionAttr, indexArr[0]);
                b.fromBufferAttribute(positionAttr, indexArr[1]);
                c.fromBufferAttribute(positionAttr, indexArr[2]);
                _triangle.getNormal(_normal$1); // create hashes for the edge from the vertices
                hashes[0] = Math.round(a.x * precision) + "," + Math.round(a.y * precision) + "," + Math.round(a.z * precision);
                hashes[1] = Math.round(b.x * precision) + "," + Math.round(b.y * precision) + "," + Math.round(b.z * precision);
                hashes[2] = Math.round(c.x * precision) + "," + Math.round(c.y * precision) + "," + Math.round(c.z * precision); // skip degenerate triangles
                if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) continue;
                 // iterate over every edge
                for(var j = 0; j < 3; j++){
                    // get the first and next vertex making up the edge
                    var jNext = (j + 1) % 3;
                    var vecHash0 = hashes[j];
                    var vecHash1 = hashes[jNext];
                    var v0 = _triangle[vertKeys[j]];
                    var v1 = _triangle[vertKeys[jNext]];
                    var hash = vecHash0 + "_" + vecHash1;
                    var reverseHash = vecHash1 + "_" + vecHash0;
                    if (reverseHash in edgeData && edgeData[reverseHash]) {
                        // if we found a sibling edge add it into the vertex array if
                        // it meets the angle threshold and delete the edge from the map.
                        if (_normal$1.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                            vertices.push(v0.x, v0.y, v0.z);
                            vertices.push(v1.x, v1.y, v1.z);
                        }
                        edgeData[reverseHash] = null;
                    } else if (!(hash in edgeData)) // if we've already got an edge here then skip adding a new one
                    edgeData[hash] = {
                        index0: indexArr[j],
                        index1: indexArr[jNext],
                        normal: _normal$1.clone()
                    };
                }
            } // iterate over all remaining, unmatched edges and add them to the vertex array
            for(var key3 in edgeData)if (edgeData[key3]) {
                var _edgeData$key = edgeData[key3], index0 = _edgeData$key.index0, index1 = _edgeData$key.index1;
                _v0$2.fromBufferAttribute(positionAttr, index0);
                _v1$5.fromBufferAttribute(positionAttr, index1);
                vertices.push(_v0$2.x, _v0$2.y, _v0$2.z);
                vertices.push(_v1$5.x, _v1$5.y, _v1$5.z);
            }
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            return _this;
        }
        return EdgesGeometry2;
    }(BufferGeometry);
    /**
	 * Port from https://github.com/mapbox/earcut (v2.2.2)
	 */ var Earcut = {
        triangulate: function triangulate(data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length;
            var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
            var outerNode = linkedList(data, 0, outerLen, dim, true);
            var triangles = [];
            if (!outerNode || outerNode.next === outerNode.prev) return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
            if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for(var i40 = dim; i40 < outerLen; i40 += dim){
                    x = data[i40];
                    y = data[i40 + 1];
                    if (x < minX) minX = x;
                    if (y < minY) minY = y;
                    if (x > maxX) maxX = x;
                    if (y > maxY) maxY = y;
                } // minX, minY and invSize are later used to transform coords into integers for z-order calculation
                invSize = Math.max(maxX - minX, maxY - minY);
                invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
            return triangles;
        }
    }; // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList(data, start, end, dim, clockwise) {
        var i42, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) for(i42 = start; i42 < end; i42 += dim)last = insertNode(i42, data[i42], data[i42 + 1], last);
        else for(i42 = end - dim; i42 >= start; i42 -= dim)last = insertNode(i42, data[i42], data[i42 + 1], last);
        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }
        return last;
    } // eliminate colinear or duplicate points
    function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;
        var p = start, again;
        do {
            again = false;
            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next) break;
                again = true;
            } else p = p.next;
        }while (again || p !== end)
        return end;
    } // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear) return; // interlink polygon nodes in z-order
        if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next; // iterate through ears, slicing them one by one
        while(ear.prev !== ear.next){
            prev = ear.prev;
            next = ear.next;
            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                removeNode(ear); // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next; // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
                else if (pass === 1) {
                    ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
                } else if (pass === 2) splitEarcut(ear, triangles, dim, minX, minY, invSize);
                break;
            }
        }
    } // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;
        while(p !== ear.prev){
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.next;
        }
        return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;
        var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ; // look for points inside the triangle in both directions
        while(p && p.z >= minZ && n && n.z <= maxZ){
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
            if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        } // look for remaining points in decreasing z-order
        while(p && p.z >= minZ){
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
        } // look for remaining points in increasing z-order
        while(n && n.z <= maxZ){
            if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
            n = n.nextZ;
        }
        return true;
    } // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev, b = p.next.next;
            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim); // remove two nodes involved
                removeNode(p);
                removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        }while (p !== start)
        return filterPoints(p);
    } // try splitting polygon into two and triangulate them independently
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while(b !== a.prev){
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = splitPolygon(a, b); // filter colinear points around the cuts
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next); // run earcut on each half
                    earcutLinked(a, triangles, dim, minX, minY, invSize);
                    earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        }while (a !== start)
    } // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [];
        var i42, len, start, end, list;
        for(i42 = 0, len = holeIndices.length; i42 < len; i42++){
            start = holeIndices[i42] * dim;
            end = i42 < len - 1 ? holeIndices[i42 + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next) list.steiner = true;
            queue.push(getLeftmost(list));
        }
        queue.sort(compareX); // process holes from left to right
        for(i42 = 0; i42 < queue.length; i42++){
            eliminateHole(queue[i42], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
    }
    function compareX(a, b) {
        return a.x - b.x;
    } // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole); // filter collinear points around the cuts
            filterPoints(outerNode, outerNode.next);
            filterPoints(b, b.next);
        }
    } // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge(hole, outerNode) {
        var p = outerNode;
        var hx = hole.x;
        var hy = hole.y;
        var qx = -Infinity, m; // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) return p;
                        if (hy === p.next.y) return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        }while (p !== outerNode)
        if (!m) return null;
        if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        var stop = m, mx = m.x, my = m.y;
        var tanMin = Infinity, tan;
        p = m;
        do {
            if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        }while (p !== stop)
        return m;
    } // whether sector in vertex m contains sector in vertex p in the same coordinates
    function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    } // interlink polygon nodes in z-order
    function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        }while (p !== start)
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
    } // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked(list) {
        var i42, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while(p){
                numMerges++;
                q = p;
                pSize = 0;
                for(i42 = 0; i42 < inSize; i42++){
                    pSize++;
                    q = q.nextZ;
                    if (!q) break;
                }
                qSize = inSize;
                while(pSize > 0 || qSize > 0 && q){
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail) tail.nextZ = e;
                    else list = e;
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        }while (numMerges > 1)
        return list;
    } // z-order of a point given coords and inverse of the longer side of data bbox
    function zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | x << 8) & 16711935;
        x = (x | x << 4) & 252645135;
        x = (x | x << 2) & 858993459;
        x = (x | x << 1) & 1431655765;
        y = (y | y << 8) & 16711935;
        y = (y | y << 4) & 252645135;
        y = (y | y << 2) & 858993459;
        y = (y | y << 1) & 1431655765;
        return x | y << 1;
    } // find the leftmost node of a polygon ring
    function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
            if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
            p = p.next;
        }while (p !== start)
        return leftmost;
    } // check if a point lies within a convex triangle
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    } // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
    } // signed area of a triangle
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    } // check if two points are equal
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    } // check if two segments intersect
    function intersects(p1, q1, p2, q2) {
        var o1 = sign(area(p1, q1, p2));
        var o2 = sign(area(p1, q1, q2));
        var o3 = sign(area(p2, q2, p1));
        var o4 = sign(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4) return true; // general case
        if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
        if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
        if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
        if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
        return false;
    } // for collinear points p, q, r, check if point q lies on segment pr
    function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
    } // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
            p = p.next;
        }while (p !== a)
        return false;
    } // check if a polygon diagonal is locally inside the polygon
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    } // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside(a, b) {
        var p = a, inside = false;
        var px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
            if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
            p = p.next;
        }while (p !== a)
        return inside;
    } // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon(a, b) {
        var a2 = new Node1(a.i, a.x, a.y), b2 = new Node1(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    } // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode(i42, x, y, last) {
        var p = new Node1(i42, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }
    function Node1(i42, x, y) {
        // vertex index in coordinates array
        this.i = i42; // vertex coordinates
        this.x = x;
        this.y = y; // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null; // z-order curve value
        this.z = null; // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null; // indicates whether this is a steiner point
        this.steiner = false;
    }
    function signedArea(data, start, end, dim) {
        var sum = 0;
        for(var i42 = start, j = end - dim; i42 < end; i42 += dim){
            sum += (data[j] - data[i42]) * (data[i42 + 1] + data[j + 1]);
            j = i42;
        }
        return sum;
    }
    var ShapeUtils = {
        // calculate area of the contour polygon
        area: function area1(contour) {
            var n = contour.length;
            var a = 0;
            for(var p = n - 1, q = 0; q < n; p = q++)a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            return a * 0.5;
        },
        isClockWise: function isClockWise(pts) {
            return ShapeUtils.area(pts) < 0;
        },
        triangulateShape: function triangulateShape(contour, holes) {
            var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
            var holeIndices = []; // array of hole indices
            var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
            removeDupEndPts(contour);
            addContour(vertices, contour); //
            var holeIndex = contour.length;
            holes.forEach(removeDupEndPts);
            for(var i42 = 0; i42 < holes.length; i42++){
                holeIndices.push(holeIndex);
                holeIndex += holes[i42].length;
                addContour(vertices, holes[i42]);
            } //
            var triangles = Earcut.triangulate(vertices, holeIndices); //
            for(var _i = 0; _i < triangles.length; _i += 3)faces.push(triangles.slice(_i, _i + 3));
            return faces;
        }
    };
    function removeDupEndPts(points) {
        var l = points.length;
        if (l > 2 && points[l - 1].equals(points[0])) points.pop();
    }
    function addContour(vertices, contour) {
        for(var i42 = 0; i42 < contour.length; i42++){
            vertices.push(contour[i42].x);
            vertices.push(contour[i42].y);
        }
    }
    var ExtrudeGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(ExtrudeGeometry2, _BufferGeometry);
        function ExtrudeGeometry2(shapes, options) {
            var _this;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'ExtrudeGeometry';
            _this.parameters = {
                shapes: shapes,
                options: options
            };
            shapes = Array.isArray(shapes) ? shapes : [
                shapes
            ];
            var scope = _assertThisInitialized(_this);
            var verticesArray = [];
            var uvArray = [];
            for(var i42 = 0, l = shapes.length; i42 < l; i42++){
                var shape = shapes[i42];
                addShape(shape);
            } // build geometry
            _this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
            _this.computeVertexNormals(); // functions
            function addShape(shape) {
                var placeholder = []; // options
                var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
                var steps = options.steps !== undefined ? options.steps : 1;
                var depth = options.depth !== undefined ? options.depth : 100;
                var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
                var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
                var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
                var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
                var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
                var extrudePath = options.extrudePath;
                var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options
                if (options.amount !== undefined) {
                    console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
                    depth = options.amount;
                } //
                var extrudePts, extrudeByPath = false;
                var splineTube, binormal, normal, position2;
                if (extrudePath) {
                    extrudePts = extrudePath.getSpacedPoints(steps);
                    extrudeByPath = true;
                    bevelEnabled = false; // bevels not supported for path extrusion
                    // SETUP TNB variables
                    // TODO1 - have a .isClosed in spline?
                    splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
                    binormal = new Vector3();
                    normal = new Vector3();
                    position2 = new Vector3();
                } // Safeguards if bevels are not enabled
                if (!bevelEnabled) {
                    bevelSegments = 0;
                    bevelThickness = 0;
                    bevelSize = 0;
                    bevelOffset = 0;
                } // Variables initialization
                var shapePoints = shape.extractPoints(curveSegments);
                var vertices = shapePoints.shape;
                var holes = shapePoints.holes;
                var reverse = !ShapeUtils.isClockWise(vertices);
                if (reverse) {
                    vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...
                    for(var h = 0, hl = holes.length; h < hl; h++){
                        var ahole = holes[h];
                        if (ShapeUtils.isClockWise(ahole)) holes[h] = ahole.reverse();
                    }
                }
                var faces = ShapeUtils.triangulateShape(vertices, holes);
                /* Vertices */ var contour = vertices; // vertices has all points but contour has only points of circumference
                for(var _h = 0, _hl = holes.length; _h < _hl; _h++){
                    var _ahole = holes[_h];
                    vertices = vertices.concat(_ahole);
                }
                function scalePt2(pt, vec, size) {
                    if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
                    return vec.clone().multiplyScalar(size).add(pt);
                }
                var vlen = vertices.length, flen = faces.length; // Find directions for point movement
                function getBevelVec(inPt, inPrev, inNext) {
                    // computes for inPt the corresponding point inPt' on a new contour
                    //	 shifted by 1 unit (length of normalized vector) to the left
                    // if we walk along contour clockwise, this new contour is outside the old one
                    //
                    // inPt' is the intersection of the two lines parallel to the two
                    //	adjacent edges of inPt at a distance of 1 unit on the left side.
                    var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
                    // good reading for geometry algorithms (here: line-line intersection)
                    // http://geomalgorithms.com/a05-_intersect-1.html
                    var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
                    var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
                    var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges
                    var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
                    if (Math.abs(collinear0) > Number.EPSILON) {
                        // not collinear
                        // length of vectors for normalizing
                        var v_prev_len = Math.sqrt(v_prev_lensq);
                        var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left
                        var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                        var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                        var ptNextShift_x = inNext.x - v_next_y / v_next_len;
                        var ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point
                        var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point
                        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
                        //	but prevent crazy spikes
                        var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                        if (v_trans_lensq <= 2) return new Vector2(v_trans_x, v_trans_y);
                        else shrink_by = Math.sqrt(v_trans_lensq / 2);
                    } else {
                        // handle special case of collinear edges
                        var direction_eq = false; // assumes: opposite
                        if (v_prev_x > Number.EPSILON) {
                            if (v_next_x > Number.EPSILON) direction_eq = true;
                        } else {
                            if (v_prev_x < -Number.EPSILON) {
                                if (v_next_x < -Number.EPSILON) direction_eq = true;
                            } else if (Math.sign(v_prev_y) === Math.sign(v_next_y)) direction_eq = true;
                        }
                        if (direction_eq) {
                            // console.log("Warning: lines are a straight sequence");
                            v_trans_x = -v_prev_y;
                            v_trans_y = v_prev_x;
                            shrink_by = Math.sqrt(v_prev_lensq);
                        } else {
                            // console.log("Warning: lines are a straight spike");
                            v_trans_x = v_prev_x;
                            v_trans_y = v_prev_y;
                            shrink_by = Math.sqrt(v_prev_lensq / 2);
                        }
                    }
                    return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
                }
                var contourMovements = [];
                for(var _i = 0, il = contour.length, j = il - 1, k = _i + 1; _i < il; _i++, j++, k++){
                    if (j === il) j = 0;
                    if (k === il) k = 0; //	(j)---(i)---(k)
                    // console.log('i,j,k', i, j , k)
                    contourMovements[_i] = getBevelVec(contour[_i], contour[j], contour[k]);
                }
                var holesMovements = [];
                var oneHoleMovements, verticesMovements = contourMovements.concat();
                for(var _h2 = 0, _hl2 = holes.length; _h2 < _hl2; _h2++){
                    var _ahole2 = holes[_h2];
                    oneHoleMovements = [];
                    for(var _i2 = 0, _il = _ahole2.length, _j = _il - 1, _k = _i2 + 1; _i2 < _il; _i2++, _j++, _k++){
                        if (_j === _il) _j = 0;
                        if (_k === _il) _k = 0; //	(j)---(i)---(k)
                        oneHoleMovements[_i2] = getBevelVec(_ahole2[_i2], _ahole2[_j], _ahole2[_k]);
                    }
                    holesMovements.push(oneHoleMovements);
                    verticesMovements = verticesMovements.concat(oneHoleMovements);
                } // Loop bevelSegments, 1 for the front, 1 for the back
                for(var b = 0; b < bevelSegments; b++){
                    //for ( b = bevelSegments; b > 0; b -- ) {
                    var t = b / bevelSegments;
                    var z = bevelThickness * Math.cos(t * Math.PI / 2);
                    var _bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape
                    for(var _i3 = 0, _il2 = contour.length; _i3 < _il2; _i3++){
                        var vert = scalePt2(contour[_i3], contourMovements[_i3], _bs);
                        v(vert.x, vert.y, -z);
                    } // expand holes
                    for(var _h3 = 0, _hl3 = holes.length; _h3 < _hl3; _h3++){
                        var _ahole3 = holes[_h3];
                        oneHoleMovements = holesMovements[_h3];
                        for(var _i4 = 0, _il3 = _ahole3.length; _i4 < _il3; _i4++){
                            var _vert = scalePt2(_ahole3[_i4], oneHoleMovements[_i4], _bs);
                            v(_vert.x, _vert.y, -z);
                        }
                    }
                }
                var bs = bevelSize + bevelOffset; // Back facing vertices
                for(var _i5 = 0; _i5 < vlen; _i5++){
                    var _vert2 = bevelEnabled ? scalePt2(vertices[_i5], verticesMovements[_i5], bs) : vertices[_i5];
                    if (!extrudeByPath) v(_vert2.x, _vert2.y, 0);
                    else {
                        // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
                        normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);
                        binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);
                        position2.copy(extrudePts[0]).add(normal).add(binormal);
                        v(position2.x, position2.y, position2.z);
                    }
                } // Add stepped vertices...
                // Including front facing vertices
                for(var s = 1; s <= steps; s++)for(var _i6 = 0; _i6 < vlen; _i6++){
                    var _vert3 = bevelEnabled ? scalePt2(vertices[_i6], verticesMovements[_i6], bs) : vertices[_i6];
                    if (!extrudeByPath) v(_vert3.x, _vert3.y, depth / steps * s);
                    else {
                        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
                        normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);
                        binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);
                        position2.copy(extrudePts[s]).add(normal).add(binormal);
                        v(position2.x, position2.y, position2.z);
                    }
                }
                 // Add bevel segments planes
                //for ( b = 1; b <= bevelSegments; b ++ ) {
                for(var _b = bevelSegments - 1; _b >= 0; _b--){
                    var _t = _b / bevelSegments;
                    var _z1 = bevelThickness * Math.cos(_t * Math.PI / 2);
                    var _bs2 = bevelSize * Math.sin(_t * Math.PI / 2) + bevelOffset; // contract shape
                    for(var _i7 = 0, _il4 = contour.length; _i7 < _il4; _i7++){
                        var _vert4 = scalePt2(contour[_i7], contourMovements[_i7], _bs2);
                        v(_vert4.x, _vert4.y, depth + _z1);
                    } // expand holes
                    for(var _h4 = 0, _hl4 = holes.length; _h4 < _hl4; _h4++){
                        var _ahole4 = holes[_h4];
                        oneHoleMovements = holesMovements[_h4];
                        for(var _i8 = 0, _il5 = _ahole4.length; _i8 < _il5; _i8++){
                            var _vert5 = scalePt2(_ahole4[_i8], oneHoleMovements[_i8], _bs2);
                            if (!extrudeByPath) v(_vert5.x, _vert5.y, depth + _z1);
                            else v(_vert5.x, _vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + _z1);
                        }
                    }
                }
                /* Faces */ // Top and bottom faces
                buildLidFaces(); // Sides faces
                buildSideFaces(); /////	Internal functions
                function buildLidFaces() {
                    var start = verticesArray.length / 3;
                    if (bevelEnabled) {
                        var layer = 0; // steps + 1
                        var offset = vlen * layer; // Bottom faces
                        for(var _i9 = 0; _i9 < flen; _i9++){
                            var face = faces[_i9];
                            f3(face[2] + offset, face[1] + offset, face[0] + offset);
                        }
                        layer = steps + bevelSegments * 2;
                        offset = vlen * layer; // Top faces
                        for(var _i10 = 0; _i10 < flen; _i10++){
                            var _face = faces[_i10];
                            f3(_face[0] + offset, _face[1] + offset, _face[2] + offset);
                        }
                    } else {
                        // Bottom faces
                        for(var _i11 = 0; _i11 < flen; _i11++){
                            var _face2 = faces[_i11];
                            f3(_face2[2], _face2[1], _face2[0]);
                        } // Top faces
                        for(var _i12 = 0; _i12 < flen; _i12++){
                            var _face3 = faces[_i12];
                            f3(_face3[0] + vlen * steps, _face3[1] + vlen * steps, _face3[2] + vlen * steps);
                        }
                    }
                    scope.addGroup(start, verticesArray.length / 3 - start, 0);
                } // Create faces for the z-sides of the shape
                function buildSideFaces() {
                    var start = verticesArray.length / 3;
                    var layeroffset = 0;
                    sidewalls(contour, layeroffset);
                    layeroffset += contour.length;
                    for(var _h5 = 0, _hl5 = holes.length; _h5 < _hl5; _h5++){
                        var _ahole5 = holes[_h5];
                        sidewalls(_ahole5, layeroffset); //, true
                        layeroffset += _ahole5.length;
                    }
                    scope.addGroup(start, verticesArray.length / 3 - start, 1);
                }
                function sidewalls(contour1, layeroffset) {
                    var i43 = contour1.length;
                    while((--i43) >= 0){
                        var _j2 = i43;
                        var _k2 = i43 - 1;
                        if (_k2 < 0) _k2 = contour1.length - 1; //console.log('b', i,j, i-1, k,vertices.length);
                        for(var _s = 0, sl = steps + bevelSegments * 2; _s < sl; _s++){
                            var slen1 = vlen * _s;
                            var slen2 = vlen * (_s + 1);
                            var a = layeroffset + _j2 + slen1, _b2 = layeroffset + _k2 + slen1, c = layeroffset + _k2 + slen2, d = layeroffset + _j2 + slen2;
                            f4(a, _b2, c, d);
                        }
                    }
                }
                function v(x, y, z) {
                    placeholder.push(x);
                    placeholder.push(y);
                    placeholder.push(z);
                }
                function f3(a, b1, c) {
                    addVertex(a);
                    addVertex(b1);
                    addVertex(c);
                    var nextIndex = verticesArray.length / 3;
                    var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                    addUV(uvs[0]);
                    addUV(uvs[1]);
                    addUV(uvs[2]);
                }
                function f4(a, b1, c, d) {
                    addVertex(a);
                    addVertex(b1);
                    addVertex(d);
                    addVertex(b1);
                    addVertex(c);
                    addVertex(d);
                    var nextIndex = verticesArray.length / 3;
                    var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                    addUV(uvs[0]);
                    addUV(uvs[1]);
                    addUV(uvs[3]);
                    addUV(uvs[1]);
                    addUV(uvs[2]);
                    addUV(uvs[3]);
                }
                function addVertex(index) {
                    verticesArray.push(placeholder[index * 3 + 0]);
                    verticesArray.push(placeholder[index * 3 + 1]);
                    verticesArray.push(placeholder[index * 3 + 2]);
                }
                function addUV(vector2) {
                    uvArray.push(vector2.x);
                    uvArray.push(vector2.y);
                }
            }
            return _this;
        }
        var _proto = ExtrudeGeometry2.prototype;
        _proto.toJSON = function toJSON() {
            var data = BufferGeometry.prototype.toJSON.call(this);
            var shapes = this.parameters.shapes;
            var options = this.parameters.options;
            return _toJSON(shapes, options, data);
        };
        return ExtrudeGeometry2;
    }(BufferGeometry);
    var WorldUVGenerator = {
        generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {
            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];
            return [
                new Vector2(a_x, a_y),
                new Vector2(b_x, b_y),
                new Vector2(c_x, c_y)
            ];
        },
        generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {
            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var a_z = vertices[indexA * 3 + 2];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var b_z = vertices[indexB * 3 + 2];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];
            var c_z = vertices[indexC * 3 + 2];
            var d_x = vertices[indexD * 3];
            var d_y = vertices[indexD * 3 + 1];
            var d_z = vertices[indexD * 3 + 2];
            if (Math.abs(a_y - b_y) < 0.01) return [
                new Vector2(a_x, 1 - a_z),
                new Vector2(b_x, 1 - b_z),
                new Vector2(c_x, 1 - c_z),
                new Vector2(d_x, 1 - d_z)
            ];
            else return [
                new Vector2(a_y, 1 - a_z),
                new Vector2(b_y, 1 - b_z),
                new Vector2(c_y, 1 - c_z),
                new Vector2(d_y, 1 - d_z)
            ];
        }
    };
    function _toJSON(shapes, options, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) for(var i42 = 0, l = shapes.length; i42 < l; i42++){
            var shape = shapes[i42];
            data.shapes.push(shape.uuid);
        }
        else data.shapes.push(shapes.uuid);
        if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
        return data;
    }
    var IcosahedronGeometry1 = /*#__PURE__*/ function(_PolyhedronGeometry) {
        _inheritsLoose(IcosahedronGeometry2, _PolyhedronGeometry);
        function IcosahedronGeometry2(radius, detail) {
            var _this;
            if (radius === void 0) radius = 1;
            if (detail === void 0) detail = 0;
            var t = (1 + Math.sqrt(5)) / 2;
            var vertices = [
                -1,
                t,
                0,
                1,
                t,
                0,
                -1,
                -t,
                0,
                1,
                -t,
                0,
                0,
                -1,
                t,
                0,
                1,
                t,
                0,
                -1,
                -t,
                0,
                1,
                -t,
                t,
                0,
                -1,
                t,
                0,
                1,
                -t,
                0,
                -1,
                -t,
                0,
                1
            ];
            var indices = [
                0,
                11,
                5,
                0,
                5,
                1,
                0,
                1,
                7,
                0,
                7,
                10,
                0,
                10,
                11,
                1,
                5,
                9,
                5,
                11,
                4,
                11,
                10,
                2,
                10,
                7,
                6,
                7,
                1,
                8,
                3,
                9,
                4,
                3,
                4,
                2,
                3,
                2,
                6,
                3,
                6,
                8,
                3,
                8,
                9,
                4,
                9,
                5,
                2,
                4,
                11,
                6,
                2,
                10,
                8,
                6,
                7,
                9,
                8,
                1
            ];
            _this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
            _this.type = 'IcosahedronGeometry';
            _this.parameters = {
                radius: radius,
                detail: detail
            };
            return _this;
        }
        return IcosahedronGeometry2;
    }(PolyhedronGeometry1);
    var LatheGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(LatheGeometry2, _BufferGeometry);
        function LatheGeometry2(points, segments, phiStart, phiLength) {
            var _this;
            if (segments === void 0) segments = 12;
            if (phiStart === void 0) phiStart = 0;
            if (phiLength === void 0) phiLength = Math.PI * 2;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'LatheGeometry';
            _this.parameters = {
                points: points,
                segments: segments,
                phiStart: phiStart,
                phiLength: phiLength
            };
            segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]
            phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2); // buffers
            var indices = [];
            var vertices = [];
            var uvs = []; // helper variables
            var inverseSegments = 1 / segments;
            var vertex = new Vector3();
            var uv = new Vector2(); // generate vertices and uvs
            for(var i42 = 0; i42 <= segments; i42++){
                var phi = phiStart + i42 * inverseSegments * phiLength;
                var sin = Math.sin(phi);
                var cos = Math.cos(phi);
                for(var j = 0; j <= points.length - 1; j++){
                    // vertex
                    vertex.x = points[j].x * sin;
                    vertex.y = points[j].y;
                    vertex.z = points[j].x * cos;
                    vertices.push(vertex.x, vertex.y, vertex.z); // uv
                    uv.x = i42 / segments;
                    uv.y = j / (points.length - 1);
                    uvs.push(uv.x, uv.y);
                }
            } // indices
            for(var _i = 0; _i < segments; _i++)for(var _j = 0; _j < points.length - 1; _j++){
                var base = _j + _i * points.length;
                var a = base;
                var b = base + points.length;
                var c = base + points.length + 1;
                var d = base + 1; // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
             // build geometry
            _this.setIndex(indices);
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals
            _this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
            // because the corresponding vertices are identical (but still have different UVs).
            if (phiLength === Math.PI * 2) {
                var normals = _this.attributes.normal.array;
                var n1 = new Vector3();
                var n2 = new Vector3();
                var n = new Vector3(); // this is the buffer offset for the last line of vertices
                var _base = segments * points.length * 3;
                for(var _i2 = 0, _j2 = 0; _i2 < points.length; _i2++, _j2 += 3){
                    // select the normal of the vertex in the first line
                    n1.x = normals[_j2 + 0];
                    n1.y = normals[_j2 + 1];
                    n1.z = normals[_j2 + 2]; // select the normal of the vertex in the last line
                    n2.x = normals[_base + _j2 + 0];
                    n2.y = normals[_base + _j2 + 1];
                    n2.z = normals[_base + _j2 + 2]; // average normals
                    n.addVectors(n1, n2).normalize(); // assign the new values to both normals
                    normals[_j2 + 0] = normals[_base + _j2 + 0] = n.x;
                    normals[_j2 + 1] = normals[_base + _j2 + 1] = n.y;
                    normals[_j2 + 2] = normals[_base + _j2 + 2] = n.z;
                }
            }
            return _this;
        }
        return LatheGeometry2;
    }(BufferGeometry);
    var OctahedronGeometry1 = /*#__PURE__*/ function(_PolyhedronGeometry) {
        _inheritsLoose(OctahedronGeometry2, _PolyhedronGeometry);
        function OctahedronGeometry2(radius, detail) {
            var _this;
            if (radius === void 0) radius = 1;
            if (detail === void 0) detail = 0;
            var vertices = [
                1,
                0,
                0,
                -1,
                0,
                0,
                0,
                1,
                0,
                0,
                -1,
                0,
                0,
                0,
                1,
                0,
                0,
                -1
            ];
            var indices = [
                0,
                2,
                4,
                0,
                4,
                3,
                0,
                3,
                5,
                0,
                5,
                2,
                1,
                2,
                5,
                1,
                5,
                3,
                1,
                3,
                4,
                1,
                4,
                2
            ];
            _this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
            _this.type = 'OctahedronGeometry';
            _this.parameters = {
                radius: radius,
                detail: detail
            };
            return _this;
        }
        return OctahedronGeometry2;
    }(PolyhedronGeometry1);
    /**
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
	 */ function ParametricGeometry(func, slices, stacks) {
        BufferGeometry.call(this);
        this.type = 'ParametricGeometry';
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        }; // buffers
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var EPS = 0.00001;
        var normal = new Vector3();
        var p0 = new Vector3(), p1 = new Vector3();
        var pu = new Vector3(), pv = new Vector3();
        if (func.length < 3) console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
         // generate vertices, normals and uvs
        var sliceCount = slices + 1;
        for(var i42 = 0; i42 <= stacks; i42++){
            var v = i42 / stacks;
            for(var j = 0; j <= slices; j++){
                var u = j / slices; // vertex
                func(u, v, p0);
                vertices.push(p0.x, p0.y, p0.z); // normal
                // approximate tangent vectors via finite differences
                if (u - EPS >= 0) {
                    func(u - EPS, v, p1);
                    pu.subVectors(p0, p1);
                } else {
                    func(u + EPS, v, p1);
                    pu.subVectors(p1, p0);
                }
                if (v - EPS >= 0) {
                    func(u, v - EPS, p1);
                    pv.subVectors(p0, p1);
                } else {
                    func(u, v + EPS, p1);
                    pv.subVectors(p1, p0);
                } // cross product of tangent vectors returns surface normal
                normal.crossVectors(pu, pv).normalize();
                normals.push(normal.x, normal.y, normal.z); // uv
                uvs.push(u, v);
            }
        } // generate indices
        for(var _i = 0; _i < stacks; _i++)for(var _j = 0; _j < slices; _j++){
            var a = _i * sliceCount + _j;
            var b = _i * sliceCount + _j + 1;
            var c = (_i + 1) * sliceCount + _j + 1;
            var d = (_i + 1) * sliceCount + _j; // faces one and two
            indices.push(a, b, d);
            indices.push(b, c, d);
        }
         // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    ParametricGeometry.prototype = Object.create(BufferGeometry.prototype);
    ParametricGeometry.prototype.constructor = ParametricGeometry;
    var RingGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(RingGeometry2, _BufferGeometry);
        function RingGeometry2(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
            var _this;
            if (innerRadius === void 0) innerRadius = 0.5;
            if (outerRadius === void 0) outerRadius = 1;
            if (thetaSegments === void 0) thetaSegments = 8;
            if (phiSegments === void 0) phiSegments = 1;
            if (thetaStart === void 0) thetaStart = 0;
            if (thetaLength === void 0) thetaLength = Math.PI * 2;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'RingGeometry';
            _this.parameters = {
                innerRadius: innerRadius,
                outerRadius: outerRadius,
                thetaSegments: thetaSegments,
                phiSegments: phiSegments,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            thetaSegments = Math.max(3, thetaSegments);
            phiSegments = Math.max(1, phiSegments); // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = []; // some helper variables
            var radius = innerRadius;
            var radiusStep = (outerRadius - innerRadius) / phiSegments;
            var vertex = new Vector3();
            var uv = new Vector2(); // generate vertices, normals and uvs
            for(var j = 0; j <= phiSegments; j++){
                for(var i42 = 0; i42 <= thetaSegments; i42++){
                    // values are generate from the inside of the ring to the outside
                    var segment = thetaStart + i42 / thetaSegments * thetaLength; // vertex
                    vertex.x = radius * Math.cos(segment);
                    vertex.y = radius * Math.sin(segment);
                    vertices.push(vertex.x, vertex.y, vertex.z); // normal
                    normals.push(0, 0, 1); // uv
                    uv.x = (vertex.x / outerRadius + 1) / 2;
                    uv.y = (vertex.y / outerRadius + 1) / 2;
                    uvs.push(uv.x, uv.y);
                } // increase the radius for next row of vertices
                radius += radiusStep;
            } // indices
            for(var _j = 0; _j < phiSegments; _j++){
                var thetaSegmentLevel = _j * (thetaSegments + 1);
                for(var _i = 0; _i < thetaSegments; _i++){
                    var _segment = _i + thetaSegmentLevel;
                    var a = _segment;
                    var b = _segment + thetaSegments + 1;
                    var c = _segment + thetaSegments + 2;
                    var d = _segment + 1; // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            } // build geometry
            _this.setIndex(indices);
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            return _this;
        }
        return RingGeometry2;
    }(BufferGeometry);
    var ShapeGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(ShapeGeometry2, _BufferGeometry);
        function ShapeGeometry2(shapes, curveSegments) {
            var _this;
            if (curveSegments === void 0) curveSegments = 12;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'ShapeGeometry';
            _this.parameters = {
                shapes: shapes,
                curveSegments: curveSegments
            }; // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = []; // helper variables
            var groupStart = 0;
            var groupCount = 0; // allow single and array values for "shapes" parameter
            if (Array.isArray(shapes) === false) addShape(shapes);
            else for(var i43 = 0; i43 < shapes.length; i43++){
                addShape(shapes[i43]);
                _this.addGroup(groupStart, groupCount, i43); // enables MultiMaterial support
                groupStart += groupCount;
                groupCount = 0;
            }
             // build geometry
            _this.setIndex(indices);
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions
            function addShape(shape) {
                var indexOffset = vertices.length / 3;
                var points = shape.extractPoints(curveSegments);
                var shapeVertices = points.shape;
                var shapeHoles = points.holes; // check direction of vertices
                if (ShapeUtils.isClockWise(shapeVertices) === false) shapeVertices = shapeVertices.reverse();
                for(var _i = 0, l = shapeHoles.length; _i < l; _i++){
                    var shapeHole = shapeHoles[_i];
                    if (ShapeUtils.isClockWise(shapeHole) === true) shapeHoles[_i] = shapeHole.reverse();
                }
                var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array
                for(var _i2 = 0, _l = shapeHoles.length; _i2 < _l; _i2++){
                    var _shapeHole = shapeHoles[_i2];
                    shapeVertices = shapeVertices.concat(_shapeHole);
                } // vertices, normals, uvs
                for(var _i3 = 0, _l2 = shapeVertices.length; _i3 < _l2; _i3++){
                    var vertex = shapeVertices[_i3];
                    vertices.push(vertex.x, vertex.y, 0);
                    normals.push(0, 0, 1);
                    uvs.push(vertex.x, vertex.y); // world uvs
                } // incides
                for(var _i4 = 0, _l3 = faces.length; _i4 < _l3; _i4++){
                    var face = faces[_i4];
                    var a = face[0] + indexOffset;
                    var b = face[1] + indexOffset;
                    var c = face[2] + indexOffset;
                    indices.push(a, b, c);
                    groupCount += 3;
                }
            }
            return _this;
        }
        var _proto = ShapeGeometry2.prototype;
        _proto.toJSON = function toJSON() {
            var data = BufferGeometry.prototype.toJSON.call(this);
            var shapes = this.parameters.shapes;
            return _toJSON$1(shapes, data);
        };
        return ShapeGeometry2;
    }(BufferGeometry);
    function _toJSON$1(shapes, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) for(var i43 = 0, l = shapes.length; i43 < l; i43++){
            var shape = shapes[i43];
            data.shapes.push(shape.uuid);
        }
        else data.shapes.push(shapes.uuid);
        return data;
    }
    var SphereGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(SphereGeometry2, _BufferGeometry);
        function SphereGeometry2(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            var _this;
            if (radius === void 0) radius = 1;
            if (widthSegments === void 0) widthSegments = 8;
            if (heightSegments === void 0) heightSegments = 6;
            if (phiStart === void 0) phiStart = 0;
            if (phiLength === void 0) phiLength = Math.PI * 2;
            if (thetaStart === void 0) thetaStart = 0;
            if (thetaLength === void 0) thetaLength = Math.PI;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'SphereGeometry';
            _this.parameters = {
                radius: radius,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                phiStart: phiStart,
                phiLength: phiLength,
                thetaStart: thetaStart,
                thetaLength: thetaLength
            };
            widthSegments = Math.max(3, Math.floor(widthSegments));
            heightSegments = Math.max(2, Math.floor(heightSegments));
            var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
            var index = 0;
            var grid = [];
            var vertex = new Vector3();
            var normal = new Vector3(); // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = []; // generate vertices, normals and uvs
            for(var iy = 0; iy <= heightSegments; iy++){
                var verticesRow = [];
                var v = iy / heightSegments; // special case for the poles
                var uOffset = 0;
                if (iy == 0 && thetaStart == 0) uOffset = 0.5 / widthSegments;
                else if (iy == heightSegments && thetaEnd == Math.PI) uOffset = -0.5 / widthSegments;
                for(var ix = 0; ix <= widthSegments; ix++){
                    var u = ix / widthSegments; // vertex
                    vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                    vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertices.push(vertex.x, vertex.y, vertex.z); // normal
                    normal.copy(vertex).normalize();
                    normals.push(normal.x, normal.y, normal.z); // uv
                    uvs.push(u + uOffset, 1 - v);
                    verticesRow.push(index++);
                }
                grid.push(verticesRow);
            } // indices
            for(var _iy = 0; _iy < heightSegments; _iy++)for(var _ix = 0; _ix < widthSegments; _ix++){
                var a = grid[_iy][_ix + 1];
                var b = grid[_iy][_ix];
                var c = grid[_iy + 1][_ix];
                var d = grid[_iy + 1][_ix + 1];
                if (_iy !== 0 || thetaStart > 0) indices.push(a, b, d);
                if (_iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
            }
             // build geometry
            _this.setIndex(indices);
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            return _this;
        }
        return SphereGeometry2;
    }(BufferGeometry);
    var TetrahedronGeometry1 = /*#__PURE__*/ function(_PolyhedronGeometry) {
        _inheritsLoose(TetrahedronGeometry2, _PolyhedronGeometry);
        function TetrahedronGeometry2(radius, detail) {
            var _this;
            if (radius === void 0) radius = 1;
            if (detail === void 0) detail = 0;
            var vertices = [
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                1,
                -1,
                -1
            ];
            var indices = [
                2,
                1,
                0,
                0,
                3,
                2,
                1,
                3,
                0,
                2,
                3,
                1
            ];
            _this = _PolyhedronGeometry.call(this, vertices, indices, radius, detail) || this;
            _this.type = 'TetrahedronGeometry';
            _this.parameters = {
                radius: radius,
                detail: detail
            };
            return _this;
        }
        return TetrahedronGeometry2;
    }(PolyhedronGeometry1);
    var TextGeometry1 = /*#__PURE__*/ function(_ExtrudeGeometry) {
        _inheritsLoose(TextGeometry2, _ExtrudeGeometry);
        function TextGeometry2(text, parameters) {
            var _this;
            if (parameters === void 0) parameters = {
            };
            var font = parameters.font;
            if (!(font && font.isFont)) {
                console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
                return new BufferGeometry();
            }
            var shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API
            parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults
            if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
            if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
            if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
            _this = _ExtrudeGeometry.call(this, shapes, parameters) || this;
            _this.type = 'TextGeometry';
            return _this;
        }
        return TextGeometry2;
    }(ExtrudeGeometry1);
    var TorusGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(TorusGeometry2, _BufferGeometry);
        function TorusGeometry2(radius, tube, radialSegments, tubularSegments, arc) {
            var _this;
            if (radius === void 0) radius = 1;
            if (tube === void 0) tube = 0.4;
            if (radialSegments === void 0) radialSegments = 8;
            if (tubularSegments === void 0) tubularSegments = 6;
            if (arc === void 0) arc = Math.PI * 2;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'TorusGeometry';
            _this.parameters = {
                radius: radius,
                tube: tube,
                radialSegments: radialSegments,
                tubularSegments: tubularSegments,
                arc: arc
            };
            radialSegments = Math.floor(radialSegments);
            tubularSegments = Math.floor(tubularSegments); // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = []; // helper variables
            var center2 = new Vector3();
            var vertex = new Vector3();
            var normal = new Vector3(); // generate vertices, normals and uvs
            for(var j = 0; j <= radialSegments; j++)for(var i43 = 0; i43 <= tubularSegments; i43++){
                var u = i43 / tubularSegments * arc;
                var v = j / radialSegments * Math.PI * 2; // vertex
                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                vertex.z = tube * Math.sin(v);
                vertices.push(vertex.x, vertex.y, vertex.z); // normal
                center2.x = radius * Math.cos(u);
                center2.y = radius * Math.sin(u);
                normal.subVectors(vertex, center2).normalize();
                normals.push(normal.x, normal.y, normal.z); // uv
                uvs.push(i43 / tubularSegments);
                uvs.push(j / radialSegments);
            }
             // generate indices
            for(var _j = 1; _j <= radialSegments; _j++)for(var _i = 1; _i <= tubularSegments; _i++){
                // indices
                var a = (tubularSegments + 1) * _j + _i - 1;
                var b = (tubularSegments + 1) * (_j - 1) + _i - 1;
                var c = (tubularSegments + 1) * (_j - 1) + _i;
                var d = (tubularSegments + 1) * _j + _i; // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
             // build geometry
            _this.setIndex(indices);
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
            return _this;
        }
        return TorusGeometry2;
    }(BufferGeometry);
    var TorusKnotGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(TorusKnotGeometry2, _BufferGeometry);
        function TorusKnotGeometry2(radius, tube, tubularSegments, radialSegments, p, q) {
            var _this;
            if (radius === void 0) radius = 1;
            if (tube === void 0) tube = 0.4;
            if (tubularSegments === void 0) tubularSegments = 64;
            if (radialSegments === void 0) radialSegments = 8;
            if (p === void 0) p = 2;
            if (q === void 0) q = 3;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'TorusKnotGeometry';
            _this.parameters = {
                radius: radius,
                tube: tube,
                tubularSegments: tubularSegments,
                radialSegments: radialSegments,
                p: p,
                q: q
            };
            tubularSegments = Math.floor(tubularSegments);
            radialSegments = Math.floor(radialSegments); // buffers
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = []; // helper variables
            var vertex = new Vector3();
            var normal = new Vector3();
            var P1 = new Vector3();
            var P2 = new Vector3();
            var B = new Vector3();
            var T = new Vector3();
            var N = new Vector3(); // generate vertices, normals and uvs
            for(var i43 = 0; i43 <= tubularSegments; ++i43){
                // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
                var u = i43 / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
                // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
                calculatePositionOnCurve(u, p, q, radius, P1);
                calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis
                T.subVectors(P2, P1);
                N.addVectors(P2, P1);
                B.crossVectors(T, N);
                N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it
                B.normalize();
                N.normalize();
                for(var j = 0; j <= radialSegments; ++j){
                    // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                    // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
                    var v = j / radialSegments * Math.PI * 2;
                    var cx = -tube * Math.cos(v);
                    var cy = tube * Math.sin(v); // now calculate the final vertex position.
                    // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
                    vertex.x = P1.x + (cx * N.x + cy * B.x);
                    vertex.y = P1.y + (cx * N.y + cy * B.y);
                    vertex.z = P1.z + (cx * N.z + cy * B.z);
                    vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
                    normal.subVectors(vertex, P1).normalize();
                    normals.push(normal.x, normal.y, normal.z); // uv
                    uvs.push(i43 / tubularSegments);
                    uvs.push(j / radialSegments);
                }
            } // generate indices
            for(var _j = 1; _j <= tubularSegments; _j++)for(var _i = 1; _i <= radialSegments; _i++){
                // indices
                var a = (radialSegments + 1) * (_j - 1) + (_i - 1);
                var b = (radialSegments + 1) * _j + (_i - 1);
                var c = (radialSegments + 1) * _j + _i;
                var d = (radialSegments + 1) * (_j - 1) + _i; // faces
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
             // build geometry
            _this.setIndex(indices);
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve
            function calculatePositionOnCurve(u, p1, q1, radius1, position) {
                var cu = Math.cos(u);
                var su = Math.sin(u);
                var quOverP = q1 / p1 * u;
                var cs = Math.cos(quOverP);
                position.x = radius1 * (2 + cs) * 0.5 * cu;
                position.y = radius1 * (2 + cs) * su * 0.5;
                position.z = radius1 * Math.sin(quOverP) * 0.5;
            }
            return _this;
        }
        return TorusKnotGeometry2;
    }(BufferGeometry);
    var TubeGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(TubeGeometry2, _BufferGeometry);
        function TubeGeometry2(path, tubularSegments, radius, radialSegments, closed) {
            var _this;
            if (tubularSegments === void 0) tubularSegments = 64;
            if (radius === void 0) radius = 1;
            if (radialSegments === void 0) radialSegments = 8;
            if (closed === void 0) closed = false;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'TubeGeometry';
            _this.parameters = {
                path: path,
                tubularSegments: tubularSegments,
                radius: radius,
                radialSegments: radialSegments,
                closed: closed
            };
            var frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals
            _this.tangents = frames.tangents;
            _this.normals = frames.normals;
            _this.binormals = frames.binormals; // helper variables
            var vertex = new Vector3();
            var normal = new Vector3();
            var uv = new Vector2();
            var P = new Vector3(); // buffer
            var vertices = [];
            var normals = [];
            var uvs = [];
            var indices = []; // create buffer data
            generateBufferData(); // build geometry
            _this.setIndex(indices);
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            _this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            _this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions
            function generateBufferData() {
                for(var i43 = 0; i43 < tubularSegments; i43++)generateSegment(i43);
                 // if the geometry is not closed, generate the last row of vertices and normals
                // at the regular position on the given path
                //
                // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
                generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
                // this makes it easy compute correct values for closed geometries
                generateUVs(); // finally create faces
                generateIndices();
            }
            function generateSegment(i43) {
                // we use getPointAt to sample evenly distributed points from the given path
                P = path.getPointAt(i43 / tubularSegments, P); // retrieve corresponding normal and binormal
                var N = frames.normals[i43];
                var B = frames.binormals[i43]; // generate normals and vertices for the current segment
                for(var j = 0; j <= radialSegments; j++){
                    var v = j / radialSegments * Math.PI * 2;
                    var sin = Math.sin(v);
                    var cos = -Math.cos(v); // normal
                    normal.x = cos * N.x + sin * B.x;
                    normal.y = cos * N.y + sin * B.y;
                    normal.z = cos * N.z + sin * B.z;
                    normal.normalize();
                    normals.push(normal.x, normal.y, normal.z); // vertex
                    vertex.x = P.x + radius * normal.x;
                    vertex.y = P.y + radius * normal.y;
                    vertex.z = P.z + radius * normal.z;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            }
            function generateIndices() {
                for(var j = 1; j <= tubularSegments; j++)for(var i43 = 1; i43 <= radialSegments; i43++){
                    var a = (radialSegments + 1) * (j - 1) + (i43 - 1);
                    var b = (radialSegments + 1) * j + (i43 - 1);
                    var c = (radialSegments + 1) * j + i43;
                    var d = (radialSegments + 1) * (j - 1) + i43; // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
            function generateUVs() {
                for(var i43 = 0; i43 <= tubularSegments; i43++)for(var j = 0; j <= radialSegments; j++){
                    uv.x = i43 / tubularSegments;
                    uv.y = j / radialSegments;
                    uvs.push(uv.x, uv.y);
                }
            }
            return _this;
        }
        var _proto = TubeGeometry2.prototype;
        _proto.toJSON = function toJSON() {
            var data = BufferGeometry.prototype.toJSON.call(this);
            data.path = this.parameters.path.toJSON();
            return data;
        };
        return TubeGeometry2;
    }(BufferGeometry);
    var WireframeGeometry1 = /*#__PURE__*/ function(_BufferGeometry) {
        _inheritsLoose(WireframeGeometry2, _BufferGeometry);
        function WireframeGeometry2(geometry) {
            var _this;
            _this = _BufferGeometry.call(this) || this;
            _this.type = 'WireframeGeometry';
            if (geometry.isGeometry === true) {
                console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
                return _assertThisInitialized(_this);
            } // buffer
            var vertices = []; // helper variables
            var edge = [
                0,
                0
            ], edges = {
            };
            var vertex = new Vector3();
            if (geometry.index !== null) {
                // indexed BufferGeometry
                var position = geometry.attributes.position;
                var indices = geometry.index;
                var groups = geometry.groups;
                if (groups.length === 0) groups = [
                    {
                        start: 0,
                        count: indices.count,
                        materialIndex: 0
                    }
                ];
                 // create a data structure that contains all eges without duplicates
                for(var o = 0, ol = groups.length; o < ol; ++o){
                    var group = groups[o];
                    var start = group.start;
                    var count = group.count;
                    for(var i43 = start, l = start + count; i43 < l; i43 += 3)for(var j = 0; j < 3; j++){
                        var edge1 = indices.getX(i43 + j);
                        var edge2 = indices.getX(i43 + (j + 1) % 3);
                        edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                        edge[1] = Math.max(edge1, edge2);
                        var key3 = edge[0] + ',' + edge[1];
                        if (edges[key3] === undefined) edges[key3] = {
                            index1: edge[0],
                            index2: edge[1]
                        };
                    }
                } // generate vertices
                for(var _key in edges){
                    var e = edges[_key];
                    vertex.fromBufferAttribute(position, e.index1);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    vertex.fromBufferAttribute(position, e.index2);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            } else {
                // non-indexed BufferGeometry
                var _position1 = geometry.attributes.position;
                for(var _i = 0, _l = _position1.count / 3; _i < _l; _i++)for(var _j = 0; _j < 3; _j++){
                    // three edges per triangle, an edge is represented as (index1, index2)
                    // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
                    var index1 = 3 * _i + _j;
                    vertex.fromBufferAttribute(_position1, index1);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    var index2 = 3 * _i + (_j + 1) % 3;
                    vertex.fromBufferAttribute(_position1, index2);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            } // build geometry
            _this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            return _this;
        }
        return WireframeGeometry2;
    }(BufferGeometry);
    var Geometries = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        BoxGeometry: BoxGeometry1,
        BoxBufferGeometry: BoxGeometry1,
        CircleGeometry: CircleGeometry1,
        CircleBufferGeometry: CircleGeometry1,
        ConeGeometry: ConeGeometry1,
        ConeBufferGeometry: ConeGeometry1,
        CylinderGeometry: CylinderGeometry1,
        CylinderBufferGeometry: CylinderGeometry1,
        DodecahedronGeometry: DodecahedronGeometry1,
        DodecahedronBufferGeometry: DodecahedronGeometry1,
        EdgesGeometry: EdgesGeometry1,
        ExtrudeGeometry: ExtrudeGeometry1,
        ExtrudeBufferGeometry: ExtrudeGeometry1,
        IcosahedronGeometry: IcosahedronGeometry1,
        IcosahedronBufferGeometry: IcosahedronGeometry1,
        LatheGeometry: LatheGeometry1,
        LatheBufferGeometry: LatheGeometry1,
        OctahedronGeometry: OctahedronGeometry1,
        OctahedronBufferGeometry: OctahedronGeometry1,
        ParametricGeometry: ParametricGeometry,
        ParametricBufferGeometry: ParametricGeometry,
        PlaneGeometry: PlaneGeometry1,
        PlaneBufferGeometry: PlaneGeometry1,
        PolyhedronGeometry: PolyhedronGeometry1,
        PolyhedronBufferGeometry: PolyhedronGeometry1,
        RingGeometry: RingGeometry1,
        RingBufferGeometry: RingGeometry1,
        ShapeGeometry: ShapeGeometry1,
        ShapeBufferGeometry: ShapeGeometry1,
        SphereGeometry: SphereGeometry1,
        SphereBufferGeometry: SphereGeometry1,
        TetrahedronGeometry: TetrahedronGeometry1,
        TetrahedronBufferGeometry: TetrahedronGeometry1,
        TextGeometry: TextGeometry1,
        TextBufferGeometry: TextGeometry1,
        TorusGeometry: TorusGeometry1,
        TorusBufferGeometry: TorusGeometry1,
        TorusKnotGeometry: TorusKnotGeometry1,
        TorusKnotBufferGeometry: TorusKnotGeometry1,
        TubeGeometry: TubeGeometry1,
        TubeBufferGeometry: TubeGeometry1,
        WireframeGeometry: WireframeGeometry1
    });
    /**
	 * parameters = {
	 *	color: <THREE.Color>
	 * }
	 */ function ShadowMaterial(parameters) {
        Material.call(this);
        this.type = 'ShadowMaterial';
        this.color = new Color(0);
        this.transparent = true;
        this.setValues(parameters);
    }
    ShadowMaterial.prototype = Object.create(Material.prototype);
    ShadowMaterial.prototype.constructor = ShadowMaterial;
    ShadowMaterial.prototype.isShadowMaterial = true;
    ShadowMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        return this;
    };
    function RawShaderMaterial(parameters) {
        ShaderMaterial.call(this, parameters);
        this.type = 'RawShaderMaterial';
    }
    RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;
    RawShaderMaterial.prototype.isRawShaderMaterial = true;
    /**
	 * parameters = {
	 *	color: <hex>,
	 *	roughness: <float>,
	 *	metalness: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *	metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	envMapIntensity: <float>
	 *
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */ function MeshStandardMaterial(parameters) {
        Material.call(this);
        this.defines = {
            'STANDARD': ''
        };
        this.type = 'MeshStandardMaterial';
        this.color = new Color(16777215); // diffuse
        this.roughness = 1;
        this.metalness = 0;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.vertexTangents = false;
        this.setValues(parameters);
    }
    MeshStandardMaterial.prototype = Object.create(Material.prototype);
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
    MeshStandardMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.defines = {
            'STANDARD': ''
        };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.vertexTangents = source.vertexTangents;
        return this;
    };
    /**
	 * parameters = {
	 *	clearcoat: <float>,
	 *	clearcoatMap: new THREE.Texture( <Image> ),
	 *	clearcoatRoughness: <float>,
	 *	clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	 *	clearcoatNormalScale: <Vector2>,
	 *	clearcoatNormalMap: new THREE.Texture( <Image> ),
	 *
	 *	reflectivity: <float>,
	 *	ior: <float>,
	 *
	 *	sheen: <Color>,
	 *
	 *	transmission: <float>,
	 *	transmissionMap: new THREE.Texture( <Image> )
	 * }
	 */ function MeshPhysicalMaterial(parameters) {
        MeshStandardMaterial.call(this);
        this.defines = {
            'STANDARD': '',
            'PHYSICAL': ''
        };
        this.type = 'MeshPhysicalMaterial';
        this.clearcoat = 0;
        this.clearcoatMap = null;
        this.clearcoatRoughness = 0;
        this.clearcoatRoughnessMap = null;
        this.clearcoatNormalScale = new Vector2(1, 1);
        this.clearcoatNormalMap = null;
        this.reflectivity = 0.5; // maps to F0 = 0.04
        Object.defineProperty(this, 'ior', {
            get: function get() {
                return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
            },
            set: function set(ior) {
                this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
            }
        });
        this.sheen = null; // null will disable sheen bsdf
        this.transmission = 0;
        this.transmissionMap = null;
        this.setValues(parameters);
    }
    MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
    MeshPhysicalMaterial.prototype.copy = function(source) {
        MeshStandardMaterial.prototype.copy.call(this, source);
        this.defines = {
            'STANDARD': '',
            'PHYSICAL': ''
        };
        this.clearcoat = source.clearcoat;
        this.clearcoatMap = source.clearcoatMap;
        this.clearcoatRoughness = source.clearcoatRoughness;
        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
        this.clearcoatNormalMap = source.clearcoatNormalMap;
        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
        this.reflectivity = source.reflectivity;
        if (source.sheen) this.sheen = (this.sheen || new Color()).copy(source.sheen);
        else this.sheen = null;
        this.transmission = source.transmission;
        this.transmissionMap = source.transmissionMap;
        return this;
    };
    /**
	 * parameters = {
	 *	color: <hex>,
	 *	specular: <hex>,
	 *	shininess: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.MultiplyOperation,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */ function MeshPhongMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshPhongMaterial';
        this.color = new Color(16777215); // diffuse
        this.specular = new Color(1118481);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshPhongMaterial.prototype = Object.create(Material.prototype);
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
    MeshPhongMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    /**
	 * parameters = {
	 *	color: <hex>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *	gradientMap: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */ function MeshToonMaterial(parameters) {
        Material.call(this);
        this.defines = {
            'TOON': ''
        };
        this.type = 'MeshToonMaterial';
        this.color = new Color(16777215);
        this.map = null;
        this.gradientMap = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshToonMaterial.prototype = Object.create(Material.prototype);
    MeshToonMaterial.prototype.constructor = MeshToonMaterial;
    MeshToonMaterial.prototype.isMeshToonMaterial = true;
    MeshToonMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.gradientMap = source.gradientMap;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    /**
	 * parameters = {
	 *	opacity: <float>,
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */ function MeshNormalMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshNormalMaterial';
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshNormalMaterial.prototype = Object.create(Material.prototype);
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
    MeshNormalMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    /**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */ function MeshLambertMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshLambertMaterial';
        this.color = new Color(16777215); // diffuse
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshLambertMaterial.prototype = Object.create(Material.prototype);
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
    MeshLambertMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    /**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	matcap: new THREE.Texture( <Image> ),
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	skinning: <bool>,
	 *	morphTargets: <bool>,
	 *	morphNormals: <bool>
	 * }
	 */ function MeshMatcapMaterial(parameters) {
        Material.call(this);
        this.defines = {
            'MATCAP': ''
        };
        this.type = 'MeshMatcapMaterial';
        this.color = new Color(16777215); // diffuse
        this.matcap = null;
        this.map = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshMatcapMaterial.prototype = Object.create(Material.prototype);
    MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
    MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
    MeshMatcapMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.defines = {
            'MATCAP': ''
        };
        this.color.copy(source.color);
        this.matcap = source.matcap;
        this.map = source.map;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    /**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *
	 *	scale: <float>,
	 *	dashSize: <float>,
	 *	gapSize: <float>
	 * }
	 */ function LineDashedMaterial(parameters) {
        LineBasicMaterial.call(this);
        this.type = 'LineDashedMaterial';
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters);
    }
    LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;
    LineDashedMaterial.prototype.isLineDashedMaterial = true;
    LineDashedMaterial.prototype.copy = function(source) {
        LineBasicMaterial.prototype.copy.call(this, source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
    };
    var Materials = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        ShadowMaterial: ShadowMaterial,
        SpriteMaterial: SpriteMaterial,
        RawShaderMaterial: RawShaderMaterial,
        ShaderMaterial: ShaderMaterial,
        PointsMaterial: PointsMaterial,
        MeshPhysicalMaterial: MeshPhysicalMaterial,
        MeshStandardMaterial: MeshStandardMaterial,
        MeshPhongMaterial: MeshPhongMaterial,
        MeshToonMaterial: MeshToonMaterial,
        MeshNormalMaterial: MeshNormalMaterial,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshDepthMaterial: MeshDepthMaterial,
        MeshDistanceMaterial: MeshDistanceMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        MeshMatcapMaterial: MeshMatcapMaterial,
        LineDashedMaterial: LineDashedMaterial,
        LineBasicMaterial: LineBasicMaterial,
        Material: Material
    });
    var AnimationUtils = {
        // same as Array.prototype.slice, but also works on typed arrays
        arraySlice: function arraySlice(array, from, to) {
            if (AnimationUtils.isTypedArray(array)) // in ios9 array.subarray(from, undefined) will return empty array
            // but array.subarray(from) or array.subarray(from, len) is correct
            return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
            return array.slice(from, to);
        },
        // converts an array to a specific type
        convertArray: function convertArray(array, type, forceClone) {
            if (!array || !forceClone && array.constructor === type) return array;
            if (typeof type.BYTES_PER_ELEMENT === 'number') return new type(array); // create typed array
            return Array.prototype.slice.call(array); // create Array
        },
        isTypedArray: function isTypedArray(object) {
            return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        // returns an array by which times and values can be sorted
        getKeyframeOrder: function getKeyframeOrder(times) {
            function compareTime(i44, j) {
                return times[i44] - times[j];
            }
            var n = times.length;
            var result = new Array(n);
            for(var i44 = 0; i44 !== n; ++i44)result[i44] = i44;
            result.sort(compareTime);
            return result;
        },
        // uses the array previously returned by 'getKeyframeOrder' to sort data
        sortedArray: function sortedArray(values, stride, order) {
            var nValues = values.length;
            var result = new values.constructor(nValues);
            for(var i44 = 0, dstOffset = 0; dstOffset !== nValues; ++i44){
                var srcOffset = order[i44] * stride;
                for(var j = 0; j !== stride; ++j)result[dstOffset++] = values[srcOffset + j];
            }
            return result;
        },
        // function for parsing AOS keyframe formats
        flattenJSON: function flattenJSON(jsonKeys, times, values, valuePropertyName) {
            var i44 = 1, key4 = jsonKeys[0];
            while(key4 !== undefined && key4[valuePropertyName] === undefined)key4 = jsonKeys[i44++];
            if (key4 === undefined) return; // no data
            var value = key4[valuePropertyName];
            if (value === undefined) return; // no data
            if (Array.isArray(value)) do {
                value = key4[valuePropertyName];
                if (value !== undefined) {
                    times.push(key4.time);
                    values.push.apply(values, value); // push all elements
                }
                key4 = jsonKeys[i44++];
            }while (key4 !== undefined)
            else if (value.toArray !== undefined) // ...assume THREE.Math-ish
            do {
                value = key4[valuePropertyName];
                if (value !== undefined) {
                    times.push(key4.time);
                    value.toArray(values, values.length);
                }
                key4 = jsonKeys[i44++];
            }while (key4 !== undefined)
            else // otherwise push as-is
            do {
                value = key4[valuePropertyName];
                if (value !== undefined) {
                    times.push(key4.time);
                    values.push(value);
                }
                key4 = jsonKeys[i44++];
            }while (key4 !== undefined)
        },
        subclip: function subclip(sourceClip, name, startFrame, endFrame, fps) {
            if (fps === void 0) fps = 30;
            var clip = sourceClip.clone();
            clip.name = name;
            var tracks = [];
            for(var i44 = 0; i44 < clip.tracks.length; ++i44){
                var track = clip.tracks[i44];
                var valueSize = track.getValueSize();
                var times = [];
                var values = [];
                for(var j = 0; j < track.times.length; ++j){
                    var frame = track.times[j] * fps;
                    if (frame < startFrame || frame >= endFrame) continue;
                    times.push(track.times[j]);
                    for(var k = 0; k < valueSize; ++k)values.push(track.values[j * valueSize + k]);
                }
                if (times.length === 0) continue;
                track.times = AnimationUtils.convertArray(times, track.times.constructor);
                track.values = AnimationUtils.convertArray(values, track.values.constructor);
                tracks.push(track);
            }
            clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip
            var minStartTime = Infinity;
            for(var _i = 0; _i < clip.tracks.length; ++_i)if (minStartTime > clip.tracks[_i].times[0]) minStartTime = clip.tracks[_i].times[0];
             // shift all tracks such that clip begins at t=0
            for(var _i2 = 0; _i2 < clip.tracks.length; ++_i2)clip.tracks[_i2].shift(-1 * minStartTime);
            clip.resetDuration();
            return clip;
        },
        makeClipAdditive: function makeClipAdditive(targetClip, referenceFrame, referenceClip, fps) {
            if (referenceFrame === void 0) referenceFrame = 0;
            if (referenceClip === void 0) referenceClip = targetClip;
            if (fps === void 0) fps = 30;
            if (fps <= 0) fps = 30;
            var numTracks = referenceClip.tracks.length;
            var referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame
            var _loop = function _loop1(i44) {
                var referenceTrack = referenceClip.tracks[i44];
                var referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric
                if (referenceTrackType === 'bool' || referenceTrackType === 'string') return "continue"; // Find the track in the target clip whose name and type matches the reference track
                var targetTrack = targetClip.tracks.find(function(track) {
                    return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
                });
                if (targetTrack === undefined) return "continue";
                var referenceOffset = 0;
                var referenceValueSize = referenceTrack.getValueSize();
                if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) referenceOffset = referenceValueSize / 3;
                var targetOffset = 0;
                var targetValueSize = targetTrack.getValueSize();
                if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) targetOffset = targetValueSize / 3;
                var lastIndex = referenceTrack.times.length - 1;
                var referenceValue = void 0; // Find the value to subtract out of the track
                if (referenceTime <= referenceTrack.times[0]) {
                    // Reference frame is earlier than the first keyframe, so just use the first keyframe
                    var startIndex = referenceOffset;
                    var endIndex = referenceValueSize - referenceOffset;
                    referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
                } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                    // Reference frame is after the last keyframe, so just use the last keyframe
                    var _startIndex = lastIndex * referenceValueSize + referenceOffset;
                    var _endIndex = _startIndex + referenceValueSize - referenceOffset;
                    referenceValue = AnimationUtils.arraySlice(referenceTrack.values, _startIndex, _endIndex);
                } else {
                    // Interpolate to the reference value
                    var interpolant = referenceTrack.createInterpolant();
                    var _startIndex2 = referenceOffset;
                    var _endIndex2 = referenceValueSize - referenceOffset;
                    interpolant.evaluate(referenceTime);
                    referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, _startIndex2, _endIndex2);
                } // Conjugate the quaternion
                if (referenceTrackType === 'quaternion') {
                    var referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
                    referenceQuat.toArray(referenceValue);
                } // Subtract the reference value from all of the track values
                var numTimes = targetTrack.times.length;
                for(var j = 0; j < numTimes; ++j){
                    var valueStart = j * targetValueSize + targetOffset;
                    if (referenceTrackType === 'quaternion') // Multiply the conjugate for quaternion track types
                    Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                    else {
                        var valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types
                        for(var k = 0; k < valueEnd; ++k)targetTrack.values[valueStart + k] -= referenceValue[k];
                    }
                }
            };
            for(var i44 = 0; i44 < numTracks; ++i44){
                var _ret = _loop(i44);
                if (_ret === "continue") continue;
            }
            targetClip.blendMode = AdditiveAnimationBlendMode;
            return targetClip;
        }
    };
    /**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */ function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
    }
    Object.assign(Interpolant.prototype, {
        evaluate: function evaluate(t) {
            var pp = this.parameterPositions;
            var i110 = this._cachedIndex, t1 = pp[i110], t0 = pp[i110 - 1];
            validate_interval: {
                seek: {
                    var right;
                    linear_scan: {
                        //- See http://jsperf.com/comparison-to-undefined/3
                        //- slower code:
                        //-
                        //- 				if ( t >= t1 || t1 === undefined ) {
                        forward_scan: if (!(t < t1)) {
                            for(var giveUpAt = i110 + 2;;){
                                if (t1 === undefined) {
                                    if (t < t0) break forward_scan; // after end
                                    i110 = pp.length;
                                    this._cachedIndex = i110;
                                    return this.afterEnd_(i110 - 1, t, t0);
                                }
                                if (i110 === giveUpAt) break; // this loop
                                t0 = t1;
                                t1 = pp[++i110];
                                if (t < t1) break seek;
                            } // prepare binary search on the right side of the index
                            right = pp.length;
                            break linear_scan;
                        } //- slower code:
                        //-					if ( t < t0 || t0 === undefined ) {
                        if (!(t >= t0)) {
                            // looping?
                            var t1global = pp[1];
                            if (t < t1global) {
                                i110 = 2; // + 1, using the scan for the details
                                t0 = t1global;
                            } // linear reverse scan
                            for(var _giveUpAt = i110 - 2;;){
                                if (t0 === undefined) {
                                    // before start
                                    this._cachedIndex = 0;
                                    return this.beforeStart_(0, t, t1);
                                }
                                if (i110 === _giveUpAt) break; // this loop
                                t1 = t0;
                                t0 = pp[(--i110) - 1];
                                if (t >= t0) break seek;
                            } // prepare binary search on the left side of the index
                            right = i110;
                            i110 = 0;
                            break linear_scan;
                        } // the interval is valid
                        break validate_interval;
                    } // linear scan
                    // binary search
                    while(i110 < right){
                        var mid = i110 + right >>> 1;
                        if (t < pp[mid]) right = mid;
                        else i110 = mid + 1;
                    }
                    t1 = pp[i110];
                    t0 = pp[i110 - 1]; // check boundary cases, again
                    if (t0 === undefined) {
                        this._cachedIndex = 0;
                        return this.beforeStart_(0, t, t1);
                    }
                    if (t1 === undefined) {
                        i110 = pp.length;
                        this._cachedIndex = i110;
                        return this.afterEnd_(i110 - 1, t0, t);
                    }
                } // seek
                this._cachedIndex = i110;
                this.intervalChanged_(i110, t0, t1);
            } // validate_interval
            return this.interpolate_(i110, t0, t, t1);
        },
        settings: null,
        // optional, subclass-specific settings structure
        // Note: The indirection allows central control of many interpolants.
        // --- Protected interface
        DefaultSettings_: {
        },
        getSettings_: function getSettings_() {
            return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function copySampleValue_(index) {
            // copies a sample value to the result buffer
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
            for(var i44 = 0; i44 !== stride; ++i44)result[i44] = values[offset + i44];
            return result;
        },
        // Template methods for derived classes:
        interpolate_: function interpolate_() /* i1, t0, t, t1 */ {
            throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
        },
        intervalChanged_: function intervalChanged_() /* i1, t0, t1 */ {
        }
    }); // DECLARE ALIAS AFTER assign prototype
    Object.assign(Interpolant.prototype, {
        //( 0, t, t0 ), returns this.resultBuffer
        beforeStart_: Interpolant.prototype.copySampleValue_,
        //( N-1, tN-1, t ), returns this.resultBuffer
        afterEnd_: Interpolant.prototype.copySampleValue_
    });
    /**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */ function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
    }
    CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: CubicInterpolant,
        DefaultSettings_: {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        },
        intervalChanged_: function intervalChanged_(i110, t0, t1) {
            var pp = this.parameterPositions;
            var iPrev = i110 - 2, iNext = i110 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
            if (tPrev === undefined) switch(this.getSettings_().endingStart){
                case ZeroSlopeEnding:
                    // f'(t0) = 0
                    iPrev = i110;
                    tPrev = 2 * t0 - t1;
                    break;
                case WrapAroundEnding:
                    // use the other end of the curve
                    iPrev = pp.length - 2;
                    tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                    break;
                default:
                    // ZeroCurvatureEnding
                    // f''(t0) = 0 a.k.a. Natural Spline
                    iPrev = i110;
                    tPrev = t1;
            }
            if (tNext === undefined) switch(this.getSettings_().endingEnd){
                case ZeroSlopeEnding:
                    // f'(tN) = 0
                    iNext = i110;
                    tNext = 2 * t1 - t0;
                    break;
                case WrapAroundEnding:
                    // use the other end of the curve
                    iNext = 1;
                    tNext = t1 + pp[1] - pp[0];
                    break;
                default:
                    // ZeroCurvatureEnding
                    // f''(tN) = 0, a.k.a. Natural Spline
                    iNext = i110 - 1;
                    tNext = t0;
            }
            var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
            this._weightPrev = halfDt / (t0 - tPrev);
            this._weightNext = halfDt / (tNext - t1);
            this._offsetPrev = iPrev * stride;
            this._offsetNext = iNext * stride;
        },
        interpolate_: function interpolate_(i110, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i110 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p; // evaluate polynomials
            var sP = -wP * ppp + 2 * wP * pp - wP * p;
            var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
            var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
            var sN = wN * ppp - wN * pp; // combine data linearly
            for(var i44 = 0; i44 !== stride; ++i44)result[i44] = sP * values[oP + i44] + s0 * values[o0 + i44] + s1 * values[o1 + i44] + sN * values[oN + i44];
            return result;
        }
    });
    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: LinearInterpolant,
        interpolate_: function interpolate_(i110, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i110 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
            for(var i44 = 0; i44 !== stride; ++i44)result[i44] = values[offset0 + i44] * weight0 + values[offset1 + i44] * weight1;
            return result;
        }
    });
    /**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 */ function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: DiscreteInterpolant,
        interpolate_: function interpolate_(i110) {
            return this.copySampleValue_(i110 - 1);
        }
    });
    function KeyframeTrack(name, times, values, interpolation) {
        if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
        if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
        this.name = name;
        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
    } // Static methods
    Object.assign(KeyframeTrack, {
        // Serialization (in static context, because of constructor invocation
        // and automatic invocation of .toJSON):
        toJSON: function toJSON(track) {
            var trackType = track.constructor;
            var json; // derived classes can define a static toJSON method
            if (trackType.toJSON !== undefined) json = trackType.toJSON(track);
            else {
                // by default, we assume the data can be serialized as-is
                json = {
                    'name': track.name,
                    'times': AnimationUtils.convertArray(track.times, Array),
                    'values': AnimationUtils.convertArray(track.values, Array)
                };
                var interpolation = track.getInterpolation();
                if (interpolation !== track.DefaultInterpolation) json.interpolation = interpolation;
            }
            json.type = track.ValueTypeName; // mandatory
            return json;
        }
    });
    Object.assign(KeyframeTrack.prototype, {
        constructor: KeyframeTrack,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodDiscrete: function InterpolantFactoryMethodDiscrete(result) {
            return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodLinear: function InterpolantFactoryMethodLinear(result) {
            return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: function InterpolantFactoryMethodSmooth(result) {
            return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        setInterpolation: function setInterpolation(interpolation) {
            var factoryMethod;
            switch(interpolation){
                case InterpolateDiscrete:
                    factoryMethod = this.InterpolantFactoryMethodDiscrete;
                    break;
                case InterpolateLinear:
                    factoryMethod = this.InterpolantFactoryMethodLinear;
                    break;
                case InterpolateSmooth:
                    factoryMethod = this.InterpolantFactoryMethodSmooth;
                    break;
            }
            if (factoryMethod === undefined) {
                var message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
                if (this.createInterpolant === undefined) {
                    // fall back to default, unless the default itself is messed up
                    if (interpolation !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                    else throw new Error(message); // fatal, in this case
                }
                console.warn('THREE.KeyframeTrack:', message);
                return this;
            }
            this.createInterpolant = factoryMethod;
            return this;
        },
        getInterpolation: function getInterpolation() {
            switch(this.createInterpolant){
                case this.InterpolantFactoryMethodDiscrete:
                    return InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                    return InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                    return InterpolateSmooth;
            }
        },
        getValueSize: function getValueSize() {
            return this.values.length / this.times.length;
        },
        // move all keyframes either forwards or backwards in time
        shift: function shift(timeOffset) {
            if (timeOffset !== 0) {
                var times = this.times;
                for(var i44 = 0, n = times.length; i44 !== n; ++i44)times[i44] += timeOffset;
            }
            return this;
        },
        // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
        scale: function scale(timeScale) {
            if (timeScale !== 1) {
                var times = this.times;
                for(var i45 = 0, n = times.length; i45 !== n; ++i45)times[i45] *= timeScale;
            }
            return this;
        },
        // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
        // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
        trim: function trim(startTime, endTime) {
            var times = this.times, nKeys = times.length;
            var from = 0, to = nKeys - 1;
            while(from !== nKeys && times[from] < startTime)++from;
            while(to !== -1 && times[to] > endTime)--to;
            ++to; // inclusive -> exclusive bound
            if (from !== 0 || to !== nKeys) {
                // empty tracks are forbidden, so keep at least one keyframe
                if (from >= to) {
                    to = Math.max(to, 1);
                    from = to - 1;
                }
                var stride = this.getValueSize();
                this.times = AnimationUtils.arraySlice(times, from, to);
                this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
            }
            return this;
        },
        // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
        validate: function validate() {
            var valid = true;
            var valueSize = this.getValueSize();
            if (valueSize - Math.floor(valueSize) !== 0) {
                console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
                valid = false;
            }
            var times = this.times, values = this.values, nKeys = times.length;
            if (nKeys === 0) {
                console.error('THREE.KeyframeTrack: Track is empty.', this);
                valid = false;
            }
            var prevTime = null;
            for(var i46 = 0; i46 !== nKeys; i46++){
                var currTime = times[i46];
                if (typeof currTime === 'number' && isNaN(currTime)) {
                    console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i46, currTime);
                    valid = false;
                    break;
                }
                if (prevTime !== null && prevTime > currTime) {
                    console.error('THREE.KeyframeTrack: Out of order keys.', this, i46, currTime, prevTime);
                    valid = false;
                    break;
                }
                prevTime = currTime;
            }
            if (values !== undefined) {
                if (AnimationUtils.isTypedArray(values)) for(var _i = 0, n = values.length; _i !== n; ++_i){
                    var value = values[_i];
                    if (isNaN(value)) {
                        console.error('THREE.KeyframeTrack: Value is not a valid number.', this, _i, value);
                        valid = false;
                        break;
                    }
                }
            }
            return valid;
        },
        // removes equivalent sequential keys as common in morph target sequences
        // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
        optimize: function optimize() {
            // times or values may be shared with other tracks, so overwriting is unsafe
            var times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
            var writeIndex = 1;
            for(var i46 = 1; i46 < lastIndex; ++i46){
                var keep = false;
                var time = times[i46];
                var timeNext = times[i46 + 1]; // remove adjacent keyframes scheduled at the same time
                if (time !== timeNext && (i46 !== 1 || time !== times[0])) {
                    if (!smoothInterpolation) {
                        // remove unnecessary keyframes same as their neighbors
                        var offset = i46 * stride, offsetP = offset - stride, offsetN = offset + stride;
                        for(var j = 0; j !== stride; ++j){
                            var value = values[offset + j];
                            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                                keep = true;
                                break;
                            }
                        }
                    } else keep = true;
                } // in-place compaction
                if (keep) {
                    if (i46 !== writeIndex) {
                        times[writeIndex] = times[i46];
                        var readOffset = i46 * stride, writeOffset = writeIndex * stride;
                        for(var _j = 0; _j !== stride; ++_j)values[writeOffset + _j] = values[readOffset + _j];
                    }
                    ++writeIndex;
                }
            } // flush last keyframe (compaction looks ahead)
            if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for(var _readOffset = lastIndex * stride, _writeOffset = writeIndex * stride, _j2 = 0; _j2 !== stride; ++_j2)values[_writeOffset + _j2] = values[_readOffset + _j2];
                ++writeIndex;
            }
            if (writeIndex !== times.length) {
                this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
                this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
            } else {
                this.times = times;
                this.values = values;
            }
            return this;
        },
        clone: function clone() {
            var times = AnimationUtils.arraySlice(this.times, 0);
            var values = AnimationUtils.arraySlice(this.values, 0);
            var TypedKeyframeTrack = this.constructor;
            var track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.
            track.createInterpolant = this.createInterpolant;
            return track;
        }
    });
    /**
	 * A Track of Boolean keyframe values.
	 */ function BooleanKeyframeTrack(name, times, values) {
        KeyframeTrack.call(this, name, times, values);
    }
    BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: BooleanKeyframeTrack,
        ValueTypeName: 'bool',
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined
    });
    /**
	 * A Track of keyframe values that represent color.
	 */ function ColorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: ColorKeyframeTrack,
        ValueTypeName: 'color'
    });
    /**
	 * A Track of numeric keyframe values.
	 */ function NumberKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: NumberKeyframeTrack,
        ValueTypeName: 'number'
    });
    /**
	 * Spherical linear unit quaternion interpolant.
	 */ function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: QuaternionLinearInterpolant,
        interpolate_: function interpolate_(i110, t0, t, t1) {
            var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
            var offset = i110 * stride;
            for(var end = offset + stride; offset !== end; offset += 4)Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
            return result;
        }
    });
    /**
	 * A Track of quaternion keyframe values.
	 */ function QuaternionKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: QuaternionKeyframeTrack,
        ValueTypeName: 'quaternion',
        // ValueBufferType is inherited
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodLinear: function InterpolantFactoryMethodLinear(result) {
            return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: undefined
    });
    /**
	 * A Track that interpolates Strings
	 */ function StringKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: StringKeyframeTrack,
        ValueTypeName: 'string',
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined
    });
    /**
	 * A Track of vectored keyframe values.
	 */ function VectorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: VectorKeyframeTrack,
        ValueTypeName: 'vector'
    });
    function AnimationClip(name, duration, tracks, blendMode) {
        if (duration === void 0) duration = -1;
        if (blendMode === void 0) blendMode = NormalAnimationBlendMode;
        this.name = name;
        this.tracks = tracks;
        this.duration = duration;
        this.blendMode = blendMode;
        this.uuid = MathUtils.generateUUID(); // this means it should figure out its duration by scanning the tracks
        if (this.duration < 0) this.resetDuration();
    }
    function getTrackTypeForValueTypeName(typeName) {
        switch(typeName.toLowerCase()){
            case 'scalar':
            case 'double':
            case 'float':
            case 'number':
            case 'integer':
                return NumberKeyframeTrack;
            case 'vector':
            case 'vector2':
            case 'vector3':
            case 'vector4':
                return VectorKeyframeTrack;
            case 'color':
                return ColorKeyframeTrack;
            case 'quaternion':
                return QuaternionKeyframeTrack;
            case 'bool':
            case 'boolean':
                return BooleanKeyframeTrack;
            case 'string':
                return StringKeyframeTrack;
        }
        throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
    }
    function parseKeyframeTrack(json) {
        if (json.type === undefined) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
        var trackType = getTrackTypeForValueTypeName(json.type);
        if (json.times === undefined) {
            var times = [], values = [];
            AnimationUtils.flattenJSON(json.keys, times, values, 'value');
            json.times = times;
            json.values = values;
        } // derived classes can define a static parse method
        if (trackType.parse !== undefined) return trackType.parse(json);
        else // by default, we assume a constructor compatible with the base
        return new trackType(json.name, json.times, json.values, json.interpolation);
    }
    Object.assign(AnimationClip, {
        parse: function parse(json) {
            var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
            for(var i46 = 0, n = jsonTracks.length; i46 !== n; ++i46)tracks.push(parseKeyframeTrack(jsonTracks[i46]).scale(frameTime));
            var clip = new AnimationClip(json.name, json.duration, tracks, json.blendMode);
            clip.uuid = json.uuid;
            return clip;
        },
        toJSON: function toJSON(clip) {
            var tracks = [], clipTracks = clip.tracks;
            var json = {
                'name': clip.name,
                'duration': clip.duration,
                'tracks': tracks,
                'uuid': clip.uuid,
                'blendMode': clip.blendMode
            };
            for(var i46 = 0, n = clipTracks.length; i46 !== n; ++i46)tracks.push(KeyframeTrack.toJSON(clipTracks[i46]));
            return json;
        },
        CreateFromMorphTargetSequence: function CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
            var numMorphTargets = morphTargetSequence.length;
            var tracks = [];
            for(var i46 = 0; i46 < numMorphTargets; i46++){
                var times = [];
                var values = [];
                times.push((i46 + numMorphTargets - 1) % numMorphTargets, i46, (i46 + 1) % numMorphTargets);
                values.push(0, 1, 0);
                var order = AnimationUtils.getKeyframeOrder(times);
                times = AnimationUtils.sortedArray(times, 1, order);
                values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
                // last frame as well for perfect loop.
                if (!noLoop && times[0] === 0) {
                    times.push(numMorphTargets);
                    values.push(values[0]);
                }
                tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i46].name + ']', times, values).scale(1 / fps));
            }
            return new AnimationClip(name, -1, tracks);
        },
        findByName: function findByName(objectOrClipArray, name) {
            var clipArray = objectOrClipArray;
            if (!Array.isArray(objectOrClipArray)) {
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
            }
            for(var i46 = 0; i46 < clipArray.length; i46++){
                if (clipArray[i46].name === name) return clipArray[i46];
            }
            return null;
        },
        CreateClipsFromMorphTargetSequences: function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
            var animationToMorphTargets = {
            }; // tested with https://regex101.com/ on trick sequences
            // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
            var pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
            // patterns like Walk_001, Walk_002, Run_001, Run_002
            for(var i46 = 0, il = morphTargets.length; i46 < il; i46++){
                var morphTarget = morphTargets[i46];
                var parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                    var name = parts[1];
                    var animationMorphTargets = animationToMorphTargets[name];
                    if (!animationMorphTargets) animationToMorphTargets[name] = animationMorphTargets = [];
                    animationMorphTargets.push(morphTarget);
                }
            }
            var clips = [];
            for(var _name in animationToMorphTargets)clips.push(AnimationClip.CreateFromMorphTargetSequence(_name, animationToMorphTargets[_name], fps, noLoop));
            return clips;
        },
        // parse the animation.hierarchy format
        parseAnimation: function parseAnimation(animation, bones) {
            if (!animation) {
                console.error('THREE.AnimationClip: No animation in JSONLoader data.');
                return null;
            }
            var addNonemptyTrack = function addNonemptyTrack1(trackType, trackName, animationKeys, propertyName, destTracks) {
                // only return track if there are actually keys.
                if (animationKeys.length !== 0) {
                    var times = [];
                    var values = [];
                    AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again
                    if (times.length !== 0) destTracks.push(new trackType(trackName, times, values));
                }
            };
            var tracks = [];
            var clipName = animation.name || 'default';
            var fps = animation.fps || 30;
            var blendMode = animation.blendMode; // automatic length determination in AnimationClip.
            var duration = animation.length || -1;
            var hierarchyTracks = animation.hierarchy || [];
            for(var h = 0; h < hierarchyTracks.length; h++){
                var animationKeys = hierarchyTracks[h].keys; // skip empty tracks
                if (!animationKeys || animationKeys.length === 0) continue; // process morph targets
                if (animationKeys[0].morphTargets) {
                    // figure out all morph targets used in this track
                    var morphTargetNames = {
                    };
                    var k = void 0;
                    for(k = 0; k < animationKeys.length; k++){
                        if (animationKeys[k].morphTargets) for(var m = 0; m < animationKeys[k].morphTargets.length; m++)morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                    } // create a track for each morph target with all zero
                    // morphTargetInfluences except for the keys in which
                    // the morphTarget is named.
                    for(var morphTargetName in morphTargetNames){
                        var times = [];
                        var values = [];
                        for(var _m = 0; _m !== animationKeys[k].morphTargets.length; ++_m){
                            var animationKey = animationKeys[k];
                            times.push(animationKey.time);
                            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                        }
                        tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                    }
                    duration = morphTargetNames.length * (fps || 1);
                } else {
                    // ...assume skeletal animation
                    var boneName = '.bones[' + bones[h].name + ']';
                    addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                    addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                    addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
                }
            }
            if (tracks.length === 0) return null;
            var clip = new AnimationClip(clipName, duration, tracks, blendMode);
            return clip;
        }
    });
    Object.assign(AnimationClip.prototype, {
        resetDuration: function resetDuration() {
            var tracks = this.tracks;
            var duration = 0;
            for(var i46 = 0, n = tracks.length; i46 !== n; ++i46){
                var track = this.tracks[i46];
                duration = Math.max(duration, track.times[track.times.length - 1]);
            }
            this.duration = duration;
            return this;
        },
        trim: function trim() {
            for(var i46 = 0; i46 < this.tracks.length; i46++)this.tracks[i46].trim(0, this.duration);
            return this;
        },
        validate: function validate() {
            var valid = true;
            for(var i46 = 0; i46 < this.tracks.length; i46++)valid = valid && this.tracks[i46].validate();
            return valid;
        },
        optimize: function optimize() {
            for(var i46 = 0; i46 < this.tracks.length; i46++)this.tracks[i46].optimize();
            return this;
        },
        clone: function clone() {
            var tracks = [];
            for(var i46 = 0; i46 < this.tracks.length; i46++)tracks.push(this.tracks[i46].clone());
            return new AnimationClip(this.name, this.duration, tracks, this.blendMode);
        },
        toJSON: function toJSON() {
            return AnimationClip.toJSON(this);
        }
    });
    var Cache1 = {
        enabled: false,
        files: {
        },
        add: function add(key4, file) {
            if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );
            this.files[key4] = file;
        },
        get: function get(key4) {
            if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );
            return this.files[key4];
        },
        remove: function remove(key4) {
            delete this.files[key4];
        },
        clear: function clear() {
            this.files = {
            };
        }
    };
    function LoadingManager(onLoad, onProgress, onError) {
        var scope = this;
        var isLoading = false;
        var itemsLoaded = 0;
        var itemsTotal = 0;
        var urlModifier = undefined;
        var handlers = []; // Refer to #5689 for the reason why we don't set .onStart
        // in the constructor
        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
                if (scope.onStart !== undefined) scope.onStart(url, itemsLoaded, itemsTotal);
            }
            isLoading = true;
        };
        this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== undefined) scope.onProgress(url, itemsLoaded, itemsTotal);
            if (itemsLoaded === itemsTotal) {
                isLoading = false;
                if (scope.onLoad !== undefined) scope.onLoad();
            }
        };
        this.itemError = function(url) {
            if (scope.onError !== undefined) scope.onError(url);
        };
        this.resolveURL = function(url) {
            if (urlModifier) return urlModifier(url);
            return url;
        };
        this.setURLModifier = function(transform) {
            urlModifier = transform;
            return this;
        };
        this.addHandler = function(regex, loader) {
            handlers.push(regex, loader);
            return this;
        };
        this.removeHandler = function(regex) {
            var index = handlers.indexOf(regex);
            if (index !== -1) handlers.splice(index, 2);
            return this;
        };
        this.getHandler = function(file) {
            for(var i46 = 0, l = handlers.length; i46 < l; i46 += 2){
                var regex = handlers[i46];
                var loader = handlers[i46 + 1];
                if (regex.global) regex.lastIndex = 0; // see #17920
                if (regex.test(file)) return loader;
            }
            return null;
        };
    }
    var DefaultLoadingManager = new LoadingManager();
    function Loader(manager) {
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
        this.crossOrigin = 'anonymous';
        this.withCredentials = false;
        this.path = '';
        this.resourcePath = '';
        this.requestHeader = {
        };
    }
    Object.assign(Loader.prototype, {
        load: function load() /* url, onLoad, onProgress, onError */ {
        },
        loadAsync: function loadAsync(url, onProgress) {
            var scope = this;
            return new Promise(function(resolve, reject) {
                scope.load(url, resolve, onProgress, reject);
            });
        },
        parse: function parse() /* data */ {
        },
        setCrossOrigin: function setCrossOrigin(crossOrigin) {
            this.crossOrigin = crossOrigin;
            return this;
        },
        setWithCredentials: function setWithCredentials(value) {
            this.withCredentials = value;
            return this;
        },
        setPath: function setPath(path) {
            this.path = path;
            return this;
        },
        setResourcePath: function setResourcePath(resourcePath) {
            this.resourcePath = resourcePath;
            return this;
        },
        setRequestHeader: function setRequestHeader(requestHeader) {
            this.requestHeader = requestHeader;
            return this;
        }
    });
    var loading = {
    };
    function FileLoader(manager) {
        Loader.call(this, manager);
    }
    FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: FileLoader,
        load: function load(url, onLoad, onProgress, onError) {
            if (url === undefined) url = '';
            if (this.path !== undefined) url = this.path + url;
            url = this.manager.resolveURL(url);
            var scope = this;
            var cached = Cache1.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function() {
                    if (onLoad) onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            } // Check if request is duplicate
            if (loading[url] !== undefined) {
                loading[url].push({
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
                });
                return;
            } // Check for data: URI
            var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
            var dataUriRegexResult = url.match(dataUriRegex);
            var request; // Safari can not handle Data URIs through XMLHttpRequest so process manually
            if (dataUriRegexResult) {
                var mimeType = dataUriRegexResult[1];
                var isBase64 = !!dataUriRegexResult[2];
                var data = dataUriRegexResult[3];
                data = decodeURIComponent(data);
                if (isBase64) data = atob(data);
                try {
                    var response;
                    var responseType = (this.responseType || '').toLowerCase();
                    switch(responseType){
                        case 'arraybuffer':
                        case 'blob':
                            var view = new Uint8Array(data.length);
                            for(var i46 = 0; i46 < data.length; i46++)view[i46] = data.charCodeAt(i46);
                            if (responseType === 'blob') response = new Blob([
                                view.buffer
                            ], {
                                type: mimeType
                            });
                            else response = view.buffer;
                            break;
                        case 'document':
                            var parser = new DOMParser();
                            response = parser.parseFromString(data, mimeType);
                            break;
                        case 'json':
                            response = JSON.parse(data);
                            break;
                        default:
                            // 'text' or other
                            response = data;
                            break;
                    } // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                    setTimeout(function() {
                        if (onLoad) onLoad(response);
                        scope.manager.itemEnd(url);
                    }, 0);
                } catch (error) {
                    // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                    setTimeout(function() {
                        if (onError) onError(error);
                        scope.manager.itemError(url);
                        scope.manager.itemEnd(url);
                    }, 0);
                }
            } else {
                // Initialise array for duplicate requests
                loading[url] = [];
                loading[url].push({
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
                });
                request = new XMLHttpRequest();
                request.open('GET', url, true);
                request.addEventListener('load', function(event) {
                    var response = this.response;
                    var callbacks = loading[url];
                    delete loading[url];
                    if (this.status === 200 || this.status === 0) {
                        // Some browsers return HTTP Status 0 when using non-http protocol
                        // e.g. 'file://' or 'data://'. Handle as success.
                        if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache
                        // error response bodies as proper responses to requests.
                        Cache1.add(url, response);
                        for(var _i = 0, il = callbacks.length; _i < il; _i++){
                            var callback = callbacks[_i];
                            if (callback.onLoad) callback.onLoad(response);
                        }
                        scope.manager.itemEnd(url);
                    } else {
                        for(var _i2 = 0, _il = callbacks.length; _i2 < _il; _i2++){
                            var _callback = callbacks[_i2];
                            if (_callback.onError) _callback.onError(event);
                        }
                        scope.manager.itemError(url);
                        scope.manager.itemEnd(url);
                    }
                }, false);
                request.addEventListener('progress', function(event) {
                    var callbacks = loading[url];
                    for(var _i3 = 0, il = callbacks.length; _i3 < il; _i3++){
                        var callback = callbacks[_i3];
                        if (callback.onProgress) callback.onProgress(event);
                    }
                }, false);
                request.addEventListener('error', function(event) {
                    var callbacks = loading[url];
                    delete loading[url];
                    for(var _i4 = 0, il = callbacks.length; _i4 < il; _i4++){
                        var callback = callbacks[_i4];
                        if (callback.onError) callback.onError(event);
                    }
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                }, false);
                request.addEventListener('abort', function(event) {
                    var callbacks = loading[url];
                    delete loading[url];
                    for(var _i5 = 0, il = callbacks.length; _i5 < il; _i5++){
                        var callback = callbacks[_i5];
                        if (callback.onError) callback.onError(event);
                    }
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                }, false);
                if (this.responseType !== undefined) request.responseType = this.responseType;
                if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
                if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
                for(var header in this.requestHeader)request.setRequestHeader(header, this.requestHeader[header]);
                request.send(null);
            }
            scope.manager.itemStart(url);
            return request;
        },
        setResponseType: function setResponseType(value) {
            this.responseType = value;
            return this;
        },
        setMimeType: function setMimeType(value) {
            this.mimeType = value;
            return this;
        }
    });
    function AnimationLoader(manager) {
        Loader.call(this, manager);
    }
    AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: AnimationLoader,
        load: function load(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.setPath(scope.path);
            loader.setRequestHeader(scope.requestHeader);
            loader.setWithCredentials(scope.withCredentials);
            loader.load(url, function(text) {
                try {
                    onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                    if (onError) onError(e);
                    else console.error(e);
                    scope.manager.itemError(url);
                }
            }, onProgress, onError);
        },
        parse: function parse(json) {
            var animations = [];
            for(var i47 = 0; i47 < json.length; i47++){
                var clip = AnimationClip.parse(json[i47]);
                animations.push(clip);
            }
            return animations;
        }
    });
    /**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */ function CompressedTextureLoader(manager) {
        Loader.call(this, manager);
    }
    CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: CompressedTextureLoader,
        load: function load(url, onLoad, onProgress, onError) {
            var scope = this;
            var images = [];
            var texture = new CompressedTexture();
            var loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setResponseType('arraybuffer');
            loader.setRequestHeader(this.requestHeader);
            loader.setWithCredentials(scope.withCredentials);
            var loaded = 0;
            function loadTexture(i47) {
                loader.load(url[i47], function(buffer) {
                    var texDatas = scope.parse(buffer, true);
                    images[i47] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };
                    loaded += 1;
                    if (loaded === 6) {
                        if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                        texture.image = images;
                        texture.format = texDatas.format;
                        texture.needsUpdate = true;
                        if (onLoad) onLoad(texture);
                    }
                }, onProgress, onError);
            }
            if (Array.isArray(url)) for(var i47 = 0, il = url.length; i47 < il; ++i47)loadTexture(i47);
            else // compressed cubemap texture stored in a single DDS file
            loader.load(url, function(buffer) {
                var texDatas = scope.parse(buffer, true);
                if (texDatas.isCubemap) {
                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                    for(var f = 0; f < faces; f++){
                        images[f] = {
                            mipmaps: []
                        };
                        for(var _i = 0; _i < texDatas.mipmapCount; _i++){
                            images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + _i]);
                            images[f].format = texDatas.format;
                            images[f].width = texDatas.width;
                            images[f].height = texDatas.height;
                        }
                    }
                    texture.image = images;
                } else {
                    texture.image.width = texDatas.width;
                    texture.image.height = texDatas.height;
                    texture.mipmaps = texDatas.mipmaps;
                }
                if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad) onLoad(texture);
            }, onProgress, onError);
            return texture;
        }
    });
    function ImageLoader(manager) {
        Loader.call(this, manager);
    }
    ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: ImageLoader,
        load: function load(url, onLoad, onProgress, onError) {
            if (this.path !== undefined) url = this.path + url;
            url = this.manager.resolveURL(url);
            var scope = this;
            var cached = Cache1.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function() {
                    if (onLoad) onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
            function onImageLoad() {
                image.removeEventListener('load', onImageLoad, false);
                image.removeEventListener('error', onImageError, false);
                Cache1.add(url, this);
                if (onLoad) onLoad(this);
                scope.manager.itemEnd(url);
            }
            function onImageError(event) {
                image.removeEventListener('load', onImageLoad, false);
                image.removeEventListener('error', onImageError, false);
                if (onError) onError(event);
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            }
            image.addEventListener('load', onImageLoad, false);
            image.addEventListener('error', onImageError, false);
            if (url.substr(0, 5) !== 'data:') {
                if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
            }
            scope.manager.itemStart(url);
            image.src = url;
            return image;
        }
    });
    function CubeTextureLoader(manager) {
        Loader.call(this, manager);
    }
    CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: CubeTextureLoader,
        load: function load(urls, onLoad, onProgress, onError) {
            var texture = new CubeTexture();
            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            var loaded = 0;
            function loadTexture(i47) {
                loader.load(urls[i47], function(image) {
                    texture.images[i47] = image;
                    loaded++;
                    if (loaded === 6) {
                        texture.needsUpdate = true;
                        if (onLoad) onLoad(texture);
                    }
                }, undefined, onError);
            }
            for(var i47 = 0; i47 < urls.length; ++i47)loadTexture(i47);
            return texture;
        }
    });
    /**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */ function DataTextureLoader(manager) {
        Loader.call(this, manager);
    }
    DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: DataTextureLoader,
        load: function load(url, onLoad, onProgress, onError) {
            var scope = this;
            var texture = new DataTexture();
            var loader = new FileLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.setRequestHeader(this.requestHeader);
            loader.setPath(this.path);
            loader.setWithCredentials(scope.withCredentials);
            loader.load(url, function(buffer) {
                var texData = scope.parse(buffer);
                if (!texData) return;
                if (texData.image !== undefined) texture.image = texData.image;
                else if (texData.data !== undefined) {
                    texture.image.width = texData.width;
                    texture.image.height = texData.height;
                    texture.image.data = texData.data;
                }
                texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
                texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
                texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
                texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
                texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
                if (texData.encoding !== undefined) texture.encoding = texData.encoding;
                if (texData.flipY !== undefined) texture.flipY = texData.flipY;
                if (texData.format !== undefined) texture.format = texData.format;
                if (texData.type !== undefined) texture.type = texData.type;
                if (texData.mipmaps !== undefined) {
                    texture.mipmaps = texData.mipmaps;
                    texture.minFilter = LinearMipmapLinearFilter; // presumably...
                }
                if (texData.mipmapCount === 1) texture.minFilter = LinearFilter;
                texture.needsUpdate = true;
                if (onLoad) onLoad(texture, texData);
            }, onProgress, onError);
            return texture;
        }
    });
    function TextureLoader(manager) {
        Loader.call(this, manager);
    }
    TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: TextureLoader,
        load: function load(url, onLoad, onProgress, onError) {
            var texture = new Texture();
            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            loader.load(url, function(image) {
                texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
                var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
                texture.format = isJPEG ? RGBFormat : RGBAFormat;
                texture.needsUpdate = true;
                if (onLoad !== undefined) onLoad(texture);
            }, onProgress, onError);
            return texture;
        }
    });
    /**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/ function Curve() {
        this.type = 'Curve';
        this.arcLengthDivisions = 200;
    }
    Object.assign(Curve.prototype, {
        // Virtual base class method to overwrite and implement in subclasses
        //	- t [0 .. 1]
        getPoint: function getPoint() /* t, optionalTarget */ {
            console.warn('THREE.Curve: .getPoint() not implemented.');
            return null;
        },
        // Get point at relative position in curve according to arc length
        // - u [0 .. 1]
        getPointAt: function getPointAt(u, optionalTarget) {
            var t = this.getUtoTmapping(u);
            return this.getPoint(t, optionalTarget);
        },
        // Get sequence of points using getPoint( t )
        getPoints: function getPoints(divisions) {
            if (divisions === void 0) divisions = 5;
            var points = [];
            for(var d = 0; d <= divisions; d++)points.push(this.getPoint(d / divisions));
            return points;
        },
        // Get sequence of points using getPointAt( u )
        getSpacedPoints: function getSpacedPoints(divisions) {
            if (divisions === void 0) divisions = 5;
            var points = [];
            for(var d = 0; d <= divisions; d++)points.push(this.getPointAt(d / divisions));
            return points;
        },
        // Get total curve arc length
        getLength: function getLength() {
            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
        },
        // Get list of cumulative segment lengths
        getLengths: function getLengths(divisions) {
            if (divisions === undefined) divisions = this.arcLengthDivisions;
            if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = false;
            var cache = [];
            var current, last = this.getPoint(0);
            var sum = 0;
            cache.push(0);
            for(var p = 1; p <= divisions; p++){
                current = this.getPoint(p / divisions);
                sum += current.distanceTo(last);
                cache.push(sum);
                last = current;
            }
            this.cacheArcLengths = cache;
            return cache; // { sums: cache, sum: sum }; Sum is in the last element.
        },
        updateArcLengths: function updateArcLengths() {
            this.needsUpdate = true;
            this.getLengths();
        },
        // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
        getUtoTmapping: function getUtoTmapping(u, distance) {
            var arcLengths = this.getLengths();
            var i47 = 0;
            var il = arcLengths.length;
            var targetArcLength; // The targeted u distance value to get
            if (distance) targetArcLength = distance;
            else targetArcLength = u * arcLengths[il - 1];
             // binary search for the index with largest value smaller than target u distance
            var low = 0, high = il - 1, comparison;
            while(low <= high){
                i47 = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
                comparison = arcLengths[i47] - targetArcLength;
                if (comparison < 0) low = i47 + 1;
                else if (comparison > 0) high = i47 - 1;
                else {
                    high = i47;
                    break; // DONE
                }
            }
            i47 = high;
            if (arcLengths[i47] === targetArcLength) return i47 / (il - 1);
             // we could get finer grain at lengths, or use simple interpolation between two points
            var lengthBefore = arcLengths[i47];
            var lengthAfter = arcLengths[i47 + 1];
            var segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points
            var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t
            var t = (i47 + segmentFraction) / (il - 1);
            return t;
        },
        // Returns a unit vector tangent at t
        // In case any sub curve does not implement its tangent derivation,
        // 2 points a small delta apart will be used to find its gradient
        // which seems to give a reasonable approximation
        getTangent: function getTangent(t, optionalTarget) {
            var delta = 0.0001;
            var t1 = t - delta;
            var t2 = t + delta; // Capping in case of danger
            if (t1 < 0) t1 = 0;
            if (t2 > 1) t2 = 1;
            var pt1 = this.getPoint(t1);
            var pt2 = this.getPoint(t2);
            var tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
            tangent.copy(pt2).sub(pt1).normalize();
            return tangent;
        },
        getTangentAt: function getTangentAt(u, optionalTarget) {
            var t = this.getUtoTmapping(u);
            return this.getTangent(t, optionalTarget);
        },
        computeFrenetFrames: function computeFrenetFrames(segments, closed) {
            // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
            var normal = new Vector3();
            var tangents = [];
            var normals = [];
            var binormals = [];
            var vec = new Vector3();
            var mat = new Matrix4(); // compute the tangent vectors for each segment on the curve
            for(var i47 = 0; i47 <= segments; i47++){
                var u = i47 / segments;
                tangents[i47] = this.getTangentAt(u, new Vector3());
                tangents[i47].normalize();
            } // select an initial normal vector perpendicular to the first tangent vector,
            // and in the direction of the minimum tangent xyz component
            normals[0] = new Vector3();
            binormals[0] = new Vector3();
            var min = Number.MAX_VALUE;
            var tx = Math.abs(tangents[0].x);
            var ty = Math.abs(tangents[0].y);
            var tz = Math.abs(tangents[0].z);
            if (tx <= min) {
                min = tx;
                normal.set(1, 0, 0);
            }
            if (ty <= min) {
                min = ty;
                normal.set(0, 1, 0);
            }
            if (tz <= min) normal.set(0, 0, 1);
            vec.crossVectors(tangents[0], normal).normalize();
            normals[0].crossVectors(tangents[0], vec);
            binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve
            for(var _i = 1; _i <= segments; _i++){
                normals[_i] = normals[_i - 1].clone();
                binormals[_i] = binormals[_i - 1].clone();
                vec.crossVectors(tangents[_i - 1], tangents[_i]);
                if (vec.length() > Number.EPSILON) {
                    vec.normalize();
                    var theta = Math.acos(MathUtils.clamp(tangents[_i - 1].dot(tangents[_i]), -1, 1)); // clamp for floating pt errors
                    normals[_i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                }
                binormals[_i].crossVectors(tangents[_i], normals[_i]);
            } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
            if (closed === true) {
                var _theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
                _theta /= segments;
                if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) _theta = -_theta;
                for(var _i2 = 1; _i2 <= segments; _i2++){
                    // twist a little...
                    normals[_i2].applyMatrix4(mat.makeRotationAxis(tangents[_i2], _theta * _i2));
                    binormals[_i2].crossVectors(tangents[_i2], normals[_i2]);
                }
            }
            return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
            };
        },
        clone: function clone() {
            return new this.constructor().copy(this);
        },
        copy: function copy(source) {
            this.arcLengthDivisions = source.arcLengthDivisions;
            return this;
        },
        toJSON: function toJSON() {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Curve',
                    generator: 'Curve.toJSON'
                }
            };
            data.arcLengthDivisions = this.arcLengthDivisions;
            data.type = this.type;
            return data;
        },
        fromJSON: function fromJSON(json) {
            this.arcLengthDivisions = json.arcLengthDivisions;
            return this;
        }
    });
    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        Curve.call(this);
        this.type = 'EllipseCurve';
        this.aX = aX || 0;
        this.aY = aY || 0;
        this.xRadius = xRadius || 1;
        this.yRadius = yRadius || 1;
        this.aStartAngle = aStartAngle || 0;
        this.aEndAngle = aEndAngle || 2 * Math.PI;
        this.aClockwise = aClockwise || false;
        this.aRotation = aRotation || 0;
    }
    EllipseCurve.prototype = Object.create(Curve.prototype);
    EllipseCurve.prototype.constructor = EllipseCurve;
    EllipseCurve.prototype.isEllipseCurve = true;
    EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        var twoPi = Math.PI * 2;
        var deltaAngle = this.aEndAngle - this.aStartAngle;
        var samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI
        while(deltaAngle < 0)deltaAngle += twoPi;
        while(deltaAngle > twoPi)deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
            if (samePoints) deltaAngle = 0;
            else deltaAngle = twoPi;
        }
        if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) deltaAngle = -twoPi;
            else deltaAngle = deltaAngle - twoPi;
        }
        var angle = this.aStartAngle + t * deltaAngle;
        var x = this.aX + this.xRadius * Math.cos(angle);
        var y = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
            var cos = Math.cos(this.aRotation);
            var sin = Math.sin(this.aRotation);
            var tx = x - this.aX;
            var ty = y - this.aY; // Rotate the point about the center of the ellipse.
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
        }
        return point.set(x, y);
    };
    EllipseCurve.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.aX = source.aX;
        this.aY = source.aY;
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
        this.aClockwise = source.aClockwise;
        this.aRotation = source.aRotation;
        return this;
    };
    EllipseCurve.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.aX = this.aX;
        data.aY = this.aY;
        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;
        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;
        data.aClockwise = this.aClockwise;
        data.aRotation = this.aRotation;
        return data;
    };
    EllipseCurve.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.aX = json.aX;
        this.aY = json.aY;
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
        this.aClockwise = json.aClockwise;
        this.aRotation = json.aRotation;
        return this;
    };
    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        this.type = 'ArcCurve';
    }
    ArcCurve.prototype = Object.create(EllipseCurve.prototype);
    ArcCurve.prototype.constructor = ArcCurve;
    ArcCurve.prototype.isArcCurve = true;
    /**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */ /*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/ function CubicPoly() {
        var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
        /*
		 * Compute coefficients for a cubic polynomial
		 *	 p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *	 p(0) = x0, p(1) = x1
		 *	and
		 *	 p'(0) = t0, p'(1) = t1.
		 */ function init(x0, x1, t0, t1) {
            c0 = x0;
            c1 = t0;
            c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
            c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
            initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {
                init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            },
            initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
                // compute tangents when parameterized in [t1,t2]
                var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]
                t1 *= dt1;
                t2 *= dt1;
                init(x1, x2, t1, t2);
            },
            calc: function calc(t) {
                var t2 = t * t;
                var t3 = t2 * t;
                return c0 + c1 * t + c2 * t2 + c3 * t3;
            }
        };
    } //
    var tmp = new Vector3();
    var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
    function CatmullRomCurve3(points, closed, curveType, tension) {
        if (points === void 0) points = [];
        if (closed === void 0) closed = false;
        if (curveType === void 0) curveType = 'centripetal';
        if (tension === void 0) tension = 0.5;
        Curve.call(this);
        this.type = 'CatmullRomCurve3';
        this.points = points;
        this.closed = closed;
        this.curveType = curveType;
        this.tension = tension;
    }
    CatmullRomCurve3.prototype = Object.create(Curve.prototype);
    CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
    CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
    CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {
        if (optionalTarget === void 0) optionalTarget = new Vector3();
        var point = optionalTarget;
        var points = this.points;
        var l = points.length;
        var p = (l - (this.closed ? 0 : 1)) * t;
        var intPoint = Math.floor(p);
        var weight = p - intPoint;
        if (this.closed) intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
        else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
        }
        var p0, p3; // 4 points (p1 & p2 defined below)
        if (this.closed || intPoint > 0) p0 = points[(intPoint - 1) % l];
        else {
            // extrapolate first point
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
        }
        var p1 = points[intPoint % l];
        var p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) p3 = points[(intPoint + 2) % l];
        else {
            // extrapolate last point
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
        }
        if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
            // init Centripetal / Chordal Catmull-Rom
            var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
            var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            var dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points
            if (dt1 < 0.0001) dt1 = 1;
            if (dt0 < 0.0001) dt0 = dt1;
            if (dt2 < 0.0001) dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.curveType === 'catmullrom') {
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
        }
        point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
        return point;
    };
    CatmullRomCurve3.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.points = [];
        for(var i47 = 0, l = source.points.length; i47 < l; i47++){
            var point = source.points[i47];
            this.points.push(point.clone());
        }
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
        return this;
    };
    CatmullRomCurve3.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.points = [];
        for(var i47 = 0, l = this.points.length; i47 < l; i47++){
            var point = this.points[i47];
            data.points.push(point.toArray());
        }
        data.closed = this.closed;
        data.curveType = this.curveType;
        data.tension = this.tension;
        return data;
    };
    CatmullRomCurve3.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.points = [];
        for(var i47 = 0, l = json.points.length; i47 < l; i47++){
            var point = json.points[i47];
            this.points.push(new Vector3().fromArray(point));
        }
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
        return this;
    };
    /**
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/BÃ©zier_curve
	 */ function CatmullRom(t, p0, p1, p2, p3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    } //
    function QuadraticBezierP0(t, p) {
        var k = 1 - t;
        return k * k * p;
    }
    function QuadraticBezierP1(t, p) {
        return 2 * (1 - t) * t * p;
    }
    function QuadraticBezierP2(t, p) {
        return t * t * p;
    }
    function QuadraticBezier(t, p0, p1, p2) {
        return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
    } //
    function CubicBezierP0(t, p) {
        var k = 1 - t;
        return k * k * k * p;
    }
    function CubicBezierP1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
    }
    function CubicBezierP2(t, p) {
        return 3 * (1 - t) * t * t * p;
    }
    function CubicBezierP3(t, p) {
        return t * t * t * p;
    }
    function CubicBezier(t, p0, p1, p2, p3) {
        return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
    }
    function CubicBezierCurve(v0, v1, v2, v3) {
        if (v0 === void 0) v0 = new Vector2();
        if (v1 === void 0) v1 = new Vector2();
        if (v2 === void 0) v2 = new Vector2();
        if (v3 === void 0) v3 = new Vector2();
        Curve.call(this);
        this.type = 'CubicBezierCurve';
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    CubicBezierCurve.prototype = Object.create(Curve.prototype);
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;
    CubicBezierCurve.prototype.isCubicBezierCurve = true;
    CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {
        if (optionalTarget === void 0) optionalTarget = new Vector2();
        var point = optionalTarget;
        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
        return point;
    };
    CubicBezierCurve.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    };
    CubicBezierCurve.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
    };
    CubicBezierCurve.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    };
    function CubicBezierCurve3(v0, v1, v2, v3) {
        if (v0 === void 0) v0 = new Vector3();
        if (v1 === void 0) v1 = new Vector3();
        if (v2 === void 0) v2 = new Vector3();
        if (v3 === void 0) v3 = new Vector3();
        Curve.call(this);
        this.type = 'CubicBezierCurve3';
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    CubicBezierCurve3.prototype = Object.create(Curve.prototype);
    CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
    CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
    CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
        if (optionalTarget === void 0) optionalTarget = new Vector3();
        var point = optionalTarget;
        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
        return point;
    };
    CubicBezierCurve3.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    };
    CubicBezierCurve3.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
    };
    CubicBezierCurve3.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    };
    function LineCurve(v1, v2) {
        if (v1 === void 0) v1 = new Vector2();
        if (v2 === void 0) v2 = new Vector2();
        Curve.call(this);
        this.type = 'LineCurve';
        this.v1 = v1;
        this.v2 = v2;
    }
    LineCurve.prototype = Object.create(Curve.prototype);
    LineCurve.prototype.constructor = LineCurve;
    LineCurve.prototype.isLineCurve = true;
    LineCurve.prototype.getPoint = function(t, optionalTarget) {
        if (optionalTarget === void 0) optionalTarget = new Vector2();
        var point = optionalTarget;
        if (t === 1) point.copy(this.v2);
        else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    }; // Line curve is linear, so we can overwrite default getPointAt
    LineCurve.prototype.getPointAt = function(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    };
    LineCurve.prototype.getTangent = function(t, optionalTarget) {
        var tangent = optionalTarget || new Vector2();
        tangent.copy(this.v2).sub(this.v1).normalize();
        return tangent;
    };
    LineCurve.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    };
    LineCurve.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    };
    LineCurve.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    };
    function LineCurve3(v1, v2) {
        if (v1 === void 0) v1 = new Vector3();
        if (v2 === void 0) v2 = new Vector3();
        Curve.call(this);
        this.type = 'LineCurve3';
        this.v1 = v1;
        this.v2 = v2;
    }
    LineCurve3.prototype = Object.create(Curve.prototype);
    LineCurve3.prototype.constructor = LineCurve3;
    LineCurve3.prototype.isLineCurve3 = true;
    LineCurve3.prototype.getPoint = function(t, optionalTarget) {
        if (optionalTarget === void 0) optionalTarget = new Vector3();
        var point = optionalTarget;
        if (t === 1) point.copy(this.v2);
        else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    }; // Line curve is linear, so we can overwrite default getPointAt
    LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    };
    LineCurve3.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    };
    LineCurve3.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    };
    LineCurve3.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    };
    function QuadraticBezierCurve(v0, v1, v2) {
        if (v0 === void 0) v0 = new Vector2();
        if (v1 === void 0) v1 = new Vector2();
        if (v2 === void 0) v2 = new Vector2();
        Curve.call(this);
        this.type = 'QuadraticBezierCurve';
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }
    QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
    QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {
        if (optionalTarget === void 0) optionalTarget = new Vector2();
        var point = optionalTarget;
        var v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
        return point;
    };
    QuadraticBezierCurve.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    };
    QuadraticBezierCurve.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    };
    QuadraticBezierCurve.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    };
    function QuadraticBezierCurve3(v0, v1, v2) {
        if (v0 === void 0) v0 = new Vector3();
        if (v1 === void 0) v1 = new Vector3();
        if (v2 === void 0) v2 = new Vector3();
        Curve.call(this);
        this.type = 'QuadraticBezierCurve3';
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
    }
    QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
    QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
        if (optionalTarget === void 0) optionalTarget = new Vector3();
        var point = optionalTarget;
        var v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
        return point;
    };
    QuadraticBezierCurve3.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    };
    QuadraticBezierCurve3.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    };
    QuadraticBezierCurve3.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    };
    function SplineCurve(points) {
        if (points === void 0) points = [];
        Curve.call(this);
        this.type = 'SplineCurve';
        this.points = points;
    }
    SplineCurve.prototype = Object.create(Curve.prototype);
    SplineCurve.prototype.constructor = SplineCurve;
    SplineCurve.prototype.isSplineCurve = true;
    SplineCurve.prototype.getPoint = function(t, optionalTarget) {
        if (optionalTarget === void 0) optionalTarget = new Vector2();
        var point = optionalTarget;
        var points = this.points;
        var p = (points.length - 1) * t;
        var intPoint = Math.floor(p);
        var weight = p - intPoint;
        var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        var p1 = points[intPoint];
        var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
        return point;
    };
    SplineCurve.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.points = [];
        for(var i47 = 0, l = source.points.length; i47 < l; i47++){
            var point = source.points[i47];
            this.points.push(point.clone());
        }
        return this;
    };
    SplineCurve.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.points = [];
        for(var i47 = 0, l = this.points.length; i47 < l; i47++){
            var point = this.points[i47];
            data.points.push(point.toArray());
        }
        return data;
    };
    SplineCurve.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.points = [];
        for(var i47 = 0, l = json.points.length; i47 < l; i47++){
            var point = json.points[i47];
            this.points.push(new Vector2().fromArray(point));
        }
        return this;
    };
    var Curves = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        ArcCurve: ArcCurve,
        CatmullRomCurve3: CatmullRomCurve3,
        CubicBezierCurve: CubicBezierCurve,
        CubicBezierCurve3: CubicBezierCurve3,
        EllipseCurve: EllipseCurve,
        LineCurve: LineCurve,
        LineCurve3: LineCurve3,
        QuadraticBezierCurve: QuadraticBezierCurve,
        QuadraticBezierCurve3: QuadraticBezierCurve3,
        SplineCurve: SplineCurve
    });
    /**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *	curves, but retains the api of a curve
	 **************************************************************/ function CurvePath() {
        Curve.call(this);
        this.type = 'CurvePath';
        this.curves = [];
        this.autoClose = false; // Automatically closes the path
    }
    CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
        constructor: CurvePath,
        add: function add(curve) {
            this.curves.push(curve);
        },
        closePath: function closePath() {
            // Add a line curve if start and end of lines are not connected
            var startPoint = this.curves[0].getPoint(0);
            var endPoint = this.curves[this.curves.length - 1].getPoint(1);
            if (!startPoint.equals(endPoint)) this.curves.push(new LineCurve(endPoint, startPoint));
        },
        // To get accurate point with reference to
        // entire path distance at time t,
        // following has to be done:
        // 1. Length of each sub path have to be known
        // 2. Locate and identify type of curve
        // 3. Get t for the curve
        // 4. Return curve.getPointAt(t')
        getPoint: function getPoint(t) {
            var d = t * this.getLength();
            var curveLengths = this.getCurveLengths();
            var i47 = 0; // To think about boundaries points.
            while(i47 < curveLengths.length){
                if (curveLengths[i47] >= d) {
                    var diff = curveLengths[i47] - d;
                    var curve = this.curves[i47];
                    var segmentLength = curve.getLength();
                    var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                    return curve.getPointAt(u);
                }
                i47++;
            }
            return null; // loop where sum != 0, sum > d , sum+1 <d
        },
        // We cannot use the default THREE.Curve getPoint() with getLength() because in
        // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
        // getPoint() depends on getLength
        getLength: function getLength() {
            var lens = this.getCurveLengths();
            return lens[lens.length - 1];
        },
        // cacheLengths must be recalculated.
        updateArcLengths: function updateArcLengths() {
            this.needsUpdate = true;
            this.cacheLengths = null;
            this.getCurveLengths();
        },
        // Compute lengths and cache them
        // We cannot overwrite getLengths() because UtoT mapping uses it.
        getCurveLengths: function getCurveLengths() {
            // We use cache values if curves and cache array are same length
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
             // Get length of sub-curve
            // Push sums into cached array
            var lengths = [];
            var sums = 0;
            for(var i47 = 0, l = this.curves.length; i47 < l; i47++){
                sums += this.curves[i47].getLength();
                lengths.push(sums);
            }
            this.cacheLengths = lengths;
            return lengths;
        },
        getSpacedPoints: function getSpacedPoints(divisions) {
            if (divisions === void 0) divisions = 40;
            var points = [];
            for(var i47 = 0; i47 <= divisions; i47++)points.push(this.getPoint(i47 / divisions));
            if (this.autoClose) points.push(points[0]);
            return points;
        },
        getPoints: function getPoints(divisions) {
            if (divisions === void 0) divisions = 12;
            var points = [];
            var last;
            for(var i47 = 0, curves = this.curves; i47 < curves.length; i47++){
                var curve = curves[i47];
                var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
                var pts = curve.getPoints(resolution);
                for(var j = 0; j < pts.length; j++){
                    var point = pts[j];
                    if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates
                    points.push(point);
                    last = point;
                }
            }
            if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) points.push(points[0]);
            return points;
        },
        copy: function copy(source) {
            Curve.prototype.copy.call(this, source);
            this.curves = [];
            for(var i47 = 0, l = source.curves.length; i47 < l; i47++){
                var curve = source.curves[i47];
                this.curves.push(curve.clone());
            }
            this.autoClose = source.autoClose;
            return this;
        },
        toJSON: function toJSON() {
            var data = Curve.prototype.toJSON.call(this);
            data.autoClose = this.autoClose;
            data.curves = [];
            for(var i47 = 0, l = this.curves.length; i47 < l; i47++){
                var curve = this.curves[i47];
                data.curves.push(curve.toJSON());
            }
            return data;
        },
        fromJSON: function fromJSON(json) {
            Curve.prototype.fromJSON.call(this, json);
            this.autoClose = json.autoClose;
            this.curves = [];
            for(var i47 = 0, l = json.curves.length; i47 < l; i47++){
                var curve = json.curves[i47];
                this.curves.push(new Curves[curve.type]().fromJSON(curve));
            }
            return this;
        }
    });
    function Path(points) {
        CurvePath.call(this);
        this.type = 'Path';
        this.currentPoint = new Vector2();
        if (points) this.setFromPoints(points);
    }
    Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
        constructor: Path,
        setFromPoints: function setFromPoints(points) {
            this.moveTo(points[0].x, points[0].y);
            for(var i47 = 1, l = points.length; i47 < l; i47++)this.lineTo(points[i47].x, points[i47].y);
            return this;
        },
        moveTo: function moveTo(x, y) {
            this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
            return this;
        },
        lineTo: function lineTo(x, y) {
            var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
            this.curves.push(curve);
            this.currentPoint.set(x, y);
            return this;
        },
        quadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
            var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
            return this;
        },
        bezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
            return this;
        },
        splineThru: function splineThru(pts) {
            var npts = [
                this.currentPoint.clone()
            ].concat(pts);
            var curve = new SplineCurve(npts);
            this.curves.push(curve);
            this.currentPoint.copy(pts[pts.length - 1]);
            return this;
        },
        arc: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
            return this;
        },
        absarc: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
            return this;
        },
        ellipse: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            return this;
        },
        absellipse: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            if (this.curves.length > 0) {
                // if a previous curve is present, attempt to join
                var firstPoint = curve.getPoint(0);
                if (!firstPoint.equals(this.currentPoint)) this.lineTo(firstPoint.x, firstPoint.y);
            }
            this.curves.push(curve);
            var lastPoint = curve.getPoint(1);
            this.currentPoint.copy(lastPoint);
            return this;
        },
        copy: function copy(source) {
            CurvePath.prototype.copy.call(this, source);
            this.currentPoint.copy(source.currentPoint);
            return this;
        },
        toJSON: function toJSON() {
            var data = CurvePath.prototype.toJSON.call(this);
            data.currentPoint = this.currentPoint.toArray();
            return data;
        },
        fromJSON: function fromJSON(json) {
            CurvePath.prototype.fromJSON.call(this, json);
            this.currentPoint.fromArray(json.currentPoint);
            return this;
        }
    });
    function Shape(points) {
        Path.call(this, points);
        this.uuid = MathUtils.generateUUID();
        this.type = 'Shape';
        this.holes = [];
    }
    Shape.prototype = Object.assign(Object.create(Path.prototype), {
        constructor: Shape,
        getPointsHoles: function getPointsHoles(divisions) {
            var holesPts = [];
            for(var i47 = 0, l = this.holes.length; i47 < l; i47++)holesPts[i47] = this.holes[i47].getPoints(divisions);
            return holesPts;
        },
        // get points of shape and holes (keypoints based on segments parameter)
        extractPoints: function extractPoints(divisions) {
            return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
            };
        },
        copy: function copy(source) {
            Path.prototype.copy.call(this, source);
            this.holes = [];
            for(var i47 = 0, l = source.holes.length; i47 < l; i47++){
                var hole = source.holes[i47];
                this.holes.push(hole.clone());
            }
            return this;
        },
        toJSON: function toJSON() {
            var data = Path.prototype.toJSON.call(this);
            data.uuid = this.uuid;
            data.holes = [];
            for(var i47 = 0, l = this.holes.length; i47 < l; i47++){
                var hole = this.holes[i47];
                data.holes.push(hole.toJSON());
            }
            return data;
        },
        fromJSON: function fromJSON(json) {
            Path.prototype.fromJSON.call(this, json);
            this.uuid = json.uuid;
            this.holes = [];
            for(var i47 = 0, l = json.holes.length; i47 < l; i47++){
                var hole = json.holes[i47];
                this.holes.push(new Path().fromJSON(hole));
            }
            return this;
        }
    });
    function Light(color, intensity) {
        if (intensity === void 0) intensity = 1;
        Object3D.call(this);
        this.type = 'Light';
        this.color = new Color(color);
        this.intensity = intensity;
    }
    Light.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Light,
        isLight: true,
        copy: function copy(source) {
            Object3D.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.intensity = source.intensity;
            return this;
        },
        toJSON: function toJSON(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.color = this.color.getHex();
            data.object.intensity = this.intensity;
            if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
            if (this.distance !== undefined) data.object.distance = this.distance;
            if (this.angle !== undefined) data.object.angle = this.angle;
            if (this.decay !== undefined) data.object.decay = this.decay;
            if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
            if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
            return data;
        }
    });
    function HemisphereLight(skyColor, groundColor, intensity) {
        Light.call(this, skyColor, intensity);
        this.type = 'HemisphereLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.groundColor = new Color(groundColor);
    }
    HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: HemisphereLight,
        isHemisphereLight: true,
        copy: function copy(source) {
            Light.prototype.copy.call(this, source);
            this.groundColor.copy(source.groundColor);
            return this;
        }
    });
    function LightShadow(camera) {
        this.camera = camera;
        this.bias = 0;
        this.normalBias = 0;
        this.radius = 1;
        this.mapSize = new Vector2(512, 512);
        this.map = null;
        this.mapPass = null;
        this.matrix = new Matrix4();
        this.autoUpdate = true;
        this.needsUpdate = false;
        this._frustum = new Frustum();
        this._frameExtents = new Vector2(1, 1);
        this._viewportCount = 1;
        this._viewports = [
            new Vector4(0, 0, 1, 1)
        ];
    }
    Object.assign(LightShadow.prototype, {
        _projScreenMatrix: new Matrix4(),
        _lightPositionWorld: new Vector3(),
        _lookTarget: new Vector3(),
        getViewportCount: function getViewportCount() {
            return this._viewportCount;
        },
        getFrustum: function getFrustum() {
            return this._frustum;
        },
        updateMatrices: function updateMatrices(light) {
            var shadowCamera = this.camera, shadowMatrix = this.matrix, projScreenMatrix = this._projScreenMatrix, lookTarget = this._lookTarget, lightPositionWorld = this._lightPositionWorld;
            lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
            shadowCamera.position.copy(lightPositionWorld);
            lookTarget.setFromMatrixPosition(light.target.matrixWorld);
            shadowCamera.lookAt(lookTarget);
            shadowCamera.updateMatrixWorld();
            projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
            this._frustum.setFromProjectionMatrix(projScreenMatrix);
            shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
            shadowMatrix.multiply(shadowCamera.projectionMatrix);
            shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
        },
        getViewport: function getViewport(viewportIndex) {
            return this._viewports[viewportIndex];
        },
        getFrameExtents: function getFrameExtents() {
            return this._frameExtents;
        },
        copy: function copy(source) {
            this.camera = source.camera.clone();
            this.bias = source.bias;
            this.radius = source.radius;
            this.mapSize.copy(source.mapSize);
            return this;
        },
        clone: function clone() {
            return new this.constructor().copy(this);
        },
        toJSON: function toJSON() {
            var object = {
            };
            if (this.bias !== 0) object.bias = this.bias;
            if (this.normalBias !== 0) object.normalBias = this.normalBias;
            if (this.radius !== 1) object.radius = this.radius;
            if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
            object.camera = this.camera.toJSON(false).object;
            delete object.camera.matrix;
            return object;
        }
    });
    function SpotLightShadow() {
        LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
        this.focus = 1;
    }
    SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: SpotLightShadow,
        isSpotLightShadow: true,
        updateMatrices: function updateMatrices(light) {
            var camera = this.camera;
            var fov1 = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
            var aspect1 = this.mapSize.width / this.mapSize.height;
            var far = light.distance || camera.far;
            if (fov1 !== camera.fov || aspect1 !== camera.aspect || far !== camera.far) {
                camera.fov = fov1;
                camera.aspect = aspect1;
                camera.far = far;
                camera.updateProjectionMatrix();
            }
            LightShadow.prototype.updateMatrices.call(this, light);
        }
    });
    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
        Light.call(this, color, intensity);
        this.type = 'SpotLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        Object.defineProperty(this, 'power', {
            get: function get() {
                // intensity = power per solid angle.
                // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                return this.intensity * Math.PI;
            },
            set: function set(power) {
                // intensity = power per solid angle.
                // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                this.intensity = power / Math.PI;
            }
        });
        this.distance = distance !== undefined ? distance : 0;
        this.angle = angle !== undefined ? angle : Math.PI / 3;
        this.penumbra = penumbra !== undefined ? penumbra : 0;
        this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.
        this.shadow = new SpotLightShadow();
    }
    SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: SpotLight,
        isSpotLight: true,
        copy: function copy(source) {
            Light.prototype.copy.call(this, source);
            this.distance = source.distance;
            this.angle = source.angle;
            this.penumbra = source.penumbra;
            this.decay = source.decay;
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    });
    function PointLightShadow() {
        LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
        this._frameExtents = new Vector2(4, 2);
        this._viewportCount = 6;
        this._viewports = [
            // following orientation:
            //
            //	xzXZ
            //	 y Y
            //
            // X - Positive x direction
            // x - Negative x direction
            // Y - Positive y direction
            // y - Negative y direction
            // Z - Positive z direction
            // z - Negative z direction
            // positive X
            new Vector4(2, 1, 1, 1),
            new Vector4(0, 1, 1, 1),
            new Vector4(3, 1, 1, 1),
            new Vector4(1, 1, 1, 1),
            new Vector4(3, 0, 1, 1),
            new Vector4(1, 0, 1, 1)
        ];
        this._cubeDirections = [
            new Vector3(1, 0, 0),
            new Vector3(-1, 0, 0),
            new Vector3(0, 0, 1),
            new Vector3(0, 0, -1),
            new Vector3(0, 1, 0),
            new Vector3(0, -1, 0)
        ];
        this._cubeUps = [
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 1, 0),
            new Vector3(0, 0, 1),
            new Vector3(0, 0, -1)
        ];
    }
    PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: PointLightShadow,
        isPointLightShadow: true,
        updateMatrices: function updateMatrices(light, viewportIndex) {
            if (viewportIndex === void 0) viewportIndex = 0;
            var camera = this.camera, shadowMatrix = this.matrix, lightPositionWorld = this._lightPositionWorld, lookTarget = this._lookTarget, projScreenMatrix = this._projScreenMatrix;
            lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
            camera.position.copy(lightPositionWorld);
            lookTarget.copy(camera.position);
            lookTarget.add(this._cubeDirections[viewportIndex]);
            camera.up.copy(this._cubeUps[viewportIndex]);
            camera.lookAt(lookTarget);
            camera.updateMatrixWorld();
            shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
            projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            this._frustum.setFromProjectionMatrix(projScreenMatrix);
        }
    });
    function PointLight(color, intensity, distance, decay) {
        Light.call(this, color, intensity);
        this.type = 'PointLight';
        Object.defineProperty(this, 'power', {
            get: function get() {
                // intensity = power per solid angle.
                // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                return this.intensity * 4 * Math.PI;
            },
            set: function set(power) {
                // intensity = power per solid angle.
                // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                this.intensity = power / (4 * Math.PI);
            }
        });
        this.distance = distance !== undefined ? distance : 0;
        this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.
        this.shadow = new PointLightShadow();
    }
    PointLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: PointLight,
        isPointLight: true,
        copy: function copy(source) {
            Light.prototype.copy.call(this, source);
            this.distance = source.distance;
            this.decay = source.decay;
            this.shadow = source.shadow.clone();
            return this;
        }
    });
    function OrthographicCamera(left, right, top, bottom, near, far) {
        if (left === void 0) left = -1;
        if (right === void 0) right = 1;
        if (top === void 0) top = 1;
        if (bottom === void 0) bottom = -1;
        if (near === void 0) near = 0.1;
        if (far === void 0) far = 2000;
        Camera.call(this);
        this.type = 'OrthographicCamera';
        this.zoom = 1;
        this.view = null;
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = near;
        this.far = far;
        this.updateProjectionMatrix();
    }
    OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: OrthographicCamera,
        isOrthographicCamera: true,
        copy: function copy(source, recursive) {
            Camera.prototype.copy.call(this, source, recursive);
            this.left = source.left;
            this.right = source.right;
            this.top = source.top;
            this.bottom = source.bottom;
            this.near = source.near;
            this.far = source.far;
            this.zoom = source.zoom;
            this.view = source.view === null ? null : Object.assign({
            }, source.view);
            return this;
        },
        setViewOffset: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
            if (this.view === null) this.view = {
                enabled: true,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            };
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
            this.updateProjectionMatrix();
        },
        clearViewOffset: function clearViewOffset() {
            if (this.view !== null) this.view.enabled = false;
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function updateProjectionMatrix() {
            var dx = (this.right - this.left) / (2 * this.zoom);
            var dy = (this.top - this.bottom) / (2 * this.zoom);
            var cx = (this.right + this.left) / 2;
            var cy = (this.top + this.bottom) / 2;
            var left = cx - dx;
            var right = cx + dx;
            var top = cy + dy;
            var bottom = cy - dy;
            if (this.view !== null && this.view.enabled) {
                var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
                var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                left += scaleW * this.view.offsetX;
                right = left + scaleW * this.view.width;
                top -= scaleH * this.view.offsetY;
                bottom = top - scaleH * this.view.height;
            }
            this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        },
        toJSON: function toJSON(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.zoom = this.zoom;
            data.object.left = this.left;
            data.object.right = this.right;
            data.object.top = this.top;
            data.object.bottom = this.bottom;
            data.object.near = this.near;
            data.object.far = this.far;
            if (this.view !== null) data.object.view = Object.assign({
            }, this.view);
            return data;
        }
    });
    function DirectionalLightShadow() {
        LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }
    DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: DirectionalLightShadow,
        isDirectionalLightShadow: true,
        updateMatrices: function updateMatrices(light) {
            LightShadow.prototype.updateMatrices.call(this, light);
        }
    });
    function DirectionalLight(color, intensity) {
        Light.call(this, color, intensity);
        this.type = 'DirectionalLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.shadow = new DirectionalLightShadow();
    }
    DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: DirectionalLight,
        isDirectionalLight: true,
        copy: function copy(source) {
            Light.prototype.copy.call(this, source);
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    });
    function AmbientLight(color, intensity) {
        Light.call(this, color, intensity);
        this.type = 'AmbientLight';
    }
    AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: AmbientLight,
        isAmbientLight: true
    });
    function RectAreaLight(color, intensity, width, height) {
        Light.call(this, color, intensity);
        this.type = 'RectAreaLight';
        this.width = width !== undefined ? width : 10;
        this.height = height !== undefined ? height : 10;
    }
    RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: RectAreaLight,
        isRectAreaLight: true,
        copy: function copy(source) {
            Light.prototype.copy.call(this, source);
            this.width = source.width;
            this.height = source.height;
            return this;
        },
        toJSON: function toJSON(meta) {
            var data = Light.prototype.toJSON.call(this, meta);
            data.object.width = this.width;
            data.object.height = this.height;
            return data;
        }
    });
    /**
	 * Primary reference:
	 *	 https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *	 https://www.ppsloan.org/publications/StupidSH36.pdf
	 */ // 3-band SH defined by 9 coefficients
    var SphericalHarmonics3 = /*#__PURE__*/ function() {
        function SphericalHarmonics31() {
            Object.defineProperty(this, 'isSphericalHarmonics3', {
                value: true
            });
            this.coefficients = [];
            for(var i47 = 0; i47 < 9; i47++)this.coefficients.push(new Vector3());
        }
        var _proto = SphericalHarmonics31.prototype;
        _proto.set = function set(coefficients) {
            for(var i47 = 0; i47 < 9; i47++)this.coefficients[i47].copy(coefficients[i47]);
            return this;
        };
        _proto.zero = function zero() {
            for(var i47 = 0; i47 < 9; i47++)this.coefficients[i47].set(0, 0, 0);
            return this;
        };
        _proto.getAt = function getAt(normal, target) {
            // normal is assumed to be unit length
            var x = normal.x, y = normal.y, z = normal.z;
            var coeff = this.coefficients; // band 0
            target.copy(coeff[0]).multiplyScalar(0.282095); // band 1
            target.addScaledVector(coeff[1], 0.488603 * y);
            target.addScaledVector(coeff[2], 0.488603 * z);
            target.addScaledVector(coeff[3], 0.488603 * x); // band 2
            target.addScaledVector(coeff[4], 1.092548 * (x * y));
            target.addScaledVector(coeff[5], 1.092548 * (y * z));
            target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
            target.addScaledVector(coeff[7], 1.092548 * (x * z));
            target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
            return target;
        };
        _proto.getIrradianceAt = function getIrradianceAt(normal, target) {
            // normal is assumed to be unit length
            var x = normal.x, y = normal.y, z = normal.z;
            var coeff = this.coefficients; // band 0
            target.copy(coeff[0]).multiplyScalar(0.886227); // Ï€ * 0.282095
            // band 1
            target.addScaledVector(coeff[1], 1.023328 * y); // ( 2 * Ï€ / 3 ) * 0.488603
            target.addScaledVector(coeff[2], 1.023328 * z);
            target.addScaledVector(coeff[3], 1.023328 * x); // band 2
            target.addScaledVector(coeff[4], 0.858086 * x * y); // ( Ï€ / 4 ) * 1.092548
            target.addScaledVector(coeff[5], 0.858086 * y * z);
            target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( Ï€ / 4 ) * 0.315392 * 3
            target.addScaledVector(coeff[7], 0.858086 * x * z);
            target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( Ï€ / 4 ) * 0.546274
            return target;
        };
        _proto.add = function add(sh) {
            for(var i47 = 0; i47 < 9; i47++)this.coefficients[i47].add(sh.coefficients[i47]);
            return this;
        };
        _proto.addScaledSH = function addScaledSH(sh, s) {
            for(var i47 = 0; i47 < 9; i47++)this.coefficients[i47].addScaledVector(sh.coefficients[i47], s);
            return this;
        };
        _proto.scale = function scale(s) {
            for(var i47 = 0; i47 < 9; i47++)this.coefficients[i47].multiplyScalar(s);
            return this;
        };
        _proto.lerp = function lerp(sh, alpha) {
            for(var i47 = 0; i47 < 9; i47++)this.coefficients[i47].lerp(sh.coefficients[i47], alpha);
            return this;
        };
        _proto.equals = function equals1(sh) {
            for(var i47 = 0; i47 < 9; i47++){
                if (!this.coefficients[i47].equals(sh.coefficients[i47])) return false;
            }
            return true;
        };
        _proto.copy = function copy(sh) {
            return this.set(sh.coefficients);
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.fromArray = function fromArray(array, offset) {
            if (offset === void 0) offset = 0;
            var coefficients = this.coefficients;
            for(var i47 = 0; i47 < 9; i47++)coefficients[i47].fromArray(array, offset + i47 * 3);
            return this;
        };
        _proto.toArray = function toArray(array, offset) {
            if (array === void 0) array = [];
            if (offset === void 0) offset = 0;
            var coefficients = this.coefficients;
            for(var i47 = 0; i47 < 9; i47++)coefficients[i47].toArray(array, offset + i47 * 3);
            return array;
        };
        SphericalHarmonics31.getBasisAt = function getBasisAt(normal, shBasis) {
            // normal is assumed to be unit length
            var x = normal.x, y = normal.y, z = normal.z; // band 0
            shBasis[0] = 0.282095; // band 1
            shBasis[1] = 0.488603 * y;
            shBasis[2] = 0.488603 * z;
            shBasis[3] = 0.488603 * x; // band 2
            shBasis[4] = 1.092548 * x * y;
            shBasis[5] = 1.092548 * y * z;
            shBasis[6] = 0.315392 * (3 * z * z - 1);
            shBasis[7] = 1.092548 * x * z;
            shBasis[8] = 0.546274 * (x * x - y * y);
        };
        return SphericalHarmonics31;
    }();
    function LightProbe(sh, intensity) {
        Light.call(this, undefined, intensity);
        this.type = 'LightProbe';
        this.sh = sh !== undefined ? sh : new SphericalHarmonics3();
    }
    LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: LightProbe,
        isLightProbe: true,
        copy: function copy(source) {
            Light.prototype.copy.call(this, source);
            this.sh.copy(source.sh);
            return this;
        },
        fromJSON: function fromJSON(json) {
            this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
            this.sh.fromArray(json.sh);
            return this;
        },
        toJSON: function toJSON(meta) {
            var data = Light.prototype.toJSON.call(this, meta);
            data.object.sh = this.sh.toArray();
            return data;
        }
    });
    function MaterialLoader(manager) {
        Loader.call(this, manager);
        this.textures = {
        };
    }
    MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: MaterialLoader,
        load: function load(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.setPath(scope.path);
            loader.setRequestHeader(scope.requestHeader);
            loader.setWithCredentials(scope.withCredentials);
            loader.load(url, function(text) {
                try {
                    onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                    if (onError) onError(e);
                    else console.error(e);
                    scope.manager.itemError(url);
                }
            }, onProgress, onError);
        },
        parse: function parse(json) {
            var textures = this.textures;
            function getTexture(name) {
                if (textures[name] === undefined) console.warn('THREE.MaterialLoader: Undefined texture', name);
                return textures[name];
            }
            var material = new Materials[json.type]();
            if (json.uuid !== undefined) material.uuid = json.uuid;
            if (json.name !== undefined) material.name = json.name;
            if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
            if (json.roughness !== undefined) material.roughness = json.roughness;
            if (json.metalness !== undefined) material.metalness = json.metalness;
            if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
            if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
            if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
            if (json.shininess !== undefined) material.shininess = json.shininess;
            if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
            if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
            if (json.fog !== undefined) material.fog = json.fog;
            if (json.flatShading !== undefined) material.flatShading = json.flatShading;
            if (json.blending !== undefined) material.blending = json.blending;
            if (json.combine !== undefined) material.combine = json.combine;
            if (json.side !== undefined) material.side = json.side;
            if (json.opacity !== undefined) material.opacity = json.opacity;
            if (json.transparent !== undefined) material.transparent = json.transparent;
            if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
            if (json.depthTest !== undefined) material.depthTest = json.depthTest;
            if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
            if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
            if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
            if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
            if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
            if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
            if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
            if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
            if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
            if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
            if (json.wireframe !== undefined) material.wireframe = json.wireframe;
            if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
            if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
            if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
            if (json.rotation !== undefined) material.rotation = json.rotation;
            if (json.linewidth !== 1) material.linewidth = json.linewidth;
            if (json.dashSize !== undefined) material.dashSize = json.dashSize;
            if (json.gapSize !== undefined) material.gapSize = json.gapSize;
            if (json.scale !== undefined) material.scale = json.scale;
            if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
            if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
            if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
            if (json.skinning !== undefined) material.skinning = json.skinning;
            if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
            if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
            if (json.dithering !== undefined) material.dithering = json.dithering;
            if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
            if (json.visible !== undefined) material.visible = json.visible;
            if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
            if (json.userData !== undefined) material.userData = json.userData;
            if (json.vertexColors !== undefined) {
                if (typeof json.vertexColors === 'number') material.vertexColors = json.vertexColors > 0 ? true : false;
                else material.vertexColors = json.vertexColors;
            } // Shader Material
            if (json.uniforms !== undefined) for(var name in json.uniforms){
                var uniform = json.uniforms[name];
                material.uniforms[name] = {
                };
                switch(uniform.type){
                    case 't':
                        material.uniforms[name].value = getTexture(uniform.value);
                        break;
                    case 'c':
                        material.uniforms[name].value = new Color().setHex(uniform.value);
                        break;
                    case 'v2':
                        material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                        break;
                    case 'v3':
                        material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                        break;
                    case 'v4':
                        material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                        break;
                    case 'm3':
                        material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                        break;
                    case 'm4':
                        material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                        break;
                    default:
                        material.uniforms[name].value = uniform.value;
                }
            }
            if (json.defines !== undefined) material.defines = json.defines;
            if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
            if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
            if (json.extensions !== undefined) for(var key4 in json.extensions)material.extensions[key4] = json.extensions[key4];
             // Deprecated
            if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
            // for PointsMaterial
            if (json.size !== undefined) material.size = json.size;
            if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps
            if (json.map !== undefined) material.map = getTexture(json.map);
            if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
            if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
            if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
            if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
            if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
            if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
            if (json.normalScale !== undefined) {
                var normalScale = json.normalScale;
                if (Array.isArray(normalScale) === false) // Blender exporter used to export a scalar. See #7459
                normalScale = [
                    normalScale,
                    normalScale
                ];
                material.normalScale = new Vector2().fromArray(normalScale);
            }
            if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
            if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
            if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
            if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
            if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
            if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
            if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
            if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
            if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
            if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
            if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
            if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
            if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
            if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
            if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
            if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
            if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
            if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
            if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
            if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
            if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
            if (json.transmission !== undefined) material.transmission = json.transmission;
            if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
            return material;
        },
        setTextures: function setTextures(value) {
            this.textures = value;
            return this;
        }
    });
    var LoaderUtils = {
        decodeText: function decodeText(array) {
            if (typeof TextDecoder !== 'undefined') return new TextDecoder().decode(array);
             // Avoid the String.fromCharCode.apply(null, array) shortcut, which
            // throws a "maximum call stack size exceeded" error for large arrays.
            var s = '';
            for(var i47 = 0, il = array.length; i47 < il; i47++)// Implicitly assumes little-endian.
            s += String.fromCharCode(array[i47]);
            try {
                // merges multi-byte utf-8 characters.
                return decodeURIComponent(escape(s));
            } catch (e) {
                // see #16358
                return s;
            }
        },
        extractUrlBase: function extractUrlBase(url) {
            var index = url.lastIndexOf('/');
            if (index === -1) return './';
            return url.substr(0, index + 1);
        }
    };
    function InstancedBufferGeometry() {
        BufferGeometry.call(this);
        this.type = 'InstancedBufferGeometry';
        this.instanceCount = Infinity;
    }
    InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
        constructor: InstancedBufferGeometry,
        isInstancedBufferGeometry: true,
        copy: function copy(source) {
            BufferGeometry.prototype.copy.call(this, source);
            this.instanceCount = source.instanceCount;
            return this;
        },
        clone: function clone() {
            return new this.constructor().copy(this);
        },
        toJSON: function toJSON() {
            var data = BufferGeometry.prototype.toJSON.call(this);
            data.instanceCount = this.instanceCount;
            data.isInstancedBufferGeometry = true;
            return data;
        }
    });
    function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
        if (typeof normalized === 'number') {
            meshPerAttribute = normalized;
            normalized = false;
            console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
        }
        BufferAttribute.call(this, array, itemSize, normalized);
        this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
        constructor: InstancedBufferAttribute,
        isInstancedBufferAttribute: true,
        copy: function copy(source) {
            BufferAttribute.prototype.copy.call(this, source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        },
        toJSON: function toJSON() {
            var data = BufferAttribute.prototype.toJSON.call(this);
            data.meshPerAttribute = this.meshPerAttribute;
            data.isInstancedBufferAttribute = true;
            return data;
        }
    });
    function BufferGeometryLoader(manager) {
        Loader.call(this, manager);
    }
    BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: BufferGeometryLoader,
        load: function load(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.setPath(scope.path);
            loader.setRequestHeader(scope.requestHeader);
            loader.setWithCredentials(scope.withCredentials);
            loader.load(url, function(text) {
                try {
                    onLoad(scope.parse(JSON.parse(text)));
                } catch (e) {
                    if (onError) onError(e);
                    else console.error(e);
                    scope.manager.itemError(url);
                }
            }, onProgress, onError);
        },
        parse: function parse(json) {
            var interleavedBufferMap = {
            };
            var arrayBufferMap = {
            };
            function getInterleavedBuffer(json1, uuid) {
                if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
                var interleavedBuffers = json1.interleavedBuffers;
                var interleavedBuffer = interleavedBuffers[uuid];
                var buffer = getArrayBuffer(json1, interleavedBuffer.buffer);
                var array = getTypedArray(interleavedBuffer.type, buffer);
                var ib = new InterleavedBuffer(array, interleavedBuffer.stride);
                ib.uuid = interleavedBuffer.uuid;
                interleavedBufferMap[uuid] = ib;
                return ib;
            }
            function getArrayBuffer(json1, uuid) {
                if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
                var arrayBuffers = json1.arrayBuffers;
                var arrayBuffer = arrayBuffers[uuid];
                var ab = new Uint32Array(arrayBuffer).buffer;
                arrayBufferMap[uuid] = ab;
                return ab;
            }
            var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
            var index = json.data.index;
            if (index !== undefined) {
                var typedArray = getTypedArray(index.type, index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
            }
            var attributes = json.data.attributes;
            for(var key4 in attributes){
                var attribute = attributes[key4];
                var bufferAttribute = void 0;
                if (attribute.isInterleavedBufferAttribute) {
                    var interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                    bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                    var _typedArray = getTypedArray(attribute.type, attribute.array);
                    var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                    bufferAttribute = new bufferAttributeConstr(_typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                geometry.setAttribute(key4, bufferAttribute);
            }
            var morphAttributes = json.data.morphAttributes;
            if (morphAttributes) for(var _key in morphAttributes){
                var attributeArray = morphAttributes[_key];
                var array = [];
                for(var i47 = 0, il = attributeArray.length; i47 < il; i47++){
                    var _attribute = attributeArray[i47];
                    var _bufferAttribute = void 0;
                    if (_attribute.isInterleavedBufferAttribute) {
                        var _interleavedBuffer = getInterleavedBuffer(json.data, _attribute.data);
                        _bufferAttribute = new InterleavedBufferAttribute(_interleavedBuffer, _attribute.itemSize, _attribute.offset, _attribute.normalized);
                    } else {
                        var _typedArray2 = getTypedArray(_attribute.type, _attribute.array);
                        _bufferAttribute = new BufferAttribute(_typedArray2, _attribute.itemSize, _attribute.normalized);
                    }
                    if (_attribute.name !== undefined) _bufferAttribute.name = _attribute.name;
                    array.push(_bufferAttribute);
                }
                geometry.morphAttributes[_key] = array;
            }
            var morphTargetsRelative = json.data.morphTargetsRelative;
            if (morphTargetsRelative) geometry.morphTargetsRelative = true;
            var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
            if (groups !== undefined) for(var _i = 0, n = groups.length; _i !== n; ++_i){
                var group = groups[_i];
                geometry.addGroup(group.start, group.count, group.materialIndex);
            }
            var boundingSphere = json.data.boundingSphere;
            if (boundingSphere !== undefined) {
                var center2 = new Vector3();
                if (boundingSphere.center !== undefined) center2.fromArray(boundingSphere.center);
                geometry.boundingSphere = new Sphere(center2, boundingSphere.radius);
            }
            if (json.name) geometry.name = json.name;
            if (json.userData) geometry.userData = json.userData;
            return geometry;
        }
    });
    var ObjectLoader1 = /*#__PURE__*/ function(_Loader) {
        _inheritsLoose(ObjectLoader2, _Loader);
        function ObjectLoader2(manager) {
            return _Loader.call(this, manager) || this;
        }
        var _proto = ObjectLoader2.prototype;
        _proto.load = function load(url, onLoad, onProgress, onError) {
            var scope = this;
            var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
            this.resourcePath = this.resourcePath || path;
            var loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setRequestHeader(this.requestHeader);
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function(text) {
                var json = null;
                try {
                    json = JSON.parse(text);
                } catch (error) {
                    if (onError !== undefined) onError(error);
                    console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                    return;
                }
                var metadata = json.metadata;
                if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                    console.error('THREE.ObjectLoader: Can\'t load ' + url);
                    return;
                }
                scope.parse(json, onLoad);
            }, onProgress, onError);
        };
        _proto.parse = function parse(json, onLoad) {
            var animations = this.parseAnimations(json.animations);
            var shapes = this.parseShapes(json.shapes);
            var geometries = this.parseGeometries(json.geometries, shapes);
            var images = this.parseImages(json.images, function() {
                if (onLoad !== undefined) onLoad(object);
            });
            var textures = this.parseTextures(json.textures, images);
            var materials = this.parseMaterials(json.materials, textures);
            var object = this.parseObject(json.object, geometries, materials, animations);
            var skeletons = this.parseSkeletons(json.skeletons, object);
            this.bindSkeletons(object, skeletons); //
            if (onLoad !== undefined) {
                var hasImages = false;
                for(var uuid in images)if (images[uuid] instanceof HTMLImageElement) {
                    hasImages = true;
                    break;
                }
                if (hasImages === false) onLoad(object);
            }
            return object;
        };
        _proto.parseShapes = function parseShapes(json) {
            var shapes = {
            };
            if (json !== undefined) for(var i48 = 0, l = json.length; i48 < l; i48++){
                var shape = new Shape().fromJSON(json[i48]);
                shapes[shape.uuid] = shape;
            }
            return shapes;
        };
        _proto.parseSkeletons = function parseSkeletons(json, object) {
            var skeletons = {
            };
            var bones = {
            }; // generate bone lookup table
            object.traverse(function(child) {
                if (child.isBone) bones[child.uuid] = child;
            }); // create skeletons
            if (json !== undefined) for(var i48 = 0, l = json.length; i48 < l; i48++){
                var skeleton = new Skeleton().fromJSON(json[i48], bones);
                skeletons[skeleton.uuid] = skeleton;
            }
            return skeletons;
        };
        _proto.parseGeometries = function parseGeometries(json, shapes) {
            var geometries = {
            };
            var geometryShapes;
            if (json !== undefined) {
                var bufferGeometryLoader = new BufferGeometryLoader();
                for(var i48 = 0, l = json.length; i48 < l; i48++){
                    var geometry = void 0;
                    var data = json[i48];
                    switch(data.type){
                        case 'PlaneGeometry':
                        case 'PlaneBufferGeometry':
                            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                            break;
                        case 'BoxGeometry':
                        case 'BoxBufferGeometry':
                            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                            break;
                        case 'CircleGeometry':
                        case 'CircleBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                            break;
                        case 'CylinderGeometry':
                        case 'CylinderBufferGeometry':
                            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                            break;
                        case 'ConeGeometry':
                        case 'ConeBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                            break;
                        case 'SphereGeometry':
                        case 'SphereBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                            break;
                        case 'DodecahedronGeometry':
                        case 'DodecahedronBufferGeometry':
                        case 'IcosahedronGeometry':
                        case 'IcosahedronBufferGeometry':
                        case 'OctahedronGeometry':
                        case 'OctahedronBufferGeometry':
                        case 'TetrahedronGeometry':
                        case 'TetrahedronBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.detail);
                            break;
                        case 'RingGeometry':
                        case 'RingBufferGeometry':
                            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                            break;
                        case 'TorusGeometry':
                        case 'TorusBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                            break;
                        case 'TorusKnotGeometry':
                        case 'TorusKnotBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                            break;
                        case 'TubeGeometry':
                        case 'TubeBufferGeometry':
                            // This only works for built-in curves (e.g. CatmullRomCurve3).
                            // User defined curves or instances of CurvePath will not be deserialized.
                            geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
                            break;
                        case 'LatheGeometry':
                        case 'LatheBufferGeometry':
                            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                            break;
                        case 'PolyhedronGeometry':
                        case 'PolyhedronBufferGeometry':
                            geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                            break;
                        case 'ShapeGeometry':
                        case 'ShapeBufferGeometry':
                            geometryShapes = [];
                            for(var j = 0, jl = data.shapes.length; j < jl; j++){
                                var shape = shapes[data.shapes[j]];
                                geometryShapes.push(shape);
                            }
                            geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
                            break;
                        case 'ExtrudeGeometry':
                        case 'ExtrudeBufferGeometry':
                            geometryShapes = [];
                            for(var _j = 0, _jl = data.shapes.length; _j < _jl; _j++){
                                var _shape = shapes[data.shapes[_j]];
                                geometryShapes.push(_shape);
                            }
                            var extrudePath = data.options.extrudePath;
                            if (extrudePath !== undefined) data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
                            geometry = new Geometries[data.type](geometryShapes, data.options);
                            break;
                        case 'BufferGeometry':
                        case 'InstancedBufferGeometry':
                            geometry = bufferGeometryLoader.parse(data);
                            break;
                        case 'Geometry':
                            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                            continue;
                    }
                    geometry.uuid = data.uuid;
                    if (data.name !== undefined) geometry.name = data.name;
                    if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
                    geometries[data.uuid] = geometry;
                }
            }
            return geometries;
        };
        _proto.parseMaterials = function parseMaterials(json, textures) {
            var cache = {
            }; // MultiMaterial
            var materials = {
            };
            if (json !== undefined) {
                var loader = new MaterialLoader();
                loader.setTextures(textures);
                for(var i49 = 0, l = json.length; i49 < l; i49++){
                    var data = json[i49];
                    if (data.type === 'MultiMaterial') {
                        // Deprecated
                        var array = [];
                        for(var j = 0; j < data.materials.length; j++){
                            var material = data.materials[j];
                            if (cache[material.uuid] === undefined) cache[material.uuid] = loader.parse(material);
                            array.push(cache[material.uuid]);
                        }
                        materials[data.uuid] = array;
                    } else {
                        if (cache[data.uuid] === undefined) cache[data.uuid] = loader.parse(data);
                        materials[data.uuid] = cache[data.uuid];
                    }
                }
            }
            return materials;
        };
        _proto.parseAnimations = function parseAnimations(json) {
            var animations = {
            };
            if (json !== undefined) for(var i50 = 0; i50 < json.length; i50++){
                var data = json[i50];
                var clip = AnimationClip.parse(data);
                animations[clip.uuid] = clip;
            }
            return animations;
        };
        _proto.parseImages = function parseImages(json, onLoad) {
            var scope = this;
            var images = {
            };
            var loader;
            function loadImage(url) {
                scope.manager.itemStart(url);
                return loader.load(url, function() {
                    scope.manager.itemEnd(url);
                }, undefined, function() {
                    scope.manager.itemError(url);
                    scope.manager.itemEnd(url);
                });
            }
            function deserializeImage(image) {
                if (typeof image === 'string') {
                    var url = image;
                    var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                    return loadImage(path);
                } else {
                    if (image.data) return {
                        data: getTypedArray(image.type, image.data),
                        width: image.width,
                        height: image.height
                    };
                    else return null;
                }
            }
            if (json !== undefined && json.length > 0) {
                var manager = new LoadingManager(onLoad);
                loader = new ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for(var i50 = 0, il = json.length; i50 < il; i50++){
                    var image = json[i50];
                    var url = image.url;
                    if (Array.isArray(url)) {
                        // load array of images e.g CubeTexture
                        images[image.uuid] = [];
                        for(var j = 0, jl = url.length; j < jl; j++){
                            var currentUrl = url[j];
                            var deserializedImage = deserializeImage(currentUrl);
                            if (deserializedImage !== null) {
                                if (deserializedImage instanceof HTMLImageElement) images[image.uuid].push(deserializedImage);
                                else // special case: handle array of data textures for cube textures
                                images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                            }
                        }
                    } else {
                        // load single image
                        var _deserializedImage = deserializeImage(image.url);
                        if (_deserializedImage !== null) images[image.uuid] = _deserializedImage;
                    }
                }
            }
            return images;
        };
        _proto.parseTextures = function parseTextures(json, images) {
            function parseConstant(value, type) {
                if (typeof value === 'number') return value;
                console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
                return type[value];
            }
            var textures = {
            };
            if (json !== undefined) for(var i51 = 0, l = json.length; i51 < l; i51++){
                var data = json[i51];
                if (data.image === undefined) console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                if (images[data.image] === undefined) console.warn('THREE.ObjectLoader: Undefined image', data.image);
                var texture = void 0;
                var image = images[data.image];
                if (Array.isArray(image)) {
                    texture = new CubeTexture(image);
                    if (image.length === 6) texture.needsUpdate = true;
                } else {
                    if (image && image.data) texture = new DataTexture(image.data, image.width, image.height);
                    else texture = new Texture(image);
                    if (image) texture.needsUpdate = true; // textures can have undefined image data
                }
                texture.uuid = data.uuid;
                if (data.name !== undefined) texture.name = data.name;
                if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
                if (data.offset !== undefined) texture.offset.fromArray(data.offset);
                if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
                if (data.center !== undefined) texture.center.fromArray(data.center);
                if (data.rotation !== undefined) texture.rotation = data.rotation;
                if (data.wrap !== undefined) {
                    texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                    texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
                }
                if (data.format !== undefined) texture.format = data.format;
                if (data.type !== undefined) texture.type = data.type;
                if (data.encoding !== undefined) texture.encoding = data.encoding;
                if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
                if (data.flipY !== undefined) texture.flipY = data.flipY;
                if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
                if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
                textures[data.uuid] = texture;
            }
            return textures;
        };
        _proto.parseObject = function parseObject(data, geometries, materials, animations) {
            var object;
            function getGeometry(name) {
                if (geometries[name] === undefined) console.warn('THREE.ObjectLoader: Undefined geometry', name);
                return geometries[name];
            }
            function getMaterial(name) {
                if (name === undefined) return undefined;
                if (Array.isArray(name)) {
                    var array = [];
                    for(var i51 = 0, l = name.length; i51 < l; i51++){
                        var uuid = name[i51];
                        if (materials[uuid] === undefined) console.warn('THREE.ObjectLoader: Undefined material', uuid);
                        array.push(materials[uuid]);
                    }
                    return array;
                }
                if (materials[name] === undefined) console.warn('THREE.ObjectLoader: Undefined material', name);
                return materials[name];
            }
            var geometry, material;
            switch(data.type){
                case 'Scene':
                    object = new Scene1();
                    if (data.background !== undefined) {
                        if (Number.isInteger(data.background)) object.background = new Color(data.background);
                    }
                    if (data.fog !== undefined) {
                        if (data.fog.type === 'Fog') object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                        else if (data.fog.type === 'FogExp2') object.fog = new FogExp2(data.fog.color, data.fog.density);
                    }
                    break;
                case 'PerspectiveCamera':
                    object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                    if (data.focus !== undefined) object.focus = data.focus;
                    if (data.zoom !== undefined) object.zoom = data.zoom;
                    if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                    if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                    if (data.view !== undefined) object.view = Object.assign({
                    }, data.view);
                    break;
                case 'OrthographicCamera':
                    object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                    if (data.zoom !== undefined) object.zoom = data.zoom;
                    if (data.view !== undefined) object.view = Object.assign({
                    }, data.view);
                    break;
                case 'AmbientLight':
                    object = new AmbientLight(data.color, data.intensity);
                    break;
                case 'DirectionalLight':
                    object = new DirectionalLight(data.color, data.intensity);
                    break;
                case 'PointLight':
                    object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                    break;
                case 'RectAreaLight':
                    object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                    break;
                case 'SpotLight':
                    object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                    break;
                case 'HemisphereLight':
                    object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                    break;
                case 'LightProbe':
                    object = new LightProbe().fromJSON(data);
                    break;
                case 'SkinnedMesh':
                    geometry = getGeometry(data.geometry);
                    material = getMaterial(data.material);
                    object = new SkinnedMesh(geometry, material);
                    if (data.bindMode !== undefined) object.bindMode = data.bindMode;
                    if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
                    if (data.skeleton !== undefined) object.skeleton = data.skeleton;
                    break;
                case 'Mesh':
                    geometry = getGeometry(data.geometry);
                    material = getMaterial(data.material);
                    object = new Mesh(geometry, material);
                    break;
                case 'InstancedMesh':
                    geometry = getGeometry(data.geometry);
                    material = getMaterial(data.material);
                    var count = data.count;
                    var instanceMatrix = data.instanceMatrix;
                    object = new InstancedMesh(geometry, material, count);
                    object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
                    break;
                case 'LOD':
                    object = new LOD();
                    break;
                case 'Line':
                    object = new Line(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'LineLoop':
                    object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'LineSegments':
                    object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'PointCloud':
                case 'Points':
                    object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'Sprite':
                    object = new Sprite(getMaterial(data.material));
                    break;
                case 'Group':
                    object = new Group();
                    break;
                case 'Bone':
                    object = new Bone();
                    break;
                default:
                    object = new Object3D();
            }
            object.uuid = data.uuid;
            if (data.name !== undefined) object.name = data.name;
            if (data.matrix !== undefined) {
                object.matrix.fromArray(data.matrix);
                if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
                if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
            } else {
                if (data.position !== undefined) object.position.fromArray(data.position);
                if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
                if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
                if (data.scale !== undefined) object.scale.fromArray(data.scale);
            }
            if (data.castShadow !== undefined) object.castShadow = data.castShadow;
            if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
            if (data.shadow) {
                if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
                if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
                if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
                if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
                if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
            }
            if (data.visible !== undefined) object.visible = data.visible;
            if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
            if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
            if (data.userData !== undefined) object.userData = data.userData;
            if (data.layers !== undefined) object.layers.mask = data.layers;
            if (data.children !== undefined) {
                var children = data.children;
                for(var i52 = 0; i52 < children.length; i52++)object.add(this.parseObject(children[i52], geometries, materials, animations));
            }
            if (data.animations !== undefined) {
                var objectAnimations = data.animations;
                for(var _i = 0; _i < objectAnimations.length; _i++){
                    var uuid = objectAnimations[_i];
                    object.animations.push(animations[uuid]);
                }
            }
            if (data.type === 'LOD') {
                if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
                var levels = data.levels;
                for(var l = 0; l < levels.length; l++){
                    var level = levels[l];
                    var child = object.getObjectByProperty('uuid', level.object);
                    if (child !== undefined) object.addLevel(child, level.distance);
                }
            }
            return object;
        };
        _proto.bindSkeletons = function bindSkeletons(object, skeletons) {
            if (Object.keys(skeletons).length === 0) return;
            object.traverse(function(child) {
                if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
                    var skeleton = skeletons[child.skeleton];
                    if (skeleton === undefined) console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
                    else child.bind(skeleton, child.bindMatrix);
                }
            });
        };
        _proto.setTexturePath = function setTexturePath(value) {
            console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
            return this.setResourcePath(value);
        };
        return ObjectLoader2;
    }(Loader);
    var TEXTURE_MAPPING = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    };
    var TEXTURE_WRAPPING = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    };
    var TEXTURE_FILTER = {
        NearestFilter: NearestFilter,
        NearestMipmapNearestFilter: NearestMipmapNearestFilter,
        NearestMipmapLinearFilter: NearestMipmapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipmapNearestFilter: LinearMipmapNearestFilter,
        LinearMipmapLinearFilter: LinearMipmapLinearFilter
    };
    function ImageBitmapLoader(manager) {
        if (typeof createImageBitmap === 'undefined') console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
        if (typeof fetch === 'undefined') console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
        Loader.call(this, manager);
        this.options = {
            premultiplyAlpha: 'none'
        };
    }
    ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: ImageBitmapLoader,
        isImageBitmapLoader: true,
        setOptions: function setOptions(options) {
            this.options = options;
            return this;
        },
        load: function load(url, onLoad, onProgress, onError) {
            if (url === undefined) url = '';
            if (this.path !== undefined) url = this.path + url;
            url = this.manager.resolveURL(url);
            var scope = this;
            var cached = Cache1.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function() {
                    if (onLoad) onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            var fetchOptions = {
            };
            fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
            fetch(url, fetchOptions).then(function(res) {
                return res.blob();
            }).then(function(blob) {
                return createImageBitmap(blob, scope.options);
            }).then(function(imageBitmap) {
                Cache1.add(url, imageBitmap);
                if (onLoad) onLoad(imageBitmap);
                scope.manager.itemEnd(url);
            }).catch(function(e) {
                if (onError) onError(e);
                scope.manager.itemError(url);
                scope.manager.itemEnd(url);
            });
            scope.manager.itemStart(url);
        }
    });
    function ShapePath() {
        this.type = 'ShapePath';
        this.color = new Color();
        this.subPaths = [];
        this.currentPath = null;
    }
    Object.assign(ShapePath.prototype, {
        moveTo: function moveTo(x, y) {
            this.currentPath = new Path();
            this.subPaths.push(this.currentPath);
            this.currentPath.moveTo(x, y);
            return this;
        },
        lineTo: function lineTo(x, y) {
            this.currentPath.lineTo(x, y);
            return this;
        },
        quadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
            this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
            return this;
        },
        bezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
            return this;
        },
        splineThru: function splineThru(pts) {
            this.currentPath.splineThru(pts);
            return this;
        },
        toShapes: function toShapes(isCCW, noHoles) {
            function toShapesNoHoles(inSubpaths) {
                var shapes = [];
                for(var i53 = 0, l = inSubpaths.length; i53 < l; i53++){
                    var _tmpPath = inSubpaths[i53];
                    var _tmpShape = new Shape();
                    _tmpShape.curves = _tmpPath.curves;
                    shapes.push(_tmpShape);
                }
                return shapes;
            }
            function isPointInsidePolygon(inPt, inPolygon) {
                var polyLen = inPolygon.length; // inPt on polygon contour => immediate success		or
                // toggling of inside/outside at every single! intersection point of an edge
                //	with the horizontal line through inPt, left of inPt
                //	not counting lowerY endpoints of edges and whole edges on that line
                var inside = false;
                for(var p = polyLen - 1, q = 0; q < polyLen; p = q++){
                    var edgeLowPt = inPolygon[p];
                    var edgeHighPt = inPolygon[q];
                    var edgeDx = edgeHighPt.x - edgeLowPt.x;
                    var edgeDy = edgeHighPt.y - edgeLowPt.y;
                    if (Math.abs(edgeDy) > Number.EPSILON) {
                        // not parallel
                        if (edgeDy < 0) {
                            edgeLowPt = inPolygon[q];
                            edgeDx = -edgeDx;
                            edgeHighPt = inPolygon[p];
                            edgeDy = -edgeDy;
                        }
                        if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                        if (inPt.y === edgeLowPt.y) {
                            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                        // continue;				// no intersection or edgeLowPt => doesn't count !!!
                        } else {
                            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                            if (perpEdge === 0) return true; // inPt is on contour ?
                            if (perpEdge < 0) continue;
                            inside = !inside; // true intersection left of inPt
                        }
                    } else {
                        // parallel or collinear
                        if (inPt.y !== edgeLowPt.y) continue; // parallel
                        // edge lies on the same horizontal line as inPt
                        if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
                    // continue;
                    }
                }
                return inside;
            }
            var isClockWise = ShapeUtils.isClockWise;
            var subPaths = this.subPaths;
            if (subPaths.length === 0) return [];
            if (noHoles === true) return toShapesNoHoles(subPaths);
            var solid, tmpPath, tmpShape;
            var shapes = [];
            if (subPaths.length === 1) {
                tmpPath = subPaths[0];
                tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
                return shapes;
            }
            var holesFirst = !isClockWise(subPaths[0].getPoints());
            holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);
            var betterShapeHoles = [];
            var newShapes = [];
            var newShapeHoles = [];
            var mainIdx = 0;
            var tmpPoints;
            newShapes[mainIdx] = undefined;
            newShapeHoles[mainIdx] = [];
            for(var i53 = 0, l = subPaths.length; i53 < l; i53++){
                tmpPath = subPaths[i53];
                tmpPoints = tmpPath.getPoints();
                solid = isClockWise(tmpPoints);
                solid = isCCW ? !solid : solid;
                if (solid) {
                    if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                    newShapes[mainIdx] = {
                        s: new Shape(),
                        p: tmpPoints
                    };
                    newShapes[mainIdx].s.curves = tmpPath.curves;
                    if (holesFirst) mainIdx++;
                    newShapeHoles[mainIdx] = []; //console.log('cw', i);
                } else newShapeHoles[mainIdx].push({
                    h: tmpPath,
                    p: tmpPoints[0]
                }); //console.log('ccw', i);
            } // only Holes? -> probably all Shapes with wrong orientation
            if (!newShapes[0]) return toShapesNoHoles(subPaths);
            if (newShapes.length > 1) {
                var ambiguous = false;
                var toChange = [];
                for(var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)betterShapeHoles[sIdx] = [];
                for(var _sIdx = 0, _sLen = newShapes.length; _sIdx < _sLen; _sIdx++){
                    var sho = newShapeHoles[_sIdx];
                    for(var hIdx = 0; hIdx < sho.length; hIdx++){
                        var ho = sho[hIdx];
                        var hole_unassigned = true;
                        for(var s2Idx = 0; s2Idx < newShapes.length; s2Idx++)if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                            if (_sIdx !== s2Idx) toChange.push({
                                froms: _sIdx,
                                tos: s2Idx,
                                hole: hIdx
                            });
                            if (hole_unassigned) {
                                hole_unassigned = false;
                                betterShapeHoles[s2Idx].push(ho);
                            } else ambiguous = true;
                        }
                        if (hole_unassigned) betterShapeHoles[_sIdx].push(ho);
                    }
                } // console.log("ambiguous: ", ambiguous);
                if (toChange.length > 0) // console.log("to change: ", toChange);
                {
                    if (!ambiguous) newShapeHoles = betterShapeHoles;
                }
            }
            var tmpHoles;
            for(var _i = 0, il = newShapes.length; _i < il; _i++){
                tmpShape = newShapes[_i].s;
                shapes.push(tmpShape);
                tmpHoles = newShapeHoles[_i];
                for(var j = 0, jl = tmpHoles.length; j < jl; j++)tmpShape.holes.push(tmpHoles[j].h);
            } //console.log("shape", shapes);
            return shapes;
        }
    });
    var Font = /*#__PURE__*/ function() {
        function Font1(data) {
            Object.defineProperty(this, 'isFont', {
                value: true
            });
            this.type = 'Font';
            this.data = data;
        }
        var _proto = Font1.prototype;
        _proto.generateShapes = function generateShapes(text, size) {
            if (size === void 0) size = 100;
            var shapes = [];
            var paths = createPaths(text, size, this.data);
            for(var p = 0, pl = paths.length; p < pl; p++)Array.prototype.push.apply(shapes, paths[p].toShapes());
            return shapes;
        };
        return Font1;
    }();
    function createPaths(text, size, data) {
        var chars = Array.from ? Array.from(text) : String(text).split(''); // workaround for IE11, see #13988
        var scale = size / data.resolution;
        var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
        var paths = [];
        var offsetX = 0, offsetY = 0;
        for(var i53 = 0; i53 < chars.length; i53++){
            var char = chars[i53];
            if (char === '\n') {
                offsetX = 0;
                offsetY -= line_height;
            } else {
                var ret = createPath(char, scale, offsetX, offsetY, data);
                offsetX += ret.offsetX;
                paths.push(ret.path);
            }
        }
        return paths;
    }
    function createPath(char, scale, offsetX, offsetY, data) {
        var glyph = data.glyphs[char] || data.glyphs['?'];
        if (!glyph) {
            console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
            return;
        }
        var path = new ShapePath();
        var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
        if (glyph.o) {
            var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
            for(var i53 = 0, l = outline.length; i53 < l;){
                var action = outline[i53++];
                switch(action){
                    case 'm':
                        // moveTo
                        x = outline[i53++] * scale + offsetX;
                        y = outline[i53++] * scale + offsetY;
                        path.moveTo(x, y);
                        break;
                    case 'l':
                        // lineTo
                        x = outline[i53++] * scale + offsetX;
                        y = outline[i53++] * scale + offsetY;
                        path.lineTo(x, y);
                        break;
                    case 'q':
                        // quadraticCurveTo
                        cpx = outline[i53++] * scale + offsetX;
                        cpy = outline[i53++] * scale + offsetY;
                        cpx1 = outline[i53++] * scale + offsetX;
                        cpy1 = outline[i53++] * scale + offsetY;
                        path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                        break;
                    case 'b':
                        // bezierCurveTo
                        cpx = outline[i53++] * scale + offsetX;
                        cpy = outline[i53++] * scale + offsetY;
                        cpx1 = outline[i53++] * scale + offsetX;
                        cpy1 = outline[i53++] * scale + offsetY;
                        cpx2 = outline[i53++] * scale + offsetX;
                        cpy2 = outline[i53++] * scale + offsetY;
                        path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                        break;
                }
            }
        }
        return {
            offsetX: glyph.ha * scale,
            path: path
        };
    }
    function FontLoader(manager) {
        Loader.call(this, manager);
    }
    FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: FontLoader,
        load: function load(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setRequestHeader(this.requestHeader);
            loader.setWithCredentials(scope.withCredentials);
            loader.load(url, function(text) {
                var json;
                try {
                    json = JSON.parse(text);
                } catch (e) {
                    console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                    json = JSON.parse(text.substring(65, text.length - 2));
                }
                var font = scope.parse(json);
                if (onLoad) onLoad(font);
            }, onProgress, onError);
        },
        parse: function parse(json) {
            return new Font(json);
        }
    });
    var _context;
    var AudioContext1 = {
        getContext: function getContext() {
            if (_context === undefined) _context = new (window.AudioContext || window.webkitAudioContext)();
            return _context;
        },
        setContext: function setContext(value) {
            _context = value;
        }
    };
    function AudioLoader(manager) {
        Loader.call(this, manager);
    }
    AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
        constructor: AudioLoader,
        load: function load(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.setResponseType('arraybuffer');
            loader.setPath(scope.path);
            loader.setRequestHeader(scope.requestHeader);
            loader.setWithCredentials(scope.withCredentials);
            loader.load(url, function(buffer) {
                try {
                    // Create a copy of the buffer. The `decodeAudioData` method
                    // detaches the buffer when complete, preventing reuse.
                    var bufferCopy = buffer.slice(0);
                    var context = AudioContext1.getContext();
                    context.decodeAudioData(bufferCopy, function(audioBuffer) {
                        onLoad(audioBuffer);
                    });
                } catch (e) {
                    if (onError) onError(e);
                    else console.error(e);
                    scope.manager.itemError(url);
                }
            }, onProgress, onError);
        }
    });
    function HemisphereLightProbe(skyColor, groundColor, intensity) {
        LightProbe.call(this, undefined, intensity);
        var color1 = new Color().set(skyColor);
        var color2 = new Color().set(groundColor);
        var sky = new Vector3(color1.r, color1.g, color1.b);
        var ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
        var c0 = Math.sqrt(Math.PI);
        var c1 = c0 * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
        this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
    }
    HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
        constructor: HemisphereLightProbe,
        isHemisphereLightProbe: true,
        copy: function copy(source) {
            // modifying colors not currently supported
            LightProbe.prototype.copy.call(this, source);
            return this;
        },
        toJSON: function toJSON(meta) {
            var data = LightProbe.prototype.toJSON.call(this, meta); // data.sh = this.sh.toArray(); // todo
            return data;
        }
    });
    function AmbientLightProbe(color, intensity) {
        LightProbe.call(this, undefined, intensity);
        var color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
        this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
    AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
        constructor: AmbientLightProbe,
        isAmbientLightProbe: true,
        copy: function copy(source) {
            // modifying color not currently supported
            LightProbe.prototype.copy.call(this, source);
            return this;
        },
        toJSON: function toJSON(meta) {
            var data = LightProbe.prototype.toJSON.call(this, meta); // data.sh = this.sh.toArray(); // todo
            return data;
        }
    });
    var _eyeRight = new Matrix4();
    var _eyeLeft = new Matrix4();
    function StereoCamera() {
        this.type = 'StereoCamera';
        this.aspect = 1;
        this.eyeSep = 0.064;
        this.cameraL = new PerspectiveCamera();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new PerspectiveCamera();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        };
    }
    Object.assign(StereoCamera.prototype, {
        update: function update(camera) {
            var cache = this._cache;
            var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
            if (needsUpdate) {
                cache.focus = camera.focus;
                cache.fov = camera.fov;
                cache.aspect = camera.aspect * this.aspect;
                cache.near = camera.near;
                cache.far = camera.far;
                cache.zoom = camera.zoom;
                cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
                // http://paulbourke.net/stereographics/stereorender/
                var projectionMatrix = camera.projectionMatrix.clone();
                var eyeSepHalf = cache.eyeSep / 2;
                var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
                var ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
                var xmin, xmax; // translate xOffset
                _eyeLeft.elements[12] = -eyeSepHalf;
                _eyeRight.elements[12] = eyeSepHalf; // for left eye
                xmin = -ymax * cache.aspect + eyeSepOnProjection;
                xmax = ymax * cache.aspect + eyeSepOnProjection;
                projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye
                xmin = -ymax * cache.aspect - eyeSepOnProjection;
                xmax = ymax * cache.aspect - eyeSepOnProjection;
                projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                this.cameraR.projectionMatrix.copy(projectionMatrix);
            }
            this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
            this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
        }
    });
    var Clock = /*#__PURE__*/ function() {
        function Clock1(autoStart) {
            this.autoStart = autoStart !== undefined ? autoStart : true;
            this.startTime = 0;
            this.oldTime = 0;
            this.elapsedTime = 0;
            this.running = false;
        }
        var _proto = Clock1.prototype;
        _proto.start = function start() {
            this.startTime = now();
            this.oldTime = this.startTime;
            this.elapsedTime = 0;
            this.running = true;
        };
        _proto.stop = function stop() {
            this.getElapsedTime();
            this.running = false;
            this.autoStart = false;
        };
        _proto.getElapsedTime = function getElapsedTime() {
            this.getDelta();
            return this.elapsedTime;
        };
        _proto.getDelta = function getDelta() {
            var diff = 0;
            if (this.autoStart && !this.running) {
                this.start();
                return 0;
            }
            if (this.running) {
                var newTime = now();
                diff = (newTime - this.oldTime) / 1000;
                this.oldTime = newTime;
                this.elapsedTime += diff;
            }
            return diff;
        };
        return Clock1;
    }();
    function now() {
        return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
    }
    var _position$2 = /*@__PURE__*/ new Vector3();
    var _quaternion$3 = /*@__PURE__*/ new Quaternion();
    var _scale$1 = /*@__PURE__*/ new Vector3();
    var _orientation = /*@__PURE__*/ new Vector3();
    var AudioListener1 = /*#__PURE__*/ function(_Object3D) {
        _inheritsLoose(AudioListener2, _Object3D);
        function AudioListener2() {
            var _this;
            _this = _Object3D.call(this) || this;
            _this.type = 'AudioListener';
            _this.context = AudioContext1.getContext();
            _this.gain = _this.context.createGain();
            _this.gain.connect(_this.context.destination);
            _this.filter = null;
            _this.timeDelta = 0; // private
            _this._clock = new Clock();
            return _this;
        }
        var _proto = AudioListener2.prototype;
        _proto.getInput = function getInput() {
            return this.gain;
        };
        _proto.removeFilter = function removeFilter() {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
                this.gain.connect(this.context.destination);
                this.filter = null;
            }
            return this;
        };
        _proto.getFilter = function getFilter() {
            return this.filter;
        };
        _proto.setFilter = function setFilter(value) {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
            } else this.gain.disconnect(this.context.destination);
            this.filter = value;
            this.gain.connect(this.filter);
            this.filter.connect(this.context.destination);
            return this;
        };
        _proto.getMasterVolume = function getMasterVolume() {
            return this.gain.gain.value;
        };
        _proto.setMasterVolume = function setMasterVolume(value) {
            this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
            return this;
        };
        _proto.updateMatrixWorld = function updateMatrixWorld(force) {
            _Object3D.prototype.updateMatrixWorld.call(this, force);
            var listener = this.context.listener;
            var up = this.up;
            this.timeDelta = this._clock.getDelta();
            this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);
            _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);
            if (listener.positionX) {
                // code path for Chrome (see #14393)
                var endTime = this.context.currentTime + this.timeDelta;
                listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
                listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
                listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
                listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
                listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
                listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
                listener.upX.linearRampToValueAtTime(up.x, endTime);
                listener.upY.linearRampToValueAtTime(up.y, endTime);
                listener.upZ.linearRampToValueAtTime(up.z, endTime);
            } else {
                listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
                listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
            }
        };
        return AudioListener2;
    }(Object3D);
    var Audio1 = /*#__PURE__*/ function(_Object3D) {
        _inheritsLoose(Audio2, _Object3D);
        function Audio2(listener) {
            var _this;
            _this = _Object3D.call(this) || this;
            _this.type = 'Audio';
            _this.listener = listener;
            _this.context = listener.context;
            _this.gain = _this.context.createGain();
            _this.gain.connect(listener.getInput());
            _this.autoplay = false;
            _this.buffer = null;
            _this.detune = 0;
            _this.loop = false;
            _this.loopStart = 0;
            _this.loopEnd = 0;
            _this.offset = 0;
            _this.duration = undefined;
            _this.playbackRate = 1;
            _this.isPlaying = false;
            _this.hasPlaybackControl = true;
            _this.source = null;
            _this.sourceType = 'empty';
            _this._startedAt = 0;
            _this._progress = 0;
            _this._connected = false;
            _this.filters = [];
            return _this;
        }
        var _proto = Audio2.prototype;
        _proto.getOutput = function getOutput() {
            return this.gain;
        };
        _proto.setNodeSource = function setNodeSource(audioNode) {
            this.hasPlaybackControl = false;
            this.sourceType = 'audioNode';
            this.source = audioNode;
            this.connect();
            return this;
        };
        _proto.setMediaElementSource = function setMediaElementSource(mediaElement) {
            this.hasPlaybackControl = false;
            this.sourceType = 'mediaNode';
            this.source = this.context.createMediaElementSource(mediaElement);
            this.connect();
            return this;
        };
        _proto.setMediaStreamSource = function setMediaStreamSource(mediaStream) {
            this.hasPlaybackControl = false;
            this.sourceType = 'mediaStreamNode';
            this.source = this.context.createMediaStreamSource(mediaStream);
            this.connect();
            return this;
        };
        _proto.setBuffer = function setBuffer(audioBuffer) {
            this.buffer = audioBuffer;
            this.sourceType = 'buffer';
            if (this.autoplay) this.play();
            return this;
        };
        _proto.play = function play(delay) {
            if (delay === void 0) delay = 0;
            if (this.isPlaying === true) {
                console.warn('THREE.Audio: Audio is already playing.');
                return;
            }
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this._startedAt = this.context.currentTime + delay;
            var source = this.context.createBufferSource();
            source.buffer = this.buffer;
            source.loop = this.loop;
            source.loopStart = this.loopStart;
            source.loopEnd = this.loopEnd;
            source.onended = this.onEnded.bind(this);
            source.start(this._startedAt, this._progress + this.offset, this.duration);
            this.isPlaying = true;
            this.source = source;
            this.setDetune(this.detune);
            this.setPlaybackRate(this.playbackRate);
            return this.connect();
        };
        _proto.pause = function pause() {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            if (this.isPlaying === true) {
                // update current progress
                this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
                if (this.loop === true) // ensure _progress does not exceed duration with looped audios
                this._progress = this._progress % (this.duration || this.buffer.duration);
                this.source.stop();
                this.source.onended = null;
                this.isPlaying = false;
            }
            return this;
        };
        _proto.stop = function stop() {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this._progress = 0;
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
            return this;
        };
        _proto.connect = function connect() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for(var i54 = 1, l = this.filters.length; i54 < l; i54++)this.filters[i54 - 1].connect(this.filters[i54]);
                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            this._connected = true;
            return this;
        };
        _proto.disconnect = function disconnect() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for(var i55 = 1, l = this.filters.length; i55 < l; i55++)this.filters[i55 - 1].disconnect(this.filters[i55]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else this.source.disconnect(this.getOutput());
            this._connected = false;
            return this;
        };
        _proto.getFilters = function getFilters() {
            return this.filters;
        };
        _proto.setFilters = function setFilters(value) {
            if (!value) value = [];
            if (this._connected === true) {
                this.disconnect();
                this.filters = value.slice();
                this.connect();
            } else this.filters = value.slice();
            return this;
        };
        _proto.setDetune = function setDetune(value) {
            this.detune = value;
            if (this.source.detune === undefined) return; // only set detune when available
            if (this.isPlaying === true) this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
            return this;
        };
        _proto.getDetune = function getDetune() {
            return this.detune;
        };
        _proto.getFilter = function getFilter() {
            return this.getFilters()[0];
        };
        _proto.setFilter = function setFilter(filter) {
            return this.setFilters(filter ? [
                filter
            ] : []);
        };
        _proto.setPlaybackRate = function setPlaybackRate(value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.playbackRate = value;
            if (this.isPlaying === true) this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
            return this;
        };
        _proto.getPlaybackRate = function getPlaybackRate() {
            return this.playbackRate;
        };
        _proto.onEnded = function onEnded() {
            this.isPlaying = false;
        };
        _proto.getLoop = function getLoop() {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return false;
            }
            return this.loop;
        };
        _proto.setLoop = function setLoop(value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.loop = value;
            if (this.isPlaying === true) this.source.loop = this.loop;
            return this;
        };
        _proto.setLoopStart = function setLoopStart(value) {
            this.loopStart = value;
            return this;
        };
        _proto.setLoopEnd = function setLoopEnd(value) {
            this.loopEnd = value;
            return this;
        };
        _proto.getVolume = function getVolume() {
            return this.gain.gain.value;
        };
        _proto.setVolume = function setVolume(value) {
            this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
            return this;
        };
        return Audio2;
    }(Object3D);
    var _position$3 = /*@__PURE__*/ new Vector3();
    var _quaternion$4 = /*@__PURE__*/ new Quaternion();
    var _scale$2 = /*@__PURE__*/ new Vector3();
    var _orientation$1 = /*@__PURE__*/ new Vector3();
    var PositionalAudio1 = /*#__PURE__*/ function(_Audio) {
        _inheritsLoose(PositionalAudio2, _Audio);
        function PositionalAudio2(listener) {
            var _this;
            _this = _Audio.call(this, listener) || this;
            _this.panner = _this.context.createPanner();
            _this.panner.panningModel = 'HRTF';
            _this.panner.connect(_this.gain);
            return _this;
        }
        var _proto = PositionalAudio2.prototype;
        _proto.getOutput = function getOutput() {
            return this.panner;
        };
        _proto.getRefDistance = function getRefDistance() {
            return this.panner.refDistance;
        };
        _proto.setRefDistance = function setRefDistance(value) {
            this.panner.refDistance = value;
            return this;
        };
        _proto.getRolloffFactor = function getRolloffFactor() {
            return this.panner.rolloffFactor;
        };
        _proto.setRolloffFactor = function setRolloffFactor(value) {
            this.panner.rolloffFactor = value;
            return this;
        };
        _proto.getDistanceModel = function getDistanceModel() {
            return this.panner.distanceModel;
        };
        _proto.setDistanceModel = function setDistanceModel(value) {
            this.panner.distanceModel = value;
            return this;
        };
        _proto.getMaxDistance = function getMaxDistance() {
            return this.panner.maxDistance;
        };
        _proto.setMaxDistance = function setMaxDistance(value) {
            this.panner.maxDistance = value;
            return this;
        };
        _proto.setDirectionalCone = function setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
            this.panner.coneInnerAngle = coneInnerAngle;
            this.panner.coneOuterAngle = coneOuterAngle;
            this.panner.coneOuterGain = coneOuterGain;
            return this;
        };
        _proto.updateMatrixWorld = function updateMatrixWorld(force) {
            _Audio.prototype.updateMatrixWorld.call(this, force);
            if (this.hasPlaybackControl === true && this.isPlaying === false) return;
            this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);
            _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);
            var panner = this.panner;
            if (panner.positionX) {
                // code path for Chrome and Firefox (see #14393)
                var endTime = this.context.currentTime + this.listener.timeDelta;
                panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
                panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
                panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
                panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
                panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
                panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
            } else {
                panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
                panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
            }
        };
        return PositionalAudio2;
    }(Audio1);
    var AudioAnalyser = /*#__PURE__*/ function() {
        function AudioAnalyser1(audio, fftSize) {
            if (fftSize === void 0) fftSize = 2048;
            this.analyser = audio.context.createAnalyser();
            this.analyser.fftSize = fftSize;
            this.data = new Uint8Array(this.analyser.frequencyBinCount);
            audio.getOutput().connect(this.analyser);
        }
        var _proto = AudioAnalyser1.prototype;
        _proto.getFrequencyData = function getFrequencyData() {
            this.analyser.getByteFrequencyData(this.data);
            return this.data;
        };
        _proto.getAverageFrequency = function getAverageFrequency() {
            var value = 0;
            var data = this.getFrequencyData();
            for(var i56 = 0; i56 < data.length; i56++)value += data[i56];
            return value / data.length;
        };
        return AudioAnalyser1;
    }();
    function PropertyMixer(binding, typeName, valueSize) {
        this.binding = binding;
        this.valueSize = valueSize;
        var mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
        //
        // interpolators can use .buffer as their .result
        // the data then goes to 'incoming'
        //
        // 'accu0' and 'accu1' are used frame-interleaved for
        // the cumulative result and are compared to detect
        // changes
        //
        // 'orig' stores the original state of the property
        //
        // 'add' is used for additive cumulative results
        //
        // 'work' is optional and is only present for quaternion types. It is used
        // to store intermediate quaternion multiplication results
        switch(typeName){
            case 'quaternion':
                mixFunction = this._slerp;
                mixFunctionAdditive = this._slerpAdditive;
                setIdentity = this._setAdditiveIdentityQuaternion;
                this.buffer = new Float64Array(valueSize * 6);
                this._workIndex = 5;
                break;
            case 'string':
            case 'bool':
                mixFunction = this._select; // Use the regular mix function and for additive on these types,
                // additive is not relevant for non-numeric types
                mixFunctionAdditive = this._select;
                setIdentity = this._setAdditiveIdentityOther;
                this.buffer = new Array(valueSize * 5);
                break;
            default:
                mixFunction = this._lerp;
                mixFunctionAdditive = this._lerpAdditive;
                setIdentity = this._setAdditiveIdentityNumeric;
                this.buffer = new Float64Array(valueSize * 5);
        }
        this._mixBufferRegion = mixFunction;
        this._mixBufferRegionAdditive = mixFunctionAdditive;
        this._setIdentity = setIdentity;
        this._origIndex = 3;
        this._addIndex = 4;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        this.useCount = 0;
        this.referenceCount = 0;
    }
    Object.assign(PropertyMixer.prototype, {
        // accumulate data in the 'incoming' region into 'accu<i>'
        accumulate: function accumulate(accuIndex, weight) {
            // note: happily accumulating nothing when weight = 0, the caller knows
            // the weight and shouldn't have made the call in the first place
            var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
            var currentWeight = this.cumulativeWeight;
            if (currentWeight === 0) {
                // accuN := incoming * weight
                for(var i56 = 0; i56 !== stride; ++i56)buffer[offset + i56] = buffer[i56];
                currentWeight = weight;
            } else {
                // accuN := accuN + incoming * weight
                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
            }
            this.cumulativeWeight = currentWeight;
        },
        // accumulate data in the 'incoming' region into 'add'
        accumulateAdditive: function accumulateAdditive(weight) {
            var buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
            if (this.cumulativeWeightAdditive === 0) // add = identity
            this._setIdentity();
             // add := add + incoming * weight
            this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
            this.cumulativeWeightAdditive += weight;
        },
        // apply the state of 'accu<i>' to the binding when accus differ
        apply: function apply(accuIndex) {
            var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
            this.cumulativeWeight = 0;
            this.cumulativeWeightAdditive = 0;
            if (weight < 1) {
                // accuN := accuN + original * ( 1 - cumulativeWeight )
                var originalValueOffset = stride * this._origIndex;
                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
            }
            if (weightAdditive > 0) // accuN := accuN + additive accuN
            this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
            for(var i57 = stride, e = stride + stride; i57 !== e; ++i57)if (buffer[i57] !== buffer[i57 + stride]) {
                // value has changed -> update scene graph
                binding.setValue(buffer, offset);
                break;
            }
        },
        // remember the state of the bound property and copy it to both accus
        saveOriginalState: function saveOriginalState() {
            var binding = this.binding;
            var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
            binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original
            for(var i57 = stride, e = originalValueOffset; i57 !== e; ++i57)buffer[i57] = buffer[originalValueOffset + i57 % stride];
             // Add to identity for additive
            this._setIdentity();
            this.cumulativeWeight = 0;
            this.cumulativeWeightAdditive = 0;
        },
        // apply the state previously taken via 'saveOriginalState' to the binding
        restoreOriginalState: function restoreOriginalState() {
            var originalValueOffset = this.valueSize * 3;
            this.binding.setValue(this.buffer, originalValueOffset);
        },
        _setAdditiveIdentityNumeric: function _setAdditiveIdentityNumeric() {
            var startIndex = this._addIndex * this.valueSize;
            var endIndex = startIndex + this.valueSize;
            for(var i57 = startIndex; i57 < endIndex; i57++)this.buffer[i57] = 0;
        },
        _setAdditiveIdentityQuaternion: function _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric();
            this.buffer[this._addIndex * this.valueSize + 3] = 1;
        },
        _setAdditiveIdentityOther: function _setAdditiveIdentityOther() {
            var startIndex = this._origIndex * this.valueSize;
            var targetIndex = this._addIndex * this.valueSize;
            for(var i57 = 0; i57 < this.valueSize; i57++)this.buffer[targetIndex + i57] = this.buffer[startIndex + i57];
        },
        // mix functions
        _select: function _select(buffer, dstOffset, srcOffset, t, stride) {
            if (t >= 0.5) for(var i57 = 0; i57 !== stride; ++i57)buffer[dstOffset + i57] = buffer[srcOffset + i57];
        },
        _slerp: function _slerp(buffer, dstOffset, srcOffset, t) {
            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        },
        _slerpAdditive: function _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
            var workOffset = this._workIndex * stride; // Store result in intermediate buffer offset
            Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result
            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
        },
        _lerp: function _lerp(buffer, dstOffset, srcOffset, t, stride) {
            var s = 1 - t;
            for(var i57 = 0; i57 !== stride; ++i57){
                var j = dstOffset + i57;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i57] * t;
            }
        },
        _lerpAdditive: function _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
            for(var i57 = 0; i57 !== stride; ++i57){
                var j = dstOffset + i57;
                buffer[j] = buffer[j] + buffer[srcOffset + i57] * t;
            }
        }
    });
    // Characters [].:/ are reserved for track binding syntax.
    var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
    var _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
    // only latin characters, and the unicode \p{L} is not yet supported. So
    // instead, we exclude reserved characters and match everything else.
    var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
    var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
    // be matched to parse the rest of the track name.
    var _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
    var _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
    // characters. Accessor may contain any character except closing bracket.
    var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
    // contain any non-bracket characters.
    var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
    var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
    var _supportedObjectNames = [
        'material',
        'materials',
        'bones'
    ];
    function Composite(targetGroup, path, optionalParsedPath) {
        var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    Object.assign(Composite.prototype, {
        getValue: function getValue(array, offset) {
            this.bind(); // bind all binding
            var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex]; // and only call .getValue on the first
            if (binding !== undefined) binding.getValue(array, offset);
        },
        setValue: function setValue(array, offset) {
            var bindings = this._bindings;
            for(var i57 = this._targetGroup.nCachedObjects_, n = bindings.length; i57 !== n; ++i57)bindings[i57].setValue(array, offset);
        },
        bind: function bind() {
            var bindings = this._bindings;
            for(var i57 = this._targetGroup.nCachedObjects_, n = bindings.length; i57 !== n; ++i57)bindings[i57].bind();
        },
        unbind: function unbind() {
            var bindings = this._bindings;
            for(var i57 = this._targetGroup.nCachedObjects_, n = bindings.length; i57 !== n; ++i57)bindings[i57].unbind();
        }
    });
    function PropertyBinding(rootNode, path, parsedPath) {
        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
    }
    Object.assign(PropertyBinding, {
        Composite: Composite,
        create: function create(root, path, parsedPath) {
            if (!(root && root.isAnimationObjectGroup)) return new PropertyBinding(root, path, parsedPath);
            else return new PropertyBinding.Composite(root, path, parsedPath);
        },
        /**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */ sanitizeNodeName: function sanitizeNodeName(name) {
            return name.replace(/\s/g, '_').replace(_reservedRe, '');
        },
        parseTrackName: function parseTrackName(trackName) {
            var matches = _trackRe.exec(trackName);
            if (!matches) throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
            var results = {
                // directoryName: matches[ 1 ], // (tschw) currently unused
                nodeName: matches[2],
                objectName: matches[3],
                objectIndex: matches[4],
                propertyName: matches[5],
                // required
                propertyIndex: matches[6]
            };
            var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
            if (lastDot !== undefined && lastDot !== -1) {
                var objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there
                // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
                // 'bar' could be the objectName, or part of a nodeName (which can
                // include '.' characters).
                if (_supportedObjectNames.indexOf(objectName) !== -1) {
                    results.nodeName = results.nodeName.substring(0, lastDot);
                    results.objectName = objectName;
                }
            }
            if (results.propertyName === null || results.propertyName.length === 0) throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
            return results;
        },
        findNode: function findNode(root, nodeName) {
            if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) return root;
             // search into skeleton bones.
            if (root.skeleton) {
                var bone = root.skeleton.getBoneByName(nodeName);
                if (bone !== undefined) return bone;
            } // search into node subtree.
            if (root.children) {
                var searchNodeSubtree = function searchNodeSubtree1(children) {
                    for(var i57 = 0; i57 < children.length; i57++){
                        var childNode = children[i57];
                        if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                        var result = searchNodeSubtree1(childNode.children);
                        if (result) return result;
                    }
                    return null;
                };
                var subTreeNode = searchNodeSubtree(root.children);
                if (subTreeNode) return subTreeNode;
            }
            return null;
        }
    });
    Object.assign(PropertyBinding.prototype, {
        // prototype, continued
        // these are used to "bind" a nonexistent property
        _getValue_unavailable: function _getValue_unavailable() {
        },
        _setValue_unavailable: function _setValue_unavailable() {
        },
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [
            function getValue_direct(buffer, offset) {
                buffer[offset] = this.node[this.propertyName];
            },
            function getValue_array(buffer, offset) {
                var source = this.resolvedProperty;
                for(var i57 = 0, n = source.length; i57 !== n; ++i57)buffer[offset++] = source[i57];
            },
            function getValue_arrayElement(buffer, offset) {
                buffer[offset] = this.resolvedProperty[this.propertyIndex];
            },
            function getValue_toArray(buffer, offset) {
                this.resolvedProperty.toArray(buffer, offset);
            }
        ],
        SetterByBindingTypeAndVersioning: [
            [
                function setValue_direct(buffer, offset) {
                    this.targetObject[this.propertyName] = buffer[offset];
                },
                function setValue_direct_setNeedsUpdate(buffer, offset) {
                    this.targetObject[this.propertyName] = buffer[offset];
                    this.targetObject.needsUpdate = true;
                },
                function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                    this.targetObject[this.propertyName] = buffer[offset];
                    this.targetObject.matrixWorldNeedsUpdate = true;
                }
            ],
            [
                function setValue_array(buffer, offset) {
                    var dest = this.resolvedProperty;
                    for(var i57 = 0, n = dest.length; i57 !== n; ++i57)dest[i57] = buffer[offset++];
                },
                function setValue_array_setNeedsUpdate(buffer, offset) {
                    var dest = this.resolvedProperty;
                    for(var i57 = 0, n = dest.length; i57 !== n; ++i57)dest[i57] = buffer[offset++];
                    this.targetObject.needsUpdate = true;
                },
                function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                    var dest = this.resolvedProperty;
                    for(var i57 = 0, n = dest.length; i57 !== n; ++i57)dest[i57] = buffer[offset++];
                    this.targetObject.matrixWorldNeedsUpdate = true;
                }
            ],
            [
                function setValue_arrayElement(buffer, offset) {
                    this.resolvedProperty[this.propertyIndex] = buffer[offset];
                },
                function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                    this.resolvedProperty[this.propertyIndex] = buffer[offset];
                    this.targetObject.needsUpdate = true;
                },
                function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                    this.resolvedProperty[this.propertyIndex] = buffer[offset];
                    this.targetObject.matrixWorldNeedsUpdate = true;
                }
            ],
            [
                function setValue_fromArray(buffer, offset) {
                    this.resolvedProperty.fromArray(buffer, offset);
                },
                function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                    this.resolvedProperty.fromArray(buffer, offset);
                    this.targetObject.needsUpdate = true;
                },
                function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                    this.resolvedProperty.fromArray(buffer, offset);
                    this.targetObject.matrixWorldNeedsUpdate = true;
                }
            ]
        ],
        getValue: function getValue_unbound(targetArray, offset) {
            this.bind();
            this.getValue(targetArray, offset); // Note: This class uses a State pattern on a per-method basis:
        // 'bind' sets 'this.getValue' / 'setValue' and shadows the
        // prototype version of these methods with one that represents
        // the bound state. When the property is not found, the methods
        // become no-ops.
        },
        setValue: function getValue_unbound1(sourceArray, offset) {
            this.bind();
            this.setValue(sourceArray, offset);
        },
        // create getter / setter pair for a property in the scene graph
        bind: function bind() {
            var targetObject = this.node;
            var parsedPath = this.parsedPath;
            var objectName = parsedPath.objectName;
            var propertyName = parsedPath.propertyName;
            var propertyIndex = parsedPath.propertyIndex;
            if (!targetObject) {
                targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
                this.node = targetObject;
            } // set fail state so we can just 'return' on error
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable; // ensure there is a value node
            if (!targetObject) {
                console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
                return;
            }
            if (objectName) {
                var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....
                switch(objectName){
                    case 'materials':
                        if (!targetObject.material) {
                            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                            return;
                        }
                        if (!targetObject.material.materials) {
                            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                            return;
                        }
                        targetObject = targetObject.material.materials;
                        break;
                    case 'bones':
                        if (!targetObject.skeleton) {
                            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                            return;
                        } // potential future optimization: skip this if propertyIndex is already an integer
                        // and convert the integer string to a true integer.
                        targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.
                        for(var i57 = 0; i57 < targetObject.length; i57++)if (targetObject[i57].name === objectIndex) {
                            objectIndex = i57;
                            break;
                        }
                        break;
                    default:
                        if (targetObject[objectName] === undefined) {
                            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                            return;
                        }
                        targetObject = targetObject[objectName];
                }
                if (objectIndex !== undefined) {
                    if (targetObject[objectIndex] === undefined) {
                        console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                        return;
                    }
                    targetObject = targetObject[objectIndex];
                }
            } // resolve property
            var nodeProperty = targetObject[propertyName];
            if (nodeProperty === undefined) {
                var nodeName = parsedPath.nodeName;
                console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
                return;
            } // determine versioning scheme
            var versioning = this.Versioning.None;
            this.targetObject = targetObject;
            if (targetObject.needsUpdate !== undefined) // material
            versioning = this.Versioning.NeedsUpdate;
            else if (targetObject.matrixWorldNeedsUpdate !== undefined) // node transform
            versioning = this.Versioning.MatrixWorldNeedsUpdate;
             // determine how the property gets bound
            var bindingType = this.BindingType.Direct;
            if (propertyIndex !== undefined) {
                // access a sub element of the property array (only primitives are supported right now)
                if (propertyName === 'morphTargetInfluences') {
                    // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                    // support resolving morphTarget names into indices.
                    if (!targetObject.geometry) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                        return;
                    }
                    if (targetObject.geometry.isBufferGeometry) {
                        if (!targetObject.geometry.morphAttributes) {
                            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                            return;
                        }
                        if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                    } else {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
                        return;
                    }
                }
                bindingType = this.BindingType.ArrayElement;
                this.resolvedProperty = nodeProperty;
                this.propertyIndex = propertyIndex;
            } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                // must use copy for Object3D.Euler/Quaternion
                bindingType = this.BindingType.HasFromToArray;
                this.resolvedProperty = nodeProperty;
            } else if (Array.isArray(nodeProperty)) {
                bindingType = this.BindingType.EntireArray;
                this.resolvedProperty = nodeProperty;
            } else this.propertyName = propertyName;
             // select getter / setter
            this.getValue = this.GetterByBindingType[bindingType];
            this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        },
        unbind: function unbind() {
            this.node = null; // back to the prototype version of getValue / setValue
            // note: avoiding to mutate the shape of 'this' via 'delete'
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
        }
    }); // DECLARE ALIAS AFTER assign prototype
    Object.assign(PropertyBinding.prototype, {
        // initial state of these methods that calls 'bind'
        _getValue_unbound: PropertyBinding.prototype.getValue,
        _setValue_unbound: PropertyBinding.prototype.setValue
    });
    /**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *	- Add objects you would otherwise pass as 'root' to the
	 *		constructor or the .clipAction method of AnimationMixer.
	 *
	 *	- Instead pass this object as 'root'.
	 *
	 *	- You can also add and remove objects later when the mixer
	 *		is running.
	 *
	 * Note:
	 *
	 *		Objects of this class appear as one object to the mixer,
	 *		so cache control of the individual objects must be done
	 *		on the group.
	 *
	 * Limitation:
	 *
	 *	- The animated properties must be compatible among the
	 *		all objects in the group.
	 *
	 *	- A single property can either be controlled through a
	 *		target group or directly, but not both.
	 */ function AnimationObjectGroup() {
        this.uuid = MathUtils.generateUUID(); // cached objects followed by the active ones
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0; // threshold
        // note: read by PropertyBinding.Composite
        var indices = {
        };
        this._indicesByUUID = indices; // for bookkeeping
        for(var i58 = 0, n = arguments.length; i58 !== n; ++i58)indices[arguments[i58].uuid] = i58;
        this._paths = []; // inside: string
        this._parsedPaths = []; // inside: { we don't care, here }
        this._bindings = []; // inside: Array< PropertyBinding >
        this._bindingsIndicesByPath = {
        }; // inside: indices in these arrays
        var scope = this;
        this.stats = {
            objects: {
                get total () {
                    return scope._objects.length;
                },
                get inUse () {
                    return this.total - scope.nCachedObjects_;
                }
            },
            get bindingsPerObject () {
                return scope._bindings.length;
            }
        };
    }
    Object.assign(AnimationObjectGroup.prototype, {
        isAnimationObjectGroup: true,
        add: function add() {
            var objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
            var knownObject = undefined, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
            for(var i58 = 0, n = arguments.length; i58 !== n; ++i58){
                var object = arguments[i58], uuid = object.uuid;
                var index = indicesByUUID[uuid];
                if (index === undefined) {
                    // unknown object -> add it to the ACTIVE region
                    index = nObjects++;
                    indicesByUUID[uuid] = index;
                    objects.push(object); // accounting is done, now do the same for all bindings
                    for(var j = 0, m = nBindings; j !== m; ++j)bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                } else if (index < nCachedObjects) {
                    knownObject = objects[index]; // move existing object to the ACTIVE region
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    indicesByUUID[uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings
                    for(var _j = 0, _m = nBindings; _j !== _m; ++_j){
                        var bindingsForPath = bindings[_j], lastCached = bindingsForPath[firstActiveIndex];
                        var binding = bindingsForPath[index];
                        bindingsForPath[index] = lastCached;
                        if (binding === undefined) // since we do not bother to create new bindings
                        // for objects that are cached, the binding may
                        // or may not exist
                        binding = new PropertyBinding(object, paths[_j], parsedPaths[_j]);
                        bindingsForPath[firstActiveIndex] = binding;
                    }
                } else if (objects[index] !== knownObject) console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
                 // else the object is already where we want it to be
            } // for arguments
            this.nCachedObjects_ = nCachedObjects;
        },
        remove: function remove() {
            var objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
            var nCachedObjects = this.nCachedObjects_;
            for(var i58 = 0, n = arguments.length; i58 !== n; ++i58){
                var object = arguments[i58], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== undefined && index >= nCachedObjects) {
                    // move existing object into the CACHED region
                    var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                    indicesByUUID[firstActiveObject.uuid] = index;
                    objects[index] = firstActiveObject;
                    indicesByUUID[uuid] = lastCachedIndex;
                    objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings
                    for(var j = 0, m = nBindings; j !== m; ++j){
                        var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = firstActive;
                        bindingsForPath[lastCachedIndex] = binding;
                    }
                }
            } // for arguments
            this.nCachedObjects_ = nCachedObjects;
        },
        // remove & forget
        uncache: function uncache() {
            var objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
            var nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
            for(var i58 = 0, n = arguments.length; i58 !== n; ++i58){
                var object = arguments[i58], uuid = object.uuid, index = indicesByUUID[uuid];
                if (index !== undefined) {
                    delete indicesByUUID[uuid];
                    if (index < nCachedObjects) {
                        // object is cached, shrink the CACHED region
                        var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex]; // last cached object takes this object's place
                        indicesByUUID[lastCachedObject.uuid] = index;
                        objects[index] = lastCachedObject; // last object goes to the activated slot and pop
                        indicesByUUID[lastObject.uuid] = firstActiveIndex;
                        objects[firstActiveIndex] = lastObject;
                        objects.pop(); // accounting is done, now do the same for all bindings
                        for(var j = 0, m = nBindings; j !== m; ++j){
                            var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                            bindingsForPath[index] = lastCached;
                            bindingsForPath[firstActiveIndex] = last;
                            bindingsForPath.pop();
                        }
                    } else {
                        // object is active, just swap with the last and pop
                        var _lastIndex = --nObjects, _lastObject = objects[_lastIndex];
                        if (_lastIndex > 0) indicesByUUID[_lastObject.uuid] = index;
                        objects[index] = _lastObject;
                        objects.pop(); // accounting is done, now do the same for all bindings
                        for(var _j2 = 0, _m2 = nBindings; _j2 !== _m2; ++_j2){
                            var _bindingsForPath = bindings[_j2];
                            _bindingsForPath[index] = _bindingsForPath[_lastIndex];
                            _bindingsForPath.pop();
                        }
                    } // cached or active
                } // if object is known
            } // for arguments
            this.nCachedObjects_ = nCachedObjects;
        },
        // Internal interface used by befriended PropertyBinding.Composite:
        subscribe_: function subscribe_(path, parsedPath) {
            // returns an array of bindings for the given path that is changed
            // according to the contained objects in the group
            var indicesByPath = this._bindingsIndicesByPath;
            var index = indicesByPath[path];
            var bindings = this._bindings;
            if (index !== undefined) return bindings[index];
            var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
            index = bindings.length;
            indicesByPath[path] = index;
            paths.push(path);
            parsedPaths.push(parsedPath);
            bindings.push(bindingsForPath);
            for(var i58 = nCachedObjects, n = objects.length; i58 !== n; ++i58){
                var object = objects[i58];
                bindingsForPath[i58] = new PropertyBinding(object, path, parsedPath);
            }
            return bindingsForPath;
        },
        unsubscribe_: function unsubscribe_(path) {
            // tells the group to forget about a property path and no longer
            // update the array previously obtained with 'subscribe_'
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
            if (index !== undefined) {
                var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
                indicesByPath[lastBindingsPath] = index;
                bindings[index] = lastBindings;
                bindings.pop();
                parsedPaths[index] = parsedPaths[lastBindingsIndex];
                parsedPaths.pop();
                paths[index] = paths[lastBindingsIndex];
                paths.pop();
            }
        }
    });
    var AnimationAction = /*#__PURE__*/ function() {
        function AnimationAction1(mixer, clip, localRoot, blendMode) {
            if (localRoot === void 0) localRoot = null;
            if (blendMode === void 0) blendMode = clip.blendMode;
            this._mixer = mixer;
            this._clip = clip;
            this._localRoot = localRoot;
            this.blendMode = blendMode;
            var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
            var interpolantSettings = {
                endingStart: ZeroCurvatureEnding,
                endingEnd: ZeroCurvatureEnding
            };
            for(var i58 = 0; i58 !== nTracks; ++i58){
                var interpolant = tracks[i58].createInterpolant(null);
                interpolants[i58] = interpolant;
                interpolant.settings = interpolantSettings;
            }
            this._interpolantSettings = interpolantSettings;
            this._interpolants = interpolants; // bound by the mixer
            // inside: PropertyMixer (managed by the mixer)
            this._propertyBindings = new Array(nTracks);
            this._cacheIndex = null; // for the memory manager
            this._byClipCacheIndex = null; // for the memory manager
            this._timeScaleInterpolant = null;
            this._weightInterpolant = null;
            this.loop = LoopRepeat;
            this._loopCount = -1; // global mixer time when the action is to be started
            // it's set back to 'null' upon start of the action
            this._startTime = null; // scaled local time of the action
            // gets clamped or wrapped to 0..clip.duration according to loop
            this.time = 0;
            this.timeScale = 1;
            this._effectiveTimeScale = 1;
            this.weight = 1;
            this._effectiveWeight = 1;
            this.repetitions = Infinity; // no. of repetitions when looping
            this.paused = false; // true -> zero effective time scale
            this.enabled = true; // false -> zero effective weight
            this.clampWhenFinished = false; // keep feeding the last frame?
            this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
            this.zeroSlopeAtEnd = true; // clips for start, loop and end
        } // State & Scheduling
        var _proto = AnimationAction1.prototype;
        _proto.play = function play() {
            this._mixer._activateAction(this);
            return this;
        };
        _proto.stop = function stop() {
            this._mixer._deactivateAction(this);
            return this.reset();
        };
        _proto.reset = function reset() {
            this.paused = false;
            this.enabled = true;
            this.time = 0; // restart clip
            this._loopCount = -1; // forget previous loops
            this._startTime = null; // forget scheduling
            return this.stopFading().stopWarping();
        };
        _proto.isRunning = function isRunning() {
            return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        };
        _proto.isScheduled = function isScheduled() {
            return this._mixer._isActiveAction(this);
        };
        _proto.startAt = function startAt(time) {
            this._startTime = time;
            return this;
        };
        _proto.setLoop = function setLoop(mode, repetitions) {
            this.loop = mode;
            this.repetitions = repetitions;
            return this;
        };
        _proto.setEffectiveWeight = function setEffectiveWeight(weight) {
            this.weight = weight; // note: same logic as when updated at runtime
            this._effectiveWeight = this.enabled ? weight : 0;
            return this.stopFading();
        };
        _proto.getEffectiveWeight = function getEffectiveWeight() {
            return this._effectiveWeight;
        };
        _proto.fadeIn = function fadeIn(duration) {
            return this._scheduleFading(duration, 0, 1);
        };
        _proto.fadeOut = function fadeOut(duration) {
            return this._scheduleFading(duration, 1, 0);
        };
        _proto.crossFadeFrom = function crossFadeFrom(fadeOutAction, duration, warp) {
            fadeOutAction.fadeOut(duration);
            this.fadeIn(duration);
            if (warp) {
                var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1, startEndRatio, duration);
                this.warp(endStartRatio, 1, duration);
            }
            return this;
        };
        _proto.crossFadeTo = function crossFadeTo(fadeInAction, duration, warp) {
            return fadeInAction.crossFadeFrom(this, duration, warp);
        };
        _proto.stopFading = function stopFading() {
            var weightInterpolant = this._weightInterpolant;
            if (weightInterpolant !== null) {
                this._weightInterpolant = null;
                this._mixer._takeBackControlInterpolant(weightInterpolant);
            }
            return this;
        };
        _proto.setEffectiveTimeScale = function setEffectiveTimeScale(timeScale) {
            this.timeScale = timeScale;
            this._effectiveTimeScale = this.paused ? 0 : timeScale;
            return this.stopWarping();
        };
        _proto.getEffectiveTimeScale = function getEffectiveTimeScale() {
            return this._effectiveTimeScale;
        };
        _proto.setDuration = function setDuration(duration) {
            this.timeScale = this._clip.duration / duration;
            return this.stopWarping();
        };
        _proto.syncWith = function syncWith(action) {
            this.time = action.time;
            this.timeScale = action.timeScale;
            return this.stopWarping();
        };
        _proto.halt = function halt(duration) {
            return this.warp(this._effectiveTimeScale, 0, duration);
        };
        _proto.warp = function warp(startTimeScale, endTimeScale, duration) {
            var mixer = this._mixer, now1 = mixer.time, timeScale = this.timeScale;
            var interpolant = this._timeScaleInterpolant;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._timeScaleInterpolant = interpolant;
            }
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            times[0] = now1;
            times[1] = now1 + duration;
            values[0] = startTimeScale / timeScale;
            values[1] = endTimeScale / timeScale;
            return this;
        };
        _proto.stopWarping = function stopWarping() {
            var timeScaleInterpolant = this._timeScaleInterpolant;
            if (timeScaleInterpolant !== null) {
                this._timeScaleInterpolant = null;
                this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
            }
            return this;
        };
        _proto.getMixer = function getMixer() {
            return this._mixer;
        };
        _proto.getClip = function getClip() {
            return this._clip;
        };
        _proto.getRoot = function getRoot() {
            return this._localRoot || this._mixer._root;
        };
        _proto._update = function _update(time, deltaTime, timeDirection, accuIndex) {
            // called by the mixer
            if (!this.enabled) {
                // call ._updateWeight() to update ._effectiveWeight
                this._updateWeight(time);
                return;
            }
            var startTime = this._startTime;
            if (startTime !== null) {
                // check for scheduled start of action
                var timeRunning = (time - startTime) * timeDirection;
                if (timeRunning < 0 || timeDirection === 0) return; // yet to come / don't decide when delta = 0
                 // start
                this._startTime = null; // unschedule
                deltaTime = timeDirection * timeRunning;
            } // apply time scale and advance time
            deltaTime *= this._updateTimeScale(time);
            var clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
            // an effective weight of 0
            var weight = this._updateWeight(time);
            if (weight > 0) {
                var _interpolants = this._interpolants;
                var propertyMixers = this._propertyBindings;
                switch(this.blendMode){
                    case AdditiveAnimationBlendMode:
                        for(var j = 0, m = _interpolants.length; j !== m; ++j){
                            _interpolants[j].evaluate(clipTime);
                            propertyMixers[j].accumulateAdditive(weight);
                        }
                        break;
                    case NormalAnimationBlendMode:
                    default:
                        for(var _j = 0, _m = _interpolants.length; _j !== _m; ++_j){
                            _interpolants[_j].evaluate(clipTime);
                            propertyMixers[_j].accumulate(accuIndex, weight);
                        }
                }
            }
        };
        _proto._updateWeight = function _updateWeight(time) {
            var weight = 0;
            if (this.enabled) {
                weight = this.weight;
                var interpolant = this._weightInterpolant;
                if (interpolant !== null) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    weight *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopFading();
                        if (interpolantValue === 0) // faded out, disable
                        this.enabled = false;
                    }
                }
            }
            this._effectiveWeight = weight;
            return weight;
        };
        _proto._updateTimeScale = function _updateTimeScale(time) {
            var timeScale = 0;
            if (!this.paused) {
                timeScale = this.timeScale;
                var interpolant = this._timeScaleInterpolant;
                if (interpolant !== null) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    timeScale *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopWarping();
                        if (timeScale === 0) // motion has halted, pause
                        this.paused = true;
                        else // warp done - apply final time scale
                        this.timeScale = timeScale;
                    }
                }
            }
            this._effectiveTimeScale = timeScale;
            return timeScale;
        };
        _proto._updateTime = function _updateTime(deltaTime) {
            var duration = this._clip.duration;
            var loop = this.loop;
            var time = this.time + deltaTime;
            var loopCount = this._loopCount;
            var pingPong = loop === LoopPingPong;
            if (deltaTime === 0) {
                if (loopCount === -1) return time;
                return pingPong && (loopCount & 1) === 1 ? duration - time : time;
            }
            if (loop === LoopOnce) {
                if (loopCount === -1) {
                    // just started
                    this._loopCount = 0;
                    this._setEndings(true, true, false);
                }
                handle_stop: {
                    if (time >= duration) time = duration;
                    else if (time < 0) time = 0;
                    else {
                        this.time = time;
                        break handle_stop;
                    }
                    if (this.clampWhenFinished) this.paused = true;
                    else this.enabled = false;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: deltaTime < 0 ? -1 : 1
                    });
                }
            } else {
                // repetitive Repeat or PingPong
                if (loopCount === -1) {
                    // just started
                    if (deltaTime >= 0) {
                        loopCount = 0;
                        this._setEndings(true, this.repetitions === 0, pingPong);
                    } else // when looping in reverse direction, the initial
                    // transition through zero counts as a repetition,
                    // so leave loopCount at -1
                    this._setEndings(this.repetitions === 0, true, pingPong);
                }
                if (time >= duration || time < 0) {
                    // wrap around
                    var loopDelta = Math.floor(time / duration); // signed
                    time -= duration * loopDelta;
                    loopCount += Math.abs(loopDelta);
                    var pending = this.repetitions - loopCount;
                    if (pending <= 0) {
                        // have to stop (switch state, clamp time, fire event)
                        if (this.clampWhenFinished) this.paused = true;
                        else this.enabled = false;
                        time = deltaTime > 0 ? duration : 0;
                        this.time = time;
                        this._mixer.dispatchEvent({
                            type: 'finished',
                            action: this,
                            direction: deltaTime > 0 ? 1 : -1
                        });
                    } else {
                        // keep running
                        if (pending === 1) {
                            // entering the last round
                            var atStart = deltaTime < 0;
                            this._setEndings(atStart, !atStart, pingPong);
                        } else this._setEndings(false, false, pingPong);
                        this._loopCount = loopCount;
                        this.time = time;
                        this._mixer.dispatchEvent({
                            type: 'loop',
                            action: this,
                            loopDelta: loopDelta
                        });
                    }
                } else this.time = time;
                if (pingPong && (loopCount & 1) === 1) // invert time for the "pong round"
                return duration - time;
            }
            return time;
        };
        _proto._setEndings = function _setEndings(atStart, atEnd, pingPong) {
            var settings = this._interpolantSettings;
            if (pingPong) {
                settings.endingStart = ZeroSlopeEnding;
                settings.endingEnd = ZeroSlopeEnding;
            } else {
                // assuming for LoopOnce atStart == atEnd == true
                if (atStart) settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
                else settings.endingStart = WrapAroundEnding;
                if (atEnd) settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
                else settings.endingEnd = WrapAroundEnding;
            }
        };
        _proto._scheduleFading = function _scheduleFading(duration, weightNow, weightThen) {
            var mixer = this._mixer, now1 = mixer.time;
            var interpolant = this._weightInterpolant;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._weightInterpolant = interpolant;
            }
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            times[0] = now1;
            values[0] = weightNow;
            times[1] = now1 + duration;
            values[1] = weightThen;
            return this;
        };
        return AnimationAction1;
    }();
    function AnimationMixer(root) {
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1;
    }
    AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: AnimationMixer,
        _bindAction: function _bindAction(action, prototypeAction) {
            var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
            var bindingsByName = bindingsByRoot[rootUuid];
            if (bindingsByName === undefined) {
                bindingsByName = {
                };
                bindingsByRoot[rootUuid] = bindingsByName;
            }
            for(var i58 = 0; i58 !== nTracks; ++i58){
                var track = tracks[i58], trackName = track.name;
                var binding = bindingsByName[trackName];
                if (binding !== undefined) bindings[i58] = binding;
                else {
                    binding = bindings[i58];
                    if (binding !== undefined) {
                        // existing binding, make sure the cache knows
                        if (binding._cacheIndex === null) {
                            ++binding.referenceCount;
                            this._addInactiveBinding(binding, rootUuid, trackName);
                        }
                        continue;
                    }
                    var path = prototypeAction && prototypeAction._propertyBindings[i58].binding.parsedPath;
                    binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                    ++binding.referenceCount;
                    this._addInactiveBinding(binding, rootUuid, trackName);
                    bindings[i58] = binding;
                }
                interpolants[i58].resultBuffer = binding.buffer;
            }
        },
        _activateAction: function _activateAction(action) {
            if (!this._isActiveAction(action)) {
                if (action._cacheIndex === null) {
                    // this action has been forgotten by the cache, but the user
                    // appears to be still using it -> rebind
                    var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                    this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                    this._addInactiveAction(action, clipUuid, rootUuid);
                }
                var bindings = action._propertyBindings; // increment reference counts / sort out state
                for(var i58 = 0, n = bindings.length; i58 !== n; ++i58){
                    var binding = bindings[i58];
                    if ((binding.useCount++) === 0) {
                        this._lendBinding(binding);
                        binding.saveOriginalState();
                    }
                }
                this._lendAction(action);
            }
        },
        _deactivateAction: function _deactivateAction(action) {
            if (this._isActiveAction(action)) {
                var bindings = action._propertyBindings; // decrement reference counts / sort out state
                for(var i59 = 0, n = bindings.length; i59 !== n; ++i59){
                    var binding = bindings[i59];
                    if ((--binding.useCount) === 0) {
                        binding.restoreOriginalState();
                        this._takeBackBinding(binding);
                    }
                }
                this._takeBackAction(action);
            }
        },
        // Memory manager
        _initMemoryManager: function _initMemoryManager() {
            this._actions = []; // 'nActiveActions' followed by inactive ones
            this._nActiveActions = 0;
            this._actionsByClip = {
            }; // inside:
            // {
            // 	knownActions: Array< AnimationAction > - used as prototypes
            // 	actionByRoot: AnimationAction - lookup
            // }
            this._bindings = []; // 'nActiveBindings' followed by inactive ones
            this._nActiveBindings = 0;
            this._bindingsByRootAndName = {
            }; // inside: Map< name, PropertyMixer >
            this._controlInterpolants = []; // same game as above
            this._nActiveControlInterpolants = 0;
            var scope = this;
            this.stats = {
                actions: {
                    get total () {
                        return scope._actions.length;
                    },
                    get inUse () {
                        return scope._nActiveActions;
                    }
                },
                bindings: {
                    get total () {
                        return scope._bindings.length;
                    },
                    get inUse () {
                        return scope._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total () {
                        return scope._controlInterpolants.length;
                    },
                    get inUse () {
                        return scope._nActiveControlInterpolants;
                    }
                }
            };
        },
        // Memory management for AnimationAction objects
        _isActiveAction: function _isActiveAction(action) {
            var index = action._cacheIndex;
            return index !== null && index < this._nActiveActions;
        },
        _addInactiveAction: function _addInactiveAction(action, clipUuid, rootUuid) {
            var actions = this._actions, actionsByClip = this._actionsByClip;
            var actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip === undefined) {
                actionsForClip = {
                    knownActions: [
                        action
                    ],
                    actionByRoot: {
                    }
                };
                action._byClipCacheIndex = 0;
                actionsByClip[clipUuid] = actionsForClip;
            } else {
                var knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length;
                knownActions.push(action);
            }
            action._cacheIndex = actions.length;
            actions.push(action);
            actionsForClip.actionByRoot[rootUuid] = action;
        },
        _removeInactiveAction: function _removeInactiveAction(action) {
            var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            action._cacheIndex = null;
            var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
            lastKnownAction._byClipCacheIndex = byClipCacheIndex;
            knownActionsForClip[byClipCacheIndex] = lastKnownAction;
            knownActionsForClip.pop();
            action._byClipCacheIndex = null;
            var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
            delete actionByRoot[rootUuid];
            if (knownActionsForClip.length === 0) delete actionsByClip[clipUuid];
            this._removeInactiveBindingsForAction(action);
        },
        _removeInactiveBindingsForAction: function _removeInactiveBindingsForAction(action) {
            var bindings = action._propertyBindings;
            for(var i60 = 0, n = bindings.length; i60 !== n; ++i60){
                var binding = bindings[i60];
                if ((--binding.referenceCount) === 0) this._removeInactiveBinding(binding);
            }
        },
        _lendAction: function _lendAction(action) {
            // [ active actions |	inactive actions	]
            // [	active actions >| inactive actions ]
            //								 s				a
            //									<-swap->
            //								 a				s
            var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
            action._cacheIndex = lastActiveIndex;
            actions[lastActiveIndex] = action;
            firstInactiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = firstInactiveAction;
        },
        _takeBackAction: function _takeBackAction(action) {
            // [	active actions	| inactive actions ]
            // [ active actions |< inactive actions	]
            //				a				s
            //				 <-swap->
            //				s				a
            var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
            action._cacheIndex = firstInactiveIndex;
            actions[firstInactiveIndex] = action;
            lastActiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = lastActiveAction;
        },
        // Memory management for PropertyMixer objects
        _addInactiveBinding: function _addInactiveBinding(binding, rootUuid, trackName) {
            var bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
            var bindingByName = bindingsByRoot[rootUuid];
            if (bindingByName === undefined) {
                bindingByName = {
                };
                bindingsByRoot[rootUuid] = bindingByName;
            }
            bindingByName[trackName] = binding;
            binding._cacheIndex = bindings.length;
            bindings.push(binding);
        },
        _removeInactiveBinding: function _removeInactiveBinding(binding) {
            var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
            lastInactiveBinding._cacheIndex = cacheIndex;
            bindings[cacheIndex] = lastInactiveBinding;
            bindings.pop();
            delete bindingByName[trackName];
            if (Object.keys(bindingByName).length === 0) delete bindingsByRoot[rootUuid];
        },
        _lendBinding: function _lendBinding(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
            binding._cacheIndex = lastActiveIndex;
            bindings[lastActiveIndex] = binding;
            firstInactiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = firstInactiveBinding;
        },
        _takeBackBinding: function _takeBackBinding(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
            binding._cacheIndex = firstInactiveIndex;
            bindings[firstInactiveIndex] = binding;
            lastActiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = lastActiveBinding;
        },
        // Memory management of Interpolants for weight and time scale
        _lendControlInterpolant: function _lendControlInterpolant() {
            var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
            var interpolant = interpolants[lastActiveIndex];
            if (interpolant === undefined) {
                interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
                interpolant.__cacheIndex = lastActiveIndex;
                interpolants[lastActiveIndex] = interpolant;
            }
            return interpolant;
        },
        _takeBackControlInterpolant: function _takeBackControlInterpolant(interpolant) {
            var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
            interpolant.__cacheIndex = firstInactiveIndex;
            interpolants[firstInactiveIndex] = interpolant;
            lastActiveInterpolant.__cacheIndex = prevIndex;
            interpolants[prevIndex] = lastActiveInterpolant;
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        // return an action for a clip optionally using a custom root target
        // object (this method allocates a lot of dynamic memory in case a
        // previously unknown clip/root combination is specified)
        clipAction: function clipAction(clip, optionalRoot, blendMode) {
            var root = optionalRoot || this._root, rootUuid = root.uuid;
            var clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
            var clipUuid = clipObject !== null ? clipObject.uuid : clip;
            var actionsForClip = this._actionsByClip[clipUuid];
            var prototypeAction = null;
            if (blendMode === undefined) {
                if (clipObject !== null) blendMode = clipObject.blendMode;
                else blendMode = NormalAnimationBlendMode;
            }
            if (actionsForClip !== undefined) {
                var existingAction = actionsForClip.actionByRoot[rootUuid];
                if (existingAction !== undefined && existingAction.blendMode === blendMode) return existingAction;
                 // we know the clip, so we don't have to parse all
                // the bindings again but can just copy
                prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action
                if (clipObject === null) clipObject = prototypeAction._clip;
            } // clip must be known when specified via string
            if (clipObject === null) return null; // allocate all resources required to run it
            var newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
            this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager
            this._addInactiveAction(newAction, clipUuid, rootUuid);
            return newAction;
        },
        // get an existing action
        existingAction: function existingAction(clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
            if (actionsForClip !== undefined) return actionsForClip.actionByRoot[rootUuid] || null;
            return null;
        },
        // deactivates all previously scheduled actions
        stopAllAction: function stopAllAction() {
            var actions = this._actions, nActions = this._nActiveActions;
            for(var i60 = nActions - 1; i60 >= 0; --i60)actions[i60].stop();
            return this;
        },
        // advance the time and update apply the animation
        update: function update(deltaTime) {
            deltaTime *= this.timeScale;
            var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1; // run active actions
            for(var i60 = 0; i60 !== nActions; ++i60){
                var action = actions[i60];
                action._update(time, deltaTime, timeDirection, accuIndex);
            } // update scene graph
            var bindings = this._bindings, nBindings = this._nActiveBindings;
            for(var _i = 0; _i !== nBindings; ++_i)bindings[_i].apply(accuIndex);
            return this;
        },
        // Allows you to seek to a specific time in an animation.
        setTime: function setTime(timeInSeconds) {
            this.time = 0; // Zero out time attribute for AnimationMixer object;
            for(var i60 = 0; i60 < this._actions.length; i60++)this._actions[i60].time = 0; // Zero out time attribute for all associated AnimationAction objects.
            return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
        },
        // return this mixer's root target object
        getRoot: function getRoot() {
            return this._root;
        },
        // free all resources specific to a particular clip
        uncacheClip: function uncacheClip(clip) {
            var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                // note: just calling _removeInactiveAction would mess up the
                // iteration state and also require updating the state we can
                // just throw away
                var actionsToRemove = actionsForClip.knownActions;
                for(var i60 = 0, n = actionsToRemove.length; i60 !== n; ++i60){
                    var action = actionsToRemove[i60];
                    this._deactivateAction(action);
                    var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                    action._cacheIndex = null;
                    action._byClipCacheIndex = null;
                    lastInactiveAction._cacheIndex = cacheIndex;
                    actions[cacheIndex] = lastInactiveAction;
                    actions.pop();
                    this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
            }
        },
        // free all resources specific to a particular root target object
        uncacheRoot: function uncacheRoot(root) {
            var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
            for(var clipUuid in actionsByClip){
                var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
                if (action !== undefined) {
                    this._deactivateAction(action);
                    this._removeInactiveAction(action);
                }
            }
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
            if (bindingByName !== undefined) for(var trackName in bindingByName){
                var binding = bindingByName[trackName];
                binding.restoreOriginalState();
                this._removeInactiveBinding(binding);
            }
        },
        // remove a targeted clip from the cache
        uncacheAction: function uncacheAction(clip, optionalRoot) {
            var action = this.existingAction(clip, optionalRoot);
            if (action !== null) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
    });
    var Uniform = /*#__PURE__*/ function() {
        function Uniform1(value) {
            if (typeof value === 'string') {
                console.warn('THREE.Uniform: Type parameter is no longer needed.');
                value = arguments[1];
            }
            this.value = value;
        }
        var _proto = Uniform1.prototype;
        _proto.clone = function clone() {
            return new Uniform1(this.value.clone === undefined ? this.value : this.value.clone());
        };
        return Uniform1;
    }();
    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
        InterleavedBuffer.call(this, array, stride);
        this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
        constructor: InstancedInterleavedBuffer,
        isInstancedInterleavedBuffer: true,
        copy: function copy(source) {
            InterleavedBuffer.prototype.copy.call(this, source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        },
        clone: function clone(data) {
            var ib = InterleavedBuffer.prototype.clone.call(this, data);
            ib.meshPerAttribute = this.meshPerAttribute;
            return ib;
        },
        toJSON: function toJSON(data) {
            var json = InterleavedBuffer.prototype.toJSON.call(this, data);
            json.isInstancedInterleavedBuffer = true;
            json.meshPerAttribute = this.meshPerAttribute;
            return json;
        }
    });
    function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
        this.buffer = buffer;
        this.type = type;
        this.itemSize = itemSize;
        this.elementSize = elementSize;
        this.count = count;
        this.version = 0;
    }
    Object.defineProperty(GLBufferAttribute.prototype, 'needsUpdate', {
        set: function set(value) {
            if (value === true) this.version++;
        }
    });
    Object.assign(GLBufferAttribute.prototype, {
        isGLBufferAttribute: true,
        setBuffer: function setBuffer(buffer) {
            this.buffer = buffer;
            return this;
        },
        setType: function setType(type, elementSize) {
            this.type = type;
            this.elementSize = elementSize;
            return this;
        },
        setItemSize: function setItemSize(itemSize) {
            this.itemSize = itemSize;
            return this;
        },
        setCount: function setCount(count) {
            this.count = count;
            return this;
        }
    });
    function Raycaster(origin, direction, near, far) {
        this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)
        this.near = near || 0;
        this.far = far || Infinity;
        this.camera = null;
        this.layers = new Layers();
        this.params = {
            Mesh: {
            },
            Line: {
                threshold: 1
            },
            LOD: {
            },
            Points: {
                threshold: 1
            },
            Sprite: {
            }
        };
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function get() {
                    console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                    return this.Points;
                }
            }
        });
    }
    function ascSort(a, b) {
        return a.distance - b.distance;
    }
    function _intersectObject(object, raycaster, intersects1, recursive) {
        if (object.layers.test(raycaster.layers)) object.raycast(raycaster, intersects1);
        if (recursive === true) {
            var children = object.children;
            for(var i61 = 0, l = children.length; i61 < l; i61++)_intersectObject(children[i61], raycaster, intersects1, true);
        }
    }
    Object.assign(Raycaster.prototype, {
        set: function set(origin, direction) {
            // direction is assumed to be normalized (for accurate distance calculations)
            this.ray.set(origin, direction);
        },
        setFromCamera: function setFromCamera(coords, camera) {
            if (camera && camera.isPerspectiveCamera) {
                this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
                this.camera = camera;
            } else if (camera && camera.isOrthographicCamera) {
                this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
                this.camera = camera;
            } else console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
        },
        intersectObject: function intersectObject(object, recursive, optionalTarget) {
            var intersects1 = optionalTarget || [];
            _intersectObject(object, this, intersects1, recursive);
            intersects1.sort(ascSort);
            return intersects1;
        },
        intersectObjects: function intersectObjects(objects, recursive, optionalTarget) {
            var intersects1 = optionalTarget || [];
            if (Array.isArray(objects) === false) {
                console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
                return intersects1;
            }
            for(var i62 = 0, l = objects.length; i62 < l; i62++)_intersectObject(objects[i62], this, intersects1, recursive);
            intersects1.sort(ascSort);
            return intersects1;
        }
    });
    /**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */ var Spherical = /*#__PURE__*/ function() {
        function Spherical1(radius, phi, theta) {
            if (radius === void 0) radius = 1;
            if (phi === void 0) phi = 0;
            if (theta === void 0) theta = 0;
            this.radius = radius;
            this.phi = phi; // polar angle
            this.theta = theta; // azimuthal angle
            return this;
        }
        var _proto = Spherical1.prototype;
        _proto.set = function set(radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(other) {
            this.radius = other.radius;
            this.phi = other.phi;
            this.theta = other.theta;
            return this;
        };
        _proto.makeSafe = function makeSafe() {
            var EPS = 0.000001;
            this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
            return this;
        };
        _proto.setFromVector3 = function setFromVector3(v) {
            return this.setFromCartesianCoords(v.x, v.y, v.z);
        };
        _proto.setFromCartesianCoords = function setFromCartesianCoords(x, y, z) {
            this.radius = Math.sqrt(x * x + y * y + z * z);
            if (this.radius === 0) {
                this.theta = 0;
                this.phi = 0;
            } else {
                this.theta = Math.atan2(x, z);
                this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
            }
            return this;
        };
        return Spherical1;
    }();
    /**
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 */ var Cylindrical = /*#__PURE__*/ function() {
        function Cylindrical1(radius, theta, y) {
            this.radius = radius !== undefined ? radius : 1; // distance from the origin to a point in the x-z plane
            this.theta = theta !== undefined ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
            this.y = y !== undefined ? y : 0; // height above the x-z plane
            return this;
        }
        var _proto = Cylindrical1.prototype;
        _proto.set = function set(radius, theta, y) {
            this.radius = radius;
            this.theta = theta;
            this.y = y;
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(other) {
            this.radius = other.radius;
            this.theta = other.theta;
            this.y = other.y;
            return this;
        };
        _proto.setFromVector3 = function setFromVector3(v) {
            return this.setFromCartesianCoords(v.x, v.y, v.z);
        };
        _proto.setFromCartesianCoords = function setFromCartesianCoords(x, y, z) {
            this.radius = Math.sqrt(x * x + z * z);
            this.theta = Math.atan2(x, z);
            this.y = y;
            return this;
        };
        return Cylindrical1;
    }();
    var _vector$8 = /*@__PURE__*/ new Vector2();
    var Box2 = /*#__PURE__*/ function() {
        function Box21(min, max) {
            Object.defineProperty(this, 'isBox2', {
                value: true
            });
            this.min = min !== undefined ? min : new Vector2(Infinity, Infinity);
            this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
        }
        var _proto = Box21.prototype;
        _proto.set = function set(min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        };
        _proto.setFromPoints = function setFromPoints(points) {
            this.makeEmpty();
            for(var i62 = 0, il = points.length; i62 < il; i62++)this.expandByPoint(points[i62]);
            return this;
        };
        _proto.setFromCenterAndSize = function setFromCenterAndSize(center3, size) {
            var halfSize = _vector$8.copy(size).multiplyScalar(0.5);
            this.min.copy(center3).sub(halfSize);
            this.max.copy(center3).add(halfSize);
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        };
        _proto.makeEmpty = function makeEmpty() {
            this.min.x = this.min.y = Infinity;
            this.max.x = this.max.y = -Infinity;
            return this;
        };
        _proto.isEmpty = function isEmpty() {
            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
            return this.max.x < this.min.x || this.max.y < this.min.y;
        };
        _proto.getCenter = function getCenter(target) {
            if (target === undefined) {
                console.warn('THREE.Box2: .getCenter() target is now required');
                target = new Vector2();
            }
            return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        };
        _proto.getSize = function getSize(target) {
            if (target === undefined) {
                console.warn('THREE.Box2: .getSize() target is now required');
                target = new Vector2();
            }
            return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
        };
        _proto.expandByPoint = function expandByPoint(point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        };
        _proto.expandByVector = function expandByVector(vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        };
        _proto.expandByScalar = function expandByScalar(scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        };
        _proto.containsPoint = function containsPoint(point) {
            return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
        };
        _proto.containsBox = function containsBox(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        };
        _proto.getParameter = function getParameter(point, target) {
            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.
            if (target === undefined) {
                console.warn('THREE.Box2: .getParameter() target is now required');
                target = new Vector2();
            }
            return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        };
        _proto.intersectsBox = function intersectsBox(box) {
            // using 4 splitting planes to rule out intersections
            return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        };
        _proto.clampPoint = function clampPoint(point, target) {
            if (target === undefined) {
                console.warn('THREE.Box2: .clampPoint() target is now required');
                target = new Vector2();
            }
            return target.copy(point).clamp(this.min, this.max);
        };
        _proto.distanceToPoint = function distanceToPoint(point) {
            var clampedPoint = _vector$8.copy(point).clamp(this.min, this.max);
            return clampedPoint.sub(point).length();
        };
        _proto.intersect = function intersect(box) {
            this.min.max(box.min);
            this.max.min(box.max);
            return this;
        };
        _proto.union = function union(box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        };
        _proto.translate = function translate(offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        };
        _proto.equals = function equals1(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        };
        return Box21;
    }();
    var _startP = /*@__PURE__*/ new Vector3();
    var _startEnd = /*@__PURE__*/ new Vector3();
    var Line3 = /*#__PURE__*/ function() {
        function Line31(start, end) {
            this.start = start !== undefined ? start : new Vector3();
            this.end = end !== undefined ? end : new Vector3();
        }
        var _proto = Line31.prototype;
        _proto.set = function set(start, end) {
            this.start.copy(start);
            this.end.copy(end);
            return this;
        };
        _proto.clone = function clone() {
            return new this.constructor().copy(this);
        };
        _proto.copy = function copy(line) {
            this.start.copy(line.start);
            this.end.copy(line.end);
            return this;
        };
        _proto.getCenter = function getCenter(target) {
            if (target === undefined) {
                console.warn('THREE.Line3: .getCenter() target is now required');
                target = new Vector3();
            }
            return target.addVectors(this.start, this.end).multiplyScalar(0.5);
        };
        _proto.delta = function delta(target) {
            if (target === undefined) {
                console.warn('THREE.Line3: .delta() target is now required');
                target = new Vector3();
            }
            return target.subVectors(this.end, this.start);
        };
        _proto.distanceSq = function distanceSq() {
            return this.start.distanceToSquared(this.end);
        };
        _proto.distance = function distance() {
            return this.start.distanceTo(this.end);
        };
        _proto.at = function at(t, target) {
            if (target === undefined) {
                console.warn('THREE.Line3: .at() target is now required');
                target = new Vector3();
            }
            return this.delta(target).multiplyScalar(t).add(this.start);
        };
        _proto.closestPointToPointParameter = function closestPointToPointParameter(point, clampToLine) {
            _startP.subVectors(point, this.start);
            _startEnd.subVectors(this.end, this.start);
            var startEnd2 = _startEnd.dot(_startEnd);
            var startEnd_startP = _startEnd.dot(_startP);
            var t = startEnd_startP / startEnd2;
            if (clampToLine) t = MathUtils.clamp(t, 0, 1);
            return t;
        };
        _proto.closestPointToPoint = function closestPointToPoint(point, clampToLine, target) {
            var t = this.closestPointToPointParameter(point, clampToLine);
            if (target === undefined) {
                console.warn('THREE.Line3: .closestPointToPoint() target is now required');
                target = new Vector3();
            }
            return this.delta(target).multiplyScalar(t).add(this.start);
        };
        _proto.applyMatrix4 = function applyMatrix4(matrix) {
            this.start.applyMatrix4(matrix);
            this.end.applyMatrix4(matrix);
            return this;
        };
        _proto.equals = function equals1(line) {
            return line.start.equals(this.start) && line.end.equals(this.end);
        };
        return Line31;
    }();
    function ImmediateRenderObject(material) {
        Object3D.call(this);
        this.material = material;
        this.render = function() /* renderCallback */ {
        };
        this.hasPositions = false;
        this.hasNormals = false;
        this.hasColors = false;
        this.hasUvs = false;
        this.positionArray = null;
        this.normalArray = null;
        this.colorArray = null;
        this.uvArray = null;
        this.count = 0;
    }
    ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
    ImmediateRenderObject.prototype.isImmediateRenderObject = true;
    var _vector$9 = /*@__PURE__*/ new Vector3();
    var SpotLightHelper1 = /*#__PURE__*/ function(_Object3D) {
        _inheritsLoose(SpotLightHelper2, _Object3D);
        function SpotLightHelper2(light, color) {
            var _this;
            _this = _Object3D.call(this) || this;
            _this.light = light;
            _this.light.updateMatrixWorld();
            _this.matrix = light.matrixWorld;
            _this.matrixAutoUpdate = false;
            _this.color = color;
            var geometry = new BufferGeometry();
            var positions = [
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1,
                0,
                1,
                0,
                0,
                0,
                -1,
                0,
                1,
                0,
                0,
                0,
                0,
                1,
                1,
                0,
                0,
                0,
                0,
                -1,
                1
            ];
            for(var i62 = 0, j = 1, l = 32; i62 < l; i62++, j++){
                var p1 = i62 / l * Math.PI * 2;
                var p2 = j / l * Math.PI * 2;
                positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
            }
            geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
            var material = new LineBasicMaterial({
                fog: false,
                toneMapped: false
            });
            _this.cone = new LineSegments(geometry, material);
            _this.add(_this.cone);
            _this.update();
            return _this;
        }
        var _proto = SpotLightHelper2.prototype;
        _proto.dispose = function dispose() {
            this.cone.geometry.dispose();
            this.cone.material.dispose();
        };
        _proto.update = function update() {
            this.light.updateMatrixWorld();
            var coneLength = this.light.distance ? this.light.distance : 1000;
            var coneWidth = coneLength * Math.tan(this.light.angle);
            this.cone.scale.set(coneWidth, coneWidth, coneLength);
            _vector$9.setFromMatrixPosition(this.light.target.matrixWorld);
            this.cone.lookAt(_vector$9);
            if (this.color !== undefined) this.cone.material.color.set(this.color);
            else this.cone.material.color.copy(this.light.color);
        };
        return SpotLightHelper2;
    }(Object3D);
    var _vector$a = /*@__PURE__*/ new Vector3();
    var _boneMatrix = /*@__PURE__*/ new Matrix4();
    var _matrixWorldInv = /*@__PURE__*/ new Matrix4();
    var SkeletonHelper1 = /*#__PURE__*/ function(_LineSegments) {
        _inheritsLoose(SkeletonHelper2, _LineSegments);
        function SkeletonHelper2(object) {
            var _this;
            var bones = getBoneList(object);
            var geometry = new BufferGeometry();
            var vertices = [];
            var colors = [];
            var color1 = new Color(0, 0, 1);
            var color2 = new Color(0, 1, 0);
            for(var i62 = 0; i62 < bones.length; i62++){
                var bone = bones[i62];
                if (bone.parent && bone.parent.isBone) {
                    vertices.push(0, 0, 0);
                    vertices.push(0, 0, 0);
                    colors.push(color1.r, color1.g, color1.b);
                    colors.push(color2.r, color2.g, color2.b);
                }
            }
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            var material = new LineBasicMaterial({
                vertexColors: true,
                depthTest: false,
                depthWrite: false,
                toneMapped: false,
                transparent: true
            });
            _this = _LineSegments.call(this, geometry, material) || this;
            _this.type = 'SkeletonHelper';
            _this.isSkeletonHelper = true;
            _this.root = object;
            _this.bones = bones;
            _this.matrix = object.matrixWorld;
            _this.matrixAutoUpdate = false;
            return _this;
        }
        var _proto = SkeletonHelper2.prototype;
        _proto.updateMatrixWorld = function updateMatrixWorld(force) {
            var bones = this.bones;
            var geometry = this.geometry;
            var position = geometry.getAttribute('position');
            _matrixWorldInv.copy(this.root.matrixWorld).invert();
            for(var i62 = 0, j = 0; i62 < bones.length; i62++){
                var bone = bones[i62];
                if (bone.parent && bone.parent.isBone) {
                    _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
                    _vector$a.setFromMatrixPosition(_boneMatrix);
                    position.setXYZ(j, _vector$a.x, _vector$a.y, _vector$a.z);
                    _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
                    _vector$a.setFromMatrixPosition(_boneMatrix);
                    position.setXYZ(j + 1, _vector$a.x, _vector$a.y, _vector$a.z);
                    j += 2;
                }
            }
            geometry.getAttribute('position').needsUpdate = true;
            _LineSegments.prototype.updateMatrixWorld.call(this, force);
        };
        return SkeletonHelper2;
    }(LineSegments);
    function getBoneList(object) {
        var boneList = [];
        if (object && object.isBone) boneList.push(object);
        for(var i62 = 0; i62 < object.children.length; i62++)boneList.push.apply(boneList, getBoneList(object.children[i62]));
        return boneList;
    }
    var PointLightHelper1 = /*#__PURE__*/ function(_Mesh) {
        _inheritsLoose(PointLightHelper2, _Mesh);
        function PointLightHelper2(light, sphereSize, color) {
            var _this;
            var geometry = new SphereGeometry1(sphereSize, 4, 2);
            var material = new MeshBasicMaterial({
                wireframe: true,
                fog: false,
                toneMapped: false
            });
            _this = _Mesh.call(this, geometry, material) || this;
            _this.light = light;
            _this.light.updateMatrixWorld();
            _this.color = color;
            _this.type = 'PointLightHelper';
            _this.matrix = _this.light.matrixWorld;
            _this.matrixAutoUpdate = false;
            _this.update();
            /*
			// TODO: delete this comment?
			const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
			const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
			const d = light.distance;
			if ( d === 0.0 ) {
				this.lightDistance.visible = false;
			} else {
				this.lightDistance.scale.set( d, d, d );
			}
			this.add( this.lightDistance );
			*/ return _this;
        }
        var _proto = PointLightHelper2.prototype;
        _proto.dispose = function dispose() {
            this.geometry.dispose();
            this.material.dispose();
        };
        _proto.update = function update() {
            if (this.color !== undefined) this.material.color.set(this.color);
            else this.material.color.copy(this.light.color);
        /*
			const d = this.light.distance;
				if ( d === 0.0 ) {
					this.lightDistance.visible = false;
				} else {
					this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );
				}
			*/ };
        return PointLightHelper2;
    }(Mesh);
    var _vector$b = /*@__PURE__*/ new Vector3();
    var _color1 = /*@__PURE__*/ new Color();
    var _color2 = /*@__PURE__*/ new Color();
    var HemisphereLightHelper1 = /*#__PURE__*/ function(_Object3D) {
        _inheritsLoose(HemisphereLightHelper2, _Object3D);
        function HemisphereLightHelper2(light, size, color) {
            var _this;
            _this = _Object3D.call(this) || this;
            _this.light = light;
            _this.light.updateMatrixWorld();
            _this.matrix = light.matrixWorld;
            _this.matrixAutoUpdate = false;
            _this.color = color;
            var geometry = new OctahedronGeometry1(size);
            geometry.rotateY(Math.PI * 0.5);
            _this.material = new MeshBasicMaterial({
                wireframe: true,
                fog: false,
                toneMapped: false
            });
            if (_this.color === undefined) _this.material.vertexColors = true;
            var position = geometry.getAttribute('position');
            var colors = new Float32Array(position.count * 3);
            geometry.setAttribute('color', new BufferAttribute(colors, 3));
            _this.add(new Mesh(geometry, _this.material));
            _this.update();
            return _this;
        }
        var _proto = HemisphereLightHelper2.prototype;
        _proto.dispose = function dispose() {
            this.children[0].geometry.dispose();
            this.children[0].material.dispose();
        };
        _proto.update = function update() {
            var mesh = this.children[0];
            if (this.color !== undefined) this.material.color.set(this.color);
            else {
                var colors = mesh.geometry.getAttribute('color');
                _color1.copy(this.light.color);
                _color2.copy(this.light.groundColor);
                for(var i62 = 0, l = colors.count; i62 < l; i62++){
                    var color = i62 < l / 2 ? _color1 : _color2;
                    colors.setXYZ(i62, color.r, color.g, color.b);
                }
                colors.needsUpdate = true;
            }
            mesh.lookAt(_vector$b.setFromMatrixPosition(this.light.matrixWorld).negate());
        };
        return HemisphereLightHelper2;
    }(Object3D);
    var GridHelper1 = /*#__PURE__*/ function(_LineSegments) {
        _inheritsLoose(GridHelper2, _LineSegments);
        function GridHelper2(size, divisions, color1, color2) {
            var _this;
            if (size === void 0) size = 10;
            if (divisions === void 0) divisions = 10;
            if (color1 === void 0) color1 = 4473924;
            if (color2 === void 0) color2 = 8947848;
            color1 = new Color(color1);
            color2 = new Color(color2);
            var center3 = divisions / 2;
            var step = size / divisions;
            var halfSize = size / 2;
            var vertices = [], colors = [];
            for(var i63 = 0, j = 0, k = -halfSize; i63 <= divisions; i63++, k += step){
                vertices.push(-halfSize, 0, k, halfSize, 0, k);
                vertices.push(k, 0, -halfSize, k, 0, halfSize);
                var color = i63 === center3 ? color1 : color2;
                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;
                color.toArray(colors, j);
                j += 3;
            }
            var geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            var material = new LineBasicMaterial({
                vertexColors: true,
                toneMapped: false
            });
            _this = _LineSegments.call(this, geometry, material) || this;
            _this.type = 'GridHelper';
            return _this;
        }
        return GridHelper2;
    }(LineSegments);
    var PolarGridHelper1 = /*#__PURE__*/ function(_LineSegments) {
        _inheritsLoose(PolarGridHelper2, _LineSegments);
        function PolarGridHelper2(radius, radials, circles, divisions, color1, color2) {
            var _this;
            if (radius === void 0) radius = 10;
            if (radials === void 0) radials = 16;
            if (circles === void 0) circles = 8;
            if (divisions === void 0) divisions = 64;
            if (color1 === void 0) color1 = 4473924;
            if (color2 === void 0) color2 = 8947848;
            color1 = new Color(color1);
            color2 = new Color(color2);
            var vertices = [];
            var colors = []; // create the radials
            for(var i63 = 0; i63 <= radials; i63++){
                var v = i63 / radials * (Math.PI * 2);
                var x = Math.sin(v) * radius;
                var z = Math.cos(v) * radius;
                vertices.push(0, 0, 0);
                vertices.push(x, 0, z);
                var color = i63 & 1 ? color1 : color2;
                colors.push(color.r, color.g, color.b);
                colors.push(color.r, color.g, color.b);
            } // create the circles
            for(var _i = 0; _i <= circles; _i++){
                var _color = _i & 1 ? color1 : color2;
                var r = radius - radius / circles * _i;
                for(var j = 0; j < divisions; j++){
                    // first vertex
                    var _v = j / divisions * (Math.PI * 2);
                    var _x1 = Math.sin(_v) * r;
                    var _z2 = Math.cos(_v) * r;
                    vertices.push(_x1, 0, _z2);
                    colors.push(_color.r, _color.g, _color.b); // second vertex
                    _v = (j + 1) / divisions * (Math.PI * 2);
                    _x1 = Math.sin(_v) * r;
                    _z2 = Math.cos(_v) * r;
                    vertices.push(_x1, 0, _z2);
                    colors.push(_color.r, _color.g, _color.b);
                }
            }
            var geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            var material = new LineBasicMaterial({
                vertexColors: true,
                toneMapped: false
            });
            _this = _LineSegments.call(this, geometry, material) || this;
            _this.type = 'PolarGridHelper';
            return _this;
        }
        return PolarGridHelper2;
    }(LineSegments);
    var _v1$6 = /*@__PURE__*/ new Vector3();
    var _v2$3 = /*@__PURE__*/ new Vector3();
    var _v3$1 = /*@__PURE__*/ new Vector3();
    var DirectionalLightHelper1 = /*#__PURE__*/ function(_Object3D) {
        _inheritsLoose(DirectionalLightHelper2, _Object3D);
        function DirectionalLightHelper2(light, size, color) {
            var _this;
            _this = _Object3D.call(this) || this;
            _this.light = light;
            _this.light.updateMatrixWorld();
            _this.matrix = light.matrixWorld;
            _this.matrixAutoUpdate = false;
            _this.color = color;
            if (size === undefined) size = 1;
            var geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute([
                -size,
                size,
                0,
                size,
                size,
                0,
                size,
                -size,
                0,
                -size,
                -size,
                0,
                -size,
                size,
                0
            ], 3));
            var material = new LineBasicMaterial({
                fog: false,
                toneMapped: false
            });
            _this.lightPlane = new Line(geometry, material);
            _this.add(_this.lightPlane);
            geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute([
                0,
                0,
                0,
                0,
                0,
                1
            ], 3));
            _this.targetLine = new Line(geometry, material);
            _this.add(_this.targetLine);
            _this.update();
            return _this;
        }
        var _proto = DirectionalLightHelper2.prototype;
        _proto.dispose = function dispose() {
            this.lightPlane.geometry.dispose();
            this.lightPlane.material.dispose();
            this.targetLine.geometry.dispose();
            this.targetLine.material.dispose();
        };
        _proto.update = function update() {
            _v1$6.setFromMatrixPosition(this.light.matrixWorld);
            _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);
            _v3$1.subVectors(_v2$3, _v1$6);
            this.lightPlane.lookAt(_v2$3);
            if (this.color !== undefined) {
                this.lightPlane.material.color.set(this.color);
                this.targetLine.material.color.set(this.color);
            } else {
                this.lightPlane.material.color.copy(this.light.color);
                this.targetLine.material.color.copy(this.light.color);
            }
            this.targetLine.lookAt(_v2$3);
            this.targetLine.scale.z = _v3$1.length();
        };
        return DirectionalLightHelper2;
    }(Object3D);
    var _vector$c = /*@__PURE__*/ new Vector3();
    var _camera = /*@__PURE__*/ new Camera();
    /**
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */ var CameraHelper1 = /*#__PURE__*/ function(_LineSegments) {
        _inheritsLoose(CameraHelper2, _LineSegments);
        function CameraHelper2(camera) {
            var _this;
            var geometry = new BufferGeometry();
            var material = new LineBasicMaterial({
                color: 16777215,
                vertexColors: true,
                toneMapped: false
            });
            var vertices = [];
            var colors = [];
            var pointMap = {
            }; // colors
            var colorFrustum = new Color(16755200);
            var colorCone = new Color(16711680);
            var colorUp = new Color(43775);
            var colorTarget = new Color(16777215);
            var colorCross = new Color(3355443); // near
            addLine('n1', 'n2', colorFrustum);
            addLine('n2', 'n4', colorFrustum);
            addLine('n4', 'n3', colorFrustum);
            addLine('n3', 'n1', colorFrustum); // far
            addLine('f1', 'f2', colorFrustum);
            addLine('f2', 'f4', colorFrustum);
            addLine('f4', 'f3', colorFrustum);
            addLine('f3', 'f1', colorFrustum); // sides
            addLine('n1', 'f1', colorFrustum);
            addLine('n2', 'f2', colorFrustum);
            addLine('n3', 'f3', colorFrustum);
            addLine('n4', 'f4', colorFrustum); // cone
            addLine('p', 'n1', colorCone);
            addLine('p', 'n2', colorCone);
            addLine('p', 'n3', colorCone);
            addLine('p', 'n4', colorCone); // up
            addLine('u1', 'u2', colorUp);
            addLine('u2', 'u3', colorUp);
            addLine('u3', 'u1', colorUp); // target
            addLine('c', 't', colorTarget);
            addLine('p', 'c', colorCross); // cross
            addLine('cn1', 'cn2', colorCross);
            addLine('cn3', 'cn4', colorCross);
            addLine('cf1', 'cf2', colorCross);
            addLine('cf3', 'cf4', colorCross);
            function addLine(a, b, color) {
                addPoint(a, color);
                addPoint(b, color);
            }
            function addPoint(id, color) {
                vertices.push(0, 0, 0);
                colors.push(color.r, color.g, color.b);
                if (pointMap[id] === undefined) pointMap[id] = [];
                pointMap[id].push(vertices.length / 3 - 1);
            }
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            _this = _LineSegments.call(this, geometry, material) || this;
            _this.type = 'CameraHelper';
            _this.camera = camera;
            if (_this.camera.updateProjectionMatrix) _this.camera.updateProjectionMatrix();
            _this.matrix = camera.matrixWorld;
            _this.matrixAutoUpdate = false;
            _this.pointMap = pointMap;
            _this.update();
            return _this;
        }
        var _proto = CameraHelper2.prototype;
        _proto.update = function update() {
            var geometry = this.geometry;
            var pointMap = this.pointMap;
            var w = 1, h = 1; // we need just camera projection matrix inverse
            // world matrix must be identity
            _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target
            setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
            setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near
            setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
            setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
            setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
            setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far
            setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
            setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
            setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
            setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up
            setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
            setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
            setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross
            setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
            setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
            setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
            setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
            setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
            setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
            setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
            setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
            geometry.getAttribute('position').needsUpdate = true;
        };
        return CameraHelper2;
    }(LineSegments);
    function setPoint(point, pointMap, geometry, camera, x, y, z) {
        _vector$c.set(x, y, z).unproject(camera);
        var points = pointMap[point];
        if (points !== undefined) {
            var position = geometry.getAttribute('position');
            for(var i63 = 0, l = points.length; i63 < l; i63++)position.setXYZ(points[i63], _vector$c.x, _vector$c.y, _vector$c.z);
        }
    }
    var _box$3 = /*@__PURE__*/ new Box3();
    var BoxHelper1 = /*#__PURE__*/ function(_LineSegments) {
        _inheritsLoose(BoxHelper2, _LineSegments);
        function BoxHelper2(object, color) {
            var _this;
            if (color === void 0) color = 16776960;
            var indices = new Uint16Array([
                0,
                1,
                1,
                2,
                2,
                3,
                3,
                0,
                4,
                5,
                5,
                6,
                6,
                7,
                7,
                4,
                0,
                4,
                1,
                5,
                2,
                6,
                3,
                7
            ]);
            var positions = new Float32Array(24);
            var geometry = new BufferGeometry();
            geometry.setIndex(new BufferAttribute(indices, 1));
            geometry.setAttribute('position', new BufferAttribute(positions, 3));
            _this = _LineSegments.call(this, geometry, new LineBasicMaterial({
                color: color,
                toneMapped: false
            })) || this;
            _this.object = object;
            _this.type = 'BoxHelper';
            _this.matrixAutoUpdate = false;
            _this.update();
            return _this;
        }
        var _proto = BoxHelper2.prototype;
        _proto.update = function update(object) {
            if (object !== undefined) console.warn('THREE.BoxHelper: .update() has no longer arguments.');
            if (this.object !== undefined) _box$3.setFromObject(this.object);
            if (_box$3.isEmpty()) return;
            var min = _box$3.min;
            var max = _box$3.max;
            /*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/
				0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/ var position = this.geometry.attributes.position;
            var array = position.array;
            array[0] = max.x;
            array[1] = max.y;
            array[2] = max.z;
            array[3] = min.x;
            array[4] = max.y;
            array[5] = max.z;
            array[6] = min.x;
            array[7] = min.y;
            array[8] = max.z;
            array[9] = max.x;
            array[10] = min.y;
            array[11] = max.z;
            array[12] = max.x;
            array[13] = max.y;
            array[14] = min.z;
            array[15] = min.x;
            array[16] = max.y;
            array[17] = min.z;
            array[18] = min.x;
            array[19] = min.y;
            array[20] = min.z;
            array[21] = max.x;
            array[22] = min.y;
            array[23] = min.z;
            position.needsUpdate = true;
            this.geometry.computeBoundingSphere();
        };
        _proto.setFromObject = function setFromObject(object) {
            this.object = object;
            this.update();
            return this;
        };
        _proto.copy = function copy(source) {
            LineSegments.prototype.copy.call(this, source);
            this.object = source.object;
            return this;
        };
        return BoxHelper2;
    }(LineSegments);
    var Box3Helper1 = /*#__PURE__*/ function(_LineSegments) {
        _inheritsLoose(Box3Helper2, _LineSegments);
        function Box3Helper2(box, color) {
            var _this;
            if (color === void 0) color = 16776960;
            var indices = new Uint16Array([
                0,
                1,
                1,
                2,
                2,
                3,
                3,
                0,
                4,
                5,
                5,
                6,
                6,
                7,
                7,
                4,
                0,
                4,
                1,
                5,
                2,
                6,
                3,
                7
            ]);
            var positions = [
                1,
                1,
                1,
                -1,
                1,
                1,
                -1,
                -1,
                1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                -1
            ];
            var geometry = new BufferGeometry();
            geometry.setIndex(new BufferAttribute(indices, 1));
            geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
            _this = _LineSegments.call(this, geometry, new LineBasicMaterial({
                color: color,
                toneMapped: false
            })) || this;
            _this.box = box;
            _this.type = 'Box3Helper';
            _this.geometry.computeBoundingSphere();
            return _this;
        }
        var _proto = Box3Helper2.prototype;
        _proto.updateMatrixWorld = function updateMatrixWorld(force) {
            var box = this.box;
            if (box.isEmpty()) return;
            box.getCenter(this.position);
            box.getSize(this.scale);
            this.scale.multiplyScalar(0.5);
            _LineSegments.prototype.updateMatrixWorld.call(this, force);
        };
        return Box3Helper2;
    }(LineSegments);
    var PlaneHelper1 = /*#__PURE__*/ function(_Line) {
        _inheritsLoose(PlaneHelper2, _Line);
        function PlaneHelper2(plane, size, hex) {
            var _this;
            if (size === void 0) size = 1;
            if (hex === void 0) hex = 16776960;
            var color = hex;
            var positions = [
                1,
                -1,
                1,
                -1,
                1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                1,
                -1,
                1,
                1,
                -1,
                -1,
                1,
                1,
                -1,
                1,
                1,
                1,
                1,
                0,
                0,
                1,
                0,
                0,
                0
            ];
            var geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
            geometry.computeBoundingSphere();
            _this = _Line.call(this, geometry, new LineBasicMaterial({
                color: color,
                toneMapped: false
            })) || this;
            _this.type = 'PlaneHelper';
            _this.plane = plane;
            _this.size = size;
            var positions2 = [
                1,
                1,
                1,
                -1,
                1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                1,
                -1,
                1
            ];
            var geometry2 = new BufferGeometry();
            geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
            geometry2.computeBoundingSphere();
            _this.add(new Mesh(geometry2, new MeshBasicMaterial({
                color: color,
                opacity: 0.2,
                transparent: true,
                depthWrite: false,
                toneMapped: false
            })));
            return _this;
        }
        var _proto = PlaneHelper2.prototype;
        _proto.updateMatrixWorld = function updateMatrixWorld(force) {
            var scale = -this.plane.constant;
            if (Math.abs(scale) < 0.00000001) scale = 0.00000001; // sign does not matter
            this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
            this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here
            this.lookAt(this.plane.normal);
            _Line.prototype.updateMatrixWorld.call(this, force);
        };
        return PlaneHelper2;
    }(Line);
    var _axis = /*@__PURE__*/ new Vector3();
    var _lineGeometry, _coneGeometry;
    var ArrowHelper1 = /*#__PURE__*/ function(_Object3D) {
        _inheritsLoose(ArrowHelper2, _Object3D);
        function ArrowHelper2(dir, origin, length, color, headLength, headWidth) {
            var _this;
            _this = _Object3D.call(this) || this; // dir is assumed to be normalized
            _this.type = 'ArrowHelper';
            if (dir === undefined) dir = new Vector3(0, 0, 1);
            if (origin === undefined) origin = new Vector3(0, 0, 0);
            if (length === undefined) length = 1;
            if (color === undefined) color = 16776960;
            if (headLength === undefined) headLength = 0.2 * length;
            if (headWidth === undefined) headWidth = 0.2 * headLength;
            if (_lineGeometry === undefined) {
                _lineGeometry = new BufferGeometry();
                _lineGeometry.setAttribute('position', new Float32BufferAttribute([
                    0,
                    0,
                    0,
                    0,
                    1,
                    0
                ], 3));
                _coneGeometry = new CylinderGeometry1(0, 0.5, 1, 5, 1);
                _coneGeometry.translate(0, -0.5, 0);
            }
            _this.position.copy(origin);
            _this.line = new Line(_lineGeometry, new LineBasicMaterial({
                color: color,
                toneMapped: false
            }));
            _this.line.matrixAutoUpdate = false;
            _this.add(_this.line);
            _this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
                color: color,
                toneMapped: false
            }));
            _this.cone.matrixAutoUpdate = false;
            _this.add(_this.cone);
            _this.setDirection(dir);
            _this.setLength(length, headLength, headWidth);
            return _this;
        }
        var _proto = ArrowHelper2.prototype;
        _proto.setDirection = function setDirection(dir) {
            // dir is assumed to be normalized
            if (dir.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
            else if (dir.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
            else {
                _axis.set(dir.z, 0, -dir.x).normalize();
                var radians = Math.acos(dir.y);
                this.quaternion.setFromAxisAngle(_axis, radians);
            }
        };
        _proto.setLength = function setLength(length, headLength, headWidth) {
            if (headLength === undefined) headLength = 0.2 * length;
            if (headWidth === undefined) headWidth = 0.2 * headLength;
            this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
            this.line.updateMatrix();
            this.cone.scale.set(headWidth, headLength, headWidth);
            this.cone.position.y = length;
            this.cone.updateMatrix();
        };
        _proto.setColor = function setColor(color) {
            this.line.material.color.set(color);
            this.cone.material.color.set(color);
        };
        _proto.copy = function copy(source) {
            _Object3D.prototype.copy.call(this, source, false);
            this.line.copy(source.line);
            this.cone.copy(source.cone);
            return this;
        };
        return ArrowHelper2;
    }(Object3D);
    var AxesHelper1 = /*#__PURE__*/ function(_LineSegments) {
        _inheritsLoose(AxesHelper2, _LineSegments);
        function AxesHelper2(size) {
            var _this;
            if (size === void 0) size = 1;
            var vertices = [
                0,
                0,
                0,
                size,
                0,
                0,
                0,
                0,
                0,
                0,
                size,
                0,
                0,
                0,
                0,
                0,
                0,
                size
            ];
            var colors = [
                1,
                0,
                0,
                1,
                0.6,
                0,
                0,
                1,
                0,
                0.6,
                1,
                0,
                0,
                0,
                1,
                0,
                0.6,
                1
            ];
            var geometry = new BufferGeometry();
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
            var material = new LineBasicMaterial({
                vertexColors: true,
                toneMapped: false
            });
            _this = _LineSegments.call(this, geometry, material) || this;
            _this.type = 'AxesHelper';
            return _this;
        }
        return AxesHelper2;
    }(LineSegments);
    var _floatView = new Float32Array(1);
    var _int32View = new Int32Array(_floatView.buffer);
    var DataUtils = {
        // Converts float32 to float16 (stored as uint16 value).
        toHalfFloat: function toHalfFloat(val) {
            // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410
            /* This method is faster than the OpenEXR implementation (very often
			* used, eg. in Ogre), with the additional benefit of rounding, inspired
			* by James Tursa?s half-precision code. */ _floatView[0] = val;
            var x = _int32View[0];
            var bits = x >> 16 & 32768;
            /* Get the sign */ var m = x >> 12 & 2047;
            /* Keep one extra bit for rounding */ var e = x >> 23 & 255;
            /* Using int is faster here */ /* If zero, or denormal, or exponent underflows too much for a denormal
				* half, return signed zero. */ if (e < 103) return bits;
            /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */ if (e > 142) {
                bits |= 31744;
                /* If exponent was 0xff and one mantissa bit was set, it means NaN,
							* not Inf, so make sure we set one mantissa bit too. */ bits |= (e == 255 ? 0 : 1) && x & 8388607;
                return bits;
            }
            /* If exponent underflows but not too much, return a denormal */ if (e < 113) {
                m |= 2048;
                /* Extra rounding may overflow and set mantissa to 0 and exponent
					* to 1, which is OK. */ bits |= (m >> 114 - e) + (m >> 113 - e & 1);
                return bits;
            }
            bits |= e - 112 << 10 | m >> 1;
            /* Extra rounding. An overflow will set mantissa to 0 and increment
				* the exponent, which is OK. */ bits += m & 1;
            return bits;
        }
    };
    var _ENCODINGS;
    var LOD_MIN = 4;
    var LOD_MAX = 8;
    var SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are
    // chosen to approximate a Trowbridge-Reitz distribution function times the
    // geometric shadowing function. These sigma values squared must match the
    // variance #defines in cube_uv_reflection_fragment.glsl.js.
    var EXTRA_LOD_SIGMA = [
        0.125,
        0.215,
        0.35,
        0.446,
        0.526,
        0.582
    ];
    var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer
    // samples and exit early, but not recompile the shader.
    var MAX_SAMPLES = 20;
    var ENCODINGS = (_ENCODINGS = {
    }, _ENCODINGS[LinearEncoding] = 0, _ENCODINGS[sRGBEncoding] = 1, _ENCODINGS[RGBEEncoding] = 2, _ENCODINGS[RGBM7Encoding] = 3, _ENCODINGS[RGBM16Encoding] = 4, _ENCODINGS[RGBDEncoding] = 5, _ENCODINGS[GammaEncoding] = 6, _ENCODINGS);
    var backgroundMaterial = new MeshBasicMaterial({
        side: BackSide,
        depthWrite: false,
        depthTest: false
    });
    var backgroundBox = new Mesh(new BoxGeometry1(), backgroundMaterial);
    var _flatCamera = /*@__PURE__*/ new OrthographicCamera();
    var _createPlanes2 = /*@__PURE__*/ _createPlanes(), _lodPlanes = _createPlanes2._lodPlanes, _sizeLods = _createPlanes2._sizeLods, _sigmas = _createPlanes2._sigmas;
    var _clearColor = /*@__PURE__*/ new Color();
    var _oldTarget = null; // Golden Ratio
    var PHI = (1 + Math.sqrt(5)) / 2;
    var INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
    // same axis), used as axis directions evenly spread on a sphere.
    var _axisDirections = [
        /*@__PURE__*/ new Vector3(1, 1, 1),
        /*@__PURE__*/ new Vector3(-1, 1, 1),
        /*@__PURE__*/ new Vector3(1, 1, -1),
        /*@__PURE__*/ new Vector3(-1, 1, -1),
        /*@__PURE__*/ new Vector3(0, PHI, INV_PHI),
        /*@__PURE__*/ new Vector3(0, PHI, -INV_PHI),
        /*@__PURE__*/ new Vector3(INV_PHI, 0, PHI),
        /*@__PURE__*/ new Vector3(-INV_PHI, 0, PHI),
        /*@__PURE__*/ new Vector3(PHI, INV_PHI, 0),
        /*@__PURE__*/ new Vector3(-PHI, INV_PHI, 0)
    ];
    /**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 */ function convertLinearToRGBE(color) {
        var maxComponent = Math.max(color.r, color.g, color.b);
        var fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
        color.multiplyScalar(Math.pow(2, -fExp));
        var alpha = (fExp + 128) / 255;
        return alpha;
    }
    var PMREMGenerator = /*#__PURE__*/ function() {
        function PMREMGenerator1(renderer) {
            this._renderer = renderer;
            this._pingPongRenderTarget = null;
            this._blurMaterial = _getBlurShader(MAX_SAMPLES);
            this._equirectShader = null;
            this._cubemapShader = null;
            this._compileMaterial(this._blurMaterial);
        }
        /**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */ var _proto = PMREMGenerator1.prototype;
        _proto.fromScene = function fromScene(scene, sigma, near, far) {
            if (sigma === void 0) sigma = 0;
            if (near === void 0) near = 0.1;
            if (far === void 0) far = 100;
            _oldTarget = this._renderer.getRenderTarget();
            var cubeUVRenderTarget = this._allocateTargets();
            this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
            if (sigma > 0) this._blur(cubeUVRenderTarget, 0, 0, sigma);
            this._applyPMREM(cubeUVRenderTarget);
            this._cleanup(cubeUVRenderTarget);
            return cubeUVRenderTarget;
        };
        _proto.fromEquirectangular = function fromEquirectangular(equirectangular) {
            return this._fromTexture(equirectangular);
        };
        _proto.fromCubemap = function fromCubemap(cubemap) {
            return this._fromTexture(cubemap);
        };
        _proto.compileCubemapShader = function compileCubemapShader() {
            if (this._cubemapShader === null) {
                this._cubemapShader = _getCubemapShader();
                this._compileMaterial(this._cubemapShader);
            }
        };
        _proto.compileEquirectangularShader = function compileEquirectangularShader() {
            if (this._equirectShader === null) {
                this._equirectShader = _getEquirectShader();
                this._compileMaterial(this._equirectShader);
            }
        };
        _proto.dispose = function dispose() {
            this._blurMaterial.dispose();
            if (this._cubemapShader !== null) this._cubemapShader.dispose();
            if (this._equirectShader !== null) this._equirectShader.dispose();
            for(var i64 = 0; i64 < _lodPlanes.length; i64++)_lodPlanes[i64].dispose();
        };
        _proto._cleanup = function _cleanup(outputTarget) {
            this._pingPongRenderTarget.dispose();
            this._renderer.setRenderTarget(_oldTarget);
            outputTarget.scissorTest = false;
            _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
        };
        _proto._fromTexture = function _fromTexture(texture) {
            _oldTarget = this._renderer.getRenderTarget();
            var cubeUVRenderTarget = this._allocateTargets(texture);
            this._textureToCubeUV(texture, cubeUVRenderTarget);
            this._applyPMREM(cubeUVRenderTarget);
            this._cleanup(cubeUVRenderTarget);
            return cubeUVRenderTarget;
        };
        _proto._allocateTargets = function _allocateTargets(texture) {
            // warning: null texture is valid
            var params = {
                magFilter: NearestFilter,
                minFilter: NearestFilter,
                generateMipmaps: false,
                type: UnsignedByteType,
                format: RGBEFormat,
                encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
                depthBuffer: false
            };
            var cubeUVRenderTarget = _createRenderTarget(params);
            cubeUVRenderTarget.depthBuffer = texture ? false : true;
            this._pingPongRenderTarget = _createRenderTarget(params);
            return cubeUVRenderTarget;
        };
        _proto._compileMaterial = function _compileMaterial(material) {
            var tmpMesh = new Mesh(_lodPlanes[0], material);
            this._renderer.compile(tmpMesh, _flatCamera);
        };
        _proto._sceneToCubeUV = function _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
            var fov1 = 90;
            var aspect1 = 1;
            var cubeCamera = new PerspectiveCamera(fov1, aspect1, near, far);
            var upSign = [
                1,
                -1,
                1,
                1,
                1,
                1
            ];
            var forwardSign = [
                1,
                1,
                1,
                -1,
                -1,
                -1
            ];
            var renderer = this._renderer;
            var originalAutoClear = renderer.autoClear;
            var outputEncoding = renderer.outputEncoding;
            var toneMapping = renderer.toneMapping;
            renderer.getClearColor(_clearColor);
            renderer.toneMapping = NoToneMapping;
            renderer.outputEncoding = LinearEncoding;
            renderer.autoClear = false;
            var useSolidColor = false;
            var background = scene.background;
            if (background) {
                if (background.isColor) {
                    backgroundMaterial.color.copy(background).convertSRGBToLinear();
                    scene.background = null;
                    var alpha = convertLinearToRGBE(backgroundMaterial.color);
                    backgroundMaterial.opacity = alpha;
                    useSolidColor = true;
                }
            } else {
                backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
                var _alpha = convertLinearToRGBE(backgroundMaterial.color);
                backgroundMaterial.opacity = _alpha;
                useSolidColor = true;
            }
            for(var i64 = 0; i64 < 6; i64++){
                var col = i64 % 3;
                if (col == 0) {
                    cubeCamera.up.set(0, upSign[i64], 0);
                    cubeCamera.lookAt(forwardSign[i64], 0, 0);
                } else if (col == 1) {
                    cubeCamera.up.set(0, 0, upSign[i64]);
                    cubeCamera.lookAt(0, forwardSign[i64], 0);
                } else {
                    cubeCamera.up.set(0, upSign[i64], 0);
                    cubeCamera.lookAt(0, 0, forwardSign[i64]);
                }
                _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i64 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
                renderer.setRenderTarget(cubeUVRenderTarget);
                if (useSolidColor) renderer.render(backgroundBox, cubeCamera);
                renderer.render(scene, cubeCamera);
            }
            renderer.toneMapping = toneMapping;
            renderer.outputEncoding = outputEncoding;
            renderer.autoClear = originalAutoClear;
        };
        _proto._textureToCubeUV = function _textureToCubeUV(texture, cubeUVRenderTarget) {
            var renderer = this._renderer;
            if (texture.isCubeTexture) {
                if (this._cubemapShader == null) this._cubemapShader = _getCubemapShader();
            } else if (this._equirectShader == null) this._equirectShader = _getEquirectShader();
            var material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
            var mesh = new Mesh(_lodPlanes[0], material);
            var uniforms = material.uniforms;
            uniforms['envMap'].value = texture;
            if (!texture.isCubeTexture) uniforms['texelSize'].value.set(1 / texture.image.width, 1 / texture.image.height);
            uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
            uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];
            _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
            renderer.setRenderTarget(cubeUVRenderTarget);
            renderer.render(mesh, _flatCamera);
        };
        _proto._applyPMREM = function _applyPMREM(cubeUVRenderTarget) {
            var renderer = this._renderer;
            var autoClear = renderer.autoClear;
            renderer.autoClear = false;
            for(var i64 = 1; i64 < TOTAL_LODS; i64++){
                var sigma = Math.sqrt(_sigmas[i64] * _sigmas[i64] - _sigmas[i64 - 1] * _sigmas[i64 - 1]);
                var poleAxis = _axisDirections[(i64 - 1) % _axisDirections.length];
                this._blur(cubeUVRenderTarget, i64 - 1, i64, sigma, poleAxis);
            }
            renderer.autoClear = autoClear;
        };
        _proto._blur = function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
            var pingPongRenderTarget = this._pingPongRenderTarget;
            this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
            this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
        };
        _proto._halfBlur = function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
            var renderer = this._renderer;
            var blurMaterial = this._blurMaterial;
            if (direction !== 'latitudinal' && direction !== 'longitudinal') console.error('blur direction must be either latitudinal or longitudinal!');
             // Number of standard deviations at which to cut off the discrete approximation.
            var STANDARD_DEVIATIONS = 3;
            var blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
            var blurUniforms = blurMaterial.uniforms;
            var pixels = _sizeLods[lodIn] - 1;
            var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
            var sigmaPixels = sigmaRadians / radiansPerPixel;
            var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
            if (samples > MAX_SAMPLES) console.warn("sigmaRadians, " + sigmaRadians + ", is too large and will clip, as it requested " + samples + " samples when the maximum is set to " + MAX_SAMPLES);
            var weights = [];
            var sum = 0;
            for(var i64 = 0; i64 < MAX_SAMPLES; ++i64){
                var _x2 = i64 / sigmaPixels;
                var weight = Math.exp(-_x2 * _x2 / 2);
                weights.push(weight);
                if (i64 == 0) sum += weight;
                else if (i64 < samples) sum += 2 * weight;
            }
            for(var _i = 0; _i < weights.length; _i++)weights[_i] = weights[_i] / sum;
            blurUniforms['envMap'].value = targetIn.texture;
            blurUniforms['samples'].value = samples;
            blurUniforms['weights'].value = weights;
            blurUniforms['latitudinal'].value = direction === 'latitudinal';
            if (poleAxis) blurUniforms['poleAxis'].value = poleAxis;
            blurUniforms['dTheta'].value = radiansPerPixel;
            blurUniforms['mipInt'].value = LOD_MAX - lodIn;
            blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
            blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
            var outputSize = _sizeLods[lodOut];
            var x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
            var y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
            _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
            renderer.setRenderTarget(targetOut);
            renderer.render(blurMesh, _flatCamera);
        };
        return PMREMGenerator1;
    }();
    function _isLDR(texture) {
        if (texture === undefined || texture.type !== UnsignedByteType) return false;
        return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
    }
    function _createPlanes() {
        var _lodPlanes1 = [];
        var _sizeLods1 = [];
        var _sigmas1 = [];
        var lod = LOD_MAX;
        for(var i64 = 0; i64 < TOTAL_LODS; i64++){
            var sizeLod = Math.pow(2, lod);
            _sizeLods1.push(sizeLod);
            var sigma = 1 / sizeLod;
            if (i64 > LOD_MAX - LOD_MIN) sigma = EXTRA_LOD_SIGMA[i64 - LOD_MAX + LOD_MIN - 1];
            else if (i64 == 0) sigma = 0;
            _sigmas1.push(sigma);
            var texelSize = 1 / (sizeLod - 1);
            var min = -texelSize / 2;
            var max = 1 + texelSize / 2;
            var uv1 = [
                min,
                min,
                max,
                min,
                max,
                max,
                min,
                min,
                max,
                max,
                min,
                max
            ];
            var cubeFaces = 6;
            var vertices = 6;
            var positionSize = 3;
            var uvSize = 2;
            var faceIndexSize = 1;
            var position = new Float32Array(positionSize * vertices * cubeFaces);
            var uv = new Float32Array(uvSize * vertices * cubeFaces);
            var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
            for(var face = 0; face < cubeFaces; face++){
                var x = face % 3 * 2 / 3 - 1;
                var y = face > 2 ? 0 : -1;
                var coordinates = [
                    x,
                    y,
                    0,
                    x + 2 / 3,
                    y,
                    0,
                    x + 2 / 3,
                    y + 1,
                    0,
                    x,
                    y,
                    0,
                    x + 2 / 3,
                    y + 1,
                    0,
                    x,
                    y + 1,
                    0
                ];
                position.set(coordinates, positionSize * vertices * face);
                uv.set(uv1, uvSize * vertices * face);
                var fill = [
                    face,
                    face,
                    face,
                    face,
                    face,
                    face
                ];
                faceIndex.set(fill, faceIndexSize * vertices * face);
            }
            var planes = new BufferGeometry();
            planes.setAttribute('position', new BufferAttribute(position, positionSize));
            planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
            planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
            _lodPlanes1.push(planes);
            if (lod > LOD_MIN) lod--;
        }
        return {
            _lodPlanes: _lodPlanes1,
            _sizeLods: _sizeLods1,
            _sigmas: _sigmas1
        };
    }
    function _createRenderTarget(params) {
        var cubeUVRenderTarget = new WebGLRenderTarget1(3 * SIZE_MAX, 3 * SIZE_MAX, params);
        cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
        cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
        cubeUVRenderTarget.scissorTest = true;
        return cubeUVRenderTarget;
    }
    function _setViewport(target, x, y, width, height) {
        target.viewport.set(x, y, width, height);
        target.scissor.set(x, y, width, height);
    }
    function _getBlurShader(maxSamples) {
        var weights = new Float32Array(maxSamples);
        var poleAxis = new Vector3(0, 1, 0);
        var shaderMaterial = new RawShaderMaterial({
            name: 'SphericalGaussianBlur',
            defines: {
                'n': maxSamples
            },
            uniforms: {
                'envMap': {
                    value: null
                },
                'samples': {
                    value: 1
                },
                'weights': {
                    value: weights
                },
                'latitudinal': {
                    value: false
                },
                'dTheta': {
                    value: 0
                },
                'mipInt': {
                    value: 0
                },
                'poleAxis': {
                    value: poleAxis
                },
                'inputEncoding': {
                    value: ENCODINGS[LinearEncoding]
                },
                'outputEncoding': {
                    value: ENCODINGS[LinearEncoding]
                }
            },
            vertexShader: _getCommonVertexShader(),
            fragmentShader: /* glsl */ "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t" + _getEncodings() + "\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
        return shaderMaterial;
    }
    function _getEquirectShader() {
        var texelSize = new Vector2(1, 1);
        var shaderMaterial = new RawShaderMaterial({
            name: 'EquirectangularToCubeUV',
            uniforms: {
                'envMap': {
                    value: null
                },
                'texelSize': {
                    value: texelSize
                },
                'inputEncoding': {
                    value: ENCODINGS[LinearEncoding]
                },
                'outputEncoding': {
                    value: ENCODINGS[LinearEncoding]
                }
            },
            vertexShader: _getCommonVertexShader(),
            fragmentShader: /* glsl */ "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t" + _getEncodings() + "\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
        return shaderMaterial;
    }
    function _getCubemapShader() {
        var shaderMaterial = new RawShaderMaterial({
            name: 'CubemapToCubeUV',
            uniforms: {
                'envMap': {
                    value: null
                },
                'inputEncoding': {
                    value: ENCODINGS[LinearEncoding]
                },
                'outputEncoding': {
                    value: ENCODINGS[LinearEncoding]
                }
            },
            vertexShader: _getCommonVertexShader(),
            fragmentShader: /* glsl */ "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t" + _getEncodings() + "\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
        });
        return shaderMaterial;
    }
    function _getCommonVertexShader() {
        return(/* glsl */ "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t");
    }
    function _getEncodings() {
        return(/* glsl */ "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t");
    }
    function Face4(a, b, c, d, normal, color, materialIndex) {
        console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
        return new Face3(a, b, c, normal, color, materialIndex);
    }
    var LineStrip = 0;
    var LinePieces = 1;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    function MeshFaceMaterial(materials) {
        console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
        return materials;
    }
    function MultiMaterial(materials) {
        if (materials === void 0) materials = [];
        console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
        materials.isMultiMaterial = true;
        materials.materials = materials;
        materials.clone = function() {
            return materials.slice();
        };
        return materials;
    }
    function PointCloud(geometry, material) {
        console.warn('THREE.PointCloud has been renamed to THREE.Points.');
        return new Points(geometry, material);
    }
    function Particle(material) {
        console.warn('THREE.Particle has been renamed to THREE.Sprite.');
        return new Sprite(material);
    }
    function ParticleSystem(geometry, material) {
        console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
        return new Points(geometry, material);
    }
    function PointCloudMaterial(parameters) {
        console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }
    function ParticleBasicMaterial(parameters) {
        console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }
    function ParticleSystemMaterial(parameters) {
        console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }
    function Vertex(x, y, z) {
        console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
        return new Vector3(x, y, z);
    } //
    function DynamicBufferAttribute(array, itemSize) {
        console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
        return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
    }
    function Int8Attribute(array, itemSize) {
        console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
        return new Int8BufferAttribute(array, itemSize);
    }
    function Uint8Attribute(array, itemSize) {
        console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
        return new Uint8BufferAttribute(array, itemSize);
    }
    function Uint8ClampedAttribute(array, itemSize) {
        console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
        return new Uint8ClampedBufferAttribute(array, itemSize);
    }
    function Int16Attribute(array, itemSize) {
        console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
        return new Int16BufferAttribute(array, itemSize);
    }
    function Uint16Attribute(array, itemSize) {
        console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
        return new Uint16BufferAttribute(array, itemSize);
    }
    function Int32Attribute(array, itemSize) {
        console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
        return new Int32BufferAttribute(array, itemSize);
    }
    function Uint32Attribute(array, itemSize) {
        console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
        return new Uint32BufferAttribute(array, itemSize);
    }
    function Float32Attribute(array, itemSize) {
        console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
        return new Float32BufferAttribute(array, itemSize);
    }
    function Float64Attribute(array, itemSize) {
        console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
        return new Float64BufferAttribute(array, itemSize);
    } //
    Curve.create = function(construct, getPoint) {
        console.log('THREE.Curve.create() has been deprecated');
        construct.prototype = Object.create(Curve.prototype);
        construct.prototype.constructor = construct;
        construct.prototype.getPoint = getPoint;
        return construct;
    }; //
    Object.assign(Path.prototype, {
        fromPoints: function fromPoints(points) {
            console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
            return this.setFromPoints(points);
        }
    }); //
    function ClosedSplineCurve3(points) {
        console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
        this.closed = true;
    }
    ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //
    function SplineCurve3(points) {
        console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
    }
    SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //
    function Spline(points) {
        console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
    }
    Spline.prototype = Object.create(CatmullRomCurve3.prototype);
    Object.assign(Spline.prototype, {
        initFromArray: function initFromArray() /* a */ {
            console.error('THREE.Spline: .initFromArray() has been removed.');
        },
        getControlPointsArray: function getControlPointsArray() /* optionalTarget */ {
            console.error('THREE.Spline: .getControlPointsArray() has been removed.');
        },
        reparametrizeByArcLength: function reparametrizeByArcLength() /* samplingCoef */ {
            console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
        }
    }); //
    function AxisHelper(size) {
        console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
        return new AxesHelper1(size);
    }
    function BoundingBoxHelper(object, color) {
        console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
        return new BoxHelper1(object, color);
    }
    function EdgesHelper(object, hex) {
        console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
        return new LineSegments(new EdgesGeometry1(object.geometry), new LineBasicMaterial({
            color: hex !== undefined ? hex : 16777215
        }));
    }
    GridHelper1.prototype.setColors = function() {
        console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
    };
    SkeletonHelper1.prototype.update = function() {
        console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
    };
    function WireframeHelper(object, hex) {
        console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
        return new LineSegments(new WireframeGeometry1(object.geometry), new LineBasicMaterial({
            color: hex !== undefined ? hex : 16777215
        }));
    } //
    Object.assign(Loader.prototype, {
        extractUrlBase: function extractUrlBase(url) {
            console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
            return LoaderUtils.extractUrlBase(url);
        }
    });
    Loader.Handlers = {
        add: function add() /* regex, loader */ {
            console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
        },
        get: function get() /* file */ {
            console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
        }
    };
    function XHRLoader(manager) {
        console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
        return new FileLoader(manager);
    }
    function BinaryTextureLoader(manager) {
        console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
        return new DataTextureLoader(manager);
    } //
    Object.assign(Box2.prototype, {
        center: function center3(optionalTarget) {
            console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
            return this.getCenter(optionalTarget);
        },
        empty: function empty() {
            console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        },
        isIntersectionBox: function isIntersectionBox(box) {
            console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        size: function size(optionalTarget) {
            console.warn('THREE.Box2: .size() has been renamed to .getSize().');
            return this.getSize(optionalTarget);
        }
    });
    Object.assign(Box3.prototype, {
        center: function center3(optionalTarget) {
            console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
            return this.getCenter(optionalTarget);
        },
        empty: function empty() {
            console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        },
        isIntersectionBox: function isIntersectionBox(box) {
            console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        isIntersectionSphere: function isIntersectionSphere(sphere) {
            console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(sphere);
        },
        size: function size(optionalTarget) {
            console.warn('THREE.Box3: .size() has been renamed to .getSize().');
            return this.getSize(optionalTarget);
        }
    });
    Object.assign(Sphere.prototype, {
        empty: function empty() {
            console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        }
    });
    Frustum.prototype.setFromMatrix = function(m) {
        console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
        return this.setFromProjectionMatrix(m);
    };
    Line3.prototype.center = function(optionalTarget) {
        console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
        return this.getCenter(optionalTarget);
    };
    Object.assign(MathUtils, {
        random16: function random16() {
            console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
            return Math.random();
        },
        nearestPowerOfTwo: function nearestPowerOfTwo(value) {
            console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
            return MathUtils.floorPowerOfTwo(value);
        },
        nextPowerOfTwo: function nextPowerOfTwo(value) {
            console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
            return MathUtils.ceilPowerOfTwo(value);
        }
    });
    Object.assign(Matrix3.prototype, {
        flattenToArrayOffset: function flattenToArrayOffset(array, offset) {
            console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
            return this.toArray(array, offset);
        },
        multiplyVector3: function multiplyVector3(vector) {
            console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
            return vector.applyMatrix3(this);
        },
        multiplyVector3Array: function multiplyVector3Array() /* a */ {
            console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
        },
        applyToBufferAttribute: function applyToBufferAttribute(attribute) {
            console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
            return attribute.applyMatrix3(this);
        },
        applyToVector3Array: function applyToVector3Array() /* array, offset, length */ {
            console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
        },
        getInverse: function getInverse(matrix) {
            console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
            return this.copy(matrix).invert();
        }
    });
    Object.assign(Matrix4.prototype, {
        extractPosition: function extractPosition(m) {
            console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
            return this.copyPosition(m);
        },
        flattenToArrayOffset: function flattenToArrayOffset(array, offset) {
            console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
            return this.toArray(array, offset);
        },
        getPosition: function getPosition() {
            console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
            return new Vector3().setFromMatrixColumn(this, 3);
        },
        setRotationFromQuaternion: function setRotationFromQuaternion(q) {
            console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
            return this.makeRotationFromQuaternion(q);
        },
        multiplyToArray: function multiplyToArray() {
            console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
        },
        multiplyVector3: function multiplyVector3(vector) {
            console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        multiplyVector4: function multiplyVector4(vector) {
            console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        multiplyVector3Array: function multiplyVector3Array() /* a */ {
            console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
        },
        rotateAxis: function rotateAxis(v) {
            console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
            v.transformDirection(this);
        },
        crossVector: function crossVector(vector) {
            console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        translate: function translate() {
            console.error('THREE.Matrix4: .translate() has been removed.');
        },
        rotateX: function rotateX() {
            console.error('THREE.Matrix4: .rotateX() has been removed.');
        },
        rotateY: function rotateY() {
            console.error('THREE.Matrix4: .rotateY() has been removed.');
        },
        rotateZ: function rotateZ() {
            console.error('THREE.Matrix4: .rotateZ() has been removed.');
        },
        rotateByAxis: function rotateByAxis() {
            console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
        },
        applyToBufferAttribute: function applyToBufferAttribute(attribute) {
            console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
            return attribute.applyMatrix4(this);
        },
        applyToVector3Array: function applyToVector3Array() /* array, offset, length */ {
            console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
        },
        makeFrustum: function makeFrustum(left, right, bottom, top, near, far) {
            console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
            return this.makePerspective(left, right, top, bottom, near, far);
        },
        getInverse: function getInverse(matrix) {
            console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
            return this.copy(matrix).invert();
        }
    });
    Plane.prototype.isIntersectionLine = function(line) {
        console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
        return this.intersectsLine(line);
    };
    Object.assign(Quaternion.prototype, {
        multiplyVector3: function multiplyVector3(vector) {
            console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
            return vector.applyQuaternion(this);
        },
        inverse: function inverse() {
            console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
            return this.invert();
        }
    });
    Object.assign(Ray.prototype, {
        isIntersectionBox: function isIntersectionBox(box) {
            console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        isIntersectionPlane: function isIntersectionPlane(plane) {
            console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
            return this.intersectsPlane(plane);
        },
        isIntersectionSphere: function isIntersectionSphere(sphere) {
            console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(sphere);
        }
    });
    Object.assign(Triangle.prototype, {
        area: function area1() {
            console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
            return this.getArea();
        },
        barycoordFromPoint: function barycoordFromPoint(point, target) {
            console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
            return this.getBarycoord(point, target);
        },
        midpoint: function midpoint(target) {
            console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
            return this.getMidpoint(target);
        },
        normal: function normal(target) {
            console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
            return this.getNormal(target);
        },
        plane: function plane(target) {
            console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
            return this.getPlane(target);
        }
    });
    Object.assign(Triangle, {
        barycoordFromPoint: function barycoordFromPoint(point, a, b, c, target) {
            console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
            return Triangle.getBarycoord(point, a, b, c, target);
        },
        normal: function normal(a, b, c, target) {
            console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
            return Triangle.getNormal(a, b, c, target);
        }
    });
    Object.assign(Shape.prototype, {
        extractAllPoints: function extractAllPoints(divisions) {
            console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
            return this.extractPoints(divisions);
        },
        extrude: function extrude(options) {
            console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
            return new ExtrudeGeometry1(this, options);
        },
        makeGeometry: function makeGeometry(options) {
            console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
            return new ShapeGeometry1(this, options);
        }
    });
    Object.assign(Vector2.prototype, {
        fromAttribute: function fromAttribute(attribute, index, offset) {
            console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        },
        distanceToManhattan: function distanceToManhattan(v) {
            console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
            return this.manhattanDistanceTo(v);
        },
        lengthManhattan: function lengthManhattan() {
            console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
            return this.manhattanLength();
        }
    });
    Object.assign(Vector3.prototype, {
        setEulerFromRotationMatrix: function setEulerFromRotationMatrix() {
            console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
        },
        setEulerFromQuaternion: function setEulerFromQuaternion() {
            console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
        },
        getPositionFromMatrix: function getPositionFromMatrix(m) {
            console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
            return this.setFromMatrixPosition(m);
        },
        getScaleFromMatrix: function getScaleFromMatrix(m) {
            console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
            return this.setFromMatrixScale(m);
        },
        getColumnFromMatrix: function getColumnFromMatrix(index, matrix) {
            console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
            return this.setFromMatrixColumn(matrix, index);
        },
        applyProjection: function applyProjection(m) {
            console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
            return this.applyMatrix4(m);
        },
        fromAttribute: function fromAttribute(attribute, index, offset) {
            console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        },
        distanceToManhattan: function distanceToManhattan(v) {
            console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
            return this.manhattanDistanceTo(v);
        },
        lengthManhattan: function lengthManhattan() {
            console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
            return this.manhattanLength();
        }
    });
    Object.assign(Vector4.prototype, {
        fromAttribute: function fromAttribute(attribute, index, offset) {
            console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        },
        lengthManhattan: function lengthManhattan() {
            console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
            return this.manhattanLength();
        }
    }); //
    Object.assign(Object3D.prototype, {
        getChildByName: function getChildByName(name) {
            console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
            return this.getObjectByName(name);
        },
        renderDepth: function renderDepth() {
            console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
        },
        translate: function translate(distance, axis) {
            console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
            return this.translateOnAxis(axis, distance);
        },
        getWorldRotation: function getWorldRotation() {
            console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
        },
        applyMatrix: function applyMatrix(matrix) {
            console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
            return this.applyMatrix4(matrix);
        }
    });
    Object.defineProperties(Object3D.prototype, {
        eulerOrder: {
            get: function get() {
                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                return this.rotation.order;
            },
            set: function set(value) {
                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                this.rotation.order = value;
            }
        },
        useQuaternion: {
            get: function get() {
                console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
            },
            set: function set() {
                console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
            }
        }
    });
    Object.assign(Mesh.prototype, {
        setDrawMode: function setDrawMode() {
            console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
        }
    });
    Object.defineProperties(Mesh.prototype, {
        drawMode: {
            get: function get() {
                console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
                return TrianglesDrawMode;
            },
            set: function set() {
                console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
            }
        }
    });
    Object.defineProperties(LOD.prototype, {
        objects: {
            get: function get() {
                console.warn('THREE.LOD: .objects has been renamed to .levels.');
                return this.levels;
            }
        }
    });
    Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
        get: function get() {
            console.warn('THREE.Skeleton: useVertexTexture has been removed.');
        },
        set: function set() {
            console.warn('THREE.Skeleton: useVertexTexture has been removed.');
        }
    });
    SkinnedMesh.prototype.initBones = function() {
        console.error('THREE.SkinnedMesh: initBones() has been removed.');
    };
    Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
        get: function get() {
            console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
            return this.arcLengthDivisions;
        },
        set: function set(value) {
            console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
            this.arcLengthDivisions = value;
        }
    }); //
    PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
        if (filmGauge !== undefined) this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
    }; //
    Object.defineProperties(Light.prototype, {
        onlyShadow: {
            set: function set() {
                console.warn('THREE.Light: .onlyShadow has been removed.');
            }
        },
        shadowCameraFov: {
            set: function set(value) {
                console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
                this.shadow.camera.fov = value;
            }
        },
        shadowCameraLeft: {
            set: function set(value) {
                console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
                this.shadow.camera.left = value;
            }
        },
        shadowCameraRight: {
            set: function set(value) {
                console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
                this.shadow.camera.right = value;
            }
        },
        shadowCameraTop: {
            set: function set(value) {
                console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
                this.shadow.camera.top = value;
            }
        },
        shadowCameraBottom: {
            set: function set(value) {
                console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
                this.shadow.camera.bottom = value;
            }
        },
        shadowCameraNear: {
            set: function set(value) {
                console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
                this.shadow.camera.near = value;
            }
        },
        shadowCameraFar: {
            set: function set(value) {
                console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
                this.shadow.camera.far = value;
            }
        },
        shadowCameraVisible: {
            set: function set() {
                console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
            }
        },
        shadowBias: {
            set: function set(value) {
                console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
                this.shadow.bias = value;
            }
        },
        shadowDarkness: {
            set: function set() {
                console.warn('THREE.Light: .shadowDarkness has been removed.');
            }
        },
        shadowMapWidth: {
            set: function set(value) {
                console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
                this.shadow.mapSize.width = value;
            }
        },
        shadowMapHeight: {
            set: function set(value) {
                console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
                this.shadow.mapSize.height = value;
            }
        }
    }); //
    Object.defineProperties(BufferAttribute.prototype, {
        length: {
            get: function get() {
                console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
                return this.array.length;
            }
        },
        dynamic: {
            get: function get() {
                console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
                return this.usage === DynamicDrawUsage;
            },
            set: function set() /* value */ {
                console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
                this.setUsage(DynamicDrawUsage);
            }
        }
    });
    Object.assign(BufferAttribute.prototype, {
        setDynamic: function setDynamic(value) {
            console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
            this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
            return this;
        },
        copyIndicesArray: function copyIndicesArray() /* indices */ {
            console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
        },
        setArray: function setArray() /* array */ {
            console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
        }
    });
    Object.assign(BufferGeometry.prototype, {
        addIndex: function addIndex(index) {
            console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
            this.setIndex(index);
        },
        addAttribute: function addAttribute(name, attribute) {
            console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');
            if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
                console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
                return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
            }
            if (name === 'index') {
                console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
                this.setIndex(attribute);
                return this;
            }
            return this.setAttribute(name, attribute);
        },
        addDrawCall: function addDrawCall(start, count, indexOffset) {
            if (indexOffset !== undefined) console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
            console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
            this.addGroup(start, count);
        },
        clearDrawCalls: function clearDrawCalls() {
            console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
            this.clearGroups();
        },
        computeOffsets: function computeOffsets() {
            console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
        },
        removeAttribute: function removeAttribute(name) {
            console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
            return this.deleteAttribute(name);
        },
        applyMatrix: function applyMatrix(matrix) {
            console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
            return this.applyMatrix4(matrix);
        }
    });
    Object.defineProperties(BufferGeometry.prototype, {
        drawcalls: {
            get: function get() {
                console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
                return this.groups;
            }
        },
        offsets: {
            get: function get() {
                console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
                return this.groups;
            }
        }
    });
    Object.defineProperties(InstancedBufferGeometry.prototype, {
        maxInstancedCount: {
            get: function get() {
                console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
                return this.instanceCount;
            },
            set: function set(value) {
                console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
                this.instanceCount = value;
            }
        }
    });
    Object.defineProperties(Raycaster.prototype, {
        linePrecision: {
            get: function get() {
                console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
                return this.params.Line.threshold;
            },
            set: function set(value) {
                console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
                this.params.Line.threshold = value;
            }
        }
    });
    Object.defineProperties(InterleavedBuffer.prototype, {
        dynamic: {
            get: function get() {
                console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
                return this.usage === DynamicDrawUsage;
            },
            set: function set(value) {
                console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
                this.setUsage(value);
            }
        }
    });
    Object.assign(InterleavedBuffer.prototype, {
        setDynamic: function setDynamic(value) {
            console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
            this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
            return this;
        },
        setArray: function setArray() /* array */ {
            console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
        }
    }); //
    Object.assign(ExtrudeGeometry1.prototype, {
        getArrays: function getArrays() {
            console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
        },
        addShapeList: function addShapeList() {
            console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
        },
        addShape: function addShape() {
            console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
        }
    }); //
    Object.assign(Scene1.prototype, {
        dispose: function dispose() {
            console.error('THREE.Scene: .dispose() has been removed.');
        }
    }); //
    Object.defineProperties(Uniform.prototype, {
        dynamic: {
            set: function set() {
                console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
            }
        },
        onUpdate: {
            value: function value() {
                console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
                return this;
            }
        }
    }); //
    Object.defineProperties(Material.prototype, {
        wrapAround: {
            get: function get() {
                console.warn('THREE.Material: .wrapAround has been removed.');
            },
            set: function set() {
                console.warn('THREE.Material: .wrapAround has been removed.');
            }
        },
        overdraw: {
            get: function get() {
                console.warn('THREE.Material: .overdraw has been removed.');
            },
            set: function set() {
                console.warn('THREE.Material: .overdraw has been removed.');
            }
        },
        wrapRGB: {
            get: function get() {
                console.warn('THREE.Material: .wrapRGB has been removed.');
                return new Color();
            }
        },
        shading: {
            get: function get() {
                console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
            },
            set: function set(value) {
                console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                this.flatShading = value === FlatShading;
            }
        },
        stencilMask: {
            get: function get() {
                console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
                return this.stencilFuncMask;
            },
            set: function set(value) {
                console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
                this.stencilFuncMask = value;
            }
        }
    });
    Object.defineProperties(MeshPhongMaterial.prototype, {
        metal: {
            get: function get() {
                console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
                return false;
            },
            set: function set() {
                console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
            }
        }
    });
    Object.defineProperties(MeshPhysicalMaterial.prototype, {
        transparency: {
            get: function get() {
                console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.');
                return this.transmission;
            },
            set: function set(value) {
                console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.');
                this.transmission = value;
            }
        }
    });
    Object.defineProperties(ShaderMaterial.prototype, {
        derivatives: {
            get: function get() {
                console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                return this.extensions.derivatives;
            },
            set: function set(value) {
                console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                this.extensions.derivatives = value;
            }
        }
    }); //
    Object.assign(WebGLRenderer.prototype, {
        clearTarget: function clearTarget(renderTarget, color, depth, stencil) {
            console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
            this.setRenderTarget(renderTarget);
            this.clear(color, depth, stencil);
        },
        animate: function animate(callback) {
            console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
            this.setAnimationLoop(callback);
        },
        getCurrentRenderTarget: function getCurrentRenderTarget() {
            console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
            return this.getRenderTarget();
        },
        getMaxAnisotropy: function getMaxAnisotropy() {
            console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
            return this.capabilities.getMaxAnisotropy();
        },
        getPrecision: function getPrecision() {
            console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
            return this.capabilities.precision;
        },
        resetGLState: function resetGLState() {
            console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
            return this.state.reset();
        },
        supportsFloatTextures: function supportsFloatTextures() {
            console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
            return this.extensions.get('OES_texture_float');
        },
        supportsHalfFloatTextures: function supportsHalfFloatTextures() {
            console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
            return this.extensions.get('OES_texture_half_float');
        },
        supportsStandardDerivatives: function supportsStandardDerivatives() {
            console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
            return this.extensions.get('OES_standard_derivatives');
        },
        supportsCompressedTextureS3TC: function supportsCompressedTextureS3TC() {
            console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_s3tc');
        },
        supportsCompressedTexturePVRTC: function supportsCompressedTexturePVRTC() {
            console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_pvrtc');
        },
        supportsBlendMinMax: function supportsBlendMinMax() {
            console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
            return this.extensions.get('EXT_blend_minmax');
        },
        supportsVertexTextures: function supportsVertexTextures() {
            console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
            return this.capabilities.vertexTextures;
        },
        supportsInstancedArrays: function supportsInstancedArrays() {
            console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
            return this.extensions.get('ANGLE_instanced_arrays');
        },
        enableScissorTest: function enableScissorTest(boolean) {
            console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
            this.setScissorTest(boolean);
        },
        initMaterial: function initMaterial() {
            console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
        },
        addPrePlugin: function addPrePlugin() {
            console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
        },
        addPostPlugin: function addPostPlugin() {
            console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
        },
        updateShadowMap: function updateShadowMap() {
            console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
        },
        setFaceCulling: function setFaceCulling() {
            console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
        },
        allocTextureUnit: function allocTextureUnit() {
            console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
        },
        setTexture: function setTexture() {
            console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
        },
        setTexture2D: function setTexture2D() {
            console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
        },
        setTextureCube: function setTextureCube() {
            console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
        },
        getActiveMipMapLevel: function getActiveMipMapLevel() {
            console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
            return this.getActiveMipmapLevel();
        }
    });
    Object.defineProperties(WebGLRenderer.prototype, {
        shadowMapEnabled: {
            get: function get() {
                return this.shadowMap.enabled;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
                this.shadowMap.enabled = value;
            }
        },
        shadowMapType: {
            get: function get() {
                return this.shadowMap.type;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
                this.shadowMap.type = value;
            }
        },
        shadowMapCullFace: {
            get: function get() {
                console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
                return undefined;
            },
            set: function set() /* value */ {
                console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
            }
        },
        context: {
            get: function get() {
                console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
                return this.getContext();
            }
        },
        vr: {
            get: function get() {
                console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
                return this.xr;
            }
        },
        gammaInput: {
            get: function get() {
                console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
                return false;
            },
            set: function set() {
                console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
            }
        },
        gammaOutput: {
            get: function get() {
                console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
                return false;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
                this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
            }
        },
        toneMappingWhitePoint: {
            get: function get() {
                console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
                return 1;
            },
            set: function set() {
                console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
            }
        }
    });
    Object.defineProperties(WebGLShadowMap.prototype, {
        cullFace: {
            get: function get() {
                console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
                return undefined;
            },
            set: function set() /* cullFace */ {
                console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
            }
        },
        renderReverseSided: {
            get: function get() {
                console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
                return undefined;
            },
            set: function set() {
                console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
            }
        },
        renderSingleSided: {
            get: function get() {
                console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
                return undefined;
            },
            set: function set() {
                console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
            }
        }
    });
    function WebGLRenderTargetCube(width, height, options) {
        console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
        return new WebGLCubeRenderTarget1(width, options);
    } //
    Object.defineProperties(WebGLRenderTarget1.prototype, {
        wrapS: {
            get: function get() {
                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                return this.texture.wrapS;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                this.texture.wrapS = value;
            }
        },
        wrapT: {
            get: function get() {
                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                return this.texture.wrapT;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                this.texture.wrapT = value;
            }
        },
        magFilter: {
            get: function get() {
                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                return this.texture.magFilter;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                this.texture.magFilter = value;
            }
        },
        minFilter: {
            get: function get() {
                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                return this.texture.minFilter;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                this.texture.minFilter = value;
            }
        },
        anisotropy: {
            get: function get() {
                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                return this.texture.anisotropy;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                this.texture.anisotropy = value;
            }
        },
        offset: {
            get: function get() {
                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                return this.texture.offset;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                this.texture.offset = value;
            }
        },
        repeat: {
            get: function get() {
                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                return this.texture.repeat;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                this.texture.repeat = value;
            }
        },
        format: {
            get: function get() {
                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                return this.texture.format;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                this.texture.format = value;
            }
        },
        type: {
            get: function get() {
                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                return this.texture.type;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                this.texture.type = value;
            }
        },
        generateMipmaps: {
            get: function get() {
                console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                return this.texture.generateMipmaps;
            },
            set: function set(value) {
                console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                this.texture.generateMipmaps = value;
            }
        }
    }); //
    Object.defineProperties(Audio1.prototype, {
        load: {
            value: function value(file) {
                console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
                var scope = this;
                var audioLoader = new AudioLoader();
                audioLoader.load(file, function(buffer) {
                    scope.setBuffer(buffer);
                });
                return this;
            }
        },
        startTime: {
            set: function set() {
                console.warn('THREE.Audio: .startTime is now .play( delay ).');
            }
        }
    });
    AudioAnalyser.prototype.getData = function() {
        console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
        return this.getFrequencyData();
    }; //
    CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
        console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
        return this.update(renderer, scene);
    };
    CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
        console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
        return this.renderTarget.clear(renderer, color, depth, stencil);
    }; //
    var GeometryUtils = {
        merge: function merge(geometry1, geometry2, materialIndexOffset) {
            console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
            var matrix;
            if (geometry2.isMesh) {
                geometry2.matrixAutoUpdate && geometry2.updateMatrix();
                matrix = geometry2.matrix;
                geometry2 = geometry2.geometry;
            }
            geometry1.merge(geometry2, matrix, materialIndexOffset);
        },
        center: function center3(geometry) {
            console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
            return geometry.center();
        }
    };
    ImageUtils.crossOrigin = undefined;
    ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
        console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
        var loader = new TextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        var texture = loader.load(url, onLoad, undefined, onError);
        if (mapping) texture.mapping = mapping;
        return texture;
    };
    ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
        console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
        var loader = new CubeTextureLoader();
        loader.setCrossOrigin(this.crossOrigin);
        var texture = loader.load(urls, onLoad, undefined, onError);
        if (mapping) texture.mapping = mapping;
        return texture;
    };
    ImageUtils.loadCompressedTexture = function() {
        console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
    };
    ImageUtils.loadCompressedTextureCube = function() {
        console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
    }; //
    function CanvasRenderer() {
        console.error('THREE.CanvasRenderer has been removed');
    } //
    function JSONLoader() {
        console.error('THREE.JSONLoader has been removed.');
    } //
    var SceneUtils = {
        createMultiMaterialObject: function createMultiMaterialObject() /* geometry, materials */ {
            console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
        },
        detach: function detach() /* child, parent, scene */ {
            console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
        },
        attach: function attach() /* child, scene, parent */ {
            console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
        }
    }; //
    function LensFlare() {
        console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
    }
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') /* eslint-disable no-undef */ __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
        detail: {
            revision: REVISION
        }
    }));
    if (typeof window !== 'undefined') {
        if (window.__THREE__) console.warn('WARNING: Multiple instances of Three.js being imported.');
        else window.__THREE__ = REVISION;
    }
    exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
    exports.AddEquation = AddEquation;
    exports.AddOperation = AddOperation;
    exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
    exports.AdditiveBlending = AdditiveBlending;
    exports.AlphaFormat = AlphaFormat;
    exports.AlwaysDepth = AlwaysDepth;
    exports.AlwaysStencilFunc = AlwaysStencilFunc;
    exports.AmbientLight = AmbientLight;
    exports.AmbientLightProbe = AmbientLightProbe;
    exports.AnimationClip = AnimationClip;
    exports.AnimationLoader = AnimationLoader;
    exports.AnimationMixer = AnimationMixer;
    exports.AnimationObjectGroup = AnimationObjectGroup;
    exports.AnimationUtils = AnimationUtils;
    exports.ArcCurve = ArcCurve;
    exports.ArrayCamera = ArrayCamera;
    exports.ArrowHelper = ArrowHelper1;
    exports.Audio = Audio1;
    exports.AudioAnalyser = AudioAnalyser;
    exports.AudioContext = AudioContext1;
    exports.AudioListener = AudioListener1;
    exports.AudioLoader = AudioLoader;
    exports.AxesHelper = AxesHelper1;
    exports.AxisHelper = AxisHelper;
    exports.BackSide = BackSide;
    exports.BasicDepthPacking = BasicDepthPacking;
    exports.BasicShadowMap = BasicShadowMap;
    exports.BinaryTextureLoader = BinaryTextureLoader;
    exports.Bone = Bone;
    exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
    exports.BoundingBoxHelper = BoundingBoxHelper;
    exports.Box2 = Box2;
    exports.Box3 = Box3;
    exports.Box3Helper = Box3Helper1;
    exports.BoxBufferGeometry = BoxGeometry1;
    exports.BoxGeometry = BoxGeometry1;
    exports.BoxHelper = BoxHelper1;
    exports.BufferAttribute = BufferAttribute;
    exports.BufferGeometry = BufferGeometry;
    exports.BufferGeometryLoader = BufferGeometryLoader;
    exports.ByteType = ByteType;
    exports.Cache = Cache1;
    exports.Camera = Camera;
    exports.CameraHelper = CameraHelper1;
    exports.CanvasRenderer = CanvasRenderer;
    exports.CanvasTexture = CanvasTexture;
    exports.CatmullRomCurve3 = CatmullRomCurve3;
    exports.CineonToneMapping = CineonToneMapping;
    exports.CircleBufferGeometry = CircleGeometry1;
    exports.CircleGeometry = CircleGeometry1;
    exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
    exports.Clock = Clock;
    exports.ClosedSplineCurve3 = ClosedSplineCurve3;
    exports.Color = Color;
    exports.ColorKeyframeTrack = ColorKeyframeTrack;
    exports.CompressedTexture = CompressedTexture;
    exports.CompressedTextureLoader = CompressedTextureLoader;
    exports.ConeBufferGeometry = ConeGeometry1;
    exports.ConeGeometry = ConeGeometry1;
    exports.CubeCamera = CubeCamera;
    exports.CubeReflectionMapping = CubeReflectionMapping;
    exports.CubeRefractionMapping = CubeRefractionMapping;
    exports.CubeTexture = CubeTexture;
    exports.CubeTextureLoader = CubeTextureLoader;
    exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
    exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
    exports.CubicBezierCurve = CubicBezierCurve;
    exports.CubicBezierCurve3 = CubicBezierCurve3;
    exports.CubicInterpolant = CubicInterpolant;
    exports.CullFaceBack = CullFaceBack;
    exports.CullFaceFront = CullFaceFront;
    exports.CullFaceFrontBack = CullFaceFrontBack;
    exports.CullFaceNone = CullFaceNone;
    exports.Curve = Curve;
    exports.CurvePath = CurvePath;
    exports.CustomBlending = CustomBlending;
    exports.CustomToneMapping = CustomToneMapping;
    exports.CylinderBufferGeometry = CylinderGeometry1;
    exports.CylinderGeometry = CylinderGeometry1;
    exports.Cylindrical = Cylindrical;
    exports.DataTexture = DataTexture;
    exports.DataTexture2DArray = DataTexture2DArray;
    exports.DataTexture3D = DataTexture3D;
    exports.DataTextureLoader = DataTextureLoader;
    exports.DataUtils = DataUtils;
    exports.DecrementStencilOp = DecrementStencilOp;
    exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
    exports.DefaultLoadingManager = DefaultLoadingManager;
    exports.DepthFormat = DepthFormat;
    exports.DepthStencilFormat = DepthStencilFormat;
    exports.DepthTexture = DepthTexture;
    exports.DirectionalLight = DirectionalLight;
    exports.DirectionalLightHelper = DirectionalLightHelper1;
    exports.DiscreteInterpolant = DiscreteInterpolant;
    exports.DodecahedronBufferGeometry = DodecahedronGeometry1;
    exports.DodecahedronGeometry = DodecahedronGeometry1;
    exports.DoubleSide = DoubleSide;
    exports.DstAlphaFactor = DstAlphaFactor;
    exports.DstColorFactor = DstColorFactor;
    exports.DynamicBufferAttribute = DynamicBufferAttribute;
    exports.DynamicCopyUsage = DynamicCopyUsage;
    exports.DynamicDrawUsage = DynamicDrawUsage;
    exports.DynamicReadUsage = DynamicReadUsage;
    exports.EdgesGeometry = EdgesGeometry1;
    exports.EdgesHelper = EdgesHelper;
    exports.EllipseCurve = EllipseCurve;
    exports.EqualDepth = EqualDepth;
    exports.EqualStencilFunc = EqualStencilFunc;
    exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
    exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
    exports.Euler = Euler;
    exports.EventDispatcher = EventDispatcher;
    exports.ExtrudeBufferGeometry = ExtrudeGeometry1;
    exports.ExtrudeGeometry = ExtrudeGeometry1;
    exports.Face3 = Face3;
    exports.Face4 = Face4;
    exports.FaceColors = FaceColors;
    exports.FileLoader = FileLoader;
    exports.FlatShading = FlatShading;
    exports.Float16BufferAttribute = Float16BufferAttribute;
    exports.Float32Attribute = Float32Attribute;
    exports.Float32BufferAttribute = Float32BufferAttribute;
    exports.Float64Attribute = Float64Attribute;
    exports.Float64BufferAttribute = Float64BufferAttribute;
    exports.FloatType = FloatType;
    exports.Fog = Fog;
    exports.FogExp2 = FogExp2;
    exports.Font = Font;
    exports.FontLoader = FontLoader;
    exports.FrontSide = FrontSide;
    exports.Frustum = Frustum;
    exports.GLBufferAttribute = GLBufferAttribute;
    exports.GLSL1 = GLSL1;
    exports.GLSL3 = GLSL3;
    exports.GammaEncoding = GammaEncoding;
    exports.GeometryUtils = GeometryUtils;
    exports.GreaterDepth = GreaterDepth;
    exports.GreaterEqualDepth = GreaterEqualDepth;
    exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
    exports.GreaterStencilFunc = GreaterStencilFunc;
    exports.GridHelper = GridHelper1;
    exports.Group = Group;
    exports.HalfFloatType = HalfFloatType;
    exports.HemisphereLight = HemisphereLight;
    exports.HemisphereLightHelper = HemisphereLightHelper1;
    exports.HemisphereLightProbe = HemisphereLightProbe;
    exports.IcosahedronBufferGeometry = IcosahedronGeometry1;
    exports.IcosahedronGeometry = IcosahedronGeometry1;
    exports.ImageBitmapLoader = ImageBitmapLoader;
    exports.ImageLoader = ImageLoader;
    exports.ImageUtils = ImageUtils;
    exports.ImmediateRenderObject = ImmediateRenderObject;
    exports.IncrementStencilOp = IncrementStencilOp;
    exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
    exports.InstancedBufferAttribute = InstancedBufferAttribute;
    exports.InstancedBufferGeometry = InstancedBufferGeometry;
    exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
    exports.InstancedMesh = InstancedMesh;
    exports.Int16Attribute = Int16Attribute;
    exports.Int16BufferAttribute = Int16BufferAttribute;
    exports.Int32Attribute = Int32Attribute;
    exports.Int32BufferAttribute = Int32BufferAttribute;
    exports.Int8Attribute = Int8Attribute;
    exports.Int8BufferAttribute = Int8BufferAttribute;
    exports.IntType = IntType;
    exports.InterleavedBuffer = InterleavedBuffer;
    exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
    exports.Interpolant = Interpolant;
    exports.InterpolateDiscrete = InterpolateDiscrete;
    exports.InterpolateLinear = InterpolateLinear;
    exports.InterpolateSmooth = InterpolateSmooth;
    exports.InvertStencilOp = InvertStencilOp;
    exports.JSONLoader = JSONLoader;
    exports.KeepStencilOp = KeepStencilOp;
    exports.KeyframeTrack = KeyframeTrack;
    exports.LOD = LOD;
    exports.LatheBufferGeometry = LatheGeometry1;
    exports.LatheGeometry = LatheGeometry1;
    exports.Layers = Layers;
    exports.LensFlare = LensFlare;
    exports.LessDepth = LessDepth;
    exports.LessEqualDepth = LessEqualDepth;
    exports.LessEqualStencilFunc = LessEqualStencilFunc;
    exports.LessStencilFunc = LessStencilFunc;
    exports.Light = Light;
    exports.LightProbe = LightProbe;
    exports.Line = Line;
    exports.Line3 = Line3;
    exports.LineBasicMaterial = LineBasicMaterial;
    exports.LineCurve = LineCurve;
    exports.LineCurve3 = LineCurve3;
    exports.LineDashedMaterial = LineDashedMaterial;
    exports.LineLoop = LineLoop;
    exports.LinePieces = LinePieces;
    exports.LineSegments = LineSegments;
    exports.LineStrip = LineStrip;
    exports.LinearEncoding = LinearEncoding;
    exports.LinearFilter = LinearFilter;
    exports.LinearInterpolant = LinearInterpolant;
    exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
    exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
    exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
    exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
    exports.LinearToneMapping = LinearToneMapping;
    exports.Loader = Loader;
    exports.LoaderUtils = LoaderUtils;
    exports.LoadingManager = LoadingManager;
    exports.LogLuvEncoding = LogLuvEncoding;
    exports.LoopOnce = LoopOnce;
    exports.LoopPingPong = LoopPingPong;
    exports.LoopRepeat = LoopRepeat;
    exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
    exports.LuminanceFormat = LuminanceFormat;
    exports.MOUSE = MOUSE;
    exports.Material = Material;
    exports.MaterialLoader = MaterialLoader;
    exports.Math = MathUtils;
    exports.MathUtils = MathUtils;
    exports.Matrix3 = Matrix3;
    exports.Matrix4 = Matrix4;
    exports.MaxEquation = MaxEquation;
    exports.Mesh = Mesh;
    exports.MeshBasicMaterial = MeshBasicMaterial;
    exports.MeshDepthMaterial = MeshDepthMaterial;
    exports.MeshDistanceMaterial = MeshDistanceMaterial;
    exports.MeshFaceMaterial = MeshFaceMaterial;
    exports.MeshLambertMaterial = MeshLambertMaterial;
    exports.MeshMatcapMaterial = MeshMatcapMaterial;
    exports.MeshNormalMaterial = MeshNormalMaterial;
    exports.MeshPhongMaterial = MeshPhongMaterial;
    exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
    exports.MeshStandardMaterial = MeshStandardMaterial;
    exports.MeshToonMaterial = MeshToonMaterial;
    exports.MinEquation = MinEquation;
    exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
    exports.MixOperation = MixOperation;
    exports.MultiMaterial = MultiMaterial;
    exports.MultiplyBlending = MultiplyBlending;
    exports.MultiplyOperation = MultiplyOperation;
    exports.NearestFilter = NearestFilter;
    exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
    exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
    exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
    exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
    exports.NeverDepth = NeverDepth;
    exports.NeverStencilFunc = NeverStencilFunc;
    exports.NoBlending = NoBlending;
    exports.NoColors = NoColors;
    exports.NoToneMapping = NoToneMapping;
    exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
    exports.NormalBlending = NormalBlending;
    exports.NotEqualDepth = NotEqualDepth;
    exports.NotEqualStencilFunc = NotEqualStencilFunc;
    exports.NumberKeyframeTrack = NumberKeyframeTrack;
    exports.Object3D = Object3D;
    exports.ObjectLoader = ObjectLoader1;
    exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
    exports.OctahedronBufferGeometry = OctahedronGeometry1;
    exports.OctahedronGeometry = OctahedronGeometry1;
    exports.OneFactor = OneFactor;
    exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
    exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
    exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
    exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
    exports.OrthographicCamera = OrthographicCamera;
    exports.PCFShadowMap = PCFShadowMap;
    exports.PCFSoftShadowMap = PCFSoftShadowMap;
    exports.PMREMGenerator = PMREMGenerator;
    exports.ParametricBufferGeometry = ParametricGeometry;
    exports.ParametricGeometry = ParametricGeometry;
    exports.Particle = Particle;
    exports.ParticleBasicMaterial = ParticleBasicMaterial;
    exports.ParticleSystem = ParticleSystem;
    exports.ParticleSystemMaterial = ParticleSystemMaterial;
    exports.Path = Path;
    exports.PerspectiveCamera = PerspectiveCamera;
    exports.Plane = Plane;
    exports.PlaneBufferGeometry = PlaneGeometry1;
    exports.PlaneGeometry = PlaneGeometry1;
    exports.PlaneHelper = PlaneHelper1;
    exports.PointCloud = PointCloud;
    exports.PointCloudMaterial = PointCloudMaterial;
    exports.PointLight = PointLight;
    exports.PointLightHelper = PointLightHelper1;
    exports.Points = Points;
    exports.PointsMaterial = PointsMaterial;
    exports.PolarGridHelper = PolarGridHelper1;
    exports.PolyhedronBufferGeometry = PolyhedronGeometry1;
    exports.PolyhedronGeometry = PolyhedronGeometry1;
    exports.PositionalAudio = PositionalAudio1;
    exports.PropertyBinding = PropertyBinding;
    exports.PropertyMixer = PropertyMixer;
    exports.QuadraticBezierCurve = QuadraticBezierCurve;
    exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
    exports.Quaternion = Quaternion;
    exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
    exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
    exports.REVISION = REVISION;
    exports.RGBADepthPacking = RGBADepthPacking;
    exports.RGBAFormat = RGBAFormat;
    exports.RGBAIntegerFormat = RGBAIntegerFormat;
    exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
    exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
    exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
    exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
    exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
    exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
    exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
    exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
    exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
    exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
    exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
    exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
    exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
    exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
    exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
    exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
    exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
    exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
    exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
    exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
    exports.RGBDEncoding = RGBDEncoding;
    exports.RGBEEncoding = RGBEEncoding;
    exports.RGBEFormat = RGBEFormat;
    exports.RGBFormat = RGBFormat;
    exports.RGBIntegerFormat = RGBIntegerFormat;
    exports.RGBM16Encoding = RGBM16Encoding;
    exports.RGBM7Encoding = RGBM7Encoding;
    exports.RGB_ETC1_Format = RGB_ETC1_Format;
    exports.RGB_ETC2_Format = RGB_ETC2_Format;
    exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
    exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
    exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
    exports.RGFormat = RGFormat;
    exports.RGIntegerFormat = RGIntegerFormat;
    exports.RawShaderMaterial = RawShaderMaterial;
    exports.Ray = Ray;
    exports.Raycaster = Raycaster;
    exports.RectAreaLight = RectAreaLight;
    exports.RedFormat = RedFormat;
    exports.RedIntegerFormat = RedIntegerFormat;
    exports.ReinhardToneMapping = ReinhardToneMapping;
    exports.RepeatWrapping = RepeatWrapping;
    exports.ReplaceStencilOp = ReplaceStencilOp;
    exports.ReverseSubtractEquation = ReverseSubtractEquation;
    exports.RingBufferGeometry = RingGeometry1;
    exports.RingGeometry = RingGeometry1;
    exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
    exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
    exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
    exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
    exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
    exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
    exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
    exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
    exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
    exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
    exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
    exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
    exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
    exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
    exports.Scene = Scene1;
    exports.SceneUtils = SceneUtils;
    exports.ShaderChunk = ShaderChunk;
    exports.ShaderLib = ShaderLib;
    exports.ShaderMaterial = ShaderMaterial;
    exports.ShadowMaterial = ShadowMaterial;
    exports.Shape = Shape;
    exports.ShapeBufferGeometry = ShapeGeometry1;
    exports.ShapeGeometry = ShapeGeometry1;
    exports.ShapePath = ShapePath;
    exports.ShapeUtils = ShapeUtils;
    exports.ShortType = ShortType;
    exports.Skeleton = Skeleton;
    exports.SkeletonHelper = SkeletonHelper1;
    exports.SkinnedMesh = SkinnedMesh;
    exports.SmoothShading = SmoothShading;
    exports.Sphere = Sphere;
    exports.SphereBufferGeometry = SphereGeometry1;
    exports.SphereGeometry = SphereGeometry1;
    exports.Spherical = Spherical;
    exports.SphericalHarmonics3 = SphericalHarmonics3;
    exports.Spline = Spline;
    exports.SplineCurve = SplineCurve;
    exports.SplineCurve3 = SplineCurve3;
    exports.SpotLight = SpotLight;
    exports.SpotLightHelper = SpotLightHelper1;
    exports.Sprite = Sprite;
    exports.SpriteMaterial = SpriteMaterial;
    exports.SrcAlphaFactor = SrcAlphaFactor;
    exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
    exports.SrcColorFactor = SrcColorFactor;
    exports.StaticCopyUsage = StaticCopyUsage;
    exports.StaticDrawUsage = StaticDrawUsage;
    exports.StaticReadUsage = StaticReadUsage;
    exports.StereoCamera = StereoCamera;
    exports.StreamCopyUsage = StreamCopyUsage;
    exports.StreamDrawUsage = StreamDrawUsage;
    exports.StreamReadUsage = StreamReadUsage;
    exports.StringKeyframeTrack = StringKeyframeTrack;
    exports.SubtractEquation = SubtractEquation;
    exports.SubtractiveBlending = SubtractiveBlending;
    exports.TOUCH = TOUCH;
    exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
    exports.TetrahedronBufferGeometry = TetrahedronGeometry1;
    exports.TetrahedronGeometry = TetrahedronGeometry1;
    exports.TextBufferGeometry = TextGeometry1;
    exports.TextGeometry = TextGeometry1;
    exports.Texture = Texture;
    exports.TextureLoader = TextureLoader;
    exports.TorusBufferGeometry = TorusGeometry1;
    exports.TorusGeometry = TorusGeometry1;
    exports.TorusKnotBufferGeometry = TorusKnotGeometry1;
    exports.TorusKnotGeometry = TorusKnotGeometry1;
    exports.Triangle = Triangle;
    exports.TriangleFanDrawMode = TriangleFanDrawMode;
    exports.TriangleStripDrawMode = TriangleStripDrawMode;
    exports.TrianglesDrawMode = TrianglesDrawMode;
    exports.TubeBufferGeometry = TubeGeometry1;
    exports.TubeGeometry = TubeGeometry1;
    exports.UVMapping = UVMapping;
    exports.Uint16Attribute = Uint16Attribute;
    exports.Uint16BufferAttribute = Uint16BufferAttribute;
    exports.Uint32Attribute = Uint32Attribute;
    exports.Uint32BufferAttribute = Uint32BufferAttribute;
    exports.Uint8Attribute = Uint8Attribute;
    exports.Uint8BufferAttribute = Uint8BufferAttribute;
    exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
    exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
    exports.Uniform = Uniform;
    exports.UniformsLib = UniformsLib;
    exports.UniformsUtils = UniformsUtils;
    exports.UnsignedByteType = UnsignedByteType;
    exports.UnsignedInt248Type = UnsignedInt248Type;
    exports.UnsignedIntType = UnsignedIntType;
    exports.UnsignedShort4444Type = UnsignedShort4444Type;
    exports.UnsignedShort5551Type = UnsignedShort5551Type;
    exports.UnsignedShort565Type = UnsignedShort565Type;
    exports.UnsignedShortType = UnsignedShortType;
    exports.VSMShadowMap = VSMShadowMap;
    exports.Vector2 = Vector2;
    exports.Vector3 = Vector3;
    exports.Vector4 = Vector4;
    exports.VectorKeyframeTrack = VectorKeyframeTrack;
    exports.Vertex = Vertex;
    exports.VertexColors = VertexColors;
    exports.VideoTexture = VideoTexture;
    exports.WebGL1Renderer = WebGL1Renderer;
    exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget1;
    exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget1;
    exports.WebGLRenderTarget = WebGLRenderTarget1;
    exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
    exports.WebGLRenderer = WebGLRenderer;
    exports.WebGLUtils = WebGLUtils;
    exports.WireframeGeometry = WireframeGeometry1;
    exports.WireframeHelper = WireframeHelper;
    exports.WrapAroundEnding = WrapAroundEnding;
    exports.XHRLoader = XHRLoader;
    exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
    exports.ZeroFactor = ZeroFactor;
    exports.ZeroSlopeEnding = ZeroSlopeEnding;
    exports.ZeroStencilOp = ZeroStencilOp;
    exports.sRGBEncoding = sRGBEncoding;
    Object.defineProperty(exports, '__esModule', {
        value: true
    });
});

},{}],"2eXZP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Sky", ()=>Sky
);
var _threeModuleJs = require("../../../build/three.module.js");
/**
 * Based on "A Practical Analytic Model for Daylight"
 * aka The Preetham Model, the de facto standard analytic skydome model
 * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight
 *
 * First implemented by Simon Wallner
 * http://www.simonwallner.at/projects/atmospheric-scattering
 *
 * Improved by Martin Upitis
 * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR
 *
 * Three.js integration by zz85 http://twitter.com/blurspline
*/ var Sky = function() {
    var shader = Sky.SkyShader;
    var material = new _threeModuleJs.ShaderMaterial({
        name: 'SkyShader',
        fragmentShader: shader.fragmentShader,
        vertexShader: shader.vertexShader,
        uniforms: _threeModuleJs.UniformsUtils.clone(shader.uniforms),
        side: _threeModuleJs.BackSide,
        depthWrite: false
    });
    _threeModuleJs.Mesh.call(this, new _threeModuleJs.BoxGeometry(1, 1, 1), material);
};
Sky.prototype = Object.create(_threeModuleJs.Mesh.prototype);
Sky.SkyShader = {
    uniforms: {
        'turbidity': {
            value: 2
        },
        'rayleigh': {
            value: 1
        },
        'mieCoefficient': {
            value: 0.005
        },
        'mieDirectionalG': {
            value: 0.8
        },
        'sunPosition': {
            value: new _threeModuleJs.Vector3()
        },
        'up': {
            value: new _threeModuleJs.Vector3(0, 1, 0)
        }
    },
    vertexShader: [
        'uniform vec3 sunPosition;',
        'uniform float rayleigh;',
        'uniform float turbidity;',
        'uniform float mieCoefficient;',
        'uniform vec3 up;',
        'varying vec3 vWorldPosition;',
        'varying vec3 vSunDirection;',
        'varying float vSunfade;',
        'varying vec3 vBetaR;',
        'varying vec3 vBetaM;',
        'varying float vSunE;',
        // constants for atmospheric scattering
        'const float e = 2.71828182845904523536028747135266249775724709369995957;',
        'const float pi = 3.141592653589793238462643383279502884197169;',
        // wavelength of used primaries, according to preetham
        'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );',
        // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
        // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
        'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );',
        // mie stuff
        // K coefficient for the primaries
        'const float v = 4.0;',
        'const vec3 K = vec3( 0.686, 0.678, 0.666 );',
        // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
        'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );',
        // earth shadow hack
        // cutoffAngle = pi / 1.95;
        'const float cutoffAngle = 1.6110731556870734;',
        'const float steepness = 1.5;',
        'const float EE = 1000.0;',
        'float sunIntensity( float zenithAngleCos ) {',
        '	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );',
        '	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );',
        '}',
        'vec3 totalMie( float T ) {',
        '	float c = ( 0.2 * T ) * 10E-18;',
        '	return 0.434 * c * MieConst;',
        '}',
        'void main() {',
        '	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
        '	vWorldPosition = worldPosition.xyz;',
        '	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
        '	gl_Position.z = gl_Position.w;',
        '	vSunDirection = normalize( sunPosition );',
        '	vSunE = sunIntensity( dot( vSunDirection, up ) );',
        '	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );',
        '	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );',
        // extinction (absorbtion + out scattering)
        // rayleigh coefficients
        '	vBetaR = totalRayleigh * rayleighCoefficient;',
        // mie coefficients
        '	vBetaM = totalMie( turbidity ) * mieCoefficient;',
        '}'
    ].join('\n'),
    fragmentShader: [
        'varying vec3 vWorldPosition;',
        'varying vec3 vSunDirection;',
        'varying float vSunfade;',
        'varying vec3 vBetaR;',
        'varying vec3 vBetaM;',
        'varying float vSunE;',
        'uniform float mieDirectionalG;',
        'uniform vec3 up;',
        'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );',
        // constants for atmospheric scattering
        'const float pi = 3.141592653589793238462643383279502884197169;',
        'const float n = 1.0003;',
        'const float N = 2.545E25;',
        // optical length at zenith for molecules
        'const float rayleighZenithLength = 8.4E3;',
        'const float mieZenithLength = 1.25E3;',
        // 66 arc seconds -> degrees, and the cosine of that
        'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;',
        // 3.0 / ( 16.0 * pi )
        'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;',
        // 1.0 / ( 4.0 * pi )
        'const float ONE_OVER_FOURPI = 0.07957747154594767;',
        'float rayleighPhase( float cosTheta ) {',
        '	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );',
        '}',
        'float hgPhase( float cosTheta, float g ) {',
        '	float g2 = pow( g, 2.0 );',
        '	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );',
        '	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );',
        '}',
        'void main() {',
        '	vec3 direction = normalize( vWorldPosition - cameraPos );',
        // optical length
        // cutoff angle at 90 to avoid singularity in next formula.
        '	float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );',
        '	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );',
        '	float sR = rayleighZenithLength * inverse;',
        '	float sM = mieZenithLength * inverse;',
        // combined extinction factor
        '	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );',
        // in scattering
        '	float cosTheta = dot( direction, vSunDirection );',
        '	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );',
        '	vec3 betaRTheta = vBetaR * rPhase;',
        '	float mPhase = hgPhase( cosTheta, mieDirectionalG );',
        '	vec3 betaMTheta = vBetaM * mPhase;',
        '	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );',
        '	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );',
        // nightsky
        '	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]',
        '	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]',
        '	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );',
        '	vec3 L0 = vec3( 0.1 ) * Fex;',
        // composition + solar disc
        '	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );',
        '	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;',
        '	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );',
        '	vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );',
        '	gl_FragColor = vec4( retColor, 1.0 );',
        '#include <tonemapping_fragment>',
        '#include <encodings_fragment>',
        '}'
    ].join('\n')
};

},{"../../../build/three.module.js":"1gWoM","@parcel/transformer-js/src/esmodule-helpers.js":"kcMTN"}],"1gWoM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ACESFilmicToneMapping", ()=>ACESFilmicToneMapping
);
parcelHelpers.export(exports, "AddEquation", ()=>AddEquation
);
parcelHelpers.export(exports, "AddOperation", ()=>AddOperation
);
parcelHelpers.export(exports, "AdditiveAnimationBlendMode", ()=>AdditiveAnimationBlendMode
);
parcelHelpers.export(exports, "AdditiveBlending", ()=>AdditiveBlending
);
parcelHelpers.export(exports, "AlphaFormat", ()=>AlphaFormat
);
parcelHelpers.export(exports, "AlwaysDepth", ()=>AlwaysDepth
);
parcelHelpers.export(exports, "AlwaysStencilFunc", ()=>AlwaysStencilFunc
);
parcelHelpers.export(exports, "AmbientLight", ()=>AmbientLight
);
parcelHelpers.export(exports, "AmbientLightProbe", ()=>AmbientLightProbe
);
parcelHelpers.export(exports, "AnimationClip", ()=>AnimationClip
);
parcelHelpers.export(exports, "AnimationLoader", ()=>AnimationLoader
);
parcelHelpers.export(exports, "AnimationMixer", ()=>AnimationMixer
);
parcelHelpers.export(exports, "AnimationObjectGroup", ()=>AnimationObjectGroup
);
parcelHelpers.export(exports, "AnimationUtils", ()=>AnimationUtils
);
parcelHelpers.export(exports, "ArcCurve", ()=>ArcCurve
);
parcelHelpers.export(exports, "ArrayCamera", ()=>ArrayCamera
);
parcelHelpers.export(exports, "ArrowHelper", ()=>ArrowHelper
);
parcelHelpers.export(exports, "Audio", ()=>Audio1
);
parcelHelpers.export(exports, "AudioAnalyser", ()=>AudioAnalyser
);
parcelHelpers.export(exports, "AudioContext", ()=>AudioContext1
);
parcelHelpers.export(exports, "AudioListener", ()=>AudioListener1
);
parcelHelpers.export(exports, "AudioLoader", ()=>AudioLoader
);
parcelHelpers.export(exports, "AxesHelper", ()=>AxesHelper
);
parcelHelpers.export(exports, "AxisHelper", ()=>AxisHelper
);
parcelHelpers.export(exports, "BackSide", ()=>BackSide
);
parcelHelpers.export(exports, "BasicDepthPacking", ()=>BasicDepthPacking
);
parcelHelpers.export(exports, "BasicShadowMap", ()=>BasicShadowMap
);
parcelHelpers.export(exports, "BinaryTextureLoader", ()=>BinaryTextureLoader
);
parcelHelpers.export(exports, "Bone", ()=>Bone
);
parcelHelpers.export(exports, "BooleanKeyframeTrack", ()=>BooleanKeyframeTrack
);
parcelHelpers.export(exports, "BoundingBoxHelper", ()=>BoundingBoxHelper
);
parcelHelpers.export(exports, "Box2", ()=>Box2
);
parcelHelpers.export(exports, "Box3", ()=>Box3
);
parcelHelpers.export(exports, "Box3Helper", ()=>Box3Helper
);
parcelHelpers.export(exports, "BoxBufferGeometry", ()=>BoxGeometry
);
parcelHelpers.export(exports, "BoxGeometry", ()=>BoxGeometry
);
parcelHelpers.export(exports, "BoxHelper", ()=>BoxHelper
);
parcelHelpers.export(exports, "BufferAttribute", ()=>BufferAttribute
);
parcelHelpers.export(exports, "BufferGeometry", ()=>BufferGeometry
);
parcelHelpers.export(exports, "BufferGeometryLoader", ()=>BufferGeometryLoader
);
parcelHelpers.export(exports, "ByteType", ()=>ByteType
);
parcelHelpers.export(exports, "Cache", ()=>Cache1
);
parcelHelpers.export(exports, "Camera", ()=>Camera
);
parcelHelpers.export(exports, "CameraHelper", ()=>CameraHelper
);
parcelHelpers.export(exports, "CanvasRenderer", ()=>CanvasRenderer
);
parcelHelpers.export(exports, "CanvasTexture", ()=>CanvasTexture
);
parcelHelpers.export(exports, "CatmullRomCurve3", ()=>CatmullRomCurve3
);
parcelHelpers.export(exports, "CineonToneMapping", ()=>CineonToneMapping
);
parcelHelpers.export(exports, "CircleBufferGeometry", ()=>CircleGeometry
);
parcelHelpers.export(exports, "CircleGeometry", ()=>CircleGeometry
);
parcelHelpers.export(exports, "ClampToEdgeWrapping", ()=>ClampToEdgeWrapping
);
parcelHelpers.export(exports, "Clock", ()=>Clock
);
parcelHelpers.export(exports, "ClosedSplineCurve3", ()=>ClosedSplineCurve3
);
parcelHelpers.export(exports, "Color", ()=>Color
);
parcelHelpers.export(exports, "ColorKeyframeTrack", ()=>ColorKeyframeTrack
);
parcelHelpers.export(exports, "CompressedTexture", ()=>CompressedTexture
);
parcelHelpers.export(exports, "CompressedTextureLoader", ()=>CompressedTextureLoader
);
parcelHelpers.export(exports, "ConeBufferGeometry", ()=>ConeGeometry
);
parcelHelpers.export(exports, "ConeGeometry", ()=>ConeGeometry
);
parcelHelpers.export(exports, "CubeCamera", ()=>CubeCamera
);
parcelHelpers.export(exports, "CubeReflectionMapping", ()=>CubeReflectionMapping
);
parcelHelpers.export(exports, "CubeRefractionMapping", ()=>CubeRefractionMapping
);
parcelHelpers.export(exports, "CubeTexture", ()=>CubeTexture
);
parcelHelpers.export(exports, "CubeTextureLoader", ()=>CubeTextureLoader
);
parcelHelpers.export(exports, "CubeUVReflectionMapping", ()=>CubeUVReflectionMapping
);
parcelHelpers.export(exports, "CubeUVRefractionMapping", ()=>CubeUVRefractionMapping
);
parcelHelpers.export(exports, "CubicBezierCurve", ()=>CubicBezierCurve
);
parcelHelpers.export(exports, "CubicBezierCurve3", ()=>CubicBezierCurve3
);
parcelHelpers.export(exports, "CubicInterpolant", ()=>CubicInterpolant
);
parcelHelpers.export(exports, "CullFaceBack", ()=>CullFaceBack
);
parcelHelpers.export(exports, "CullFaceFront", ()=>CullFaceFront
);
parcelHelpers.export(exports, "CullFaceFrontBack", ()=>CullFaceFrontBack
);
parcelHelpers.export(exports, "CullFaceNone", ()=>CullFaceNone
);
parcelHelpers.export(exports, "Curve", ()=>Curve
);
parcelHelpers.export(exports, "CurvePath", ()=>CurvePath
);
parcelHelpers.export(exports, "CustomBlending", ()=>CustomBlending
);
parcelHelpers.export(exports, "CustomToneMapping", ()=>CustomToneMapping
);
parcelHelpers.export(exports, "CylinderBufferGeometry", ()=>CylinderGeometry
);
parcelHelpers.export(exports, "CylinderGeometry", ()=>CylinderGeometry
);
parcelHelpers.export(exports, "Cylindrical", ()=>Cylindrical
);
parcelHelpers.export(exports, "DataTexture", ()=>DataTexture
);
parcelHelpers.export(exports, "DataTexture2DArray", ()=>DataTexture2DArray
);
parcelHelpers.export(exports, "DataTexture3D", ()=>DataTexture3D
);
parcelHelpers.export(exports, "DataTextureLoader", ()=>DataTextureLoader
);
parcelHelpers.export(exports, "DataUtils", ()=>DataUtils
);
parcelHelpers.export(exports, "DecrementStencilOp", ()=>DecrementStencilOp
);
parcelHelpers.export(exports, "DecrementWrapStencilOp", ()=>DecrementWrapStencilOp
);
parcelHelpers.export(exports, "DefaultLoadingManager", ()=>DefaultLoadingManager
);
parcelHelpers.export(exports, "DepthFormat", ()=>DepthFormat
);
parcelHelpers.export(exports, "DepthStencilFormat", ()=>DepthStencilFormat
);
parcelHelpers.export(exports, "DepthTexture", ()=>DepthTexture
);
parcelHelpers.export(exports, "DirectionalLight", ()=>DirectionalLight
);
parcelHelpers.export(exports, "DirectionalLightHelper", ()=>DirectionalLightHelper
);
parcelHelpers.export(exports, "DiscreteInterpolant", ()=>DiscreteInterpolant
);
parcelHelpers.export(exports, "DodecahedronBufferGeometry", ()=>DodecahedronGeometry
);
parcelHelpers.export(exports, "DodecahedronGeometry", ()=>DodecahedronGeometry
);
parcelHelpers.export(exports, "DoubleSide", ()=>DoubleSide
);
parcelHelpers.export(exports, "DstAlphaFactor", ()=>DstAlphaFactor
);
parcelHelpers.export(exports, "DstColorFactor", ()=>DstColorFactor
);
parcelHelpers.export(exports, "DynamicBufferAttribute", ()=>DynamicBufferAttribute
);
parcelHelpers.export(exports, "DynamicCopyUsage", ()=>DynamicCopyUsage
);
parcelHelpers.export(exports, "DynamicDrawUsage", ()=>DynamicDrawUsage
);
parcelHelpers.export(exports, "DynamicReadUsage", ()=>DynamicReadUsage
);
parcelHelpers.export(exports, "EdgesGeometry", ()=>EdgesGeometry
);
parcelHelpers.export(exports, "EdgesHelper", ()=>EdgesHelper
);
parcelHelpers.export(exports, "EllipseCurve", ()=>EllipseCurve
);
parcelHelpers.export(exports, "EqualDepth", ()=>EqualDepth
);
parcelHelpers.export(exports, "EqualStencilFunc", ()=>EqualStencilFunc
);
parcelHelpers.export(exports, "EquirectangularReflectionMapping", ()=>EquirectangularReflectionMapping
);
parcelHelpers.export(exports, "EquirectangularRefractionMapping", ()=>EquirectangularRefractionMapping
);
parcelHelpers.export(exports, "Euler", ()=>Euler
);
parcelHelpers.export(exports, "EventDispatcher", ()=>EventDispatcher
);
parcelHelpers.export(exports, "ExtrudeBufferGeometry", ()=>ExtrudeGeometry
);
parcelHelpers.export(exports, "ExtrudeGeometry", ()=>ExtrudeGeometry
);
parcelHelpers.export(exports, "Face3", ()=>Face3
);
parcelHelpers.export(exports, "Face4", ()=>Face4
);
parcelHelpers.export(exports, "FaceColors", ()=>FaceColors
);
parcelHelpers.export(exports, "FileLoader", ()=>FileLoader
);
parcelHelpers.export(exports, "FlatShading", ()=>FlatShading
);
parcelHelpers.export(exports, "Float16BufferAttribute", ()=>Float16BufferAttribute
);
parcelHelpers.export(exports, "Float32Attribute", ()=>Float32Attribute
);
parcelHelpers.export(exports, "Float32BufferAttribute", ()=>Float32BufferAttribute
);
parcelHelpers.export(exports, "Float64Attribute", ()=>Float64Attribute
);
parcelHelpers.export(exports, "Float64BufferAttribute", ()=>Float64BufferAttribute
);
parcelHelpers.export(exports, "FloatType", ()=>FloatType
);
parcelHelpers.export(exports, "Fog", ()=>Fog
);
parcelHelpers.export(exports, "FogExp2", ()=>FogExp2
);
parcelHelpers.export(exports, "Font", ()=>Font
);
parcelHelpers.export(exports, "FontLoader", ()=>FontLoader
);
parcelHelpers.export(exports, "FrontSide", ()=>FrontSide
);
parcelHelpers.export(exports, "Frustum", ()=>Frustum
);
parcelHelpers.export(exports, "GLBufferAttribute", ()=>GLBufferAttribute
);
parcelHelpers.export(exports, "GLSL1", ()=>GLSL1
);
parcelHelpers.export(exports, "GLSL3", ()=>GLSL3
);
parcelHelpers.export(exports, "GammaEncoding", ()=>GammaEncoding
);
parcelHelpers.export(exports, "GeometryUtils", ()=>GeometryUtils
);
parcelHelpers.export(exports, "GreaterDepth", ()=>GreaterDepth
);
parcelHelpers.export(exports, "GreaterEqualDepth", ()=>GreaterEqualDepth
);
parcelHelpers.export(exports, "GreaterEqualStencilFunc", ()=>GreaterEqualStencilFunc
);
parcelHelpers.export(exports, "GreaterStencilFunc", ()=>GreaterStencilFunc
);
parcelHelpers.export(exports, "GridHelper", ()=>GridHelper
);
parcelHelpers.export(exports, "Group", ()=>Group
);
parcelHelpers.export(exports, "HalfFloatType", ()=>HalfFloatType
);
parcelHelpers.export(exports, "HemisphereLight", ()=>HemisphereLight
);
parcelHelpers.export(exports, "HemisphereLightHelper", ()=>HemisphereLightHelper
);
parcelHelpers.export(exports, "HemisphereLightProbe", ()=>HemisphereLightProbe
);
parcelHelpers.export(exports, "IcosahedronBufferGeometry", ()=>IcosahedronGeometry
);
parcelHelpers.export(exports, "IcosahedronGeometry", ()=>IcosahedronGeometry
);
parcelHelpers.export(exports, "ImageBitmapLoader", ()=>ImageBitmapLoader
);
parcelHelpers.export(exports, "ImageLoader", ()=>ImageLoader
);
parcelHelpers.export(exports, "ImageUtils", ()=>ImageUtils
);
parcelHelpers.export(exports, "ImmediateRenderObject", ()=>ImmediateRenderObject
);
parcelHelpers.export(exports, "IncrementStencilOp", ()=>IncrementStencilOp
);
parcelHelpers.export(exports, "IncrementWrapStencilOp", ()=>IncrementWrapStencilOp
);
parcelHelpers.export(exports, "InstancedBufferAttribute", ()=>InstancedBufferAttribute
);
parcelHelpers.export(exports, "InstancedBufferGeometry", ()=>InstancedBufferGeometry
);
parcelHelpers.export(exports, "InstancedInterleavedBuffer", ()=>InstancedInterleavedBuffer
);
parcelHelpers.export(exports, "InstancedMesh", ()=>InstancedMesh
);
parcelHelpers.export(exports, "Int16Attribute", ()=>Int16Attribute
);
parcelHelpers.export(exports, "Int16BufferAttribute", ()=>Int16BufferAttribute
);
parcelHelpers.export(exports, "Int32Attribute", ()=>Int32Attribute
);
parcelHelpers.export(exports, "Int32BufferAttribute", ()=>Int32BufferAttribute
);
parcelHelpers.export(exports, "Int8Attribute", ()=>Int8Attribute
);
parcelHelpers.export(exports, "Int8BufferAttribute", ()=>Int8BufferAttribute
);
parcelHelpers.export(exports, "IntType", ()=>IntType
);
parcelHelpers.export(exports, "InterleavedBuffer", ()=>InterleavedBuffer
);
parcelHelpers.export(exports, "InterleavedBufferAttribute", ()=>InterleavedBufferAttribute
);
parcelHelpers.export(exports, "Interpolant", ()=>Interpolant
);
parcelHelpers.export(exports, "InterpolateDiscrete", ()=>InterpolateDiscrete
);
parcelHelpers.export(exports, "InterpolateLinear", ()=>InterpolateLinear
);
parcelHelpers.export(exports, "InterpolateSmooth", ()=>InterpolateSmooth
);
parcelHelpers.export(exports, "InvertStencilOp", ()=>InvertStencilOp
);
parcelHelpers.export(exports, "JSONLoader", ()=>JSONLoader
);
parcelHelpers.export(exports, "KeepStencilOp", ()=>KeepStencilOp
);
parcelHelpers.export(exports, "KeyframeTrack", ()=>KeyframeTrack
);
parcelHelpers.export(exports, "LOD", ()=>LOD
);
parcelHelpers.export(exports, "LatheBufferGeometry", ()=>LatheGeometry
);
parcelHelpers.export(exports, "LatheGeometry", ()=>LatheGeometry
);
parcelHelpers.export(exports, "Layers", ()=>Layers
);
parcelHelpers.export(exports, "LensFlare", ()=>LensFlare
);
parcelHelpers.export(exports, "LessDepth", ()=>LessDepth
);
parcelHelpers.export(exports, "LessEqualDepth", ()=>LessEqualDepth
);
parcelHelpers.export(exports, "LessEqualStencilFunc", ()=>LessEqualStencilFunc
);
parcelHelpers.export(exports, "LessStencilFunc", ()=>LessStencilFunc
);
parcelHelpers.export(exports, "Light", ()=>Light
);
parcelHelpers.export(exports, "LightProbe", ()=>LightProbe
);
parcelHelpers.export(exports, "Line", ()=>Line
);
parcelHelpers.export(exports, "Line3", ()=>Line3
);
parcelHelpers.export(exports, "LineBasicMaterial", ()=>LineBasicMaterial
);
parcelHelpers.export(exports, "LineCurve", ()=>LineCurve
);
parcelHelpers.export(exports, "LineCurve3", ()=>LineCurve3
);
parcelHelpers.export(exports, "LineDashedMaterial", ()=>LineDashedMaterial
);
parcelHelpers.export(exports, "LineLoop", ()=>LineLoop
);
parcelHelpers.export(exports, "LinePieces", ()=>LinePieces
);
parcelHelpers.export(exports, "LineSegments", ()=>LineSegments
);
parcelHelpers.export(exports, "LineStrip", ()=>LineStrip
);
parcelHelpers.export(exports, "LinearEncoding", ()=>LinearEncoding
);
parcelHelpers.export(exports, "LinearFilter", ()=>LinearFilter
);
parcelHelpers.export(exports, "LinearInterpolant", ()=>LinearInterpolant
);
parcelHelpers.export(exports, "LinearMipMapLinearFilter", ()=>LinearMipMapLinearFilter
);
parcelHelpers.export(exports, "LinearMipMapNearestFilter", ()=>LinearMipMapNearestFilter
);
parcelHelpers.export(exports, "LinearMipmapLinearFilter", ()=>LinearMipmapLinearFilter
);
parcelHelpers.export(exports, "LinearMipmapNearestFilter", ()=>LinearMipmapNearestFilter
);
parcelHelpers.export(exports, "LinearToneMapping", ()=>LinearToneMapping
);
parcelHelpers.export(exports, "Loader", ()=>Loader
);
parcelHelpers.export(exports, "LoaderUtils", ()=>LoaderUtils
);
parcelHelpers.export(exports, "LoadingManager", ()=>LoadingManager
);
parcelHelpers.export(exports, "LogLuvEncoding", ()=>LogLuvEncoding
);
parcelHelpers.export(exports, "LoopOnce", ()=>LoopOnce
);
parcelHelpers.export(exports, "LoopPingPong", ()=>LoopPingPong
);
parcelHelpers.export(exports, "LoopRepeat", ()=>LoopRepeat
);
parcelHelpers.export(exports, "LuminanceAlphaFormat", ()=>LuminanceAlphaFormat
);
parcelHelpers.export(exports, "LuminanceFormat", ()=>LuminanceFormat
);
parcelHelpers.export(exports, "MOUSE", ()=>MOUSE
);
parcelHelpers.export(exports, "Material", ()=>Material
);
parcelHelpers.export(exports, "MaterialLoader", ()=>MaterialLoader
);
parcelHelpers.export(exports, "Math", ()=>MathUtils
);
parcelHelpers.export(exports, "MathUtils", ()=>MathUtils
);
parcelHelpers.export(exports, "Matrix3", ()=>Matrix3
);
parcelHelpers.export(exports, "Matrix4", ()=>Matrix4
);
parcelHelpers.export(exports, "MaxEquation", ()=>MaxEquation
);
parcelHelpers.export(exports, "Mesh", ()=>Mesh
);
parcelHelpers.export(exports, "MeshBasicMaterial", ()=>MeshBasicMaterial
);
parcelHelpers.export(exports, "MeshDepthMaterial", ()=>MeshDepthMaterial
);
parcelHelpers.export(exports, "MeshDistanceMaterial", ()=>MeshDistanceMaterial
);
parcelHelpers.export(exports, "MeshFaceMaterial", ()=>MeshFaceMaterial
);
parcelHelpers.export(exports, "MeshLambertMaterial", ()=>MeshLambertMaterial
);
parcelHelpers.export(exports, "MeshMatcapMaterial", ()=>MeshMatcapMaterial
);
parcelHelpers.export(exports, "MeshNormalMaterial", ()=>MeshNormalMaterial
);
parcelHelpers.export(exports, "MeshPhongMaterial", ()=>MeshPhongMaterial
);
parcelHelpers.export(exports, "MeshPhysicalMaterial", ()=>MeshPhysicalMaterial
);
parcelHelpers.export(exports, "MeshStandardMaterial", ()=>MeshStandardMaterial
);
parcelHelpers.export(exports, "MeshToonMaterial", ()=>MeshToonMaterial
);
parcelHelpers.export(exports, "MinEquation", ()=>MinEquation
);
parcelHelpers.export(exports, "MirroredRepeatWrapping", ()=>MirroredRepeatWrapping
);
parcelHelpers.export(exports, "MixOperation", ()=>MixOperation
);
parcelHelpers.export(exports, "MultiMaterial", ()=>MultiMaterial
);
parcelHelpers.export(exports, "MultiplyBlending", ()=>MultiplyBlending
);
parcelHelpers.export(exports, "MultiplyOperation", ()=>MultiplyOperation
);
parcelHelpers.export(exports, "NearestFilter", ()=>NearestFilter
);
parcelHelpers.export(exports, "NearestMipMapLinearFilter", ()=>NearestMipMapLinearFilter
);
parcelHelpers.export(exports, "NearestMipMapNearestFilter", ()=>NearestMipMapNearestFilter
);
parcelHelpers.export(exports, "NearestMipmapLinearFilter", ()=>NearestMipmapLinearFilter
);
parcelHelpers.export(exports, "NearestMipmapNearestFilter", ()=>NearestMipmapNearestFilter
);
parcelHelpers.export(exports, "NeverDepth", ()=>NeverDepth
);
parcelHelpers.export(exports, "NeverStencilFunc", ()=>NeverStencilFunc
);
parcelHelpers.export(exports, "NoBlending", ()=>NoBlending
);
parcelHelpers.export(exports, "NoColors", ()=>NoColors
);
parcelHelpers.export(exports, "NoToneMapping", ()=>NoToneMapping
);
parcelHelpers.export(exports, "NormalAnimationBlendMode", ()=>NormalAnimationBlendMode
);
parcelHelpers.export(exports, "NormalBlending", ()=>NormalBlending
);
parcelHelpers.export(exports, "NotEqualDepth", ()=>NotEqualDepth
);
parcelHelpers.export(exports, "NotEqualStencilFunc", ()=>NotEqualStencilFunc
);
parcelHelpers.export(exports, "NumberKeyframeTrack", ()=>NumberKeyframeTrack
);
parcelHelpers.export(exports, "Object3D", ()=>Object3D
);
parcelHelpers.export(exports, "ObjectLoader", ()=>ObjectLoader
);
parcelHelpers.export(exports, "ObjectSpaceNormalMap", ()=>ObjectSpaceNormalMap
);
parcelHelpers.export(exports, "OctahedronBufferGeometry", ()=>OctahedronGeometry
);
parcelHelpers.export(exports, "OctahedronGeometry", ()=>OctahedronGeometry
);
parcelHelpers.export(exports, "OneFactor", ()=>OneFactor
);
parcelHelpers.export(exports, "OneMinusDstAlphaFactor", ()=>OneMinusDstAlphaFactor
);
parcelHelpers.export(exports, "OneMinusDstColorFactor", ()=>OneMinusDstColorFactor
);
parcelHelpers.export(exports, "OneMinusSrcAlphaFactor", ()=>OneMinusSrcAlphaFactor
);
parcelHelpers.export(exports, "OneMinusSrcColorFactor", ()=>OneMinusSrcColorFactor
);
parcelHelpers.export(exports, "OrthographicCamera", ()=>OrthographicCamera
);
parcelHelpers.export(exports, "PCFShadowMap", ()=>PCFShadowMap
);
parcelHelpers.export(exports, "PCFSoftShadowMap", ()=>PCFSoftShadowMap
);
parcelHelpers.export(exports, "PMREMGenerator", ()=>PMREMGenerator
);
parcelHelpers.export(exports, "ParametricBufferGeometry", ()=>ParametricGeometry
);
parcelHelpers.export(exports, "ParametricGeometry", ()=>ParametricGeometry
);
parcelHelpers.export(exports, "Particle", ()=>Particle
);
parcelHelpers.export(exports, "ParticleBasicMaterial", ()=>ParticleBasicMaterial
);
parcelHelpers.export(exports, "ParticleSystem", ()=>ParticleSystem
);
parcelHelpers.export(exports, "ParticleSystemMaterial", ()=>ParticleSystemMaterial
);
parcelHelpers.export(exports, "Path", ()=>Path
);
parcelHelpers.export(exports, "PerspectiveCamera", ()=>PerspectiveCamera
);
parcelHelpers.export(exports, "Plane", ()=>Plane
);
parcelHelpers.export(exports, "PlaneBufferGeometry", ()=>PlaneGeometry
);
parcelHelpers.export(exports, "PlaneGeometry", ()=>PlaneGeometry
);
parcelHelpers.export(exports, "PlaneHelper", ()=>PlaneHelper
);
parcelHelpers.export(exports, "PointCloud", ()=>PointCloud
);
parcelHelpers.export(exports, "PointCloudMaterial", ()=>PointCloudMaterial
);
parcelHelpers.export(exports, "PointLight", ()=>PointLight
);
parcelHelpers.export(exports, "PointLightHelper", ()=>PointLightHelper
);
parcelHelpers.export(exports, "Points", ()=>Points
);
parcelHelpers.export(exports, "PointsMaterial", ()=>PointsMaterial
);
parcelHelpers.export(exports, "PolarGridHelper", ()=>PolarGridHelper
);
parcelHelpers.export(exports, "PolyhedronBufferGeometry", ()=>PolyhedronGeometry
);
parcelHelpers.export(exports, "PolyhedronGeometry", ()=>PolyhedronGeometry
);
parcelHelpers.export(exports, "PositionalAudio", ()=>PositionalAudio
);
parcelHelpers.export(exports, "PropertyBinding", ()=>PropertyBinding
);
parcelHelpers.export(exports, "PropertyMixer", ()=>PropertyMixer
);
parcelHelpers.export(exports, "QuadraticBezierCurve", ()=>QuadraticBezierCurve
);
parcelHelpers.export(exports, "QuadraticBezierCurve3", ()=>QuadraticBezierCurve3
);
parcelHelpers.export(exports, "Quaternion", ()=>Quaternion
);
parcelHelpers.export(exports, "QuaternionKeyframeTrack", ()=>QuaternionKeyframeTrack
);
parcelHelpers.export(exports, "QuaternionLinearInterpolant", ()=>QuaternionLinearInterpolant
);
parcelHelpers.export(exports, "REVISION", ()=>REVISION
);
parcelHelpers.export(exports, "RGBADepthPacking", ()=>RGBADepthPacking
);
parcelHelpers.export(exports, "RGBAFormat", ()=>RGBAFormat
);
parcelHelpers.export(exports, "RGBAIntegerFormat", ()=>RGBAIntegerFormat
);
parcelHelpers.export(exports, "RGBA_ASTC_10x10_Format", ()=>RGBA_ASTC_10x10_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_10x5_Format", ()=>RGBA_ASTC_10x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_10x6_Format", ()=>RGBA_ASTC_10x6_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_10x8_Format", ()=>RGBA_ASTC_10x8_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_12x10_Format", ()=>RGBA_ASTC_12x10_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_12x12_Format", ()=>RGBA_ASTC_12x12_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_4x4_Format", ()=>RGBA_ASTC_4x4_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_5x4_Format", ()=>RGBA_ASTC_5x4_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_5x5_Format", ()=>RGBA_ASTC_5x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_6x5_Format", ()=>RGBA_ASTC_6x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_6x6_Format", ()=>RGBA_ASTC_6x6_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_8x5_Format", ()=>RGBA_ASTC_8x5_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_8x6_Format", ()=>RGBA_ASTC_8x6_Format
);
parcelHelpers.export(exports, "RGBA_ASTC_8x8_Format", ()=>RGBA_ASTC_8x8_Format
);
parcelHelpers.export(exports, "RGBA_BPTC_Format", ()=>RGBA_BPTC_Format
);
parcelHelpers.export(exports, "RGBA_ETC2_EAC_Format", ()=>RGBA_ETC2_EAC_Format
);
parcelHelpers.export(exports, "RGBA_PVRTC_2BPPV1_Format", ()=>RGBA_PVRTC_2BPPV1_Format
);
parcelHelpers.export(exports, "RGBA_PVRTC_4BPPV1_Format", ()=>RGBA_PVRTC_4BPPV1_Format
);
parcelHelpers.export(exports, "RGBA_S3TC_DXT1_Format", ()=>RGBA_S3TC_DXT1_Format
);
parcelHelpers.export(exports, "RGBA_S3TC_DXT3_Format", ()=>RGBA_S3TC_DXT3_Format
);
parcelHelpers.export(exports, "RGBA_S3TC_DXT5_Format", ()=>RGBA_S3TC_DXT5_Format
);
parcelHelpers.export(exports, "RGBDEncoding", ()=>RGBDEncoding
);
parcelHelpers.export(exports, "RGBEEncoding", ()=>RGBEEncoding
);
parcelHelpers.export(exports, "RGBEFormat", ()=>RGBEFormat
);
parcelHelpers.export(exports, "RGBFormat", ()=>RGBFormat
);
parcelHelpers.export(exports, "RGBIntegerFormat", ()=>RGBIntegerFormat
);
parcelHelpers.export(exports, "RGBM16Encoding", ()=>RGBM16Encoding
);
parcelHelpers.export(exports, "RGBM7Encoding", ()=>RGBM7Encoding
);
parcelHelpers.export(exports, "RGB_ETC1_Format", ()=>RGB_ETC1_Format
);
parcelHelpers.export(exports, "RGB_ETC2_Format", ()=>RGB_ETC2_Format
);
parcelHelpers.export(exports, "RGB_PVRTC_2BPPV1_Format", ()=>RGB_PVRTC_2BPPV1_Format
);
parcelHelpers.export(exports, "RGB_PVRTC_4BPPV1_Format", ()=>RGB_PVRTC_4BPPV1_Format
);
parcelHelpers.export(exports, "RGB_S3TC_DXT1_Format", ()=>RGB_S3TC_DXT1_Format
);
parcelHelpers.export(exports, "RGFormat", ()=>RGFormat
);
parcelHelpers.export(exports, "RGIntegerFormat", ()=>RGIntegerFormat
);
parcelHelpers.export(exports, "RawShaderMaterial", ()=>RawShaderMaterial
);
parcelHelpers.export(exports, "Ray", ()=>Ray
);
parcelHelpers.export(exports, "Raycaster", ()=>Raycaster
);
parcelHelpers.export(exports, "RectAreaLight", ()=>RectAreaLight
);
parcelHelpers.export(exports, "RedFormat", ()=>RedFormat
);
parcelHelpers.export(exports, "RedIntegerFormat", ()=>RedIntegerFormat
);
parcelHelpers.export(exports, "ReinhardToneMapping", ()=>ReinhardToneMapping
);
parcelHelpers.export(exports, "RepeatWrapping", ()=>RepeatWrapping
);
parcelHelpers.export(exports, "ReplaceStencilOp", ()=>ReplaceStencilOp
);
parcelHelpers.export(exports, "ReverseSubtractEquation", ()=>ReverseSubtractEquation
);
parcelHelpers.export(exports, "RingBufferGeometry", ()=>RingGeometry
);
parcelHelpers.export(exports, "RingGeometry", ()=>RingGeometry
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x10_Format", ()=>SRGB8_ALPHA8_ASTC_10x10_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x5_Format", ()=>SRGB8_ALPHA8_ASTC_10x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x6_Format", ()=>SRGB8_ALPHA8_ASTC_10x6_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_10x8_Format", ()=>SRGB8_ALPHA8_ASTC_10x8_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_12x10_Format", ()=>SRGB8_ALPHA8_ASTC_12x10_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_12x12_Format", ()=>SRGB8_ALPHA8_ASTC_12x12_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_4x4_Format", ()=>SRGB8_ALPHA8_ASTC_4x4_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_5x4_Format", ()=>SRGB8_ALPHA8_ASTC_5x4_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_5x5_Format", ()=>SRGB8_ALPHA8_ASTC_5x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_6x5_Format", ()=>SRGB8_ALPHA8_ASTC_6x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_6x6_Format", ()=>SRGB8_ALPHA8_ASTC_6x6_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_8x5_Format", ()=>SRGB8_ALPHA8_ASTC_8x5_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_8x6_Format", ()=>SRGB8_ALPHA8_ASTC_8x6_Format
);
parcelHelpers.export(exports, "SRGB8_ALPHA8_ASTC_8x8_Format", ()=>SRGB8_ALPHA8_ASTC_8x8_Format
);
parcelHelpers.export(exports, "Scene", ()=>Scene
);
parcelHelpers.export(exports, "SceneUtils", ()=>SceneUtils
);
parcelHelpers.export(exports, "ShaderChunk", ()=>ShaderChunk
);
parcelHelpers.export(exports, "ShaderLib", ()=>ShaderLib
);
parcelHelpers.export(exports, "ShaderMaterial", ()=>ShaderMaterial
);
parcelHelpers.export(exports, "ShadowMaterial", ()=>ShadowMaterial
);
parcelHelpers.export(exports, "Shape", ()=>Shape
);
parcelHelpers.export(exports, "ShapeBufferGeometry", ()=>ShapeGeometry
);
parcelHelpers.export(exports, "ShapeGeometry", ()=>ShapeGeometry
);
parcelHelpers.export(exports, "ShapePath", ()=>ShapePath
);
parcelHelpers.export(exports, "ShapeUtils", ()=>ShapeUtils
);
parcelHelpers.export(exports, "ShortType", ()=>ShortType
);
parcelHelpers.export(exports, "Skeleton", ()=>Skeleton
);
parcelHelpers.export(exports, "SkeletonHelper", ()=>SkeletonHelper
);
parcelHelpers.export(exports, "SkinnedMesh", ()=>SkinnedMesh
);
parcelHelpers.export(exports, "SmoothShading", ()=>SmoothShading
);
parcelHelpers.export(exports, "Sphere", ()=>Sphere
);
parcelHelpers.export(exports, "SphereBufferGeometry", ()=>SphereGeometry
);
parcelHelpers.export(exports, "SphereGeometry", ()=>SphereGeometry
);
parcelHelpers.export(exports, "Spherical", ()=>Spherical
);
parcelHelpers.export(exports, "SphericalHarmonics3", ()=>SphericalHarmonics3
);
parcelHelpers.export(exports, "Spline", ()=>Spline
);
parcelHelpers.export(exports, "SplineCurve", ()=>SplineCurve
);
parcelHelpers.export(exports, "SplineCurve3", ()=>SplineCurve3
);
parcelHelpers.export(exports, "SpotLight", ()=>SpotLight
);
parcelHelpers.export(exports, "SpotLightHelper", ()=>SpotLightHelper
);
parcelHelpers.export(exports, "Sprite", ()=>Sprite
);
parcelHelpers.export(exports, "SpriteMaterial", ()=>SpriteMaterial
);
parcelHelpers.export(exports, "SrcAlphaFactor", ()=>SrcAlphaFactor
);
parcelHelpers.export(exports, "SrcAlphaSaturateFactor", ()=>SrcAlphaSaturateFactor
);
parcelHelpers.export(exports, "SrcColorFactor", ()=>SrcColorFactor
);
parcelHelpers.export(exports, "StaticCopyUsage", ()=>StaticCopyUsage
);
parcelHelpers.export(exports, "StaticDrawUsage", ()=>StaticDrawUsage
);
parcelHelpers.export(exports, "StaticReadUsage", ()=>StaticReadUsage
);
parcelHelpers.export(exports, "StereoCamera", ()=>StereoCamera
);
parcelHelpers.export(exports, "StreamCopyUsage", ()=>StreamCopyUsage
);
parcelHelpers.export(exports, "StreamDrawUsage", ()=>StreamDrawUsage
);
parcelHelpers.export(exports, "StreamReadUsage", ()=>StreamReadUsage
);
parcelHelpers.export(exports, "StringKeyframeTrack", ()=>StringKeyframeTrack
);
parcelHelpers.export(exports, "SubtractEquation", ()=>SubtractEquation
);
parcelHelpers.export(exports, "SubtractiveBlending", ()=>SubtractiveBlending
);
parcelHelpers.export(exports, "TOUCH", ()=>TOUCH
);
parcelHelpers.export(exports, "TangentSpaceNormalMap", ()=>TangentSpaceNormalMap
);
parcelHelpers.export(exports, "TetrahedronBufferGeometry", ()=>TetrahedronGeometry
);
parcelHelpers.export(exports, "TetrahedronGeometry", ()=>TetrahedronGeometry
);
parcelHelpers.export(exports, "TextBufferGeometry", ()=>TextGeometry
);
parcelHelpers.export(exports, "TextGeometry", ()=>TextGeometry
);
parcelHelpers.export(exports, "Texture", ()=>Texture
);
parcelHelpers.export(exports, "TextureLoader", ()=>TextureLoader
);
parcelHelpers.export(exports, "TorusBufferGeometry", ()=>TorusGeometry
);
parcelHelpers.export(exports, "TorusGeometry", ()=>TorusGeometry
);
parcelHelpers.export(exports, "TorusKnotBufferGeometry", ()=>TorusKnotGeometry
);
parcelHelpers.export(exports, "TorusKnotGeometry", ()=>TorusKnotGeometry
);
parcelHelpers.export(exports, "Triangle", ()=>Triangle
);
parcelHelpers.export(exports, "TriangleFanDrawMode", ()=>TriangleFanDrawMode
);
parcelHelpers.export(exports, "TriangleStripDrawMode", ()=>TriangleStripDrawMode
);
parcelHelpers.export(exports, "TrianglesDrawMode", ()=>TrianglesDrawMode
);
parcelHelpers.export(exports, "TubeBufferGeometry", ()=>TubeGeometry
);
parcelHelpers.export(exports, "TubeGeometry", ()=>TubeGeometry
);
parcelHelpers.export(exports, "UVMapping", ()=>UVMapping
);
parcelHelpers.export(exports, "Uint16Attribute", ()=>Uint16Attribute
);
parcelHelpers.export(exports, "Uint16BufferAttribute", ()=>Uint16BufferAttribute
);
parcelHelpers.export(exports, "Uint32Attribute", ()=>Uint32Attribute
);
parcelHelpers.export(exports, "Uint32BufferAttribute", ()=>Uint32BufferAttribute
);
parcelHelpers.export(exports, "Uint8Attribute", ()=>Uint8Attribute
);
parcelHelpers.export(exports, "Uint8BufferAttribute", ()=>Uint8BufferAttribute
);
parcelHelpers.export(exports, "Uint8ClampedAttribute", ()=>Uint8ClampedAttribute
);
parcelHelpers.export(exports, "Uint8ClampedBufferAttribute", ()=>Uint8ClampedBufferAttribute
);
parcelHelpers.export(exports, "Uniform", ()=>Uniform
);
parcelHelpers.export(exports, "UniformsLib", ()=>UniformsLib
);
parcelHelpers.export(exports, "UniformsUtils", ()=>UniformsUtils
);
parcelHelpers.export(exports, "UnsignedByteType", ()=>UnsignedByteType
);
parcelHelpers.export(exports, "UnsignedInt248Type", ()=>UnsignedInt248Type
);
parcelHelpers.export(exports, "UnsignedIntType", ()=>UnsignedIntType
);
parcelHelpers.export(exports, "UnsignedShort4444Type", ()=>UnsignedShort4444Type
);
parcelHelpers.export(exports, "UnsignedShort5551Type", ()=>UnsignedShort5551Type
);
parcelHelpers.export(exports, "UnsignedShort565Type", ()=>UnsignedShort565Type
);
parcelHelpers.export(exports, "UnsignedShortType", ()=>UnsignedShortType
);
parcelHelpers.export(exports, "VSMShadowMap", ()=>VSMShadowMap
);
parcelHelpers.export(exports, "Vector2", ()=>Vector2
);
parcelHelpers.export(exports, "Vector3", ()=>Vector3
);
parcelHelpers.export(exports, "Vector4", ()=>Vector4
);
parcelHelpers.export(exports, "VectorKeyframeTrack", ()=>VectorKeyframeTrack
);
parcelHelpers.export(exports, "Vertex", ()=>Vertex
);
parcelHelpers.export(exports, "VertexColors", ()=>VertexColors
);
parcelHelpers.export(exports, "VideoTexture", ()=>VideoTexture
);
parcelHelpers.export(exports, "WebGL1Renderer", ()=>WebGL1Renderer
);
parcelHelpers.export(exports, "WebGLCubeRenderTarget", ()=>WebGLCubeRenderTarget
);
parcelHelpers.export(exports, "WebGLMultisampleRenderTarget", ()=>WebGLMultisampleRenderTarget
);
parcelHelpers.export(exports, "WebGLRenderTarget", ()=>WebGLRenderTarget
);
parcelHelpers.export(exports, "WebGLRenderTargetCube", ()=>WebGLRenderTargetCube
);
parcelHelpers.export(exports, "WebGLRenderer", ()=>WebGLRenderer
);
parcelHelpers.export(exports, "WebGLUtils", ()=>WebGLUtils
);
parcelHelpers.export(exports, "WireframeGeometry", ()=>WireframeGeometry
);
parcelHelpers.export(exports, "WireframeHelper", ()=>WireframeHelper
);
parcelHelpers.export(exports, "WrapAroundEnding", ()=>WrapAroundEnding
);
parcelHelpers.export(exports, "XHRLoader", ()=>XHRLoader
);
parcelHelpers.export(exports, "ZeroCurvatureEnding", ()=>ZeroCurvatureEnding
);
parcelHelpers.export(exports, "ZeroFactor", ()=>ZeroFactor
);
parcelHelpers.export(exports, "ZeroSlopeEnding", ()=>ZeroSlopeEnding
);
parcelHelpers.export(exports, "ZeroStencilOp", ()=>ZeroStencilOp
);
parcelHelpers.export(exports, "sRGBEncoding", ()=>sRGBEncoding
);
// threejs.org/license
const REVISION = '125';
const MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
};
const TOUCH = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
};
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const SmoothShading = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;
const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;
const GLSL1 = '100';
const GLSL3 = '300 es';
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */ function EventDispatcher() {
}
Object.assign(EventDispatcher.prototype, {
    addEventListener: function(type, listener) {
        if (this._listeners === undefined) this._listeners = {
        };
        const listeners = this._listeners;
        if (listeners[type] === undefined) listeners[type] = [];
        if (listeners[type].indexOf(listener) === -1) listeners[type].push(listener);
    },
    hasEventListener: function(type, listener) {
        if (this._listeners === undefined) return false;
        const listeners = this._listeners;
        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    },
    removeEventListener: function(type, listener) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) listenerArray.splice(index, 1);
        }
    },
    dispatchEvent: function(event) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            // Make a copy, in case listeners are removed while iterating.
            const array = listenerArray.slice(0);
            for(let i = 0, l = array.length; i < l; i++)array[i].call(this, event);
        }
    }
});
const _lut = [];
for(let i = 0; i < 256; i++)_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
let _seed = 1234567;
const MathUtils = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
        const d0 = Math.random() * 4294967295 | 0;
        const d1 = Math.random() * 4294967295 | 0;
        const d2 = Math.random() * 4294967295 | 0;
        const d3 = Math.random() * 4294967295 | 0;
        const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + '-' + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + '-' + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + '-' + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + '-' + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
        // .toUpperCase() here flattens concatenated strings to save heap memory space.
        return uuid.toUpperCase();
    },
    clamp: function(value, min, max) {
        return Math.max(min, Math.min(max, value));
    },
    // compute euclidian modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation
    euclideanModulo: function(n, m) {
        return (n % m + m) % m;
    },
    // Linear mapping from range <a1, a2> to range <b1, b2>
    mapLinear: function(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    },
    // https://en.wikipedia.org/wiki/Linear_interpolation
    lerp: function(x, y, t) {
        return (1 - t) * x + t * y;
    },
    // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
    damp: function(x, y, lambda, dt) {
        return MathUtils.lerp(x, y, 1 - Math.exp(-lambda * dt));
    },
    // https://www.desmos.com/calculator/vcsjnyz7x4
    pingpong: function(x, length = 1) {
        return length - Math.abs(MathUtils.euclideanModulo(x, length * 2) - length);
    },
    // http://en.wikipedia.org/wiki/Smoothstep
    smoothstep: function(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
    },
    smootherstep: function(x, min, max) {
        if (x <= min) return 0;
        if (x >= max) return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
    },
    // Random integer from <low, high> interval
    randInt: function(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
    },
    // Random float from <low, high> interval
    randFloat: function(low, high) {
        return low + Math.random() * (high - low);
    },
    // Random float from <-range/2, range/2> interval
    randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
    },
    // Deterministic pseudo-random float in the interval [ 0, 1 ]
    seededRandom: function(s) {
        if (s !== undefined) _seed = s % 2147483647;
        // Park-Miller algorithm
        _seed = _seed * 16807 % 2147483647;
        return (_seed - 1) / 2147483646;
    },
    degToRad: function(degrees) {
        return degrees * MathUtils.DEG2RAD;
    },
    radToDeg: function(radians) {
        return radians * MathUtils.RAD2DEG;
    },
    isPowerOfTwo: function(value) {
        return (value & value - 1) === 0 && value !== 0;
    },
    ceilPowerOfTwo: function(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    },
    floorPowerOfTwo: function(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    },
    setQuaternionFromProperEuler: function(q, a, b, c, order) {
        // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
        // rotations are applied to the axes in the order specified by 'order'
        // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
        // angles are in radians
        const cos = Math.cos;
        const sin = Math.sin;
        const c2 = cos(b / 2);
        const s2 = sin(b / 2);
        const c13 = cos((a + c) / 2);
        const s13 = sin((a + c) / 2);
        const c1_3 = cos((a - c) / 2);
        const s1_3 = sin((a - c) / 2);
        const c3_1 = cos((c - a) / 2);
        const s3_1 = sin((c - a) / 2);
        switch(order){
            case 'XYX':
                q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                break;
            case 'YZY':
                q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                break;
            case 'ZXZ':
                q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                break;
            case 'XZX':
                q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                break;
            case 'YXY':
                q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                break;
            case 'ZYZ':
                q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                break;
            default:
                console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
        }
    }
};
class Vector2 {
    constructor(x1 = 0, y1 = 0){
        Object.defineProperty(this, 'isVector2', {
            value: true
        });
        this.x = x1;
        this.y = y1;
    }
    get width() {
        return this.x;
    }
    set width(value) {
        this.x = value;
    }
    get height() {
        return this.y;
    }
    set height(value) {
        this.y = value;
    }
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
        const x2 = this.x, y2 = this.y;
        const e = m.elements;
        this.x = e[0] * x2 + e[3] * y2 + e[6];
        this.y = e[1] * x2 + e[4] * y2 + e[7];
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        // computes the angle in radians with respect to the positive x-axis
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
    }
    rotateAround(center, angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        const x2 = this.x - center.x;
        const y2 = this.y - center.y;
        this.x = x2 * c - y2 * s + center.x;
        this.y = x2 * s + y2 * c + center.y;
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
    }
}
class Matrix3 {
    constructor(){
        Object.defineProperty(this, 'isMatrix3', {
            value: true
        });
        this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    }
    clone() {
        return new this.constructor().fromArray(this.elements);
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
    }
    setFromMatrix4(m) {
        const me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
    }
    multiply(m) {
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i1 = te[8];
        return a * e * i1 - a * f * h - b * d * i1 + b * f * g + c * d * h - c * e * g;
    }
    invert() {
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    }
    transpose() {
        let tmp;
        const m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
    }
    getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).copy(this).invert().transpose();
    }
    transposeIntoArray(r) {
        const m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        return this;
    }
    scale(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
    }
    rotate(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        const te = this.elements;
        const a11 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s * a21;
        te[3] = c * a12 + s * a22;
        te[6] = c * a13 + s * a23;
        te[1] = -s * a11 + c * a21;
        te[4] = -s * a12 + c * a22;
        te[7] = -s * a13 + c * a23;
        return this;
    }
    translate(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i1 = 0; i1 < 9; i1++){
            if (te[i1] !== me[i1]) return false;
        }
        return true;
    }
    fromArray(array, offset = 0) {
        for(let i1 = 0; i1 < 9; i1++)this.elements[i1] = array[i1 + offset];
        return this;
    }
    toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    }
}
let _canvas;
const ImageUtils = {
    getDataURL: function(image) {
        if (/^data:/i.test(image.src)) return image.src;
        if (typeof HTMLCanvasElement == 'undefined') return image.src;
        let canvas;
        if (image instanceof HTMLCanvasElement) canvas = image;
        else {
            if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext('2d');
            if (image instanceof ImageData) context.putImageData(image, 0, 0);
            else context.drawImage(image, 0, 0, image.width, image.height);
            canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) return canvas.toDataURL('image/jpeg', 0.6);
        else return canvas.toDataURL('image/png');
    }
};
let textureId = 0;
function Texture(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    Object.defineProperty(this, 'id', {
        value: textureId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    //
    // Also changing the encoding after already used by a Material will not automatically make the Material
    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
    this.encoding = encoding;
    this.version = 0;
    this.onUpdate = null;
}
Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Texture,
    isTexture: true,
    updateMatrix: function() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
    },
    toJSON: function(meta) {
        const isRootObject = meta === undefined || typeof meta === 'string';
        if (!isRootObject && meta.textures[this.uuid] !== undefined) return meta.textures[this.uuid];
        const output = {
            metadata: {
                version: 4.5,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            center: [
                this.center.x,
                this.center.y
            ],
            rotation: this.rotation,
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        if (this.image !== undefined) {
            // TODO: Move to THREE.Image
            const image = this.image;
            if (image.uuid === undefined) image.uuid = MathUtils.generateUUID(); // UGH
            if (!isRootObject && meta.images[image.uuid] === undefined) {
                let url;
                if (Array.isArray(image)) {
                    // process array of images e.g. CubeTexture
                    url = [];
                    for(let i1 = 0, l = image.length; i1 < l; i1++)// check cube texture with data textures
                    if (image[i1].isDataTexture) url.push(serializeImage(image[i1].image));
                    else url.push(serializeImage(image[i1]));
                } else // process single image
                url = serializeImage(image);
                meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: url
                };
            }
            output.image = image.uuid;
        }
        if (!isRootObject) meta.textures[this.uuid] = output;
        return output;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    },
    transformUv: function(uv) {
        if (this.mapping !== UVMapping) return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) switch(this.wrapS){
            case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
            case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) uv.x = Math.ceil(uv.x) - uv.x;
                else uv.x = uv.x - Math.floor(uv.x);
                break;
        }
        if (uv.y < 0 || uv.y > 1) switch(this.wrapT){
            case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
            case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) uv.y = Math.ceil(uv.y) - uv.y;
                else uv.y = uv.y - Math.floor(uv.y);
                break;
        }
        if (this.flipY) uv.y = 1 - uv.y;
        return uv;
    }
});
Object.defineProperty(Texture.prototype, 'needsUpdate', {
    set: function(value) {
        if (value === true) this.version++;
    }
});
function serializeImage(image) {
    if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) // default images
    return ImageUtils.getDataURL(image);
    else {
        if (image.data) // images of DataTexture
        return {
            data: Array.prototype.slice.call(image.data),
            width: image.width,
            height: image.height,
            type: image.data.constructor.name
        };
        else {
            console.warn('THREE.Texture: Unable to serialize Texture.');
            return {
            };
        }
    }
}
class Vector4 {
    constructor(x2 = 0, y2 = 0, z1 = 0, w1 = 1){
        Object.defineProperty(this, 'isVector4', {
            value: true
        });
        this.x = x2;
        this.y = y2;
        this.z = z1;
        this.w = w1;
    }
    get width() {
        return this.z;
    }
    set width(value) {
        this.z = value;
    }
    get height() {
        return this.w;
    }
    set height(value) {
        this.w = value;
    }
    set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setW(w) {
        this.w = w;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        this.w *= v.w;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
    }
    applyMatrix4(m) {
        const x3 = this.x, y3 = this.y, z2 = this.z, w2 = this.w;
        const e = m.elements;
        this.x = e[0] * x3 + e[4] * y3 + e[8] * z2 + e[12] * w2;
        this.y = e[1] * x3 + e[5] * y3 + e[9] * z2 + e[13] * w2;
        this.z = e[2] * x3 + e[6] * y3 + e[10] * z2 + e[14] * w2;
        this.w = e[3] * x3 + e[7] * y3 + e[11] * z2 + e[15] * w2;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
        // q is assumed to be normalized
        this.w = 2 * Math.acos(q.w);
        const s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
        }
        return this;
    }
    setAxisAngleFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        let angle, x3, y3, z2; // variables for result
        const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                // this singularity is identity matrix so angle = 0
                this.set(1, 0, 0, 0);
                return this; // zero angle, arbitrary axis
            }
            // otherwise this singularity is angle = 180
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
                // m11 is the largest diagonal term
                if (xx < epsilon) {
                    x3 = 0;
                    y3 = 0.707106781;
                    z2 = 0.707106781;
                } else {
                    x3 = Math.sqrt(xx);
                    y3 = xy / x3;
                    z2 = xz / x3;
                }
            } else if (yy > zz) {
                // m22 is the largest diagonal term
                if (yy < epsilon) {
                    x3 = 0.707106781;
                    y3 = 0;
                    z2 = 0.707106781;
                } else {
                    y3 = Math.sqrt(yy);
                    x3 = xy / y3;
                    z2 = yz / y3;
                }
            } else // m33 is the largest diagonal term so base result on this
            if (zz < epsilon) {
                x3 = 0.707106781;
                y3 = 0.707106781;
                z2 = 0;
            } else {
                z2 = Math.sqrt(zz);
                x3 = xz / z2;
                y3 = yz / z2;
            }
            this.set(x3, y3, z2, angle);
            return this; // return 180 deg rotation
        }
        // as we have reached here there are no singularities so we can handle normally
        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize
        if (Math.abs(s) < 0.001) s = 1;
        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
    }
}
/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/ class WebGLRenderTarget extends EventDispatcher {
    constructor(width1, height1, options){
        super();
        Object.defineProperty(this, 'isWebGLRenderTarget', {
            value: true
        });
        this.width = width1;
        this.height = height1;
        this.scissor = new Vector4(0, 0, width1, height1);
        this.scissorTest = false;
        this.viewport = new Vector4(0, 0, width1, height1);
        options = options || {
        };
        this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.texture.image = {
        };
        this.texture.image.width = width1;
        this.texture.image.height = height1;
        this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
        this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
        this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
        this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    }
    setSize(width, height) {
        if (this.width !== width || this.height !== height) {
            this.width = width;
            this.height = height;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.width = source.width;
        this.height = source.height;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
    }
    dispose() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
}
class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
    constructor(width2, height2, options1){
        super(width2, height2, options1);
        Object.defineProperty(this, 'isWebGLMultisampleRenderTarget', {
            value: true
        });
        this.samples = 4;
    }
    copy(source) {
        super.copy.call(this, source);
        this.samples = source.samples;
        return this;
    }
}
class Quaternion {
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 1){
        Object.defineProperty(this, 'isQuaternion', {
            value: true
        });
        this._x = x3;
        this._y = y3;
        this._z = z2;
        this._w = w2;
    }
    static slerp(qa, qb, qm, t) {
        return qm.copy(qa).slerp(qb, t);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        // fuzz-free, array-based Quaternion SLERP operation
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x11 = src1[srcOffset1 + 0], y11 = src1[srcOffset1 + 1], z11 = src1[srcOffset1 + 2], w11 = src1[srcOffset1 + 3];
        if (w0 !== w11 || x0 !== x11 || y0 !== y11 || z0 !== z11) {
            let s = 1 - t;
            const cos = x0 * x11 + y0 * y11 + z0 * z11 + w0 * w11, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            // Skip the Slerp for tiny steps to avoid numeric problems:
            if (sqrSin > Number.EPSILON) {
                const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                s = Math.sin(s * len) / sin;
                t = Math.sin(t * len) / sin;
            }
            const tDir = t * dir;
            x0 = x0 * s + x11 * tDir;
            y0 = y0 * s + y11 * tDir;
            z0 = z0 * s + z11 * tDir;
            w0 = w0 * s + w11 * tDir;
            // Normalize in case we just did a lerp:
            if (s === 1 - t) {
                const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f;
                y0 *= f;
                z0 *= f;
                w0 *= f;
            }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x11 = src1[srcOffset1];
        const y11 = src1[srcOffset1 + 1];
        const z11 = src1[srcOffset1 + 2];
        const w11 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w11 + w0 * x11 + y0 * z11 - z0 * y11;
        dst[dstOffset + 1] = y0 * w11 + w0 * y11 + z0 * x11 - x0 * z11;
        dst[dstOffset + 2] = z0 * w11 + w0 * z11 + x0 * y11 - y0 * x11;
        dst[dstOffset + 3] = w0 * w11 - x0 * x11 - y0 * y11 - z0 * z11;
        return dst;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(value) {
        this._w = value;
        this._onChangeCallback();
    }
    set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
    }
    setFromEuler(euler, update) {
        if (!(euler && euler.isEuler)) throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
        const x4 = euler._x, y4 = euler._y, z3 = euler._z, order = euler._order;
        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x4 / 2);
        const c2 = cos(y4 / 2);
        const c3 = cos(z3 / 2);
        const s1 = sin(x4 / 2);
        const s2 = sin(y4 / 2);
        const s3 = sin(z3 / 2);
        switch(order){
            case 'XYZ':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'YXZ':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case 'ZXY':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'ZYX':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case 'YZX':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'XZY':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            default:
                console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
        }
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromAxisAngle(axis, angle) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
        // assumes axis is normalized
        const halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
            const s = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
            const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
            const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
        } else {
            const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
        }
        this._onChangeCallback();
        return this;
    }
    setFromUnitVectors(vFrom, vTo) {
        // assumes direction vectors vFrom and vTo are normalized
        const EPS = 0.000001;
        let r = vFrom.dot(vTo) + 1;
        if (r < EPS) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                this._x = -vFrom.y;
                this._y = vFrom.x;
                this._z = 0;
                this._w = r;
            } else {
                this._x = 0;
                this._y = -vFrom.z;
                this._z = vFrom.y;
                this._w = r;
            }
        } else {
            // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r;
        }
        return this.normalize();
    }
    angleTo(q) {
        return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
        const angle = this.angleTo(q);
        if (angle === 0) return this;
        const t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    invert() {
        // quaternion is assumed to have unit length
        return this.conjugate();
    }
    conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
    }
    dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
        let l = this.length();
        if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
    }
    multiply(q, p) {
        if (p !== undefined) {
            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
        return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
    }
    slerp(qb, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(qb);
        const x4 = this._x, y4 = this._y, z3 = this._z, w3 = this._w;
        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
        let cosHalfTheta = w3 * qb._w + x4 * qb._x + y4 * qb._y + z3 * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
        } else this.copy(qb);
        if (cosHalfTheta >= 1) {
            this._w = w3;
            this._x = x4;
            this._y = y4;
            this._z = z3;
            return this;
        }
        const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
            const s = 1 - t;
            this._w = s * w3 + t * this._w;
            this._x = s * x4 + t * this._x;
            this._y = s * y4 + t * this._y;
            this._z = s * z3 + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w3 * ratioA + this._w * ratioB;
        this._x = x4 * ratioA + this._x * ratioB;
        this._y = y4 * ratioA + this._y * ratioB;
        this._z = z3 * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
    }
    equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        return this;
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {
    }
}
class Vector3 {
    constructor(x4 = 0, y4 = 0, z3 = 0){
        Object.defineProperty(this, 'isVector3', {
            value: true
        });
        this.x = x4;
        this.y = y4;
        this.z = z3;
    }
    set(x, y, z) {
        if (z === undefined) z = this.z; // sprite.scale.set(x,y)
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    }
    multiply(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
    }
    multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    }
    applyEuler(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
        return this.applyQuaternion(_quaternion.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
        return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
        const x5 = this.x, y5 = this.y, z4 = this.z;
        const e = m.elements;
        this.x = e[0] * x5 + e[3] * y5 + e[6] * z4;
        this.y = e[1] * x5 + e[4] * y5 + e[7] * z4;
        this.z = e[2] * x5 + e[5] * y5 + e[8] * z4;
        return this;
    }
    applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
        const x5 = this.x, y5 = this.y, z4 = this.z;
        const e = m.elements;
        const w3 = 1 / (e[3] * x5 + e[7] * y5 + e[11] * z4 + e[15]);
        this.x = (e[0] * x5 + e[4] * y5 + e[8] * z4 + e[12]) * w3;
        this.y = (e[1] * x5 + e[5] * y5 + e[9] * z4 + e[13]) * w3;
        this.z = (e[2] * x5 + e[6] * y5 + e[10] * z4 + e[14]) * w3;
        return this;
    }
    applyQuaternion(q) {
        const x5 = this.x, y5 = this.y, z4 = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        // calculate quat * vector
        const ix = qw * x5 + qy * z4 - qz * y5;
        const iy = qw * y5 + qz * x5 - qx * z4;
        const iz = qw * z4 + qx * y5 - qy * x5;
        const iw = -qx * x5 - qy * y5 - qz * z4;
        // calculate result * inverse quat
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
    }
    project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction
        const x5 = this.x, y5 = this.y, z4 = this.z;
        const e = m.elements;
        this.x = e[0] * x5 + e[4] * y5 + e[8] * z4;
        this.y = e[1] * x5 + e[5] * y5 + e[9] * z4;
        this.z = e[2] * x5 + e[6] * y5 + e[10] * z4;
        return this.normalize();
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    // TODO lengthSquared?
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
    }
    cross(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
            return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    }
    projectOnVector(v) {
        const denominator = v.lengthSq();
        if (denominator === 0) return this.set(0, 0, 0);
        const scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
        _vector.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector);
    }
    reflect(normal) {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length
        return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        const theta = this.dot(v) / denominator;
        // clamp, to handle numerical problems
        return Math.acos(MathUtils.clamp(theta, -1, 1));
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
    }
    setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
    }
    setFromMatrixPosition(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
    }
    setFromMatrixScale(m) {
        const sx = this.setFromMatrixColumn(m, 0).length();
        const sy = this.setFromMatrixColumn(m, 1).length();
        const sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    }
    setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
    }
}
const _vector = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new Quaternion();
class Box3 {
    constructor(min1, max1){
        Object.defineProperty(this, 'isBox3', {
            value: true
        });
        this.min = min1 !== undefined ? min1 : new Vector3(Infinity, Infinity, Infinity);
        this.max = max1 !== undefined ? max1 : new Vector3(-Infinity, -Infinity, -Infinity);
    }
    set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    }
    setFromArray(array) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i1 = 0, l = array.length; i1 < l; i1 += 3){
            const x5 = array[i1];
            const y5 = array[i1 + 1];
            const z4 = array[i1 + 2];
            if (x5 < minX) minX = x5;
            if (y5 < minY) minY = y5;
            if (z4 < minZ) minZ = z4;
            if (x5 > maxX) maxX = x5;
            if (y5 > maxY) maxY = y5;
            if (z4 > maxZ) maxZ = z4;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    }
    setFromBufferAttribute(attribute) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i1 = 0, l = attribute.count; i1 < l; i1++){
            const x5 = attribute.getX(i1);
            const y5 = attribute.getY(i1);
            const z4 = attribute.getZ(i1);
            if (x5 < minX) minX = x5;
            if (y5 < minY) minY = y5;
            if (z4 < minZ) minZ = z4;
            if (x5 > maxX) maxX = x5;
            if (y5 > maxY) maxY = y5;
            if (z4 > maxZ) maxZ = z4;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    }
    setFromPoints(points) {
        this.makeEmpty();
        for(let i1 = 0, il = points.length; i1 < il; i1++)this.expandByPoint(points[i1]);
        return this;
    }
    setFromCenterAndSize(center, size) {
        const halfSize = _vector$1.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    }
    setFromObject(object) {
        this.makeEmpty();
        return this.expandByObject(object);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    }
    makeEmpty() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    }
    isEmpty() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .getCenter() target is now required');
            target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .getSize() target is now required');
            target = new Vector3();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    }
    expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    }
    expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    }
    expandByObject(object) {
        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== undefined) {
            if (geometry.boundingBox === null) geometry.computeBoundingBox();
            _box.copy(geometry.boundingBox);
            _box.applyMatrix4(object.matrixWorld);
            this.union(_box);
        }
        const children = object.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)this.expandByObject(children[i1]);
        return this;
    }
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        if (target === undefined) {
            console.warn('THREE.Box3: .getParameter() target is now required');
            target = new Vector3();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(box) {
        // using 6 splitting planes to rule out intersections.
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
    intersectsSphere(sphere) {
        // Find the point on the AABB closest to the sphere center.
        this.clampPoint(sphere.center, _vector$1);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        let min2, max2;
        if (plane.normal.x > 0) {
            min2 = plane.normal.x * this.min.x;
            max2 = plane.normal.x * this.max.x;
        } else {
            min2 = plane.normal.x * this.max.x;
            max2 = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
            min2 += plane.normal.y * this.min.y;
            max2 += plane.normal.y * this.max.y;
        } else {
            min2 += plane.normal.y * this.max.y;
            max2 += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
            min2 += plane.normal.z * this.min.z;
            max2 += plane.normal.z * this.max.z;
        } else {
            min2 += plane.normal.z * this.max.z;
            max2 += plane.normal.z * this.min.z;
        }
        return min2 <= -plane.constant && max2 >= -plane.constant;
    }
    intersectsTriangle(triangle) {
        if (this.isEmpty()) return false;
        // compute box center and extents
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        // translate triangle to aabb origin
        _v0.subVectors(triangle.a, _center);
        _v1.subVectors(triangle.b, _center);
        _v2.subVectors(triangle.c, _center);
        // compute edge vectors for triangle
        _f0.subVectors(_v1, _v0);
        _f1.subVectors(_v2, _v1);
        _f2.subVectors(_v0, _v2);
        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        let axes = [
            0,
            -_f0.z,
            _f0.y,
            0,
            -_f1.z,
            _f1.y,
            0,
            -_f2.z,
            _f2.y,
            _f0.z,
            0,
            -_f0.x,
            _f1.z,
            0,
            -_f1.x,
            _f2.z,
            0,
            -_f2.x,
            -_f0.y,
            _f0.x,
            0,
            -_f1.y,
            _f1.x,
            0,
            -_f2.y,
            _f2.x,
            0
        ];
        if (!satForAxes(axes, _v0, _v1, _v2, _extents)) return false;
        // test 3 face normals from the aabb
        axes = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (!satForAxes(axes, _v0, _v1, _v2, _extents)) return false;
        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [
            _triangleNormal.x,
            _triangleNormal.y,
            _triangleNormal.z
        ];
        return satForAxes(axes, _v0, _v1, _v2, _extents);
    }
    clampPoint(point, target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .clampPoint() target is now required');
            target = new Vector3();
        }
        return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
        const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    }
    getBoundingSphere(target) {
        if (target === undefined) console.error('THREE.Box3: .getBoundingSphere() target is now required');
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$1).length() * 0.5;
        return target;
    }
    intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if (this.isEmpty()) this.makeEmpty();
        return this;
    }
    union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    }
    applyMatrix4(matrix) {
        // transform of empty box is an empty box.
        if (this.isEmpty()) return this;
        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
        this.setFromPoints(_points);
        return this;
    }
    translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
}
function satForAxes(axes, v0, v1, v2, extents) {
    for(let i1 = 0, j = axes.length - 3; i1 <= j; i1 += 3){
        _testAxis.fromArray(axes, i1);
        // project the aabb onto the seperating axis
        const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
        // project all 3 vertices of the triangle onto the seperating axis
        const p0 = v0.dot(_testAxis);
        const p1 = v1.dot(_testAxis);
        const p2 = v2.dot(_testAxis);
        // actual test, basically see if either of the most extreme of the triangle points intersects r
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) // points of the projected triangle are outside the projected half-length of the aabb
        // the axis is seperating and we can exit
        return false;
    }
    return true;
}
const _points = [
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3(),
    /*@__PURE__*/ new Vector3()
];
const _vector$1 = /*@__PURE__*/ new Vector3();
const _box = /*@__PURE__*/ new Box3();
// triangle centered vertices
const _v0 = /*@__PURE__*/ new Vector3();
const _v1 = /*@__PURE__*/ new Vector3();
const _v2 = /*@__PURE__*/ new Vector3();
// triangle edge vectors
const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();
const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();
const _box$1 = /*@__PURE__*/ new Box3();
class Sphere {
    constructor(center1, radius1){
        this.center = center1 !== undefined ? center1 : new Vector3();
        this.radius = radius1 !== undefined ? radius1 : -1;
    }
    set(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
    }
    setFromPoints(points, optionalCenter) {
        const center2 = this.center;
        if (optionalCenter !== undefined) center2.copy(optionalCenter);
        else _box$1.setFromPoints(points).getCenter(center2);
        let maxRadiusSq = 0;
        for(let i1 = 0, il = points.length; i1 < il; i1++)maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(points[i1]));
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    }
    isEmpty() {
        return this.radius < 0;
    }
    makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
    }
    containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
        return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        if (target === undefined) {
            console.warn('THREE.Sphere: .clampPoint() target is now required');
            target = new Vector3();
        }
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
    }
    getBoundingBox(target) {
        if (target === undefined) {
            console.warn('THREE.Sphere: .getBoundingBox() target is now required');
            target = new Box3();
        }
        if (this.isEmpty()) {
            // Empty sphere produces empty bounding box
            target.makeEmpty();
            return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
    }
    applyMatrix4(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    }
    translate(offset) {
        this.center.add(offset);
        return this;
    }
    equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
}
const _vector$2 = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();
const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal = /*@__PURE__*/ new Vector3();
class Ray {
    constructor(origin1, direction1){
        this.origin = origin1 !== undefined ? origin1 : new Vector3();
        this.direction = direction1 !== undefined ? direction1 : new Vector3(0, 0, -1);
    }
    set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    }
    at(t, target) {
        if (target === undefined) {
            console.warn('THREE.Ray: .at() target is now required');
            target = new Vector3();
        }
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    }
    recast(t) {
        this.origin.copy(this.at(t, _vector$2));
        return this;
    }
    closestPointToPoint(point, target) {
        if (target === undefined) {
            console.warn('THREE.Ray: .closestPointToPoint() target is now required');
            target = new Vector3();
        }
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) return target.copy(this.origin);
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
        const directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);
        // point behind the ray
        if (directionDistance < 0) return this.origin.distanceToSquared(point);
        _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector$2.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
        // It returns the min distance between the ray and the segment
        // defined by v0 and v1
        // It can also set two optional targets :
        // - The closest point on the ray
        // - The closest point on the segment
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot(_segDir);
        const b0 = _diff.dot(this.direction);
        const b1 = -_diff.dot(_segDir);
        const c = _diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
            // The ray and segment are not parallel.
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
                if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                        // region 0
                        // Minimum at interior points of ray and segment.
                        const invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    } else {
                        // region 1
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    // region 5
                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            } else {
                if (s1 <= -extDet) {
                    // region 4
                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                    s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                } else if (s1 <= extDet) {
                    // region 3
                    s0 = 0;
                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = s1 * (s1 + 2 * b1) + c;
                } else {
                    // region 2
                    s0 = Math.max(0, -(a01 * segExtent + b0));
                    s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
        } else {
            // Ray and segment are parallel.
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        if (optionalPointOnSegment) optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
        return sqrDist;
    }
    intersectSphere(sphere, target) {
        _vector$2.subVectors(sphere.center, this.origin);
        const tca = _vector$2.dot(this.direction);
        const d2 = _vector$2.dot(_vector$2) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2) return null;
        const thc = Math.sqrt(radius2 - d2);
        // t0 = first intersect point - entrance on front of sphere
        const t0 = tca - thc;
        // t1 = second intersect point - exit point on back of sphere
        const t1 = tca + thc;
        // test to see if both t0 and t1 are behind the ray - if so, return null
        if (t0 < 0 && t1 < 0) return null;
        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        if (t0 < 0) return this.at(t1, target);
        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return this.at(t0, target);
    }
    intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (plane.distanceToPoint(this.origin) === 0) return 0;
            // Null is preferable to undefined since undefined means.... it is undefined
            return null;
        }
        const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        // Return if the ray never intersects the plane
        return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
        const t = this.distanceToPlane(plane);
        if (t === null) return null;
        return this.at(t, target);
    }
    intersectsPlane(plane) {
        // check if the ray lies on the plane first
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) return true;
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) return true;
        // ray origin is behind the plane (and is pointing behind it)
        return false;
    }
    intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin2 = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin2.x) * invdirx;
            tmax = (box.max.x - origin2.x) * invdirx;
        } else {
            tmin = (box.max.x - origin2.x) * invdirx;
            tmax = (box.min.x - origin2.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin2.y) * invdiry;
            tymax = (box.max.y - origin2.y) * invdiry;
        } else {
            tymin = (box.max.y - origin2.y) * invdiry;
            tymax = (box.min.y - origin2.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN
        if (tymin > tmin || tmin !== tmin) tmin = tymin;
        if (tymax < tmax || tmax !== tmax) tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin2.z) * invdirz;
            tzmax = (box.max.z - origin2.z) * invdirz;
        } else {
            tzmin = (box.max.z - origin2.z) * invdirz;
            tzmax = (box.min.z - origin2.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
        //return point closest to the ray (positive side)
        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
        return this.intersectBox(box, _vector$2) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
        // Compute the offset origin, edges, and normal.
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
        _edge1.subVectors(b, a);
        _edge2.subVectors(c, a);
        _normal.crossVectors(_edge1, _edge2);
        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        let DdN = this.direction.dot(_normal);
        let sign;
        if (DdN > 0) {
            if (backfaceCulling) return null;
            sign = 1;
        } else if (DdN < 0) {
            sign = -1;
            DdN = -DdN;
        } else return null;
        _diff.subVectors(this.origin, a);
        const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        // b1 < 0, no intersection
        if (DdQxE2 < 0) return null;
        const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
        // b2 < 0, no intersection
        if (DdE1xQ < 0) return null;
        // b1+b2 > 1, no intersection
        if (DdQxE2 + DdE1xQ > DdN) return null;
        // Line intersects triangle, check if ray does.
        const QdN = -sign * _diff.dot(_normal);
        // t < 0, no intersection
        if (QdN < 0) return null;
        // Ray intersects triangle.
        return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
    }
    equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
}
class Matrix4 {
    constructor(){
        Object.defineProperty(this, 'isMatrix4', {
            value: true
        });
        this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    clone() {
        return new Matrix4().fromArray(this.elements);
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
    }
    copyPosition(m) {
        const te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    }
    setFromMatrix3(m) {
        const me = m.elements;
        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    }
    extractRotation(m) {
        // this method does not support reflection matrices
        const te = this.elements;
        const me = m.elements;
        const scaleX = 1 / _v1$1.setFromMatrixColumn(m, 0).length();
        const scaleY = 1 / _v1$1.setFromMatrixColumn(m, 1).length();
        const scaleZ = 1 / _v1$1.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromEuler(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        const te = this.elements;
        const x5 = euler.x, y5 = euler.y, z4 = euler.z;
        const a = Math.cos(x5), b = Math.sin(x5);
        const c = Math.cos(y5), d = Math.sin(y5);
        const e = Math.cos(z4), f = Math.sin(z4);
        if (euler.order === 'XYZ') {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
        } else if (euler.order === 'YXZ') {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
        } else if (euler.order === 'ZXY') {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
        } else if (euler.order === 'ZYX') {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
        } else if (euler.order === 'YZX') {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
        }
        // bottom row
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        // last column
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromQuaternion(q) {
        return this.compose(_zero, q, _one);
    }
    lookAt(eye, target, up) {
        const te = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) // eye and target are in the same position
        _z.z = 1;
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
            // up and z are parallel
            if (Math.abs(up.z) === 1) _z.x += 0.0001;
            else _z.z += 0.0001;
            _z.normalize();
            _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
    }
    multiply(m, n) {
        if (n !== undefined) {
            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
        const te = this.elements;
        let tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
    }
    setPosition(x, y, z) {
        const te = this.elements;
        if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
        } else {
            te[12] = x;
            te[13] = y;
            te[14] = z;
        }
        return this;
    }
    invert() {
        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
    }
    scale(v) {
        const te = this.elements;
        const x5 = v.x, y5 = v.y, z4 = v.z;
        te[0] *= x5;
        te[4] *= y5;
        te[8] *= z4;
        te[1] *= x5;
        te[5] *= y5;
        te[9] *= z4;
        te[2] *= x5;
        te[6] *= y5;
        te[10] *= z4;
        te[3] *= x5;
        te[7] *= y5;
        te[11] *= z4;
        return this;
    }
    getMaxScaleOnAxis() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    }
    makeRotationX(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationY(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationZ(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationAxis(axis, angle) {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const t = 1 - c;
        const x5 = axis.x, y5 = axis.y, z4 = axis.z;
        const tx = t * x5, ty = t * y5;
        this.set(tx * x5 + c, tx * y5 - s * z4, tx * z4 + s * y5, 0, tx * y5 + s * z4, ty * y5 + c, ty * z4 - s * x5, 0, tx * z4 - s * y5, ty * z4 + s * x5, t * z4 * z4 + c, 0, 0, 0, 0, 1);
        return this;
    }
    makeScale(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    }
    makeShear(x, y, z) {
        this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
        return this;
    }
    compose(position, quaternion, scale) {
        const te = this.elements;
        const x5 = quaternion._x, y5 = quaternion._y, z4 = quaternion._z, w3 = quaternion._w;
        const x21 = x5 + x5, y21 = y5 + y5, z21 = z4 + z4;
        const xx = x5 * x21, xy = x5 * y21, xz = x5 * z21;
        const yy = y5 * y21, yz = y5 * z21, zz = z4 * z21;
        const wx = w3 * x21, wy = w3 * y21, wz = w3 * z21;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
    }
    decompose(position, quaternion, scale) {
        const te = this.elements;
        let sx = _v1$1.set(te[0], te[1], te[2]).length();
        const sy = _v1$1.set(te[4], te[5], te[6]).length();
        const sz = _v1$1.set(te[8], te[9], te[10]).length();
        // if determine is negative, we need to invert one scale
        const det = this.determinant();
        if (det < 0) sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        // scale the rotation part
        _m1.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1.elements[0] *= invSX;
        _m1.elements[1] *= invSX;
        _m1.elements[2] *= invSX;
        _m1.elements[4] *= invSY;
        _m1.elements[5] *= invSY;
        _m1.elements[6] *= invSY;
        _m1.elements[8] *= invSZ;
        _m1.elements[9] *= invSZ;
        _m1.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
        if (far === undefined) console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
        const te = this.elements;
        const x5 = 2 * near / (right - left);
        const y5 = 2 * near / (top - bottom);
        const a = (right + left) / (right - left);
        const b = (top + bottom) / (top - bottom);
        const c = -(far + near) / (far - near);
        const d = -2 * far * near / (far - near);
        te[0] = x5;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y5;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
        const te = this.elements;
        const w3 = 1 / (right - left);
        const h = 1 / (top - bottom);
        const p = 1 / (far - near);
        const x5 = (right + left) * w3;
        const y5 = (top + bottom) * h;
        const z4 = (far + near) * p;
        te[0] = 2 * w3;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x5;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y5;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z4;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i1 = 0; i1 < 16; i1++){
            if (te[i1] !== me[i1]) return false;
        }
        return true;
    }
    fromArray(array, offset = 0) {
        for(let i1 = 0; i1 < 16; i1++)this.elements[i1] = array[i1 + offset];
        return this;
    }
    toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    }
}
const _v1$1 = /*@__PURE__*/ new Vector3();
const _m1 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3(0, 0, 0);
const _one = /*@__PURE__*/ new Vector3(1, 1, 1);
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();
class Euler {
    constructor(x5 = 0, y5 = 0, z4 = 0, order1 = Euler.DefaultOrder){
        Object.defineProperty(this, 'isEuler', {
            value: true
        });
        this._x = x5;
        this._y = y5;
        this._z = z4;
        this._order = order1;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(value) {
        this._order = value;
        this._onChangeCallback();
    }
    set(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m, order, update) {
        const clamp = MathUtils.clamp;
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        switch(order){
            case 'XYZ':
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
                break;
            case 'YXZ':
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
                break;
            case 'ZXY':
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
                break;
            case 'ZYX':
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
                break;
            case 'YZX':
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
                break;
            case 'XZY':
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
                break;
            default:
                console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
        }
        this._order = order;
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromQuaternion(q, order, update) {
        _matrix.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix, order, update);
    }
    setFromVector3(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
    }
    reorder(newOrder) {
        // WARNING: this discards revolution information -bhouston
        _quaternion$1.setFromEuler(this);
        return this.setFromQuaternion(_quaternion$1, newOrder);
    }
    equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this._onChangeCallback();
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    }
    toVector3(optionalResult) {
        if (optionalResult) return optionalResult.set(this._x, this._y, this._z);
        else return new Vector3(this._x, this._y, this._z);
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {
    }
}
Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [
    'XYZ',
    'YZX',
    'ZXY',
    'XZY',
    'YXZ',
    'ZYX'
];
const _matrix = /*@__PURE__*/ new Matrix4();
const _quaternion$1 = /*@__PURE__*/ new Quaternion();
class Layers {
    constructor(){
        this.mask = 1;
    }
    set(channel) {
        this.mask = 1 << channel | 0;
    }
    enable(channel) {
        this.mask |= 1 << channel | 0;
    }
    enableAll() {
        this.mask = -1;
    }
    toggle(channel) {
        this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
        this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
        this.mask = 0;
    }
    test(layers) {
        return (this.mask & layers.mask) !== 0;
    }
}
let _object3DId = 0;
const _v1$2 = new Vector3();
const _q1 = new Quaternion();
const _m1$1 = new Matrix4();
const _target = new Vector3();
const _position = new Vector3();
const _scale = new Vector3();
const _quaternion$2 = new Quaternion();
const _xAxis = new Vector3(1, 0, 0);
const _yAxis = new Vector3(0, 1, 0);
const _zAxis = new Vector3(0, 0, 1);
const _addedEvent = {
    type: 'added'
};
const _removedEvent = {
    type: 'removed'
};
function Object3D() {
    Object.defineProperty(this, 'id', {
        value: _object3DId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, undefined, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
        position: {
            configurable: true,
            enumerable: true,
            value: position
        },
        rotation: {
            configurable: true,
            enumerable: true,
            value: rotation
        },
        quaternion: {
            configurable: true,
            enumerable: true,
            value: quaternion
        },
        scale: {
            configurable: true,
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new Matrix4()
        },
        normalMatrix: {
            value: new Matrix3()
        }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {
    };
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Object3D,
    isObject3D: true,
    onBeforeRender: function() {
    },
    onAfterRender: function() {
    },
    applyMatrix4: function(matrix) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(q) {
        this.quaternion.premultiply(q);
        return this;
    },
    setRotationFromAxisAngle: function(axis, angle) {
        // assumes axis is normalized
        this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function(m) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function(q) {
        // assumes q is normalized
        this.quaternion.copy(q);
    },
    rotateOnAxis: function(axis, angle) {
        // rotate object on axis in object space
        // axis is assumed to be normalized
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
    },
    rotateOnWorldAxis: function(axis, angle) {
        // rotate object on axis in world space
        // axis is assumed to be normalized
        // method assumes no rotated parent
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
    },
    rotateX: function(angle) {
        return this.rotateOnAxis(_xAxis, angle);
    },
    rotateY: function(angle) {
        return this.rotateOnAxis(_yAxis, angle);
    },
    rotateZ: function(angle) {
        return this.rotateOnAxis(_zAxis, angle);
    },
    translateOnAxis: function(axis, distance) {
        // translate object by distance along axis in object space
        // axis is assumed to be normalized
        _v1$2.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v1$2.multiplyScalar(distance));
        return this;
    },
    translateX: function(distance) {
        return this.translateOnAxis(_xAxis, distance);
    },
    translateY: function(distance) {
        return this.translateOnAxis(_yAxis, distance);
    },
    translateZ: function(distance) {
        return this.translateOnAxis(_zAxis, distance);
    },
    localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function(vector) {
        return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    },
    lookAt: function(x6, y6, z5) {
        // This method does not support objects having non-uniformly-scaled parent(s)
        if (x6.isVector3) _target.copy(x6);
        else _target.set(x6, y6, z5);
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) _m1$1.lookAt(_position, _target, this.up);
        else _m1$1.lookAt(_target, _position, this.up);
        this.quaternion.setFromRotationMatrix(_m1$1);
        if (parent) {
            _m1$1.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m1$1);
            this.quaternion.premultiply(_q1.invert());
        }
    },
    add: function(object) {
        if (arguments.length > 1) {
            for(let i1 = 0; i1 < arguments.length; i1++)this.add(arguments[i1]);
            return this;
        }
        if (object === this) {
            console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
            return this;
        }
        if (object && object.isObject3D) {
            if (object.parent !== null) object.parent.remove(object);
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
        } else console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
        return this;
    },
    remove: function(object) {
        if (arguments.length > 1) {
            for(let i1 = 0; i1 < arguments.length; i1++)this.remove(arguments[i1]);
            return this;
        }
        const index = this.children.indexOf(object);
        if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent(_removedEvent);
        }
        return this;
    },
    clear: function() {
        for(let i1 = 0; i1 < this.children.length; i1++){
            const object = this.children[i1];
            object.parent = null;
            object.dispatchEvent(_removedEvent);
        }
        this.children.length = 0;
        return this;
    },
    attach: function(object) {
        // adds object as a child of this, while maintaining the object's world transform
        this.updateWorldMatrix(true, false);
        _m1$1.copy(this.matrixWorld).invert();
        if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m1$1.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m1$1);
        object.updateWorldMatrix(false, false);
        this.add(object);
        return this;
    },
    getObjectById: function(id) {
        return this.getObjectByProperty('id', id);
    },
    getObjectByName: function(name) {
        return this.getObjectByProperty('name', name);
    },
    getObjectByProperty: function(name, value) {
        if (this[name] === value) return this;
        for(let i1 = 0, l = this.children.length; i1 < l; i1++){
            const child = this.children[i1];
            const object = child.getObjectByProperty(name, value);
            if (object !== undefined) return object;
        }
        return undefined;
    },
    getWorldPosition: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldPosition() target is now required');
            target = new Vector3();
        }
        this.updateWorldMatrix(true, false);
        return target.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
            target = new Quaternion();
        }
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position, target, _scale);
        return target;
    },
    getWorldScale: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldScale() target is now required');
            target = new Vector3();
        }
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position, _quaternion$2, target);
        return target;
    },
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldDirection() target is now required');
            target = new Vector3();
        }
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {
    },
    traverse: function(callback) {
        callback(this);
        const children = this.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)children[i1].traverse(callback);
    },
    traverseVisible: function(callback) {
        if (this.visible === false) return;
        callback(this);
        const children = this.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)children[i1].traverseVisible(callback);
    },
    traverseAncestors: function(callback) {
        const parent = this.parent;
        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) this.matrixWorld.copy(this.matrix);
            else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        // update children
        const children = this.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)children[i1].updateMatrixWorld(force);
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) parent.updateWorldMatrix(true, false);
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.parent === null) this.matrixWorld.copy(this.matrix);
        else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        // update children
        if (updateChildren === true) {
            const children = this.children;
            for(let i1 = 0, l = children.length; i1 < l; i1++)children[i1].updateWorldMatrix(false, true);
        }
    },
    toJSON: function(meta) {
        // meta is a string when called from JSON.stringify
        const isRootObject = meta === undefined || typeof meta === 'string';
        const output = {
        };
        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if (isRootObject) {
            // initialize meta obj
            meta = {
                geometries: {
                },
                materials: {
                },
                textures: {
                },
                images: {
                },
                shapes: {
                },
                skeletons: {
                },
                animations: {
                }
            };
            output.metadata = {
                version: 4.5,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };
        }
        // standard Object3D serialization
        const object = {
        };
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== '') object.name = this.name;
        if (this.castShadow === true) object.castShadow = true;
        if (this.receiveShadow === true) object.receiveShadow = true;
        if (this.visible === false) object.visible = false;
        if (this.frustumCulled === false) object.frustumCulled = false;
        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
        // object specific properties
        if (this.isInstancedMesh) {
            object.type = 'InstancedMesh';
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
        }
        //
        function serialize(library, element) {
            if (library[element.uuid] === undefined) library[element.uuid] = element.toJSON(meta);
            return element.uuid;
        }
        if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== undefined && parameters.shapes !== undefined) {
                const shapes = parameters.shapes;
                if (Array.isArray(shapes)) for(let i1 = 0, l = shapes.length; i1 < l; i1++){
                    const shape = shapes[i1];
                    serialize(meta.shapes, shape);
                }
                else serialize(meta.shapes, shapes);
            }
        }
        if (this.isSkinnedMesh) {
            object.bindMode = this.bindMode;
            object.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== undefined) {
                serialize(meta.skeletons, this.skeleton);
                object.skeleton = this.skeleton.uuid;
            }
        }
        if (this.material !== undefined) {
            if (Array.isArray(this.material)) {
                const uuids = [];
                for(let i1 = 0, l = this.material.length; i1 < l; i1++)uuids.push(serialize(meta.materials, this.material[i1]));
                object.material = uuids;
            } else object.material = serialize(meta.materials, this.material);
        }
        //
        if (this.children.length > 0) {
            object.children = [];
            for(let i1 = 0; i1 < this.children.length; i1++)object.children.push(this.children[i1].toJSON(meta).object);
        }
        //
        if (this.animations.length > 0) {
            object.animations = [];
            for(let i1 = 0; i1 < this.animations.length; i1++){
                const animation = this.animations[i1];
                object.animations.push(serialize(meta.animations, animation));
            }
        }
        if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            const skeletons = extractFromCache(meta.skeletons);
            const animations = extractFromCache(meta.animations);
            if (geometries.length > 0) output.geometries = geometries;
            if (materials.length > 0) output.materials = materials;
            if (textures.length > 0) output.textures = textures;
            if (images.length > 0) output.images = images;
            if (shapes.length > 0) output.shapes = shapes;
            if (skeletons.length > 0) output.skeletons = skeletons;
            if (animations.length > 0) output.animations = animations;
        }
        output.object = object;
        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
        return output;
    },
    clone: function(recursive) {
        return new this.constructor().copy(this, recursive);
    },
    copy: function(source, recursive = true) {
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) for(let i1 = 0; i1 < source.children.length; i1++){
            const child = source.children[i1];
            this.add(child.clone());
        }
        return this;
    }
});
const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();
class Plane {
    constructor(normal1, constant1){
        Object.defineProperty(this, 'isPlane', {
            value: true
        });
        // normal is assumed to be normalized
        this.normal = normal1 !== undefined ? normal1 : new Vector3(1, 0, 0);
        this.constant = constant1 !== undefined ? constant1 : 0;
    }
    set(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
    }
    setComponents(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
    }
    setFromCoplanarPoints(a, b, c) {
        const normal2 = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
        this.setFromNormalAndCoplanarPoint(normal2, a);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    }
    normalize() {
        // Note: will lead to a divide by zero if the plane is invalid.
        const inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    }
    negate() {
        this.constant *= -1;
        this.normal.negate();
        return this;
    }
    distanceToPoint(point) {
        return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .projectPoint() target is now required');
            target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
    intersectLine(line, target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .intersectLine() target is now required');
            target = new Vector3();
        }
        const direction2 = line.delta(_vector1);
        const denominator = this.normal.dot(direction2);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (this.distanceToPoint(line.start) === 0) return target.copy(line.start);
            // Unsure if this is the correct method to handle this case.
            return undefined;
        }
        const t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) return undefined;
        return target.copy(direction2).multiplyScalar(t).add(line.start);
    }
    intersectsLine(line) {
        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
        return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
        return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .coplanarPoint() target is now required');
            target = new Vector3();
        }
        return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
        const normal2 = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal2);
        return this;
    }
    translate(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
    }
    equals(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
}
const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$1 = /*@__PURE__*/ new Vector3();
const _v3 = /*@__PURE__*/ new Vector3();
const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();
class Triangle {
    constructor(a1, b1, c1){
        this.a = a1 !== undefined ? a1 : new Vector3();
        this.b = b1 !== undefined ? b1 : new Vector3();
        this.c = c1 !== undefined ? c1 : new Vector3();
    }
    static getNormal(a, b, c, target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getNormal() target is now required');
            target = new Vector3();
        }
        target.subVectors(c, b);
        _v0$1.subVectors(a, b);
        target.cross(_v0$1);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        return target.set(0, 0, 0);
    }
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    static getBarycoord(point, a, b, c, target) {
        _v0$1.subVectors(c, a);
        _v1$3.subVectors(b, a);
        _v2$1.subVectors(point, a);
        const dot00 = _v0$1.dot(_v0$1);
        const dot01 = _v0$1.dot(_v1$3);
        const dot02 = _v0$1.dot(_v2$1);
        const dot11 = _v1$3.dot(_v1$3);
        const dot12 = _v1$3.dot(_v2$1);
        const denom = dot00 * dot11 - dot01 * dot01;
        if (target === undefined) {
            console.warn('THREE.Triangle: .getBarycoord() target is now required');
            target = new Vector3();
        }
        // collinear or singular triangle
        if (denom === 0) // arbitrary location outside of triangle?
        // not sure if this is the best idea, maybe should be returning undefined
        return target.set(-2, -1, -1);
        const invDenom = 1 / denom;
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        // barycentric coordinates must always sum to 1
        return target.set(1 - u - v, v, u);
    }
    static containsPoint(point, a, b, c) {
        this.getBarycoord(point, a, b, c, _v3);
        return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
    }
    static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, _v3);
        target.set(0, 0);
        target.addScaledVector(uv1, _v3.x);
        target.addScaledVector(uv2, _v3.y);
        target.addScaledVector(uv3, _v3.z);
        return target;
    }
    static isFrontFacing(a, b, c, direction) {
        _v0$1.subVectors(c, b);
        _v1$3.subVectors(a, b);
        // strictly front facing
        return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    }
    getArea() {
        _v0$1.subVectors(this.c, this.b);
        _v1$3.subVectors(this.a, this.b);
        return _v0$1.cross(_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getMidpoint() target is now required');
            target = new Vector3();
        }
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getPlane() target is now required');
            target = new Plane();
        }
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getUV(point, uv1, uv2, uv3, target) {
        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    }
    containsPoint(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
        return box.intersectsTriangle(this);
    }
    closestPointToPoint(p, target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
            target = new Vector3();
        }
        const a2 = this.a, b2 = this.b, c2 = this.c;
        let v, w3;
        // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
        // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
        // under the accompanying license; see chapter 5.1.5 for detailed explanation.
        // basically, we're distinguishing which of the voronoi regions of the triangle
        // the point lies in with the minimum amount of redundant computation.
        _vab.subVectors(b2, a2);
        _vac.subVectors(c2, a2);
        _vap.subVectors(p, a2);
        const d1 = _vab.dot(_vap);
        const d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) // vertex region of A; barycentric coords (1, 0, 0)
        return target.copy(a2);
        _vbp.subVectors(p, b2);
        const d3 = _vab.dot(_vbp);
        const d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) // vertex region of B; barycentric coords (0, 1, 0)
        return target.copy(b2);
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            // edge region of AB; barycentric coords (1-v, v, 0)
            return target.copy(a2).addScaledVector(_vab, v);
        }
        _vcp.subVectors(p, c2);
        const d5 = _vab.dot(_vcp);
        const d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) // vertex region of C; barycentric coords (0, 0, 1)
        return target.copy(c2);
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w3 = d2 / (d2 - d6);
            // edge region of AC; barycentric coords (1-w, 0, w)
            return target.copy(a2).addScaledVector(_vac, w3);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c2, b2);
            w3 = (d4 - d3) / (d4 - d3 + (d5 - d6));
            // edge region of BC; barycentric coords (0, 1-w, w)
            return target.copy(b2).addScaledVector(_vbc, w3); // edge region of BC
        }
        // face region
        const denom = 1 / (va + vb + vc);
        // u = va * denom
        v = vb * denom;
        w3 = vc * denom;
        return target.copy(a2).addScaledVector(_vab, v).addScaledVector(_vac, w3);
    }
    equals(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
}
const _colorKeywords = {
    'aliceblue': 15792383,
    'antiquewhite': 16444375,
    'aqua': 65535,
    'aquamarine': 8388564,
    'azure': 15794175,
    'beige': 16119260,
    'bisque': 16770244,
    'black': 0,
    'blanchedalmond': 16772045,
    'blue': 255,
    'blueviolet': 9055202,
    'brown': 10824234,
    'burlywood': 14596231,
    'cadetblue': 6266528,
    'chartreuse': 8388352,
    'chocolate': 13789470,
    'coral': 16744272,
    'cornflowerblue': 6591981,
    'cornsilk': 16775388,
    'crimson': 14423100,
    'cyan': 65535,
    'darkblue': 139,
    'darkcyan': 35723,
    'darkgoldenrod': 12092939,
    'darkgray': 11119017,
    'darkgreen': 25600,
    'darkgrey': 11119017,
    'darkkhaki': 12433259,
    'darkmagenta': 9109643,
    'darkolivegreen': 5597999,
    'darkorange': 16747520,
    'darkorchid': 10040012,
    'darkred': 9109504,
    'darksalmon': 15308410,
    'darkseagreen': 9419919,
    'darkslateblue': 4734347,
    'darkslategray': 3100495,
    'darkslategrey': 3100495,
    'darkturquoise': 52945,
    'darkviolet': 9699539,
    'deeppink': 16716947,
    'deepskyblue': 49151,
    'dimgray': 6908265,
    'dimgrey': 6908265,
    'dodgerblue': 2003199,
    'firebrick': 11674146,
    'floralwhite': 16775920,
    'forestgreen': 2263842,
    'fuchsia': 16711935,
    'gainsboro': 14474460,
    'ghostwhite': 16316671,
    'gold': 16766720,
    'goldenrod': 14329120,
    'gray': 8421504,
    'green': 32768,
    'greenyellow': 11403055,
    'grey': 8421504,
    'honeydew': 15794160,
    'hotpink': 16738740,
    'indianred': 13458524,
    'indigo': 4915330,
    'ivory': 16777200,
    'khaki': 15787660,
    'lavender': 15132410,
    'lavenderblush': 16773365,
    'lawngreen': 8190976,
    'lemonchiffon': 16775885,
    'lightblue': 11393254,
    'lightcoral': 15761536,
    'lightcyan': 14745599,
    'lightgoldenrodyellow': 16448210,
    'lightgray': 13882323,
    'lightgreen': 9498256,
    'lightgrey': 13882323,
    'lightpink': 16758465,
    'lightsalmon': 16752762,
    'lightseagreen': 2142890,
    'lightskyblue': 8900346,
    'lightslategray': 7833753,
    'lightslategrey': 7833753,
    'lightsteelblue': 11584734,
    'lightyellow': 16777184,
    'lime': 65280,
    'limegreen': 3329330,
    'linen': 16445670,
    'magenta': 16711935,
    'maroon': 8388608,
    'mediumaquamarine': 6737322,
    'mediumblue': 205,
    'mediumorchid': 12211667,
    'mediumpurple': 9662683,
    'mediumseagreen': 3978097,
    'mediumslateblue': 8087790,
    'mediumspringgreen': 64154,
    'mediumturquoise': 4772300,
    'mediumvioletred': 13047173,
    'midnightblue': 1644912,
    'mintcream': 16121850,
    'mistyrose': 16770273,
    'moccasin': 16770229,
    'navajowhite': 16768685,
    'navy': 128,
    'oldlace': 16643558,
    'olive': 8421376,
    'olivedrab': 7048739,
    'orange': 16753920,
    'orangered': 16729344,
    'orchid': 14315734,
    'palegoldenrod': 15657130,
    'palegreen': 10025880,
    'paleturquoise': 11529966,
    'palevioletred': 14381203,
    'papayawhip': 16773077,
    'peachpuff': 16767673,
    'peru': 13468991,
    'pink': 16761035,
    'plum': 14524637,
    'powderblue': 11591910,
    'purple': 8388736,
    'rebeccapurple': 6697881,
    'red': 16711680,
    'rosybrown': 12357519,
    'royalblue': 4286945,
    'saddlebrown': 9127187,
    'salmon': 16416882,
    'sandybrown': 16032864,
    'seagreen': 3050327,
    'seashell': 16774638,
    'sienna': 10506797,
    'silver': 12632256,
    'skyblue': 8900331,
    'slateblue': 6970061,
    'slategray': 7372944,
    'slategrey': 7372944,
    'snow': 16775930,
    'springgreen': 65407,
    'steelblue': 4620980,
    'tan': 13808780,
    'teal': 32896,
    'thistle': 14204888,
    'tomato': 16737095,
    'turquoise': 4251856,
    'violet': 15631086,
    'wheat': 16113331,
    'white': 16777215,
    'whitesmoke': 16119285,
    'yellow': 16776960,
    'yellowgreen': 10145074
};
const _hslA = {
    h: 0,
    s: 0,
    l: 0
};
const _hslB = {
    h: 0,
    s: 0,
    l: 0
};
function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 0.5) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
}
function SRGBToLinear(c2) {
    return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
    return c2 < 0.0031308 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
class Color {
    constructor(r1, g1, b2){
        Object.defineProperty(this, 'isColor', {
            value: true
        });
        if (g1 === undefined && b2 === undefined) // r is THREE.Color, hex or string
        return this.set(r1);
        return this.setRGB(r1, g1, b2);
    }
    set(value) {
        if (value && value.isColor) this.copy(value);
        else if (typeof value === 'number') this.setHex(value);
        else if (typeof value === 'string') this.setStyle(value);
        return this;
    }
    setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
    }
    setHex(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
    }
    setRGB(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
    }
    setHSL(h, s, l) {
        // h,s,l ranges are in 0.0 - 1.0
        h = MathUtils.euclideanModulo(h, 1);
        s = MathUtils.clamp(s, 0, 1);
        l = MathUtils.clamp(l, 0, 1);
        if (s === 0) this.r = this.g = this.b = l;
        else {
            const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
            const q = 2 * l - p;
            this.r = hue2rgb(q, p, h + 1 / 3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1 / 3);
        }
        return this;
    }
    setStyle(style) {
        function handleAlpha(string) {
            if (string === undefined) return;
            if (parseFloat(string) < 1) console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
        }
        let m;
        if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
            // rgb / hsl
            let color;
            const name = m[1];
            const components = m[2];
            switch(name){
                case 'rgb':
                case 'rgba':
                    if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // rgb(255,0,0) rgba(255,0,0,0.5)
                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                        handleAlpha(color[4]);
                        return this;
                    }
                    if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                        handleAlpha(color[4]);
                        return this;
                    }
                    break;
                case 'hsl':
                case 'hsla':
                    if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                        const h = parseFloat(color[1]) / 360;
                        const s = parseInt(color[2], 10) / 100;
                        const l = parseInt(color[3], 10) / 100;
                        handleAlpha(color[4]);
                        return this.setHSL(h, s, l);
                    }
                    break;
            }
        } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
            // hex color
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
                // #ff0
                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                return this;
            } else if (size === 6) {
                // #ff0000
                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                return this;
            }
        }
        if (style && style.length > 0) return this.setColorName(style);
        return this;
    }
    setColorName(style) {
        // color keywords
        const hex = _colorKeywords[style];
        if (hex !== undefined) // red
        this.setHex(hex);
        else // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
        return this;
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    }
    copyGammaToLinear(color, gammaFactor = 2) {
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
    }
    copyLinearToGamma(color, gammaFactor = 2) {
        const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
    }
    convertGammaToLinear(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
    }
    convertLinearToGamma(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
    }
    copySRGBToLinear(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
    }
    copyLinearToSRGB(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
    }
    convertSRGBToLinear() {
        this.copySRGBToLinear(this);
        return this;
    }
    convertLinearToSRGB() {
        this.copyLinearToSRGB(this);
        return this;
    }
    getHex() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    }
    getHexString() {
        return ('000000' + this.getHex().toString(16)).slice(-6);
    }
    getHSL(target) {
        // h,s,l ranges are in 0.0 - 1.0
        if (target === undefined) {
            console.warn('THREE.Color: .getHSL() target is now required');
            target = {
                h: 0,
                s: 0,
                l: 0
            };
        }
        const r2 = this.r, g2 = this.g, b3 = this.b;
        const max2 = Math.max(r2, g2, b3);
        const min2 = Math.min(r2, g2, b3);
        let hue, saturation;
        const lightness = (min2 + max2) / 2;
        if (min2 === max2) {
            hue = 0;
            saturation = 0;
        } else {
            const delta = max2 - min2;
            saturation = lightness <= 0.5 ? delta / (max2 + min2) : delta / (2 - max2 - min2);
            switch(max2){
                case r2:
                    hue = (g2 - b3) / delta + (g2 < b3 ? 6 : 0);
                    break;
                case g2:
                    hue = (b3 - r2) / delta + 2;
                    break;
                case b3:
                    hue = (r2 - g2) / delta + 4;
                    break;
            }
            hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
    }
    getStyle() {
        return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
    }
    offsetHSL(h, s, l) {
        this.getHSL(_hslA);
        _hslA.h += h;
        _hslA.s += s;
        _hslA.l += l;
        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
        return this;
    }
    add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
    }
    addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    }
    addScalar(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
    }
    sub(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
    }
    multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
    }
    multiplyScalar(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
    }
    lerp(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
    }
    lerpColors(color1, color2, alpha) {
        this.r = color1.r + (color2.r - color1.r) * alpha;
        this.g = color1.g + (color2.g - color1.g) * alpha;
        this.b = color1.b + (color2.b - color1.b) * alpha;
        return this;
    }
    lerpHSL(color, alpha) {
        this.getHSL(_hslA);
        color.getHSL(_hslB);
        const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
        const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
        const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h, s, l);
        return this;
    }
    equals(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        if (attribute.normalized === true) {
            // assuming Uint8Array
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
        }
        return this;
    }
    toJSON() {
        return this.getHex();
    }
}
Color.NAMES = _colorKeywords;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
class Face3 {
    constructor(a2, b3, c2, normal2, color1, materialIndex = 0){
        this.a = a2;
        this.b = b3;
        this.c = c2;
        this.normal = normal2 && normal2.isVector3 ? normal2 : new Vector3();
        this.vertexNormals = Array.isArray(normal2) ? normal2 : [];
        this.color = color1 && color1.isColor ? color1 : new Color();
        this.vertexColors = Array.isArray(color1) ? color1 : [];
        this.materialIndex = materialIndex;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for(let i1 = 0, il = source.vertexNormals.length; i1 < il; i1++)this.vertexNormals[i1] = source.vertexNormals[i1].clone();
        for(let i2 = 0, il1 = source.vertexColors.length; i2 < il1; i2++)this.vertexColors[i2] = source.vertexColors[i2].clone();
        return this;
    }
}
let materialId = 0;
function Material() {
    Object.defineProperty(this, 'id', {
        value: materialId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Material';
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.flatShading = false;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null; // override the renderer's default precision for this material
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {
    };
    this.version = 0;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Material,
    isMaterial: true,
    onBeforeCompile: function() {
    },
    customProgramCacheKey: function() {
        return this.onBeforeCompile.toString();
    },
    setValues: function(values) {
        if (values === undefined) return;
        for(const key in values){
            const newValue = values[key];
            if (newValue === undefined) {
                console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
                continue;
            }
            // for backward compatability if shading is set in the constructor
            if (key === 'shading') {
                console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                this.flatShading = newValue === FlatShading ? true : false;
                continue;
            }
            const currentValue = this[key];
            if (currentValue === undefined) {
                console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
                continue;
            }
            if (currentValue && currentValue.isColor) currentValue.set(newValue);
            else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) currentValue.copy(newValue);
            else this[key] = newValue;
        }
    },
    toJSON: function(meta) {
        const isRoot = meta === undefined || typeof meta === 'string';
        if (isRoot) meta = {
            textures: {
            },
            images: {
            }
        };
        const data = {
            metadata: {
                version: 4.5,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };
        // standard Material serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (this.color && this.color.isColor) data.color = this.color.getHex();
        if (this.roughness !== undefined) data.roughness = this.roughness;
        if (this.metalness !== undefined) data.metalness = this.metalness;
        if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
        if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
        if (this.shininess !== undefined) data.shininess = this.shininess;
        if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
        if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            data.reflectivity = this.reflectivity; // Scale behind envMap
            data.refractionRatio = this.refractionRatio;
            if (this.combine !== undefined) data.combine = this.combine;
            if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
        }
        if (this.gradientMap && this.gradientMap.isTexture) data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        if (this.size !== undefined) data.size = this.size;
        if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending) data.blending = this.blending;
        if (this.flatShading === true) data.flatShading = this.flatShading;
        if (this.side !== FrontSide) data.side = this.side;
        if (this.vertexColors) data.vertexColors = true;
        if (this.opacity < 1) data.opacity = this.opacity;
        if (this.transparent === true) data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        data.stencilWrite = this.stencilWrite;
        data.stencilWriteMask = this.stencilWriteMask;
        data.stencilFunc = this.stencilFunc;
        data.stencilRef = this.stencilRef;
        data.stencilFuncMask = this.stencilFuncMask;
        data.stencilFail = this.stencilFail;
        data.stencilZFail = this.stencilZFail;
        data.stencilZPass = this.stencilZPass;
        // rotation (SpriteMaterial)
        if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
        if (this.polygonOffset === true) data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
        if (this.dashSize !== undefined) data.dashSize = this.dashSize;
        if (this.gapSize !== undefined) data.gapSize = this.gapSize;
        if (this.scale !== undefined) data.scale = this.scale;
        if (this.dithering === true) data.dithering = true;
        if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true) data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.morphTargets === true) data.morphTargets = true;
        if (this.morphNormals === true) data.morphNormals = true;
        if (this.skinning === true) data.skinning = true;
        if (this.visible === false) data.visible = false;
        if (this.toneMapped === false) data.toneMapped = false;
        if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;
        // TODO: Copied from Object3D.toJSON
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data1 = cache[key];
                delete data1.metadata;
                values.push(data1);
            }
            return values;
        }
        if (isRoot) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0) data.textures = textures;
            if (images.length > 0) data.images = images;
        }
        return data;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.flatShading = source.flatShading;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for(let i1 = 0; i1 !== n; ++i1)dstPlanes[i1] = srcPlanes[i1].clone();
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
Object.defineProperty(Material.prototype, 'needsUpdate', {
    set: function(value) {
        if (value === true) this.version++;
    }
});
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */ function MeshBasicMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshBasicMaterial';
    this.color = new Color(16777215); // emissive
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
}
MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
};
const _vector$3 = new Vector3();
const _vector2$1 = new Vector2();
function BufferAttribute(array, itemSize, normalized) {
    if (Array.isArray(array)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
    set: function(value) {
        if (value === true) this.version++;
    }
});
Object.assign(BufferAttribute.prototype, {
    isBufferAttribute: true,
    onUploadCallback: function() {
    },
    setUsage: function(value) {
        this.usage = value;
        return this;
    },
    copy: function(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
    },
    copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for(let i1 = 0, l = this.itemSize; i1 < l; i1++)this.array[index1 + i1] = attribute.array[index2 + i1];
        return this;
    },
    copyArray: function(array) {
        this.array.set(array);
        return this;
    },
    copyColorsArray: function(colors) {
        const array = this.array;
        let offset = 0;
        for(let i1 = 0, l = colors.length; i1 < l; i1++){
            let color1 = colors[i1];
            if (color1 === undefined) {
                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i1);
                color1 = new Color();
            }
            array[offset++] = color1.r;
            array[offset++] = color1.g;
            array[offset++] = color1.b;
        }
        return this;
    },
    copyVector2sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i1 = 0, l = vectors.length; i1 < l; i1++){
            let vector = vectors[i1];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i1);
                vector = new Vector2();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
        }
        return this;
    },
    copyVector3sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i1 = 0, l = vectors.length; i1 < l; i1++){
            let vector = vectors[i1];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i1);
                vector = new Vector3();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
        }
        return this;
    },
    copyVector4sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i1 = 0, l = vectors.length; i1 < l; i1++){
            let vector = vectors[i1];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i1);
                vector = new Vector4();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
        }
        return this;
    },
    applyMatrix3: function(m) {
        if (this.itemSize === 2) for(let i1 = 0, l = this.count; i1 < l; i1++){
            _vector2$1.fromBufferAttribute(this, i1);
            _vector2$1.applyMatrix3(m);
            this.setXY(i1, _vector2$1.x, _vector2$1.y);
        }
        else if (this.itemSize === 3) for(let i2 = 0, l1 = this.count; i2 < l1; i2++){
            _vector$3.fromBufferAttribute(this, i2);
            _vector$3.applyMatrix3(m);
            this.setXYZ(i2, _vector$3.x, _vector$3.y, _vector$3.z);
        }
        return this;
    },
    applyMatrix4: function(m) {
        for(let i1 = 0, l = this.count; i1 < l; i1++){
            _vector$3.x = this.getX(i1);
            _vector$3.y = this.getY(i1);
            _vector$3.z = this.getZ(i1);
            _vector$3.applyMatrix4(m);
            this.setXYZ(i1, _vector$3.x, _vector$3.y, _vector$3.z);
        }
        return this;
    },
    applyNormalMatrix: function(m) {
        for(let i1 = 0, l = this.count; i1 < l; i1++){
            _vector$3.x = this.getX(i1);
            _vector$3.y = this.getY(i1);
            _vector$3.z = this.getZ(i1);
            _vector$3.applyNormalMatrix(m);
            this.setXYZ(i1, _vector$3.x, _vector$3.y, _vector$3.z);
        }
        return this;
    },
    transformDirection: function(m) {
        for(let i1 = 0, l = this.count; i1 < l; i1++){
            _vector$3.x = this.getX(i1);
            _vector$3.y = this.getY(i1);
            _vector$3.z = this.getZ(i1);
            _vector$3.transformDirection(m);
            this.setXYZ(i1, _vector$3.x, _vector$3.y, _vector$3.z);
        }
        return this;
    },
    set: function(value, offset = 0) {
        this.array.set(value, offset);
        return this;
    },
    getX: function(index) {
        return this.array[index * this.itemSize];
    },
    setX: function(index, x6) {
        this.array[index * this.itemSize] = x6;
        return this;
    },
    getY: function(index) {
        return this.array[index * this.itemSize + 1];
    },
    setY: function(index, y6) {
        this.array[index * this.itemSize + 1] = y6;
        return this;
    },
    getZ: function(index) {
        return this.array[index * this.itemSize + 2];
    },
    setZ: function(index, z5) {
        this.array[index * this.itemSize + 2] = z5;
        return this;
    },
    getW: function(index) {
        return this.array[index * this.itemSize + 3];
    },
    setW: function(index, w3) {
        this.array[index * this.itemSize + 3] = w3;
        return this;
    },
    setXY: function(index, x6, y6) {
        index *= this.itemSize;
        this.array[index + 0] = x6;
        this.array[index + 1] = y6;
        return this;
    },
    setXYZ: function(index, x6, y6, z5) {
        index *= this.itemSize;
        this.array[index + 0] = x6;
        this.array[index + 1] = y6;
        this.array[index + 2] = z5;
        return this;
    },
    setXYZW: function(index, x6, y6, z5, w3) {
        index *= this.itemSize;
        this.array[index + 0] = x6;
        this.array[index + 1] = y6;
        this.array[index + 2] = z5;
        this.array[index + 3] = w3;
        return this;
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    },
    clone: function() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    },
    toJSON: function() {
        return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
    }
});
//
function Int8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
function Float32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function arrayMax(array) {
    if (array.length === 0) return -Infinity;
    let max2 = array[0];
    for(let i1 = 1, l = array.length; i1 < l; ++i1)if (array[i1] > max2) max2 = array[i1];
    return max2;
}
const TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    // Workaround for IE11 pre KB2929437. See #11440
    Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
};
function getTypedArray(type, buffer) {
    return new TYPED_ARRAYS[type](buffer);
}
let _id = 0;
const _m1$2 = new Matrix4();
const _obj = new Object3D();
const _offset = new Vector3();
const _box$2 = new Box3();
const _boxMorphTargets = new Box3();
const _vector$4 = new Vector3();
function BufferGeometry() {
    Object.defineProperty(this, 'id', {
        value: _id++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {
    };
    this.morphAttributes = {
    };
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
        start: 0,
        count: Infinity
    };
    this.userData = {
    };
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: BufferGeometry,
    isBufferGeometry: true,
    getIndex: function() {
        return this.index;
    },
    setIndex: function(index) {
        if (Array.isArray(index)) this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
        else this.index = index;
        return this;
    },
    getAttribute: function(name) {
        return this.attributes[name];
    },
    setAttribute: function(name, attribute) {
        this.attributes[name] = attribute;
        return this;
    },
    deleteAttribute: function(name) {
        delete this.attributes[name];
        return this;
    },
    hasAttribute: function(name) {
        return this.attributes[name] !== undefined;
    },
    addGroup: function(start, count, materialIndex1 = 0) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex1
        });
    },
    clearGroups: function() {
        this.groups = [];
    },
    setDrawRange: function(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
    },
    applyMatrix4: function(matrix) {
        const position = this.attributes.position;
        if (position !== undefined) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
        }
        const normal3 = this.attributes.normal;
        if (normal3 !== undefined) {
            const normalMatrix = new Matrix3().getNormalMatrix(matrix);
            normal3.applyNormalMatrix(normalMatrix);
            normal3.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== undefined) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        return this;
    },
    rotateX: function(angle) {
        // rotate geometry around world x-axis
        _m1$2.makeRotationX(angle);
        this.applyMatrix4(_m1$2);
        return this;
    },
    rotateY: function(angle) {
        // rotate geometry around world y-axis
        _m1$2.makeRotationY(angle);
        this.applyMatrix4(_m1$2);
        return this;
    },
    rotateZ: function(angle) {
        // rotate geometry around world z-axis
        _m1$2.makeRotationZ(angle);
        this.applyMatrix4(_m1$2);
        return this;
    },
    translate: function(x6, y6, z5) {
        // translate geometry
        _m1$2.makeTranslation(x6, y6, z5);
        this.applyMatrix4(_m1$2);
        return this;
    },
    scale: function(x6, y6, z5) {
        // scale geometry
        _m1$2.makeScale(x6, y6, z5);
        this.applyMatrix4(_m1$2);
        return this;
    },
    lookAt: function(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
    },
    center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
    },
    setFromPoints: function(points) {
        const position = [];
        for(let i1 = 0, l = points.length; i1 < l; i1++){
            const point = points[i1];
            position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute('position', new Float32BufferAttribute(position, 3));
        return this;
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) this.boundingBox = new Box3();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
            return;
        }
        if (position !== undefined) {
            this.boundingBox.setFromBufferAttribute(position);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i1 = 0, il = morphAttributesPosition.length; i1 < il; i1++){
                const morphAttribute = morphAttributesPosition[i1];
                _box$2.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    _vector$4.addVectors(this.boundingBox.min, _box$2.min);
                    this.boundingBox.expandByPoint(_vector$4);
                    _vector$4.addVectors(this.boundingBox.max, _box$2.max);
                    this.boundingBox.expandByPoint(_vector$4);
                } else {
                    this.boundingBox.expandByPoint(_box$2.min);
                    this.boundingBox.expandByPoint(_box$2.max);
                }
            }
        } else this.boundingBox.makeEmpty();
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    },
    computeBoundingSphere: function() {
        if (this.boundingSphere === null) this.boundingSphere = new Sphere();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new Vector3(), Infinity);
            return;
        }
        if (position) {
            // first, find the center of the bounding sphere
            const center2 = this.boundingSphere.center;
            _box$2.setFromBufferAttribute(position);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i1 = 0, il = morphAttributesPosition.length; i1 < il; i1++){
                const morphAttribute = morphAttributesPosition[i1];
                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
                    _box$2.expandByPoint(_vector$4);
                    _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
                    _box$2.expandByPoint(_vector$4);
                } else {
                    _box$2.expandByPoint(_boxMorphTargets.min);
                    _box$2.expandByPoint(_boxMorphTargets.max);
                }
            }
            _box$2.getCenter(center2);
            // second, try to find a boundingSphere with a radius smaller than the
            // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
            let maxRadiusSq = 0;
            for(let i2 = 0, il1 = position.count; i2 < il1; i2++){
                _vector$4.fromBufferAttribute(position, i2);
                maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(_vector$4));
            }
            // process morph attributes if present
            if (morphAttributesPosition) for(let i3 = 0, il2 = morphAttributesPosition.length; i3 < il2; i3++){
                const morphAttribute = morphAttributesPosition[i3];
                const morphTargetsRelative = this.morphTargetsRelative;
                for(let j = 0, jl = morphAttribute.count; j < jl; j++){
                    _vector$4.fromBufferAttribute(morphAttribute, j);
                    if (morphTargetsRelative) {
                        _offset.fromBufferAttribute(position, j);
                        _vector$4.add(_offset);
                    }
                    maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(_vector$4));
                }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
    },
    computeFaceNormals: function() {
    // backwards compatibility
    },
    computeTangents: function() {
        const index = this.index;
        const attributes = this.attributes;
        // based on http://www.terathon.com/code/tangent.html
        // (per vertex tangents)
        if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
            console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
            return;
        }
        const indices = index.array;
        const positions = attributes.position.array;
        const normals = attributes.normal.array;
        const uvs = attributes.uv.array;
        const nVertices = positions.length / 3;
        if (attributes.tangent === undefined) this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
        const tangents = attributes.tangent.array;
        const tan1 = [], tan2 = [];
        for(let i1 = 0; i1 < nVertices; i1++){
            tan1[i1] = new Vector3();
            tan2[i1] = new Vector3();
        }
        const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
        function handleTriangle(a3, b4, c3) {
            vA.fromArray(positions, a3 * 3);
            vB.fromArray(positions, b4 * 3);
            vC.fromArray(positions, c3 * 3);
            uvA.fromArray(uvs, a3 * 2);
            uvB.fromArray(uvs, b4 * 2);
            uvC.fromArray(uvs, c3 * 2);
            vB.sub(vA);
            vC.sub(vA);
            uvB.sub(uvA);
            uvC.sub(uvA);
            const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
            // silently ignore degenerate uv triangles having coincident or colinear vertices
            if (!isFinite(r2)) return;
            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
            tan1[a3].add(sdir);
            tan1[b4].add(sdir);
            tan1[c3].add(sdir);
            tan2[a3].add(tdir);
            tan2[b4].add(tdir);
            tan2[c3].add(tdir);
        }
        let groups = this.groups;
        if (groups.length === 0) groups = [
            {
                start: 0,
                count: indices.length
            }
        ];
        for(let i2 = 0, il = groups.length; i2 < il; ++i2){
            const group = groups[i2];
            const start = group.start;
            const count = group.count;
            for(let j = start, jl = start + count; j < jl; j += 3)handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
        }
        const tmp = new Vector3(), tmp2 = new Vector3();
        const n = new Vector3(), n2 = new Vector3();
        function handleVertex(v) {
            n.fromArray(normals, v * 3);
            n2.copy(n);
            const t = tan1[v];
            // Gram-Schmidt orthogonalize
            tmp.copy(t);
            tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
            // Calculate handedness
            tmp2.crossVectors(n2, t);
            const test = tmp2.dot(tan2[v]);
            const w3 = test < 0 ? -1 : 1;
            tangents[v * 4] = tmp.x;
            tangents[v * 4 + 1] = tmp.y;
            tangents[v * 4 + 2] = tmp.z;
            tangents[v * 4 + 3] = w3;
        }
        for(let i3 = 0, il1 = groups.length; i3 < il1; ++i3){
            const group = groups[i3];
            const start = group.start;
            const count = group.count;
            for(let j = start, jl = start + count; j < jl; j += 3){
                handleVertex(indices[j + 0]);
                handleVertex(indices[j + 1]);
                handleVertex(indices[j + 2]);
            }
        }
    },
    computeVertexNormals: function() {
        const index = this.index;
        const positionAttribute = this.getAttribute('position');
        if (positionAttribute !== undefined) {
            let normalAttribute = this.getAttribute('normal');
            if (normalAttribute === undefined) {
                normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
                this.setAttribute('normal', normalAttribute);
            } else // reset existing normals to zero
            for(let i1 = 0, il = normalAttribute.count; i1 < il; i1++)normalAttribute.setXYZ(i1, 0, 0, 0);
            const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
            const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
            const cb = new Vector3(), ab = new Vector3();
            // indexed elements
            if (index) for(let i2 = 0, il1 = index.count; i2 < il1; i2 += 3){
                const vA = index.getX(i2 + 0);
                const vB = index.getX(i2 + 1);
                const vC = index.getX(i2 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
            else // non-indexed elements (unconnected triangle soup)
            for(let i3 = 0, il2 = positionAttribute.count; i3 < il2; i3 += 3){
                pA.fromBufferAttribute(positionAttribute, i3 + 0);
                pB.fromBufferAttribute(positionAttribute, i3 + 1);
                pC.fromBufferAttribute(positionAttribute, i3 + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i3 + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i3 + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i3 + 2, cb.x, cb.y, cb.z);
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
        }
    },
    merge: function(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
            return;
        }
        if (offset === undefined) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        const attributes = this.attributes;
        for(const key in attributes){
            if (geometry.attributes[key] === undefined) continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for(let i1 = 0, j = attributeOffset; i1 < length; i1++, j++)attributeArray1[j] = attributeArray2[i1];
        }
        return this;
    },
    normalizeNormals: function() {
        const normals = this.attributes.normal;
        for(let i1 = 0, il = normals.count; i1 < il; i1++){
            _vector$4.fromBufferAttribute(normals, i1);
            _vector$4.normalize();
            normals.setXYZ(i1, _vector$4.x, _vector$4.y, _vector$4.z);
        }
    },
    toNonIndexed: function() {
        function convertBufferAttribute(attribute, indices) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices.length * itemSize);
            let index = 0, index2 = 0;
            for(let i1 = 0, l = indices.length; i1 < l; i1++){
                index = indices[i1] * itemSize;
                for(let j = 0; j < itemSize; j++)array2[index2++] = array[index++];
            }
            return new BufferAttribute(array2, itemSize, normalized);
        }
        //
        if (this.index === null) {
            console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
            return this;
        }
        const geometry2 = new BufferGeometry();
        const indices = this.index.array;
        const attributes = this.attributes;
        // attributes
        for(const name in attributes){
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices);
            geometry2.setAttribute(name, newAttribute);
        }
        // morph attributes
        const morphAttributes = this.morphAttributes;
        for(const name1 in morphAttributes){
            const morphArray = [];
            const morphAttribute = morphAttributes[name1]; // morphAttribute: array of Float32BufferAttributes
            for(let i1 = 0, il = morphAttribute.length; i1 < il; i1++){
                const attribute = morphAttribute[i1];
                const newAttribute = convertBufferAttribute(attribute, indices);
                morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name1] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        // groups
        const groups = this.groups;
        for(let i1 = 0, l = groups.length; i1 < l; i1++){
            const group = groups[i1];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };
        // standard BufferGeometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        if (this.parameters !== undefined) {
            const parameters = this.parameters;
            for(const key in parameters)if (parameters[key] !== undefined) data[key] = parameters[key];
            return data;
        }
        data.data = {
            attributes: {
            }
        };
        const index = this.index;
        if (index !== null) data.data.index = {
            type: index.array.constructor.name,
            array: Array.prototype.slice.call(index.array)
        };
        const attributes = this.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            const attributeData = attribute.toJSON(data.data);
            if (attribute.name !== '') attributeData.name = attribute.name;
            data.data.attributes[key] = attributeData;
        }
        const morphAttributes = {
        };
        let hasMorphAttributes = false;
        for(const key1 in this.morphAttributes){
            const attributeArray = this.morphAttributes[key1];
            const array = [];
            for(let i1 = 0, il = attributeArray.length; i1 < il; i1++){
                const attribute = attributeArray[i1];
                const attributeData = attribute.toJSON(data.data);
                if (attribute.name !== '') attributeData.name = attribute.name;
                array.push(attributeData);
            }
            if (array.length > 0) {
                morphAttributes[key1] = array;
                hasMorphAttributes = true;
            }
        }
        if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) data.data.groups = JSON.parse(JSON.stringify(groups));
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
        };
        return data;
    },
    clone: function() {
        /*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */ return new BufferGeometry().copy(this);
    },
    copy: function(source) {
        // reset
        this.index = null;
        this.attributes = {
        };
        this.morphAttributes = {
        };
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // used for storing cloned, shared data
        const data = {
        };
        // name
        this.name = source.name;
        // index
        const index = source.index;
        if (index !== null) this.setIndex(index.clone(data));
        // attributes
        const attributes = source.attributes;
        for(const name in attributes){
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
        }
        // morph attributes
        const morphAttributes = source.morphAttributes;
        for(const name1 in morphAttributes){
            const array = [];
            const morphAttribute = morphAttributes[name1]; // morphAttribute: array of Float32BufferAttributes
            for(let i1 = 0, l = morphAttribute.length; i1 < l; i1++)array.push(morphAttribute[i1].clone(data));
            this.morphAttributes[name1] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        // groups
        const groups = source.groups;
        for(let i1 = 0, l = groups.length; i1 < l; i1++){
            const group = groups[i1];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        // bounding box
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        // bounding sphere
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        // draw range
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        // user data
        this.userData = source.userData;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
const _inverseMatrix = new Matrix4();
const _ray = new Ray();
const _sphere = new Sphere();
const _vA = new Vector3();
const _vB = new Vector3();
const _vC = new Vector3();
const _tempA = new Vector3();
const _tempB = new Vector3();
const _tempC = new Vector3();
const _morphA = new Vector3();
const _morphB = new Vector3();
const _morphC = new Vector3();
const _uvA = new Vector2();
const _uvB = new Vector2();
const _uvC = new Vector2();
const _intersectionPoint = new Vector3();
const _intersectionPointWorld = new Vector3();
function Mesh(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    Object3D.call(this);
    this.type = 'Mesh';
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Mesh,
    isMesh: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        if (source.morphTargetInfluences !== undefined) this.morphTargetInfluences = source.morphTargetInfluences.slice();
        if (source.morphTargetDictionary !== undefined) this.morphTargetDictionary = Object.assign({
        }, source.morphTargetDictionary);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {
                    };
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    },
    raycast: function(raycaster, intersects) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === undefined) return;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere) === false) return;
        //
        _inverseMatrix.copy(matrixWorld).invert();
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        // Check boundingBox before continuing
        if (geometry.boundingBox !== null) {
            if (_ray.intersectsBox(geometry.boundingBox) === false) return;
        }
        let intersection;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const position = geometry.attributes.position;
            const morphPosition = geometry.morphAttributes.position;
            const morphTargetsRelative = geometry.morphTargetsRelative;
            const uv = geometry.attributes.uv;
            const uv2 = geometry.attributes.uv2;
            const groups = geometry.groups;
            const drawRange = geometry.drawRange;
            if (index !== null) {
                // indexed buffer geometry
                if (Array.isArray(material)) for(let i1 = 0, il = groups.length; i1 < il; i1++){
                    const group = groups[i1];
                    const groupMaterial = material[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a3 = index.getX(j);
                        const b4 = index.getX(j + 1);
                        const c3 = index.getX(j + 2);
                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a3, b4, c3);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                            intersection.face.materialIndex = group.materialIndex;
                            intersects.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(index.count, drawRange.start + drawRange.count);
                    for(let i2 = start, il1 = end; i2 < il1; i2 += 3){
                        const a3 = index.getX(i2);
                        const b4 = index.getX(i2 + 1);
                        const c3 = index.getX(i2 + 2);
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a3, b4, c3);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i2 / 3); // triangle number in indexed buffer semantics
                            intersects.push(intersection);
                        }
                    }
                }
            } else if (position !== undefined) {
                // non-indexed buffer geometry
                if (Array.isArray(material)) for(let i1 = 0, il = groups.length; i1 < il; i1++){
                    const group = groups[i1];
                    const groupMaterial = material[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a3 = j;
                        const b4 = j + 1;
                        const c3 = j + 2;
                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a3, b4, c3);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                            intersection.face.materialIndex = group.materialIndex;
                            intersects.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(position.count, drawRange.start + drawRange.count);
                    for(let i2 = start, il1 = end; i2 < il1; i2 += 3){
                        const a3 = i2;
                        const b4 = i2 + 1;
                        const c3 = i2 + 2;
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a3, b4, c3);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i2 / 3); // triangle number in non-indexed buffer semantics
                            intersects.push(intersection);
                        }
                    }
                }
            }
        } else if (geometry.isGeometry) console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
});
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    else intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    if (intersect === null) return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
        distance: distance,
        point: _intersectionPointWorld.clone(),
        object: object
    };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a3, b4, c3) {
    _vA.fromBufferAttribute(position, a3);
    _vB.fromBufferAttribute(position, b4);
    _vC.fromBufferAttribute(position, c3);
    const morphInfluences = object.morphTargetInfluences;
    if (material.morphTargets && morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        _morphB.set(0, 0, 0);
        _morphC.set(0, 0, 0);
        for(let i1 = 0, il = morphPosition.length; i1 < il; i1++){
            const influence = morphInfluences[i1];
            const morphAttribute = morphPosition[i1];
            if (influence === 0) continue;
            _tempA.fromBufferAttribute(morphAttribute, a3);
            _tempB.fromBufferAttribute(morphAttribute, b4);
            _tempC.fromBufferAttribute(morphAttribute, c3);
            if (morphTargetsRelative) {
                _morphA.addScaledVector(_tempA, influence);
                _morphB.addScaledVector(_tempB, influence);
                _morphC.addScaledVector(_tempC, influence);
            } else {
                _morphA.addScaledVector(_tempA.sub(_vA), influence);
                _morphB.addScaledVector(_tempB.sub(_vB), influence);
                _morphC.addScaledVector(_tempC.sub(_vC), influence);
            }
        }
        _vA.add(_morphA);
        _vB.add(_morphB);
        _vC.add(_morphC);
    }
    if (object.isSkinnedMesh) {
        object.boneTransform(a3, _vA);
        object.boneTransform(b4, _vB);
        object.boneTransform(c3, _vC);
    }
    const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
    if (intersection) {
        if (uv) {
            _uvA.fromBufferAttribute(uv, a3);
            _uvB.fromBufferAttribute(uv, b4);
            _uvC.fromBufferAttribute(uv, c3);
            intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
        }
        if (uv2) {
            _uvA.fromBufferAttribute(uv2, a3);
            _uvB.fromBufferAttribute(uv2, b4);
            _uvC.fromBufferAttribute(uv2, c3);
            intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
        }
        const face = new Face3(a3, b4, c3);
        Triangle.getNormal(_vA, _vB, _vC, face.normal);
        intersection.face = face;
    }
    return intersection;
}
class BoxGeometry extends BufferGeometry {
    constructor(width3 = 1, height3 = 1, depth1 = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1){
        super();
        this.type = 'BoxGeometry';
        this.parameters = {
            width: width3,
            height: height3,
            depth: depth1,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        const scope = this;
        // segments
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        let numberOfVertices = 0;
        let groupStart = 0;
        // build each side of the box geometry
        buildPlane('z', 'y', 'x', -1, -1, depth1, height3, width3, depthSegments, heightSegments, 0); // px
        buildPlane('z', 'y', 'x', 1, -1, depth1, height3, -width3, depthSegments, heightSegments, 1); // nx
        buildPlane('x', 'z', 'y', 1, 1, width3, depth1, height3, widthSegments, depthSegments, 2); // py
        buildPlane('x', 'z', 'y', 1, -1, width3, depth1, -height3, widthSegments, depthSegments, 3); // ny
        buildPlane('x', 'y', 'z', 1, -1, width3, height3, depth1, widthSegments, heightSegments, 4); // pz
        buildPlane('x', 'y', 'z', -1, -1, width3, height3, -depth1, widthSegments, heightSegments, 5); // nz
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
        function buildPlane(u, v, w3, udir, vdir, width4, height4, depth1, gridX, gridY, materialIndex1) {
            const segmentWidth = width4 / gridX;
            const segmentHeight = height4 / gridY;
            const widthHalf = width4 / 2;
            const heightHalf = height4 / 2;
            const depthHalf = depth1 / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector3();
            // generate vertices, normals and uvs
            for(let iy = 0; iy < gridY1; iy++){
                const y6 = iy * segmentHeight - heightHalf;
                for(let ix = 0; ix < gridX1; ix++){
                    const x6 = ix * segmentWidth - widthHalf;
                    // set values to correct vector component
                    vector[u] = x6 * udir;
                    vector[v] = y6 * vdir;
                    vector[w3] = depthHalf;
                    // now apply vector to vertex buffer
                    vertices.push(vector.x, vector.y, vector.z);
                    // set values to correct vector component
                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w3] = depth1 > 0 ? 1 : -1;
                    // now apply vector to normal buffer
                    normals.push(vector.x, vector.y, vector.z);
                    // uvs
                    uvs.push(ix / gridX);
                    uvs.push(1 - iy / gridY);
                    // counters
                    vertexCounter += 1;
                }
            }
            // indices
            // 1. you need three indices to draw a single face
            // 2. a single segment consists of two faces
            // 3. so we need to generate six (2*3) indices per segment
            for(let iy1 = 0; iy1 < gridY; iy1++)for(let ix = 0; ix < gridX; ix++){
                const a3 = numberOfVertices + ix + gridX1 * iy1;
                const b4 = numberOfVertices + ix + gridX1 * (iy1 + 1);
                const c3 = numberOfVertices + (ix + 1) + gridX1 * (iy1 + 1);
                const d = numberOfVertices + (ix + 1) + gridX1 * iy1;
                // faces
                indices.push(a3, b4, d);
                indices.push(b4, c3, d);
                // increase counter
                groupCount += 6;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, materialIndex1);
            // calculate new start value for groups
            groupStart += groupCount;
            // update total number of vertices
            numberOfVertices += vertexCounter;
        }
    }
}
/**
 * Uniform Utilities
 */ function cloneUniforms(src) {
    const dst = {
    };
    for(const u in src){
        dst[u] = {
        };
        for(const p in src[u]){
            const property = src[u][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) dst[u][p] = property.clone();
            else if (Array.isArray(property)) dst[u][p] = property.slice();
            else dst[u][p] = property;
        }
    }
    return dst;
}
function mergeUniforms(uniforms) {
    const merged = {
    };
    for(let u = 0; u < uniforms.length; u++){
        const tmp = cloneUniforms(uniforms[u]);
        for(const p in tmp)merged[p] = tmp[p];
    }
    return merged;
}
// Legacy
const UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
};
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function ShaderMaterial(parameters) {
    Material.call(this);
    this.type = 'ShaderMaterial';
    this.defines = {
    };
    this.uniforms = {
    };
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false; // set to use scene fog
    this.lights = false; // set to use scene lights
    this.clipping = false; // set to use user-defined clipping planes
    this.skinning = false; // set to use skinning attribute streams
    this.morphTargets = false; // set to use morph targets
    this.morphNormals = false; // set to use morph normals
    this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false
    };
    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [
            1,
            1,
            1
        ],
        'uv': [
            0,
            0
        ],
        'uv2': [
            0,
            0
        ]
    };
    this.index0AttributeName = undefined;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== undefined) {
        if (parameters.attributes !== undefined) console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
        this.setValues(parameters);
    }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({
    }, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = Object.assign({
    }, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
    const data = Material.prototype.toJSON.call(this, meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {
    };
    for(const name in this.uniforms){
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) data.uniforms[name] = {
            type: 't',
            value: value.toJSON(meta).uuid
        };
        else if (value && value.isColor) data.uniforms[name] = {
            type: 'c',
            value: value.getHex()
        };
        else if (value && value.isVector2) data.uniforms[name] = {
            type: 'v2',
            value: value.toArray()
        };
        else if (value && value.isVector3) data.uniforms[name] = {
            type: 'v3',
            value: value.toArray()
        };
        else if (value && value.isVector4) data.uniforms[name] = {
            type: 'v4',
            value: value.toArray()
        };
        else if (value && value.isMatrix3) data.uniforms[name] = {
            type: 'm3',
            value: value.toArray()
        };
        else if (value && value.isMatrix4) data.uniforms[name] = {
            type: 'm4',
            value: value.toArray()
        };
        else data.uniforms[name] = {
            value: value
        };
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {
    };
    for(const key in this.extensions)if (this.extensions[key] === true) extensions[key] = true;
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
};
function Camera() {
    Object3D.call(this);
    this.type = 'Camera';
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Camera,
    isCamera: true,
    copy: function(source, recursive) {
        Object3D.prototype.copy.call(this, source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
    },
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn('THREE.Camera: .getWorldDirection() target is now required');
            target = new Vector3();
        }
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
        Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
});
function PerspectiveCamera(fov = 50, aspect = 1, near = 0.1, far = 2000) {
    Camera.call(this);
    this.type = 'PerspectiveCamera';
    this.fov = fov;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect;
    this.view = null;
    this.filmGauge = 35; // width of the film (default in millimeters)
    this.filmOffset = 0; // horizontal film offset (same unit as gauge)
    this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: PerspectiveCamera,
    isPerspectiveCamera: true,
    copy: function(source, recursive) {
        Camera.prototype.copy.call(this, source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({
        }, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
    },
    /**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */ setFocalLength: function(focalLength) {
        /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */ const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    },
    /**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */ getFocalLength: function() {
        const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    },
    getEffectiveFOV: function() {
        return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
        // film not completely covered in portrait format (aspect < 1)
        return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
        // film not completely covered in landscape format (aspect > 1)
        return this.filmGauge / Math.max(this.aspect, 1);
    },
    /**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */ setViewOffset: function(fullWidth, fullHeight, x6, y6, width4, height4) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x6;
        this.view.offsetY = y6;
        this.view.width = width4;
        this.view.height = height4;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        const near = this.near;
        let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
        let height4 = 2 * top;
        let width4 = this.aspect * height4;
        let left = -0.5 * width4;
        const view = this.view;
        if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width4 / fullWidth;
            top -= view.offsetY * height4 / fullHeight;
            width4 *= view.width / fullWidth;
            height4 *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width4, top, top - height4, near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null) data.object.view = Object.assign({
        }, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
    }
});
const fov = 90, aspect = 1;
function CubeCamera(near, far, renderTarget) {
    Object3D.call(this);
    this.type = 'CubeCamera';
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
        console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
        return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
    this.update = function(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        const currentXrEnabled = renderer.xr.enabled;
        const currentRenderTarget = renderer.getRenderTarget();
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.xr.enabled = currentXrEnabled;
    };
}
CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    format = format !== undefined ? format : RGBFormat;
    Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
    // Why CubeTexture._needsFlipEnvMap is necessary:
    //
    // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
    // and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
    // when using WebGLCubeRenderTarget.texture as a cube texture.
    this._needsFlipEnvMap = true;
}
CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, 'images', {
    get: function() {
        return this.image;
    },
    set: function(value) {
        this.image = value;
    }
});
class WebGLCubeRenderTarget extends WebGLRenderTarget {
    constructor(size1, options2, dummy){
        if (Number.isInteger(options2)) {
            console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
            options2 = dummy;
        }
        super(size1, size1, options2);
        Object.defineProperty(this, 'isWebGLCubeRenderTarget', {
            value: true
        });
        options2 = options2 || {
        };
        this.texture = new CubeTexture(undefined, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
        this.texture._needsFlipEnvMap = false;
    }
    fromEquirectangularTexture(renderer, texture) {
        this.texture.type = texture.type;
        this.texture.format = RGBAFormat; // see #18859
        this.texture.encoding = texture.encoding;
        this.texture.generateMipmaps = texture.generateMipmaps;
        this.texture.minFilter = texture.minFilter;
        this.texture.magFilter = texture.magFilter;
        const shader = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: /* glsl */ `\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			`,
            fragmentShader: /* glsl */ `\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			`
        };
        const geometry = new BoxGeometry(5, 5, 5);
        const material = new ShaderMaterial({
            name: 'CubemapFromEquirect',
            uniforms: cloneUniforms(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: BackSide,
            blending: NoBlending
        });
        material.uniforms.tEquirect.value = texture;
        const mesh = new Mesh(geometry, material);
        const currentMinFilter = texture.minFilter;
        // Avoid blurred poles
        if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
        const camera = new CubeCamera(1, 10, this);
        camera.update(renderer, mesh);
        texture.minFilter = currentMinFilter;
        mesh.geometry.dispose();
        mesh.material.dispose();
        return this;
    }
    clear(renderer, color, depth, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for(let i1 = 0; i1 < 6; i1++){
            renderer.setRenderTarget(this, i1);
            renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
    }
}
function DataTexture(data, width4, height4, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        data: data || null,
        width: width4 || 1,
        height: height4 || 1
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
}
DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
const _sphere$1 = /*@__PURE__*/ new Sphere();
const _vector$5 = /*@__PURE__*/ new Vector3();
class Frustum {
    constructor(p01, p11, p21, p31, p41, p51){
        this.planes = [
            p01 !== undefined ? p01 : new Plane(),
            p11 !== undefined ? p11 : new Plane(),
            p21 !== undefined ? p21 : new Plane(),
            p31 !== undefined ? p31 : new Plane(),
            p41 !== undefined ? p41 : new Plane(),
            p51 !== undefined ? p51 : new Plane()
        ];
    }
    set(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(frustum) {
        const planes = this.planes;
        for(let i1 = 0; i1 < 6; i1++)planes[i1].copy(frustum.planes[i1]);
        return this;
    }
    setFromProjectionMatrix(m) {
        const planes = this.planes;
        const me = m.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    }
    intersectsObject(object) {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere$1);
    }
    intersectsSprite(sprite) {
        _sphere$1.center.set(0, 0, 0);
        _sphere$1.radius = 0.7071067811865476;
        _sphere$1.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere$1);
    }
    intersectsSphere(sphere) {
        const planes = this.planes;
        const center2 = sphere.center;
        const negRadius = -sphere.radius;
        for(let i1 = 0; i1 < 6; i1++){
            const distance = planes[i1].distanceToPoint(center2);
            if (distance < negRadius) return false;
        }
        return true;
    }
    intersectsBox(box) {
        const planes = this.planes;
        for(let i1 = 0; i1 < 6; i1++){
            const plane = planes[i1];
            // corner at max distance
            _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector$5) < 0) return false;
        }
        return true;
    }
    containsPoint(point) {
        const planes = this.planes;
        for(let i1 = 0; i1 < 6; i1++){
            if (planes[i1].distanceToPoint(point) < 0) return false;
        }
        return true;
    }
}
function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
        animationLoop(time, frame);
        requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
        start: function() {
            if (isAnimating === true) return;
            if (animationLoop === null) return;
            requestId = context.requestAnimationFrame(onAnimationFrame);
            isAnimating = true;
        },
        stop: function() {
            context.cancelAnimationFrame(requestId);
            isAnimating = false;
        },
        setAnimationLoop: function(callback) {
            animationLoop = callback;
        },
        setContext: function(value) {
            context = value;
        }
    };
}
function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
        const array = attribute.array;
        const usage = attribute.usage;
        const buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array, usage);
        attribute.onUploadCallback();
        let type = 5126;
        if (array instanceof Float32Array) type = 5126;
        else if (array instanceof Float64Array) console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
        else if (array instanceof Uint16Array) {
            if (attribute.isFloat16BufferAttribute) {
                if (isWebGL2) type = 5131;
                else console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
            } else type = 5123;
        } else if (array instanceof Int16Array) type = 5122;
        else if (array instanceof Uint32Array) type = 5125;
        else if (array instanceof Int32Array) type = 5124;
        else if (array instanceof Int8Array) type = 5120;
        else if (array instanceof Uint8Array) type = 5121;
        return {
            buffer: buffer,
            type: type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
        };
    }
    function updateBuffer(buffer, attribute, bufferType) {
        const array = attribute.array;
        const updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (updateRange.count === -1) // Not using update ranges
        gl.bufferSubData(bufferType, 0, array);
        else {
            if (isWebGL2) gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
            else gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            updateRange.count = -1; // reset range
        }
    }
    //
    function get(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        return buffers.get(attribute);
    }
    function remove(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
        }
    }
    function update(attribute, bufferType) {
        if (attribute.isGLBufferAttribute) {
            const cached = buffers.get(attribute);
            if (!cached || cached.version < attribute.version) buffers.set(attribute, {
                buffer: attribute.buffer,
                type: attribute.type,
                bytesPerElement: attribute.elementSize,
                version: attribute.version
            });
            return;
        }
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data === undefined) buffers.set(attribute, createBuffer(attribute, bufferType));
        else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
        }
    }
    return {
        get: get,
        remove: remove,
        update: update
    };
}
class PlaneGeometry extends BufferGeometry {
    constructor(width4 = 1, height4 = 1, widthSegments1 = 1, heightSegments1 = 1){
        super();
        this.type = 'PlaneGeometry';
        this.parameters = {
            width: width4,
            height: height4,
            widthSegments: widthSegments1,
            heightSegments: heightSegments1
        };
        const width_half = width4 / 2;
        const height_half = height4 / 2;
        const gridX = Math.floor(widthSegments1);
        const gridY = Math.floor(heightSegments1);
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        const segment_width = width4 / gridX;
        const segment_height = height4 / gridY;
        //
        const indices1 = [];
        const vertices1 = [];
        const normals1 = [];
        const uvs1 = [];
        for(let iy = 0; iy < gridY1; iy++){
            const y6 = iy * segment_height - height_half;
            for(let ix = 0; ix < gridX1; ix++){
                const x6 = ix * segment_width - width_half;
                vertices1.push(x6, -y6, 0);
                normals1.push(0, 0, 1);
                uvs1.push(ix / gridX);
                uvs1.push(1 - iy / gridY);
            }
        }
        for(let iy1 = 0; iy1 < gridY; iy1++)for(let ix = 0; ix < gridX; ix++){
            const a3 = ix + gridX1 * iy1;
            const b4 = ix + gridX1 * (iy1 + 1);
            const c3 = ix + 1 + gridX1 * (iy1 + 1);
            const d = ix + 1 + gridX1 * iy1;
            indices1.push(a3, b4, d);
            indices1.push(b4, c3, d);
        }
        this.setIndex(indices1);
        this.setAttribute('position', new Float32BufferAttribute(vertices1, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals1, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs1, 2));
    }
}
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const ShaderChunk = {
    alphamap_fragment: alphamap_fragment,
    alphamap_pars_fragment: alphamap_pars_fragment,
    alphatest_fragment: alphatest_fragment,
    aomap_fragment: aomap_fragment,
    aomap_pars_fragment: aomap_pars_fragment,
    begin_vertex: begin_vertex,
    beginnormal_vertex: beginnormal_vertex,
    bsdfs: bsdfs,
    bumpmap_pars_fragment: bumpmap_pars_fragment,
    clipping_planes_fragment: clipping_planes_fragment,
    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    clipping_planes_vertex: clipping_planes_vertex,
    color_fragment: color_fragment,
    color_pars_fragment: color_pars_fragment,
    color_pars_vertex: color_pars_vertex,
    color_vertex: color_vertex,
    common: common,
    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    defaultnormal_vertex: defaultnormal_vertex,
    displacementmap_pars_vertex: displacementmap_pars_vertex,
    displacementmap_vertex: displacementmap_vertex,
    emissivemap_fragment: emissivemap_fragment,
    emissivemap_pars_fragment: emissivemap_pars_fragment,
    encodings_fragment: encodings_fragment,
    encodings_pars_fragment: encodings_pars_fragment,
    envmap_fragment: envmap_fragment,
    envmap_common_pars_fragment: envmap_common_pars_fragment,
    envmap_pars_fragment: envmap_pars_fragment,
    envmap_pars_vertex: envmap_pars_vertex,
    envmap_physical_pars_fragment: envmap_physical_pars_fragment,
    envmap_vertex: envmap_vertex,
    fog_vertex: fog_vertex,
    fog_pars_vertex: fog_pars_vertex,
    fog_fragment: fog_fragment,
    fog_pars_fragment: fog_pars_fragment,
    gradientmap_pars_fragment: gradientmap_pars_fragment,
    lightmap_fragment: lightmap_fragment,
    lightmap_pars_fragment: lightmap_pars_fragment,
    lights_lambert_vertex: lights_lambert_vertex,
    lights_pars_begin: lights_pars_begin,
    lights_toon_fragment: lights_toon_fragment,
    lights_toon_pars_fragment: lights_toon_pars_fragment,
    lights_phong_fragment: lights_phong_fragment,
    lights_phong_pars_fragment: lights_phong_pars_fragment,
    lights_physical_fragment: lights_physical_fragment,
    lights_physical_pars_fragment: lights_physical_pars_fragment,
    lights_fragment_begin: lights_fragment_begin,
    lights_fragment_maps: lights_fragment_maps,
    lights_fragment_end: lights_fragment_end,
    logdepthbuf_fragment: logdepthbuf_fragment,
    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    logdepthbuf_vertex: logdepthbuf_vertex,
    map_fragment: map_fragment,
    map_pars_fragment: map_pars_fragment,
    map_particle_fragment: map_particle_fragment,
    map_particle_pars_fragment: map_particle_pars_fragment,
    metalnessmap_fragment: metalnessmap_fragment,
    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    morphnormal_vertex: morphnormal_vertex,
    morphtarget_pars_vertex: morphtarget_pars_vertex,
    morphtarget_vertex: morphtarget_vertex,
    normal_fragment_begin: normal_fragment_begin,
    normal_fragment_maps: normal_fragment_maps,
    normalmap_pars_fragment: normalmap_pars_fragment,
    clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment: clearcoat_pars_fragment,
    packing: packing,
    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    project_vertex: project_vertex,
    dithering_fragment: dithering_fragment,
    dithering_pars_fragment: dithering_pars_fragment,
    roughnessmap_fragment: roughnessmap_fragment,
    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    shadowmap_pars_fragment: shadowmap_pars_fragment,
    shadowmap_pars_vertex: shadowmap_pars_vertex,
    shadowmap_vertex: shadowmap_vertex,
    shadowmask_pars_fragment: shadowmask_pars_fragment,
    skinbase_vertex: skinbase_vertex,
    skinning_pars_vertex: skinning_pars_vertex,
    skinning_vertex: skinning_vertex,
    skinnormal_vertex: skinnormal_vertex,
    specularmap_fragment: specularmap_fragment,
    specularmap_pars_fragment: specularmap_pars_fragment,
    tonemapping_fragment: tonemapping_fragment,
    tonemapping_pars_fragment: tonemapping_pars_fragment,
    transmissionmap_fragment: transmissionmap_fragment,
    transmissionmap_pars_fragment: transmissionmap_pars_fragment,
    uv_pars_fragment: uv_pars_fragment,
    uv_pars_vertex: uv_pars_vertex,
    uv_vertex: uv_vertex,
    uv2_pars_fragment: uv2_pars_fragment,
    uv2_pars_vertex: uv2_pars_vertex,
    uv2_vertex: uv2_vertex,
    worldpos_vertex: worldpos_vertex,
    background_frag: background_frag,
    background_vert: background_vert,
    cube_frag: cube_frag,
    cube_vert: cube_vert,
    depth_frag: depth_frag,
    depth_vert: depth_vert,
    distanceRGBA_frag: distanceRGBA_frag,
    distanceRGBA_vert: distanceRGBA_vert,
    equirect_frag: equirect_frag,
    equirect_vert: equirect_vert,
    linedashed_frag: linedashed_frag,
    linedashed_vert: linedashed_vert,
    meshbasic_frag: meshbasic_frag,
    meshbasic_vert: meshbasic_vert,
    meshlambert_frag: meshlambert_frag,
    meshlambert_vert: meshlambert_vert,
    meshmatcap_frag: meshmatcap_frag,
    meshmatcap_vert: meshmatcap_vert,
    meshtoon_frag: meshtoon_frag,
    meshtoon_vert: meshtoon_vert,
    meshphong_frag: meshphong_frag,
    meshphong_vert: meshphong_vert,
    meshphysical_frag: meshphysical_frag,
    meshphysical_vert: meshphysical_vert,
    normal_frag: normal_frag,
    normal_vert: normal_vert,
    points_frag: points_frag,
    points_vert: points_vert,
    shadow_frag: shadow_frag,
    shadow_vert: shadow_vert,
    sprite_frag: sprite_frag,
    sprite_vert: sprite_vert
};
/**
 * Uniforms library for shared webgl shaders
 */ const UniformsLib = {
    common: {
        diffuse: {
            value: new Color(15658734)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        },
        uv2Transform: {
            value: new Matrix3()
        },
        alphaMap: {
            value: null
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        refractionRatio: {
            value: 0.98
        },
        maxMipLevel: {
            value: 0
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Vector2(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 0.00025
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2000
        },
        fogColor: {
            value: new Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {
                },
                color: {
                }
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                }
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                direction: {
                },
                distance: {
                },
                coneCos: {
                },
                penumbraCos: {
                },
                decay: {
                }
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                }
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                decay: {
                },
                distance: {
                }
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                },
                shadowCameraNear: {
                },
                shadowCameraFar: {
                }
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {
                },
                skyColor: {
                },
                groundColor: {
                }
            }
        },
        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
        rectAreaLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                width: {
                },
                height: {
                }
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Color(15658734)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        }
    },
    sprite: {
        diffuse: {
            value: new Color(15658734)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Vector2(0.5, 0.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new Matrix3()
        }
    }
};
const ShaderLib = {
    basic: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.specularmap,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                },
                specular: {
                    value: new Color(1118481)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.envmap,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.roughnessmap,
            UniformsLib.metalnessmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.aomap,
            UniformsLib.lightmap,
            UniformsLib.emissivemap,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.gradientmap,
            UniformsLib.fog,
            UniformsLib.lights,
            {
                emissive: {
                    value: new Color(0)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            UniformsLib.fog,
            {
                matcap: {
                    value: null
                }
            }
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
        uniforms: mergeUniforms([
            UniformsLib.points,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.bumpmap,
            UniformsLib.normalmap,
            UniformsLib.displacementmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.normal_vert,
        fragmentShader: ShaderChunk.normal_frag
    },
    sprite: {
        uniforms: mergeUniforms([
            UniformsLib.sprite,
            UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Matrix3()
            },
            t2D: {
                value: null
            }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
    },
    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */ cube: {
        uniforms: mergeUniforms([
            UniformsLib.envmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: mergeUniforms([
            UniformsLib.common,
            UniformsLib.displacementmap,
            {
                referencePosition: {
                    value: new Vector3()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            }
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: mergeUniforms([
            UniformsLib.lights,
            UniformsLib.fog,
            {
                color: {
                    value: new Color(0)
                },
                opacity: {
                    value: 1
                }
            }, 
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
    }
};
ShaderLib.physical = {
    uniforms: mergeUniforms([
        ShaderLib.standard.uniforms,
        {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new Vector2(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new Color(0)
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            }
        }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = 0;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene, camera, forceClear) {
        let background = scene.isScene === true ? scene.background : null;
        if (background && background.isTexture) background = cubemaps.get(background);
        // Ignore background in AR
        // TODO: Reconsider this.
        const xr = renderer.xr;
        const session = xr.getSession && xr.getSession();
        if (session && session.environmentBlendMode === 'additive') background = null;
        if (background === null) setClear(clearColor, clearAlpha);
        else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
        }
        if (renderer.autoClear || forceClear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
            if (boxMesh === undefined) {
                boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
                    name: 'BackgroundCubeMaterial',
                    uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                    vertexShader: ShaderLib.cube.vertexShader,
                    fragmentShader: ShaderLib.cube.fragmentShader,
                    side: BackSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                boxMesh.geometry.deleteAttribute('normal');
                boxMesh.geometry.deleteAttribute('uv');
                boxMesh.onBeforeRender = function(renderer1, scene1, camera1) {
                    this.matrixWorld.copyPosition(camera1.matrixWorld);
                };
                // enable code injection for non-built-in material
                Object.defineProperty(boxMesh.material, 'envMap', {
                    get: function() {
                        return this.uniforms.envMap.value;
                    }
                });
                objects.update(boxMesh);
            }
            if (background.isWebGLCubeRenderTarget) // TODO Deprecate
            background = background.texture;
            boxMesh.material.uniforms.envMap.value = background;
            boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                boxMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
        } else if (background && background.isTexture) {
            if (planeMesh === undefined) {
                planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
                    name: 'BackgroundMaterial',
                    uniforms: cloneUniforms(ShaderLib.background.uniforms),
                    vertexShader: ShaderLib.background.vertexShader,
                    fragmentShader: ShaderLib.background.fragmentShader,
                    side: FrontSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                planeMesh.geometry.deleteAttribute('normal');
                // enable code injection for non-built-in material
                Object.defineProperty(planeMesh.material, 'map', {
                    get: function() {
                        return this.uniforms.t2D.value;
                    }
                });
                objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) background.updateMatrix();
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                planeMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
        }
    }
    function setClear(color2, alpha) {
        state.buffers.color.setClear(color2.r, color2.g, color2.b, alpha, premultipliedAlpha);
    }
    return {
        getClearColor: function() {
            return clearColor;
        },
        setClearColor: function(color2, alpha = 1) {
            clearColor.set(color2);
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function() {
            return clearAlpha;
        },
        setClearAlpha: function(alpha) {
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        render: render
    };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {
    };
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    function setup(object, material, program, geometry, index) {
        let updateBuffers = false;
        if (vaoAvailable) {
            const state = getBindingState(geometry, program, material);
            if (currentState !== state) {
                currentState = state;
                bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(geometry, index);
            if (updateBuffers) saveCache(geometry, index);
        } else {
            const wireframe = material.wireframe === true;
            if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
                currentState.geometry = geometry.id;
                currentState.program = program.id;
                currentState.wireframe = wireframe;
                updateBuffers = true;
            }
        }
        if (object.isInstancedMesh === true) updateBuffers = true;
        if (index !== null) attributes.update(index, 34963);
        if (updateBuffers) {
            setupVertexAttributes(object, material, program, geometry);
            if (index !== null) gl.bindBuffer(34963, attributes.get(index).buffer);
        }
    }
    function createVertexArrayObject() {
        if (capabilities.isWebGL2) return gl.createVertexArray();
        return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
        return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
        return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
        const wireframe = material.wireframe === true;
        let programMap = bindingStates[geometry.id];
        if (programMap === undefined) {
            programMap = {
            };
            bindingStates[geometry.id] = programMap;
        }
        let stateMap = programMap[program.id];
        if (stateMap === undefined) {
            stateMap = {
            };
            programMap[program.id] = stateMap;
        }
        let state = stateMap[wireframe];
        if (state === undefined) {
            state = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state;
        }
        return state;
    }
    function createBindingState(vao) {
        const newAttributes = [];
        const enabledAttributes = [];
        const attributeDivisors = [];
        for(let i1 = 0; i1 < maxVertexAttributes; i1++){
            newAttributes[i1] = 0;
            enabledAttributes[i1] = 0;
            attributeDivisors[i1] = 0;
        }
        return {
            // for backward compatibility on non-VAO support browser
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: newAttributes,
            enabledAttributes: enabledAttributes,
            attributeDivisors: attributeDivisors,
            object: vao,
            attributes: {
            },
            index: null
        };
    }
    function needsUpdate(geometry, index) {
        const cachedAttributes = currentState.attributes;
        const geometryAttributes = geometry.attributes;
        let attributesNum = 0;
        for(const key in geometryAttributes){
            const cachedAttribute = cachedAttributes[key];
            const geometryAttribute = geometryAttributes[key];
            if (cachedAttribute === undefined) return true;
            if (cachedAttribute.attribute !== geometryAttribute) return true;
            if (cachedAttribute.data !== geometryAttribute.data) return true;
            attributesNum++;
        }
        if (currentState.attributesNum !== attributesNum) return true;
        if (currentState.index !== index) return true;
        return false;
    }
    function saveCache(geometry, index) {
        const cache = {
        };
        const attributes1 = geometry.attributes;
        let attributesNum = 0;
        for(const key in attributes1){
            const attribute = attributes1[key];
            const data = {
            };
            data.attribute = attribute;
            if (attribute.data) data.data = attribute.data;
            cache[key] = data;
            attributesNum++;
        }
        currentState.attributes = cache;
        currentState.attributesNum = attributesNum;
        currentState.index = index;
    }
    function initAttributes() {
        const newAttributes = currentState.newAttributes;
        for(let i1 = 0, il = newAttributes.length; i1 < il; i1++)newAttributes[i1] = 0;
    }
    function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        const attributeDivisors = currentState.attributeDivisors;
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension1 = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
            extension1[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
        }
    }
    function disableUnusedAttributes() {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        for(let i1 = 0, il = enabledAttributes.length; i1 < il; i1++)if (enabledAttributes[i1] !== newAttributes[i1]) {
            gl.disableVertexAttribArray(i1);
            enabledAttributes[i1] = 0;
        }
    }
    function vertexAttribPointer(index, size1, type, normalized, stride, offset) {
        if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) gl.vertexAttribIPointer(index, size1, type, stride, offset);
        else gl.vertexAttribPointer(index, size1, type, normalized, stride, offset);
    }
    function setupVertexAttributes(object, material, program, geometry) {
        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
            if (extensions.get('ANGLE_instanced_arrays') === null) return;
        }
        initAttributes();
        const geometryAttributes = geometry.attributes;
        const programAttributes = program.getAttributes();
        const materialDefaultAttributeValues = material.defaultAttributeValues;
        for(const name in programAttributes){
            const programAttribute = programAttributes[name];
            if (programAttribute >= 0) {
                const geometryAttribute = geometryAttributes[name];
                if (geometryAttribute !== undefined) {
                    const normalized = geometryAttribute.normalized;
                    const size1 = geometryAttribute.itemSize;
                    const attribute = attributes.get(geometryAttribute);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    const bytesPerElement = attribute.bytesPerElement;
                    if (geometryAttribute.isInterleavedBufferAttribute) {
                        const data = geometryAttribute.data;
                        const stride = data.stride;
                        const offset = geometryAttribute.offset;
                        if (data && data.isInstancedInterleavedBuffer) {
                            enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                            if (geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                        } else enableAttribute(programAttribute);
                        gl.bindBuffer(34962, buffer);
                        vertexAttribPointer(programAttribute, size1, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                    } else {
                        if (geometryAttribute.isInstancedBufferAttribute) {
                            enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                            if (geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                        } else enableAttribute(programAttribute);
                        gl.bindBuffer(34962, buffer);
                        vertexAttribPointer(programAttribute, size1, type, normalized, 0, 0);
                    }
                } else if (name === 'instanceMatrix') {
                    const attribute = attributes.get(object.instanceMatrix);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    enableAttributeAndDivisor(programAttribute + 0, 1);
                    enableAttributeAndDivisor(programAttribute + 1, 1);
                    enableAttributeAndDivisor(programAttribute + 2, 1);
                    enableAttributeAndDivisor(programAttribute + 3, 1);
                    gl.bindBuffer(34962, buffer);
                    gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
                    gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
                    gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
                    gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
                } else if (name === 'instanceColor') {
                    const attribute = attributes.get(object.instanceColor);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    enableAttributeAndDivisor(programAttribute, 1);
                    gl.bindBuffer(34962, buffer);
                    gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
                } else if (materialDefaultAttributeValues !== undefined) {
                    const value = materialDefaultAttributeValues[name];
                    if (value !== undefined) switch(value.length){
                        case 2:
                            gl.vertexAttrib2fv(programAttribute, value);
                            break;
                        case 3:
                            gl.vertexAttrib3fv(programAttribute, value);
                            break;
                        case 4:
                            gl.vertexAttrib4fv(programAttribute, value);
                            break;
                        default:
                            gl.vertexAttrib1fv(programAttribute, value);
                    }
                }
            }
        }
        disableUnusedAttributes();
    }
    function dispose() {
        reset();
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            for(const programId in programMap){
                const stateMap = programMap[programId];
                for(const wireframe in stateMap){
                    deleteVertexArrayObject(stateMap[wireframe].object);
                    delete stateMap[wireframe];
                }
                delete programMap[programId];
            }
            delete bindingStates[geometryId];
        }
    }
    function releaseStatesOfGeometry(geometry) {
        if (bindingStates[geometry.id] === undefined) return;
        const programMap = bindingStates[geometry.id];
        for(const programId in programMap){
            const stateMap = programMap[programId];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[programId];
        }
        delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === undefined) continue;
            const stateMap = programMap[program.id];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[program.id];
        }
    }
    function reset() {
        resetDefaultState();
        if (currentState === defaultState) return;
        currentState = defaultState;
        bindVertexArrayObject(currentState.object);
    }
    // for backward-compatilibity
    function resetDefaultState() {
        defaultState.geometry = null;
        defaultState.program = null;
        defaultState.wireframe = false;
    }
    return {
        setup: setup,
        reset: reset,
        resetDefaultState: resetDefaultState,
        dispose: dispose,
        releaseStatesOfGeometry: releaseStatesOfGeometry,
        releaseStatesOfProgram: releaseStatesOfProgram,
        initAttributes: initAttributes,
        enableAttribute: enableAttribute,
        disableUnusedAttributes: disableUnusedAttributes
    };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    function render(start, count) {
        gl.drawArrays(mode, start, count);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = 'drawArraysInstanced';
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            methodName = 'drawArraysInstancedANGLE';
            if (extension === null) {
                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, start, count, primcount);
        info.update(count, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
        if (maxAnisotropy !== undefined) return maxAnisotropy;
        const extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension !== null) maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        else maxAnisotropy = 0;
        return maxAnisotropy;
    }
    function getMaxPrecision(precision) {
        if (precision === 'highp') {
            if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) return 'highp';
            precision = 'mediump';
        }
        if (precision === 'mediump') {
            if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) return 'mediump';
        }
        return 'lowp';
    }
    /* eslint-disable no-undef */ const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
    /* eslint-enable no-undef */ let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
        console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
        precision = maxPrecision;
    }
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
        isWebGL2: isWebGL2,
        getMaxAnisotropy: getMaxAnisotropy,
        getMaxPrecision: getMaxPrecision,
        precision: precision,
        logarithmicDepthBuffer: logarithmicDepthBuffer,
        maxTextures: maxTextures,
        maxVertexTextures: maxVertexTextures,
        maxTextureSize: maxTextureSize,
        maxCubemapSize: maxCubemapSize,
        maxAttributes: maxAttributes,
        maxVertexUniforms: maxVertexUniforms,
        maxVaryings: maxVaryings,
        maxFragmentUniforms: maxFragmentUniforms,
        vertexTextures: vertexTextures,
        floatFragmentTextures: floatFragmentTextures,
        floatVertexTextures: floatVertexTextures,
        maxSamples: maxSamples
    };
}
function WebGLClipping(properties) {
    const scope1 = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
        value: null,
        needsUpdate: false
    };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
        const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
        // run another frame in order to reset the state:
        numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
    };
    this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
    };
    this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
    };
    this.setState = function(material, camera, useCache) {
        const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
        const materialProperties = properties.get(material);
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            // there's no local clipping
            if (renderingShadows) // there's no global clipping
            projectPlanes(null);
            else resetGlobalState();
        } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = materialProperties.clippingState || null;
            uniform.value = dstArray; // ensure unique state
            dstArray = projectPlanes(planes, camera, lGlobal, useCache);
            for(let i1 = 0; i1 !== lGlobal; ++i1)dstArray[i1] = globalState[i1];
            materialProperties.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
        }
    };
    function resetGlobalState() {
        if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope1.numPlanes = numGlobalPlanes;
        scope1.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
        const nPlanes = planes !== null ? planes.length : 0;
        let dstArray = null;
        if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
                const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) dstArray = new Float32Array(flatSize);
                for(let i1 = 0, i4 = dstOffset; i1 !== nPlanes; ++i1, i4 += 4){
                    plane.copy(planes[i1]).applyMatrix4(viewMatrix, viewNormalMatrix);
                    plane.normal.toArray(dstArray, i4);
                    dstArray[i4 + 3] = plane.constant;
                }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
        }
        scope1.numPlanes = nPlanes;
        scope1.numIntersection = 0;
        return dstArray;
    }
}
function WebGLCubeMaps(renderer) {
    let cubemaps = new WeakMap();
    function mapTextureMapping(texture, mapping) {
        if (mapping === EquirectangularReflectionMapping) texture.mapping = CubeReflectionMapping;
        else if (mapping === EquirectangularRefractionMapping) texture.mapping = CubeRefractionMapping;
        return texture;
    }
    function get(texture) {
        if (texture && texture.isTexture) {
            const mapping = texture.mapping;
            if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
                if (cubemaps.has(texture)) {
                    const cubemap = cubemaps.get(texture).texture;
                    return mapTextureMapping(cubemap, texture.mapping);
                } else {
                    const image = texture.image;
                    if (image && image.height > 0) {
                        const currentRenderList = renderer.getRenderList();
                        const currentRenderTarget = renderer.getRenderTarget();
                        const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
                        renderTarget.fromEquirectangularTexture(renderer, texture);
                        cubemaps.set(texture, renderTarget);
                        renderer.setRenderTarget(currentRenderTarget);
                        renderer.setRenderList(currentRenderList);
                        texture.addEventListener('dispose', onTextureDispose);
                        return mapTextureMapping(renderTarget.texture, texture.mapping);
                    } else // image not yet ready. try the conversion next frame
                    return null;
                }
            }
        }
        return texture;
    }
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        const cubemap = cubemaps.get(texture);
        if (cubemap !== undefined) {
            cubemaps.delete(texture);
            cubemap.dispose();
        }
    }
    function dispose() {
        cubemaps = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
function WebGLExtensions(gl) {
    const extensions = {
    };
    function getExtension(name) {
        if (extensions[name] !== undefined) return extensions[name];
        let extension;
        switch(name){
            case 'WEBGL_depth_texture':
                extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                break;
            case 'EXT_texture_filter_anisotropic':
                extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
            case 'WEBGL_compressed_texture_s3tc':
                extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
            case 'WEBGL_compressed_texture_pvrtc':
                extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
            default:
                extension = gl.getExtension(name);
        }
        extensions[name] = extension;
        return extension;
    }
    return {
        has: function(name) {
            return getExtension(name) !== null;
        },
        init: function(capabilities) {
            if (capabilities.isWebGL2) getExtension('EXT_color_buffer_float');
            else {
                getExtension('WEBGL_depth_texture');
                getExtension('OES_texture_float');
                getExtension('OES_texture_half_float');
                getExtension('OES_texture_half_float_linear');
                getExtension('OES_standard_derivatives');
                getExtension('OES_element_index_uint');
                getExtension('OES_vertex_array_object');
                getExtension('ANGLE_instanced_arrays');
            }
            getExtension('OES_texture_float_linear');
            getExtension('EXT_color_buffer_half_float');
        },
        get: function(name) {
            const extension = getExtension(name);
            if (extension === null) console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
            return extension;
        }
    };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = {
    };
    const wireframeAttributes = new WeakMap();
    function onGeometryDispose(event) {
        const geometry = event.target;
        if (geometry.index !== null) attributes.remove(geometry.index);
        for(const name in geometry.attributes)attributes.remove(geometry.attributes[name]);
        geometry.removeEventListener('dispose', onGeometryDispose);
        delete geometries[geometry.id];
        const attribute = wireframeAttributes.get(geometry);
        if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(geometry);
        }
        bindingStates.releaseStatesOfGeometry(geometry);
        if (geometry.isInstancedBufferGeometry === true) delete geometry._maxInstanceCount;
        //
        info.memory.geometries--;
    }
    function get(object, geometry) {
        if (geometries[geometry.id] === true) return geometry;
        geometry.addEventListener('dispose', onGeometryDispose);
        geometries[geometry.id] = true;
        info.memory.geometries++;
        return geometry;
    }
    function update(geometry) {
        const geometryAttributes = geometry.attributes;
        // Updating index buffer in VAO now. See WebGLBindingStates.
        for(const name in geometryAttributes)attributes.update(geometryAttributes[name], 34962);
        // morph targets
        const morphAttributes = geometry.morphAttributes;
        for(const name1 in morphAttributes){
            const array = morphAttributes[name1];
            for(let i1 = 0, l = array.length; i1 < l; i1++)attributes.update(array[i1], 34962);
        }
    }
    function updateWireframeAttribute(geometry) {
        const indices2 = [];
        const geometryIndex = geometry.index;
        const geometryPosition = geometry.attributes.position;
        let version = 0;
        if (geometryIndex !== null) {
            const array = geometryIndex.array;
            version = geometryIndex.version;
            for(let i1 = 0, l = array.length; i1 < l; i1 += 3){
                const a3 = array[i1 + 0];
                const b4 = array[i1 + 1];
                const c3 = array[i1 + 2];
                indices2.push(a3, b4, b4, c3, c3, a3);
            }
        } else {
            const array = geometryPosition.array;
            version = geometryPosition.version;
            for(let i1 = 0, l = array.length / 3 - 1; i1 < l; i1 += 3){
                const a3 = i1 + 0;
                const b4 = i1 + 1;
                const c3 = i1 + 2;
                indices2.push(a3, b4, b4, c3, c3, a3);
            }
        }
        const attribute = new (arrayMax(indices2) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices2, 1);
        attribute.version = version;
        // Updating index buffer in VAO now. See WebGLBindingStates
        //
        const previousAttribute = wireframeAttributes.get(geometry);
        if (previousAttribute) attributes.remove(previousAttribute);
        //
        wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
        const currentAttribute = wireframeAttributes.get(geometry);
        if (currentAttribute) {
            const geometryIndex = geometry.index;
            if (geometryIndex !== null) // if the attribute is obsolete, create a new one
            {
                if (currentAttribute.version < geometryIndex.version) updateWireframeAttribute(geometry);
            }
        } else updateWireframeAttribute(geometry);
        return wireframeAttributes.get(geometry);
    }
    return {
        get: get,
        update: update,
        getWireframeAttribute: getWireframeAttribute
    };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
        type = value.type;
        bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
        gl.drawElements(mode, count, type, start * bytesPerElement);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = 'drawElementsInstanced';
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            methodName = 'drawElementsInstancedANGLE';
            if (extension === null) {
                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, count, type, start * bytesPerElement, primcount);
        info.update(count, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
    const memory = {
        geometries: 0,
        textures: 0
    };
    const render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function update(count, mode, instanceCount) {
        render.calls++;
        switch(mode){
            case 4:
                render.triangles += instanceCount * (count / 3);
                break;
            case 1:
                render.lines += instanceCount * (count / 2);
                break;
            case 3:
                render.lines += instanceCount * (count - 1);
                break;
            case 2:
                render.lines += instanceCount * count;
                break;
            case 0:
                render.points += instanceCount * count;
                break;
            default:
                console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                break;
        }
    }
    function reset() {
        render.frame++;
        render.calls = 0;
        render.triangles = 0;
        render.points = 0;
        render.lines = 0;
    }
    return {
        memory: memory,
        render: render,
        programs: null,
        autoReset: true,
        reset: reset,
        update: update
    };
}
function numericalSort(a3, b4) {
    return a3[0] - b4[0];
}
function absNumericalSort(a3, b4) {
    return Math.abs(b4[1]) - Math.abs(a3[1]);
}
function WebGLMorphtargets(gl) {
    const influencesList = {
    };
    const morphInfluences = new Float32Array(8);
    const workInfluences = [];
    for(let i1 = 0; i1 < 8; i1++)workInfluences[i1] = [
        i1,
        0
    ];
    function update(object, geometry, material, program) {
        const objectInfluences = object.morphTargetInfluences;
        // When object doesn't have morph target influences defined, we treat it as a 0-length array
        // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
        const length = objectInfluences === undefined ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === undefined) {
            // initialise list
            influences = [];
            for(let i2 = 0; i2 < length; i2++)influences[i2] = [
                i2,
                0
            ];
            influencesList[geometry.id] = influences;
        }
        // Collect influences
        for(let i2 = 0; i2 < length; i2++){
            const influence = influences[i2];
            influence[0] = i2;
            influence[1] = objectInfluences[i2];
        }
        influences.sort(absNumericalSort);
        for(let i3 = 0; i3 < 8; i3++)if (i3 < length && influences[i3][1]) {
            workInfluences[i3][0] = influences[i3][0];
            workInfluences[i3][1] = influences[i3][1];
        } else {
            workInfluences[i3][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i3][1] = 0;
        }
        workInfluences.sort(numericalSort);
        const morphTargets = material.morphTargets && geometry.morphAttributes.position;
        const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for(let i4 = 0; i4 < 8; i4++){
            const influence = workInfluences[i4];
            const index = influence[0];
            const value = influence[1];
            if (index !== Number.MAX_SAFE_INTEGER && value) {
                if (morphTargets && geometry.getAttribute('morphTarget' + i4) !== morphTargets[index]) geometry.setAttribute('morphTarget' + i4, morphTargets[index]);
                if (morphNormals && geometry.getAttribute('morphNormal' + i4) !== morphNormals[index]) geometry.setAttribute('morphNormal' + i4, morphNormals[index]);
                morphInfluences[i4] = value;
                morphInfluencesSum += value;
            } else {
                if (morphTargets && geometry.hasAttribute('morphTarget' + i4) === true) geometry.deleteAttribute('morphTarget' + i4);
                if (morphNormals && geometry.hasAttribute('morphNormal' + i4) === true) geometry.deleteAttribute('morphNormal' + i4);
                morphInfluences[i4] = 0;
            }
        }
        // GLSL shader uses formula baseinfluence * base + sum(target * influence)
        // This allows us to switch between absolute morphs and relative morphs without changing shader code
        // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
        program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
    }
    return {
        update: update
    };
}
function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = new WeakMap();
    function update(object) {
        const frame = info.render.frame;
        const geometry = object.geometry;
        const buffergeometry = geometries.get(object, geometry);
        // Update once per frame
        if (updateMap.get(buffergeometry) !== frame) {
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
        }
        if (object.isInstancedMesh) {
            if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) object.addEventListener('dispose', onInstancedMeshDispose);
            attributes.update(object.instanceMatrix, 34962);
            if (object.instanceColor !== null) attributes.update(object.instanceColor, 34962);
        }
        return buffergeometry;
    }
    function dispose() {
        updateMap = new WeakMap();
    }
    function onInstancedMeshDispose(event) {
        const instancedMesh = event.target;
        instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
        attributes.remove(instancedMesh.instanceMatrix);
        if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
    }
    return {
        update: update,
        dispose: dispose
    };
}
function DataTexture2DArray(data = null, width5 = 1, height5 = 1, depth2 = 1) {
    Texture.call(this, null);
    this.image = {
        data,
        width: width5,
        height: height5,
        depth: depth2
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture2DArray.prototype = Object.create(Texture.prototype);
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;
function DataTexture3D(data = null, width5 = 1, height5 = 1, depth2 = 1) {
    // We're going to add .setXXX() methods for setting properties later.
    // Users can still set in DataTexture3D directly.
    //
    //	const texture = new THREE.DataTexture3D( data, width, height, depth );
    // 	texture.anisotropy = 16;
    //
    // See #14839
    Texture.call(this, null);
    this.image = {
        data,
        width: width5,
        height: height5,
        depth: depth2
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */ const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();
// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
const arrayCacheF32 = [];
const arrayCacheI32 = [];
// Float32Array caches used for uploading Matrix uniforms
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
// Flattening for arrays of vectors and matrices
function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0) return array;
    // unoptimized: ! isNaN( firstElem )
    // see http://jacksondunstan.com/articles/983
    const n = nBlocks * blockSize;
    let r2 = arrayCacheF32[n];
    if (r2 === undefined) {
        r2 = new Float32Array(n);
        arrayCacheF32[n] = r2;
    }
    if (nBlocks !== 0) {
        firstElem.toArray(r2, 0);
        for(let i1 = 1, offset = 0; i1 !== nBlocks; ++i1){
            offset += blockSize;
            array[i1].toArray(r2, offset);
        }
    }
    return r2;
}
function arraysEqual(a3, b4) {
    if (a3.length !== b4.length) return false;
    for(let i1 = 0, l = a3.length; i1 < l; i1++){
        if (a3[i1] !== b4[i1]) return false;
    }
    return true;
}
function copyArray(a3, b4) {
    for(let i1 = 0, l = b4.length; i1 < l; i1++)a3[i1] = b4[i1];
}
// Texture unit allocation
function allocTexUnits(textures, n) {
    let r2 = arrayCacheI32[n];
    if (r2 === undefined) {
        r2 = new Int32Array(n);
        arrayCacheI32[n] = r2;
    }
    for(let i1 = 0; i1 !== n; ++i1)r2[i1] = textures.allocateTextureUnit();
    return r2;
}
// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
}
// Single float vector (from flat array or THREE.VectorN)
function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform2fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
        }
    } else if (v.r !== undefined) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform3fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform4fv(this.addr, v);
        copyArray(cache, v);
    }
}
// Single matrix (from flat array or MatrixN)
function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix2fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat2array.set(elements);
        gl.uniformMatrix2fv(this.addr, false, mat2array);
        copyArray(cache, elements);
    }
}
function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix3fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat3array.set(elements);
        gl.uniformMatrix3fv(this.addr, false, mat3array);
        copyArray(cache, elements);
    }
}
function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix4fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat4array.set(elements);
        gl.uniformMatrix4fv(this.addr, false, mat4array);
        copyArray(cache, elements);
    }
}
// Single texture (2D / Cube)
function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}
// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
}
function setValueV2i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV3i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV4i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
}
// uint
function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
}
// Helper to pick the right setter for the singular case
function getSingularSetter(type) {
    switch(type){
        case 5126:
            return setValueV1f; // FLOAT
        case 35664:
            return setValueV2f; // _VEC2
        case 35665:
            return setValueV3f; // _VEC3
        case 35666:
            return setValueV4f; // _VEC4
        case 35674:
            return setValueM2; // _MAT2
        case 35675:
            return setValueM3; // _MAT3
        case 35676:
            return setValueM4; // _MAT4
        case 5124:
        case 35670:
            return setValueV1i; // INT, BOOL
        case 35667:
        case 35671:
            return setValueV2i; // _VEC2
        case 35668:
        case 35672:
            return setValueV3i; // _VEC3
        case 35669:
        case 35673:
            return setValueV4i; // _VEC4
        case 5125:
            return setValueV1ui; // UINT
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1;
        case 35679:
        case 36299:
        case 36307:
            return setValueT3D1;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return setValueT2DArray1;
    }
}
// Array of scalars
function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
}
// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
}
// Array of vectors (flat or from THREE classes)
function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
}
// Array of matrices (flat or from THREE clases)
function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
}
// Array of textures (2D / Cube)
function setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i1 = 0; i1 !== n; ++i1)textures.safeSetTexture2D(v[i1] || emptyTexture, units[i1]);
}
function setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i1 = 0; i1 !== n; ++i1)textures.safeSetTextureCube(v[i1] || emptyCubeTexture, units[i1]);
}
// Helper to pick the right setter for a pure (bottom-level) array
function getPureArraySetter(type) {
    switch(type){
        case 5126:
            return setValueV1fArray; // FLOAT
        case 35664:
            return setValueV2fArray; // _VEC2
        case 35665:
            return setValueV3fArray; // _VEC3
        case 35666:
            return setValueV4fArray; // _VEC4
        case 35674:
            return setValueM2Array; // _MAT2
        case 35675:
            return setValueM3Array; // _MAT3
        case 35676:
            return setValueM4Array; // _MAT4
        case 5124:
        case 35670:
            return setValueV1iArray; // INT, BOOL
        case 35667:
        case 35671:
            return setValueV2iArray; // _VEC2
        case 35668:
        case 35672:
            return setValueV3iArray; // _VEC3
        case 35669:
        case 35673:
            return setValueV4iArray; // _VEC4
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1Array;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6Array;
    }
}
// --- Uniform Classes ---
function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
// this.path = activeInfo.name; // DEBUG
}
function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
// this.path = activeInfo.name; // DEBUG
}
PureArrayUniform.prototype.updateCache = function(data) {
    const cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) this.cache = new Float32Array(data.length);
    copyArray(cache, data);
};
function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {
    };
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
    const seq = this.seq;
    for(let i1 = 0, n = seq.length; i1 !== n; ++i1){
        const u = seq[i1];
        u.setValue(gl, value[u.id], textures);
    }
};
// --- Top-level ---
// Parser - builds up the property tree from the path strings
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    // reset RegExp object, because of the early exit of a previous run
    RePathPart.lastIndex = 0;
    while(true){
        const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
        let id = match[1];
        const idIsIndex = match[2] === ']', subscript = match[3];
        if (idIsIndex) id = id | 0; // convert to integer
        if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
            // bare name or "pure" bottom-level array "[0]" suffix
            addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
            break;
        } else {
            // step into inner node / create it in case it doesn't exist
            const map = container.map;
            let next = map[id];
            if (next === undefined) {
                next = new StructuredUniform(id);
                addUniform(container, next);
            }
            container = next;
        }
    }
}
// Root Container
function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {
    };
    const n = gl.getProgramParameter(program, 35718);
    for(let i1 = 0; i1 < n; ++i1){
        const info = gl.getActiveUniform(program, i1), addr = gl.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
    }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== undefined) u.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    const v = object[name];
    if (v !== undefined) this.setValue(gl, name, v);
};
// Static interface
WebGLUniforms.upload = function(gl, seq, values, textures) {
    for(let i1 = 0, n = seq.length; i1 !== n; ++i1){
        const u = seq[i1], v = values[u.id];
        if (v.needsUpdate !== false) // note: always updating when .needsUpdate is undefined
        u.setValue(gl, v.value, textures);
    }
};
WebGLUniforms.seqWithValue = function(seq, values) {
    const r2 = [];
    for(let i1 = 0, n = seq.length; i1 !== n; ++i1){
        const u = seq[i1];
        if (u.id in values) r2.push(u);
    }
    return r2;
};
function WebGLShader1(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
}
let programIdCount = 0;
function addLineNumbers(string) {
    const lines = string.split('\n');
    for(let i1 = 0; i1 < lines.length; i1++)lines[i1] = i1 + 1 + ': ' + lines[i1];
    return lines.join('\n');
}
function getEncodingComponents(encoding) {
    switch(encoding){
        case LinearEncoding:
            return [
                'Linear',
                '( value )'
            ];
        case sRGBEncoding:
            return [
                'sRGB',
                '( value )'
            ];
        case RGBEEncoding:
            return [
                'RGBE',
                '( value )'
            ];
        case RGBM7Encoding:
            return [
                'RGBM',
                '( value, 7.0 )'
            ];
        case RGBM16Encoding:
            return [
                'RGBM',
                '( value, 16.0 )'
            ];
        case RGBDEncoding:
            return [
                'RGBD',
                '( value, 256.0 )'
            ];
        case GammaEncoding:
            return [
                'Gamma',
                '( value, float( GAMMA_FACTOR ) )'
            ];
        case LogLuvEncoding:
            return [
                'LogLuv',
                '( value )'
            ];
        default:
            console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
            return [
                'Linear',
                '( value )'
            ];
    }
}
function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, 35713);
    const log = gl.getShaderInfoLog(shader).trim();
    if (status && log === '') return '';
    // --enable-privileged-webgl-extension
    // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
    const source = gl.getShaderSource(shader);
    return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}
function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}
function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch(toneMapping){
        case LinearToneMapping:
            toneMappingName = 'Linear';
            break;
        case ReinhardToneMapping:
            toneMappingName = 'Reinhard';
            break;
        case CineonToneMapping:
            toneMappingName = 'OptimizedCineon';
            break;
        case ACESFilmicToneMapping:
            toneMappingName = 'ACESFilmic';
            break;
        case CustomToneMapping:
            toneMappingName = 'Custom';
            break;
        default:
            console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
            toneMappingName = 'Linear';
    }
    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}
function generateExtensions(parameters) {
    const chunks = [
        parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '',
        (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
        parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '',
        (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
    ];
    return chunks.filter(filterEmptyLine).join('\n');
}
function generateDefines(defines) {
    const chunks = [];
    for(const name in defines){
        const value = defines[name];
        if (value === false) continue;
        chunks.push('#define ' + name + ' ' + value);
    }
    return chunks.join('\n');
}
function fetchAttributeLocations(gl, program) {
    const attributes = {
    };
    const n = gl.getProgramParameter(program, 35721);
    for(let i1 = 0; i1 < n; i1++){
        const info = gl.getActiveAttrib(program, i1);
        const name = info.name;
        // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
        attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
}
function filterEmptyLine(string) {
    return string !== '';
}
function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
// Resolve Includes
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === undefined) throw new Error('Can not resolve #include <' + include + '>');
    return resolveIncludes(string);
}
// Unroll Loops
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
    return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
    let string = '';
    for(let i1 = parseInt(start); i1 < parseInt(end); i1++)string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i1 + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i1);
    return string;
}
//
function generatePrecision(parameters) {
    let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';
    if (parameters.precision === 'highp') precisionstring += '\n#define HIGH_PRECISION';
    else if (parameters.precision === 'mediump') precisionstring += '\n#define MEDIUM_PRECISION';
    else if (parameters.precision === 'lowp') precisionstring += '\n#define LOW_PRECISION';
    return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
    if (parameters.shadowMapType === PCFShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    else if (parameters.shadowMapType === PCFSoftShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    else if (parameters.shadowMapType === VSMShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
    return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    if (parameters.envMap) switch(parameters.envMapMode){
        case CubeReflectionMapping:
        case CubeRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
            break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
            break;
    }
    return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    if (parameters.envMap) switch(parameters.envMapMode){
        case CubeRefractionMapping:
        case CubeUVRefractionMapping:
            envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
            break;
    }
    return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
    if (parameters.envMap) switch(parameters.combine){
        case MultiplyOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
            break;
        case MixOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
            break;
        case AddOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
            break;
    }
    return envMapBlendingDefine;
}
function WebGLProgram1(renderer, cacheKey, parameters, bindingStates) {
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
    const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
    if (parameters.isRawShaderMaterial) {
        prefixVertex = [
            customDefines
        ].filter(filterEmptyLine).join('\n');
        if (prefixVertex.length > 0) prefixVertex += '\n';
        prefixFragment = [
            customExtensions,
            customDefines
        ].filter(filterEmptyLine).join('\n');
        if (prefixFragment.length > 0) prefixFragment += '\n';
    } else {
        prefixVertex = [
            generatePrecision(parameters),
            '#define SHADER_NAME ' + parameters.shaderName,
            customDefines,
            parameters.instancing ? '#define USE_INSTANCING' : '',
            parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
            parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            '#define MAX_BONES ' + parameters.maxBones,
            parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
            parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
            parameters.map ? '#define USE_MAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            parameters.vertexTangents ? '#define USE_TANGENT' : '',
            parameters.vertexColors ? '#define USE_COLOR' : '',
            parameters.vertexUvs ? '#define USE_UV' : '',
            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.skinning ? '#define USE_SKINNING' : '',
            parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
            parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
            parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            'uniform mat4 modelMatrix;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform mat4 viewMatrix;',
            'uniform mat3 normalMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            '#ifdef USE_INSTANCING',
            '	attribute mat4 instanceMatrix;',
            '#endif',
            '#ifdef USE_INSTANCING_COLOR',
            '	attribute vec3 instanceColor;',
            '#endif',
            'attribute vec3 position;',
            'attribute vec3 normal;',
            'attribute vec2 uv;',
            '#ifdef USE_TANGENT',
            '	attribute vec4 tangent;',
            '#endif',
            '#ifdef USE_COLOR',
            '	attribute vec3 color;',
            '#endif',
            '#ifdef USE_MORPHTARGETS',
            '	attribute vec3 morphTarget0;',
            '	attribute vec3 morphTarget1;',
            '	attribute vec3 morphTarget2;',
            '	attribute vec3 morphTarget3;',
            '	#ifdef USE_MORPHNORMALS',
            '		attribute vec3 morphNormal0;',
            '		attribute vec3 morphNormal1;',
            '		attribute vec3 morphNormal2;',
            '		attribute vec3 morphNormal3;',
            '	#else',
            '		attribute vec3 morphTarget4;',
            '		attribute vec3 morphTarget5;',
            '		attribute vec3 morphTarget6;',
            '		attribute vec3 morphTarget7;',
            '	#endif',
            '#endif',
            '#ifdef USE_SKINNING',
            '	attribute vec4 skinIndex;',
            '	attribute vec4 skinWeight;',
            '#endif',
            '\n'
        ].filter(filterEmptyLine).join('\n');
        prefixFragment = [
            customExtensions,
            generatePrecision(parameters),
            '#define SHADER_NAME ' + parameters.shaderName,
            customDefines,
            parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
            parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
            parameters.map ? '#define USE_MAP' : '',
            parameters.matcap ? '#define USE_MATCAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapTypeDefine : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.envMap ? '#define ' + envMapBlendingDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.sheen ? '#define USE_SHEEN' : '',
            parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            parameters.vertexTangents ? '#define USE_TANGENT' : '',
            parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
            parameters.vertexUvs ? '#define USE_UV' : '',
            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
            parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '',
            'uniform mat4 viewMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '',
            parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
            parameters.dithering ? '#define DITHERING' : '',
            ShaderChunk['encodings_pars_fragment'],
            parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
            parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '',
            parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
            parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
            parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '',
            getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding),
            parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',
            '\n'
        ].filter(filterEmptyLine).join('\n');
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
        // GLSL 3.0 conversion for built-in materials and ShaderMaterial
        versionString = '#version 300 es\n';
        prefixVertex = [
            '#define attribute in',
            '#define varying out',
            '#define texture2D texture'
        ].join('\n') + '\n' + prefixVertex;
        prefixFragment = [
            '#define varying in',
            parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;',
            parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor',
            '#define gl_FragDepthEXT gl_FragDepth',
            '#define texture2D texture',
            '#define textureCube texture',
            '#define texture2DProj textureProj',
            '#define texture2DLodEXT textureLod',
            '#define texture2DProjLodEXT textureProjLod',
            '#define textureCubeLodEXT textureLod',
            '#define texture2DGradEXT textureGrad',
            '#define texture2DProjGradEXT textureProjGrad',
            '#define textureCubeGradEXT textureGrad'
        ].join('\n') + '\n' + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    // console.log( '*VERTEX*', vertexGlsl );
    // console.log( '*FRAGMENT*', fragmentGlsl );
    const glVertexShader = WebGLShader1(gl, 35633, vertexGlsl);
    const glFragmentShader = WebGLShader1(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    // Force a particular attribute to index 0.
    if (parameters.index0AttributeName !== undefined) gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    else if (parameters.morphTargets === true) // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
    gl.linkProgram(program);
    // check for link errors
    if (renderer.debug.checkShaderErrors) {
        const programLog = gl.getProgramInfoLog(program).trim();
        const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl.getProgramParameter(program, 35714) === false) {
            runnable = false;
            const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
            const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
            console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
        } else if (programLog !== '') console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
        else if (vertexLog === '' || fragmentLog === '') haveDiagnostics = false;
        if (haveDiagnostics) this.diagnostics = {
            runnable: runnable,
            programLog: programLog,
            vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
            },
            fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
            }
        };
    }
    // Clean up
    // Crashes in iOS9 and iOS10. #18402
    // gl.detachShader( program, glVertexShader );
    // gl.detachShader( program, glFragmentShader );
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    // set up caching for uniform locations
    let cachedUniforms;
    this.getUniforms = function() {
        if (cachedUniforms === undefined) cachedUniforms = new WebGLUniforms(gl, program);
        return cachedUniforms;
    };
    // set up caching for attribute locations
    let cachedAttributes;
    this.getAttributes = function() {
        if (cachedAttributes === undefined) cachedAttributes = fetchAttributeLocations(gl, program);
        return cachedAttributes;
    };
    // free resource
    this.destroy = function() {
        bindingStates.releaseStatesOfProgram(this);
        gl.deleteProgram(program);
        this.program = undefined;
    };
    //
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
}
function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshDistanceMaterial: 'distanceRGBA',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshToonMaterial: 'toon',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        MeshMatcapMaterial: 'matcap',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points',
        ShadowMaterial: 'shadow',
        SpriteMaterial: 'sprite'
    };
    const parameterNames = [
        'precision',
        'isWebGL2',
        'supportsVertexTextures',
        'outputEncoding',
        'instancing',
        'instancingColor',
        'map',
        'mapEncoding',
        'matcap',
        'matcapEncoding',
        'envMap',
        'envMapMode',
        'envMapEncoding',
        'envMapCubeUV',
        'lightMap',
        'lightMapEncoding',
        'aoMap',
        'emissiveMap',
        'emissiveMapEncoding',
        'bumpMap',
        'normalMap',
        'objectSpaceNormalMap',
        'tangentSpaceNormalMap',
        'clearcoatMap',
        'clearcoatRoughnessMap',
        'clearcoatNormalMap',
        'displacementMap',
        'specularMap',
        'roughnessMap',
        'metalnessMap',
        'gradientMap',
        'alphaMap',
        'combine',
        'vertexColors',
        'vertexTangents',
        'vertexUvs',
        'uvsVertexOnly',
        'fog',
        'useFog',
        'fogExp2',
        'flatShading',
        'sizeAttenuation',
        'logarithmicDepthBuffer',
        'skinning',
        'maxBones',
        'useVertexTexture',
        'morphTargets',
        'morphNormals',
        'maxMorphTargets',
        'maxMorphNormals',
        'premultipliedAlpha',
        'numDirLights',
        'numPointLights',
        'numSpotLights',
        'numHemiLights',
        'numRectAreaLights',
        'numDirLightShadows',
        'numPointLightShadows',
        'numSpotLightShadows',
        'shadowMapEnabled',
        'shadowMapType',
        'toneMapping',
        'physicallyCorrectLights',
        'alphaTest',
        'doubleSided',
        'flipSided',
        'numClippingPlanes',
        'numClipIntersection',
        'depthPacking',
        'dithering',
        'sheen',
        'transmissionMap'
    ];
    function getMaxBones(object) {
        const skeleton = object.skeleton;
        const bones = skeleton.bones;
        if (floatVertexTextures) return 1024;
        else {
            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)
            const nVertexUniforms = maxVertexUniforms;
            const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            const maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
                console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                return 0;
            }
            return maxBones;
        }
    }
    function getTextureEncodingFromMap(map) {
        let encoding;
        if (map && map.isTexture) encoding = map.encoding;
        else if (map && map.isWebGLRenderTarget) {
            console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
            encoding = map.texture.encoding;
        } else encoding = LinearEncoding;
        return encoding;
    }
    function getParameters(material, lights, shadows, scene, object) {
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const envMap = cubemaps.get(material.envMap || environment);
        const shaderID = shaderIDs[material.type];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)
        const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
        if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
        }
        let vertexShader, fragmentShader;
        if (shaderID) {
            const shader = ShaderLib[shaderID];
            vertexShader = shader.vertexShader;
            fragmentShader = shader.fragmentShader;
        } else {
            vertexShader = material.vertexShader;
            fragmentShader = material.fragmentShader;
        }
        const currentRenderTarget = renderer.getRenderTarget();
        const parameters = {
            isWebGL2: isWebGL2,
            shaderID: shaderID,
            shaderName: material.type,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            defines: material.defines,
            isRawShaderMaterial: material.isRawShaderMaterial === true,
            glslVersion: material.glslVersion,
            precision: precision,
            instancing: object.isInstancedMesh === true,
            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
            map: !!material.map,
            mapEncoding: getTextureEncodingFromMap(material.map),
            matcap: !!material.matcap,
            matcapEncoding: getTextureEncodingFromMap(material.matcap),
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(envMap),
            envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
            lightMap: !!material.lightMap,
            lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
            tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
            clearcoatMap: !!material.clearcoatMap,
            clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
            clearcoatNormalMap: !!material.clearcoatNormalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,
            gradientMap: !!material.gradientMap,
            sheen: !!material.sheen,
            transmissionMap: !!material.transmissionMap,
            combine: material.combine,
            vertexTangents: material.normalMap && material.vertexTangents,
            vertexColors: material.vertexColors,
            vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
            uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
            fog: !!fog,
            useFog: material.fog,
            fogExp2: fog && fog.isFogExp2,
            flatShading: material.flatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            skinning: material.skinning && maxBones > 0,
            maxBones: maxBones,
            useVertexTexture: floatVertexTextures,
            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: clipping.numPlanes,
            numClipIntersection: clipping.numIntersection,
            dithering: material.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            alphaTest: material.alphaTest,
            doubleSided: material.side === DoubleSide,
            flipSided: material.side === BackSide,
            depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
            index0AttributeName: material.index0AttributeName,
            extensionDerivatives: material.extensions && material.extensions.derivatives,
            extensionFragDepth: material.extensions && material.extensions.fragDepth,
            extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
            extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
            rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
            customProgramCacheKey: material.customProgramCacheKey()
        };
        return parameters;
    }
    function getProgramCacheKey(parameters) {
        const array = [];
        if (parameters.shaderID) array.push(parameters.shaderID);
        else {
            array.push(parameters.fragmentShader);
            array.push(parameters.vertexShader);
        }
        if (parameters.defines !== undefined) for(const name in parameters.defines){
            array.push(name);
            array.push(parameters.defines[name]);
        }
        if (parameters.isRawShaderMaterial === false) {
            for(let i1 = 0; i1 < parameterNames.length; i1++)array.push(parameters[parameterNames[i1]]);
            array.push(renderer.outputEncoding);
            array.push(renderer.gammaFactor);
        }
        array.push(parameters.customProgramCacheKey);
        return array.join();
    }
    function getUniforms(material) {
        const shaderID = shaderIDs[material.type];
        let uniforms;
        if (shaderID) {
            const shader = ShaderLib[shaderID];
            uniforms = UniformsUtils.clone(shader.uniforms);
        } else uniforms = material.uniforms;
        return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
        let program;
        // Check if code has been already compiled
        for(let p = 0, pl = programs.length; p < pl; p++){
            const preexistingProgram = programs[p];
            if (preexistingProgram.cacheKey === cacheKey) {
                program = preexistingProgram;
                ++program.usedTimes;
                break;
            }
        }
        if (program === undefined) {
            program = new WebGLProgram1(renderer, cacheKey, parameters, bindingStates);
            programs.push(program);
        }
        return program;
    }
    function releaseProgram(program) {
        if ((--program.usedTimes) === 0) {
            // Remove from unordered set
            const i1 = programs.indexOf(program);
            programs[i1] = programs[programs.length - 1];
            programs.pop();
            // Free WebGL resources
            program.destroy();
        }
    }
    return {
        getParameters: getParameters,
        getProgramCacheKey: getProgramCacheKey,
        getUniforms: getUniforms,
        acquireProgram: acquireProgram,
        releaseProgram: releaseProgram,
        // Exposed for resource monitoring & error feedback via renderer.info:
        programs: programs
    };
}
function WebGLProperties() {
    let properties = new WeakMap();
    function get(object) {
        let map = properties.get(object);
        if (map === undefined) {
            map = {
            };
            properties.set(object, map);
        }
        return map;
    }
    function remove(object) {
        properties.delete(object);
    }
    function update(object, key, value) {
        properties.get(object)[key] = value;
    }
    function dispose() {
        properties = new WeakMap();
    }
    return {
        get: get,
        remove: remove,
        update: update,
        dispose: dispose
    };
}
function painterSortStable(a3, b4) {
    if (a3.groupOrder !== b4.groupOrder) return a3.groupOrder - b4.groupOrder;
    else if (a3.renderOrder !== b4.renderOrder) return a3.renderOrder - b4.renderOrder;
    else if (a3.program !== b4.program) return a3.program.id - b4.program.id;
    else if (a3.material.id !== b4.material.id) return a3.material.id - b4.material.id;
    else if (a3.z !== b4.z) return a3.z - b4.z;
    else return a3.id - b4.id;
}
function reversePainterSortStable(a3, b4) {
    if (a3.groupOrder !== b4.groupOrder) return a3.groupOrder - b4.groupOrder;
    else if (a3.renderOrder !== b4.renderOrder) return a3.renderOrder - b4.renderOrder;
    else if (a3.z !== b4.z) return b4.z - a3.z;
    else return a3.id - b4.id;
}
function WebGLRenderList(properties) {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transparent = [];
    const defaultProgram = {
        id: -1
    };
    function init() {
        renderItemsIndex = 0;
        opaque.length = 0;
        transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z5, group) {
        let renderItem = renderItems[renderItemsIndex];
        const materialProperties = properties.get(material);
        if (renderItem === undefined) {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                program: materialProperties.program || defaultProgram,
                groupOrder: groupOrder,
                renderOrder: object.renderOrder,
                z: z5,
                group: group
            };
            renderItems[renderItemsIndex] = renderItem;
        } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.program = materialProperties.program || defaultProgram;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z5;
            renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
    }
    function push(object, geometry, material, groupOrder, z5, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z5, group);
        (material.transparent === true ? transparent : opaque).push(renderItem);
    }
    function unshift(object, geometry, material, groupOrder, z5, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z5, group);
        (material.transparent === true ? transparent : opaque).unshift(renderItem);
    }
    function sort(customOpaqueSort, customTransparentSort) {
        if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
        if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
        // Clear references from inactive renderItems in the list
        for(let i1 = renderItemsIndex, il = renderItems.length; i1 < il; i1++){
            const renderItem = renderItems[i1];
            if (renderItem.id === null) break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.program = null;
            renderItem.group = null;
        }
    }
    return {
        opaque: opaque,
        transparent: transparent,
        init: init,
        push: push,
        unshift: unshift,
        finish: finish,
        sort: sort
    };
}
function WebGLRenderLists(properties) {
    let lists = new WeakMap();
    function get(scene, camera) {
        const cameras = lists.get(scene);
        let list;
        if (cameras === undefined) {
            list = new WebGLRenderList(properties);
            lists.set(scene, new WeakMap());
            lists.get(scene).set(camera, list);
        } else {
            list = cameras.get(camera);
            if (list === undefined) {
                list = new WebGLRenderList(properties);
                cameras.set(camera, list);
            }
        }
        return list;
    }
    function dispose() {
        lists = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
function UniformsCache() {
    const lights = {
    };
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        direction: new Vector3(),
                        color: new Color()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        position: new Vector3(),
                        direction: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        position: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        decay: 0
                    };
                    break;
                case 'HemisphereLight':
                    uniforms = {
                        direction: new Vector3(),
                        skyColor: new Color(),
                        groundColor: new Color()
                    };
                    break;
                case 'RectAreaLight':
                    uniforms = {
                        color: new Color(),
                        position: new Vector3(),
                        halfWidth: new Vector3(),
                        halfHeight: new Vector3()
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
function ShadowUniformsCache() {
    const lights = {
    };
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1000
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [
            0,
            0,
            0
        ],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for(let i1 = 0; i1 < 9; i1++)state.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights) {
        let r2 = 0, g2 = 0, b4 = 0;
        for(let i2 = 0; i2 < 9; i2++)state.probe[i2].set(0, 0, 0);
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        let numDirectionalShadows = 0;
        let numPointShadows = 0;
        let numSpotShadows = 0;
        lights.sort(shadowCastingLightsFirst);
        for(let i3 = 0, l = lights.length; i3 < l; i3++){
            const light = lights[i3];
            const color2 = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
                r2 += color2.r * intensity;
                g2 += color2.g * intensity;
                b4 += color2.b * intensity;
            } else if (light.isLightProbe) for(let j = 0; j < 9; j++)state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
            else if (light.isDirectionalLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.directionalShadow[directionalLength] = shadowUniforms;
                    state.directionalShadowMap[directionalLength] = shadowMap;
                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    numDirectionalShadows++;
                }
                state.directional[directionalLength] = uniforms;
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.color.copy(color2).multiplyScalar(intensity);
                uniforms.distance = distance;
                uniforms.coneCos = Math.cos(light.angle);
                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.spotShadow[spotLength] = shadowUniforms;
                    state.spotShadowMap[spotLength] = shadowMap;
                    state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    numSpotShadows++;
                }
                state.spot[spotLength] = uniforms;
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms = cache.get(light);
                // (a) intensity is the total visible light emitted
                //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                // (b) intensity is the brightness of the light
                uniforms.color.copy(color2).multiplyScalar(intensity);
                uniforms.halfWidth.set(light.width * 0.5, 0, 0);
                uniforms.halfHeight.set(0, light.height * 0.5, 0);
                state.rectArea[rectAreaLength] = uniforms;
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.distance = light.distance;
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    shadowUniforms.shadowCameraNear = shadow.camera.near;
                    shadowUniforms.shadowCameraFar = shadow.camera.far;
                    state.pointShadow[pointLength] = shadowUniforms;
                    state.pointShadowMap[pointLength] = shadowMap;
                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    numPointShadows++;
                }
                state.point[pointLength] = uniforms;
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms = cache.get(light);
                uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                state.hemi[hemiLength] = uniforms;
                hemiLength++;
            }
        }
        if (rectAreaLength > 0) {
            if (capabilities.isWebGL2) {
                // WebGL 2
                state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
            } else {
                // WebGL 1
                if (extensions.has('OES_texture_float_linear') === true) {
                    state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                    state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
                } else if (extensions.has('OES_texture_half_float_linear') === true) {
                    state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
                    state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
                } else console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
            }
        }
        state.ambient[0] = r2;
        state.ambient[1] = g2;
        state.ambient[2] = b4;
        const hash = state.hash;
        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.directionalShadow.length = numDirectionalShadows;
            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadow.length = numPointShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadow.length = numSpotShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;
            hash.directionalLength = directionalLength;
            hash.pointLength = pointLength;
            hash.spotLength = spotLength;
            hash.rectAreaLength = rectAreaLength;
            hash.hemiLength = hemiLength;
            hash.numDirectionalShadows = numDirectionalShadows;
            hash.numPointShadows = numPointShadows;
            hash.numSpotShadows = numSpotShadows;
            state.version = nextVersion++;
        }
    }
    function setupView(lights, camera) {
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        const viewMatrix = camera.matrixWorldInverse;
        for(let i2 = 0, l = lights.length; i2 < l; i2++){
            const light = lights[i2];
            if (light.isDirectionalLight) {
                const uniforms = state.directional[directionalLength];
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms = state.spot[spotLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms = state.rectArea[rectAreaLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                // extract local rotation of light to derive width/height half vectors
                matrix42.identity();
                matrix4.copy(light.matrixWorld);
                matrix4.premultiply(viewMatrix);
                matrix42.extractRotation(matrix4);
                uniforms.halfWidth.set(light.width * 0.5, 0, 0);
                uniforms.halfHeight.set(0, light.height * 0.5, 0);
                uniforms.halfWidth.applyMatrix4(matrix42);
                uniforms.halfHeight.applyMatrix4(matrix42);
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms = state.point[pointLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms = state.hemi[hemiLength];
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.direction.normalize();
                hemiLength++;
            }
        }
    }
    return {
        setup: setup,
        setupView: setupView,
        state: state
    };
}
function WebGLRenderState(extensions, capabilities) {
    const lights = new WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
    }
    function pushLight(light) {
        lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
    }
    function setupLights() {
        lights.setup(lightsArray);
    }
    function setupLightsView(camera) {
        lights.setupView(lightsArray, camera);
    }
    const state = {
        lightsArray: lightsArray,
        shadowsArray: shadowsArray,
        lights: lights
    };
    return {
        init: init,
        state: state,
        setupLights: setupLights,
        setupLightsView: setupLightsView,
        pushLight: pushLight,
        pushShadow: pushShadow
    };
}
function WebGLRenderStates(extensions, capabilities) {
    let renderStates = new WeakMap();
    function get(scene, renderCallDepth = 0) {
        let renderState;
        if (renderStates.has(scene) === false) {
            renderState = new WebGLRenderState(extensions, capabilities);
            renderStates.set(scene, []);
            renderStates.get(scene).push(renderState);
        } else if (renderCallDepth >= renderStates.get(scene).length) {
            renderState = new WebGLRenderState(extensions, capabilities);
            renderStates.get(scene).push(renderState);
        } else renderState = renderStates.get(scene)[renderCallDepth];
        return renderState;
    }
    function dispose() {
        renderStates = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */ function MeshDepthMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshDepthMaterial';
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
}
MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
};
/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */ function MeshDistanceMaterial(parameters) {
    Material.call(this);
    this.type = 'MeshDistanceMaterial';
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1000;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
}
MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
MeshDistanceMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
};
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {
    };
    const shadowSide = {
        0: BackSide,
        1: FrontSide,
        2: DoubleSide
    };
    const shadowMaterialVertical = new ShaderMaterial({
        defines: {
            SAMPLE_RATE: 0.25,
            HALF_SAMPLE_RATE: 0.125
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Vector2()
            },
            radius: {
                value: 4
            }
        },
        vertexShader: vsm_vert,
        fragmentShader: vsm_frag
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([
        -1,
        -1,
        0.5,
        3,
        -1,
        0.5,
        -1,
        3,
        0.5
    ]), 3));
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope1 = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
        if (scope1.enabled === false) return;
        if (scope1.autoUpdate === false && scope1.needsUpdate === false) return;
        if (lights.length === 0) return;
        const currentRenderTarget = _renderer.getRenderTarget();
        const activeCubeFace = _renderer.getActiveCubeFace();
        const activeMipmapLevel = _renderer.getActiveMipmapLevel();
        const _state = _renderer.state;
        // Set GL state for depth map.
        _state.setBlending(NoBlending);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        // render depth map
        for(let i1 = 0, il = lights.length; i1 < il; i1++){
            const light = lights[i1];
            const shadow = light.shadow;
            if (shadow === undefined) {
                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                continue;
            }
            if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
                if (_shadowMapSize.x > maxTextureSize) {
                    _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
                    _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                    shadow.mapSize.x = _viewportSize.x;
                }
                if (_shadowMapSize.y > maxTextureSize) {
                    _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
                    _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                    shadow.mapSize.y = _viewportSize.y;
                }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
                const pars = {
                    minFilter: LinearFilter,
                    magFilter: LinearFilter,
                    format: RGBAFormat
                };
                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + '.shadowMap';
                shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
                const pars = {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter,
                    format: RGBAFormat
                };
                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + '.shadowMap';
                shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for(let vp = 0; vp < viewportCount; vp++){
                const viewport = shadow.getViewport(vp);
                _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                _state.viewport(_viewport);
                shadow.updateMatrices(light, vp);
                _frustum = shadow.getFrustum();
                renderObject(scene, camera, shadow.camera, light, this.type);
            }
            // do blur pass for VSM
            if (!shadow.isPointLightShadow && this.type === VSMShadowMap) VSMPass(shadow, camera);
            shadow.needsUpdate = false;
        }
        scope1.needsUpdate = false;
        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
        const geometry = _objects.update(fullScreenMesh);
        // vertical pass
        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.mapPass);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
        // horizontal pass
        shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
        shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
        const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        let material = _depthMaterials[index];
        if (material === undefined) {
            material = new MeshDepthMaterial({
                depthPacking: RGBADepthPacking,
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _depthMaterials[index] = material;
        }
        return material;
    }
    function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
        const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        let material = _distanceMaterials[index];
        if (material === undefined) {
            material = new MeshDistanceMaterial({
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _distanceMaterials[index] = material;
        }
        return material;
    }
    function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
        let result = null;
        let getMaterialVariant = getDepthMaterialVariant;
        let customMaterial = object.customDepthMaterial;
        if (light.isPointLight === true) {
            getMaterialVariant = getDistanceMaterialVariant;
            customMaterial = object.customDistanceMaterial;
        }
        if (customMaterial === undefined) {
            let useMorphing = false;
            if (material.morphTargets === true) useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
            let useSkinning = false;
            if (object.isSkinnedMesh === true) {
                if (material.skinning === true) useSkinning = true;
                else console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
            }
            const useInstancing = object.isInstancedMesh === true;
            result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
        } else result = customMaterial;
        if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
            // in this case we need a unique material instance reflecting the
            // appropriate state
            const keyA = result.uuid, keyB = material.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === undefined) {
                materialsForVariant = {
                };
                _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === undefined) {
                cachedMaterial = result.clone();
                materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        if (type === VSMShadowMap) result.side = material.shadowSide !== null ? material.shadowSide : material.side;
        else result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.clipIntersection = material.clipIntersection;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
        }
        return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                const geometry = _objects.update(object);
                const material = object.material;
                if (Array.isArray(material)) {
                    const groups = geometry.groups;
                    for(let k = 0, kl = groups.length; k < kl; k++){
                        const group = groups[k];
                        const groupMaterial = material[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                            const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                        }
                    }
                } else if (material.visible) {
                    const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                }
            }
        }
        const children = object.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)renderObject(children[i1], camera, shadowCamera, light, type);
    }
}
function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
        let locked = false;
        const color2 = new Vector4();
        let currentColorMask = null;
        const currentColorClear = new Vector4(0, 0, 0, 0);
        return {
            setMask: function(colorMask) {
                if (currentColorMask !== colorMask && !locked) {
                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                    currentColorMask = colorMask;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(r2, g2, b4, a3, premultipliedAlpha) {
                if (premultipliedAlpha === true) {
                    r2 *= a3;
                    g2 *= a3;
                    b4 *= a3;
                }
                color2.set(r2, g2, b4, a3);
                if (currentColorClear.equals(color2) === false) {
                    gl.clearColor(r2, g2, b4, a3);
                    currentColorClear.copy(color2);
                }
            },
            reset: function() {
                locked = false;
                currentColorMask = null;
                currentColorClear.set(-1, 0, 0, 0); // set to invalid state
            }
        };
    }
    function DepthBuffer() {
        let locked = false;
        let currentDepthMask = null;
        let currentDepthFunc = null;
        let currentDepthClear = null;
        return {
            setTest: function(depthTest) {
                if (depthTest) enable(2929);
                else disable(2929);
            },
            setMask: function(depthMask) {
                if (currentDepthMask !== depthMask && !locked) {
                    gl.depthMask(depthMask);
                    currentDepthMask = depthMask;
                }
            },
            setFunc: function(depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                    if (depthFunc) switch(depthFunc){
                        case NeverDepth:
                            gl.depthFunc(512);
                            break;
                        case AlwaysDepth:
                            gl.depthFunc(519);
                            break;
                        case LessDepth:
                            gl.depthFunc(513);
                            break;
                        case LessEqualDepth:
                            gl.depthFunc(515);
                            break;
                        case EqualDepth:
                            gl.depthFunc(514);
                            break;
                        case GreaterEqualDepth:
                            gl.depthFunc(518);
                            break;
                        case GreaterDepth:
                            gl.depthFunc(516);
                            break;
                        case NotEqualDepth:
                            gl.depthFunc(517);
                            break;
                        default:
                            gl.depthFunc(515);
                    }
                    else gl.depthFunc(515);
                    currentDepthFunc = depthFunc;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(depth2) {
                if (currentDepthClear !== depth2) {
                    gl.clearDepth(depth2);
                    currentDepthClear = depth2;
                }
            },
            reset: function() {
                locked = false;
                currentDepthMask = null;
                currentDepthFunc = null;
                currentDepthClear = null;
            }
        };
    }
    function StencilBuffer() {
        let locked = false;
        let currentStencilMask = null;
        let currentStencilFunc = null;
        let currentStencilRef = null;
        let currentStencilFuncMask = null;
        let currentStencilFail = null;
        let currentStencilZFail = null;
        let currentStencilZPass = null;
        let currentStencilClear = null;
        return {
            setTest: function(stencilTest) {
                if (!locked) {
                    if (stencilTest) enable(2960);
                    else disable(2960);
                }
            },
            setMask: function(stencilMask) {
                if (currentStencilMask !== stencilMask && !locked) {
                    gl.stencilMask(stencilMask);
                    currentStencilMask = stencilMask;
                }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                    currentStencilFunc = stencilFunc;
                    currentStencilRef = stencilRef;
                    currentStencilFuncMask = stencilMask;
                }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                    currentStencilFail = stencilFail;
                    currentStencilZFail = stencilZFail;
                    currentStencilZPass = stencilZPass;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(stencil) {
                if (currentStencilClear !== stencil) {
                    gl.clearStencil(stencil);
                    currentStencilClear = stencil;
                }
            },
            reset: function() {
                locked = false;
                currentStencilMask = null;
                currentStencilFunc = null;
                currentStencilRef = null;
                currentStencilFuncMask = null;
                currentStencilFail = null;
                currentStencilZFail = null;
                currentStencilZPass = null;
                currentStencilClear = null;
            }
        };
    }
    //
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {
    };
    let currentProgram = null;
    let currentBlendingEnabled = null;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf('WebGL') !== -1) {
        version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf('OpenGL ES') !== -1) {
        version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {
    };
    const currentScissor = new Vector4();
    const currentViewport = new Vector4();
    function createTexture(type, target, count) {
        const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
        const texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, 10241, 9728);
        gl.texParameteri(type, 10240, 9728);
        for(let i1 = 0; i1 < count; i1++)gl.texImage2D(target + i1, 0, 6408, 1, 1, 0, 6408, 5121, data);
        return texture;
    }
    const emptyTextures = {
    };
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    // init
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    //
    function enable(id) {
        if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
        }
    }
    function disable(id) {
        if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
        }
    }
    function useProgram(program) {
        if (currentProgram !== program) {
            gl.useProgram(program);
            currentProgram = program;
            return true;
        }
        return false;
    }
    const equationToGL = {
        [AddEquation]: 32774,
        [SubtractEquation]: 32778,
        [ReverseSubtractEquation]: 32779
    };
    if (isWebGL2) {
        equationToGL[MinEquation] = 32775;
        equationToGL[MaxEquation] = 32776;
    } else {
        const extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
            equationToGL[MinEquation] = extension.MIN_EXT;
            equationToGL[MaxEquation] = extension.MAX_EXT;
        }
    }
    const factorToGL = {
        [ZeroFactor]: 0,
        [OneFactor]: 1,
        [SrcColorFactor]: 768,
        [SrcAlphaFactor]: 770,
        [SrcAlphaSaturateFactor]: 776,
        [DstColorFactor]: 774,
        [DstAlphaFactor]: 772,
        [OneMinusSrcColorFactor]: 769,
        [OneMinusSrcAlphaFactor]: 771,
        [OneMinusDstColorFactor]: 775,
        [OneMinusDstAlphaFactor]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === NoBlending) {
            if (currentBlendingEnabled) {
                disable(3042);
                currentBlendingEnabled = false;
            }
            return;
        }
        if (!currentBlendingEnabled) {
            enable(3042);
            currentBlendingEnabled = true;
        }
        if (blending !== CustomBlending) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                    gl.blendEquation(32774);
                    currentBlendEquation = AddEquation;
                    currentBlendEquationAlpha = AddEquation;
                }
                if (premultipliedAlpha) switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(1, 1);
                        break;
                    case SubtractiveBlending:
                        gl.blendFuncSeparate(0, 0, 769, 771);
                        break;
                    case MultiplyBlending:
                        gl.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                else switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(770, 1);
                        break;
                    case SubtractiveBlending:
                        gl.blendFunc(0, 769);
                        break;
                    case MultiplyBlending:
                        gl.blendFunc(0, 768);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
        }
        // custom blending
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
        material.side === DoubleSide ? disable(2884) : enable(2884);
        let flipSided = material.side === BackSide;
        if (frontFaceCW) flipSided = !flipSided;
        setFlipSided(flipSided);
        material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
        depthBuffer.setFunc(material.depthFunc);
        depthBuffer.setTest(material.depthTest);
        depthBuffer.setMask(material.depthWrite);
        colorBuffer.setMask(material.colorWrite);
        const stencilWrite = material.stencilWrite;
        stencilBuffer.setTest(stencilWrite);
        if (stencilWrite) {
            stencilBuffer.setMask(material.stencilWriteMask);
            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
        }
        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }
    //
    function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
            if (flipSided) gl.frontFace(2304);
            else gl.frontFace(2305);
            currentFlipSided = flipSided;
        }
    }
    function setCullFace(cullFace) {
        if (cullFace !== CullFaceNone) {
            enable(2884);
            if (cullFace !== currentCullFace) {
                if (cullFace === CullFaceBack) gl.cullFace(1029);
                else if (cullFace === CullFaceFront) gl.cullFace(1028);
                else gl.cullFace(1032);
            }
        } else disable(2884);
        currentCullFace = cullFace;
    }
    function setLineWidth(width5) {
        if (width5 !== currentLineWidth) {
            if (lineWidthAvailable) gl.lineWidth(width5);
            currentLineWidth = width5;
        }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
            enable(32823);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                currentPolygonOffsetFactor = factor;
                currentPolygonOffsetUnits = units;
            }
        } else disable(32823);
    }
    function setScissorTest(scissorTest) {
        if (scissorTest) enable(3089);
        else disable(3089);
    }
    // texture
    function activeTexture(webglSlot) {
        if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
        }
    }
    function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) activeTexture();
        let boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
        }
    }
    function unbindTexture() {
        const boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== undefined && boundTexture.type !== undefined) {
            gl.bindTexture(boundTexture.type, null);
            boundTexture.type = undefined;
            boundTexture.texture = undefined;
        }
    }
    function compressedTexImage2D() {
        try {
            gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage2D() {
        try {
            gl.texImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage3D() {
        try {
            gl.texImage3D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    //
    function scissor(scissor1) {
        if (currentScissor.equals(scissor1) === false) {
            gl.scissor(scissor1.x, scissor1.y, scissor1.z, scissor1.w);
            currentScissor.copy(scissor1);
        }
    }
    function viewport(viewport1) {
        if (currentViewport.equals(viewport1) === false) {
            gl.viewport(viewport1.x, viewport1.y, viewport1.z, viewport1.w);
            currentViewport.copy(viewport1);
        }
    }
    //
    function reset() {
        enabledCapabilities = {
        };
        currentTextureSlot = null;
        currentBoundTextures = {
        };
        currentProgram = null;
        currentBlendingEnabled = null;
        currentBlending = null;
        currentBlendEquation = null;
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendEquationAlpha = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentPremultipledAlpha = false;
        currentFlipSided = null;
        currentCullFace = null;
        currentLineWidth = null;
        currentPolygonOffsetFactor = null;
        currentPolygonOffsetUnits = null;
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
    }
    return {
        buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
        },
        enable: enable,
        disable: disable,
        useProgram: useProgram,
        setBlending: setBlending,
        setMaterial: setMaterial,
        setFlipSided: setFlipSided,
        setCullFace: setCullFace,
        setLineWidth: setLineWidth,
        setPolygonOffset: setPolygonOffset,
        setScissorTest: setScissorTest,
        activeTexture: activeTexture,
        bindTexture: bindTexture,
        unbindTexture: unbindTexture,
        compressedTexImage2D: compressedTexImage2D,
        texImage2D: texImage2D,
        texImage3D: texImage3D,
        scissor: scissor,
        viewport: viewport,
        reset: reset
    };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const _videoTextures = new WeakMap();
    let _canvas1;
    // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
    // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
    // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
    let useOffscreenCanvas = false;
    try {
        useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
    } catch (err) {
    // Ignore any errors
    }
    function createCanvas(width5, height5) {
        // Use OffscreenCanvas when available. Specially needed in web workers
        return useOffscreenCanvas ? new OffscreenCanvas(width5, height5) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
        let scale = 1;
        // handle case if texture exceeds max size
        if (image.width > maxSize || image.height > maxSize) scale = maxSize / Math.max(image.width, image.height);
        // only perform resize if necessary
        if (scale < 1 || needsPowerOfTwo === true) {
            // only perform resize for certain image types
            if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
                const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
                const width5 = floor(scale * image.width);
                const height5 = floor(scale * image.height);
                if (_canvas1 === undefined) _canvas1 = createCanvas(width5, height5);
                // cube textures can't reuse the same canvas
                const canvas = needsNewCanvas ? createCanvas(width5, height5) : _canvas1;
                canvas.width = width5;
                canvas.height = height5;
                const context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, width5, height5);
                console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width5 + 'x' + height5 + ').');
                return canvas;
            } else {
                if ('data' in image) console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
                return image;
            }
        }
        return image;
    }
    function isPowerOfTwo(image) {
        return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
        if (isWebGL2) return false;
        return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
        return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target, texture, width5, height5) {
        _gl.generateMipmap(target);
        const textureProperties = properties.get(texture);
        // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
        textureProperties.__maxMipLevel = Math.log(Math.max(width5, height5)) * Math.LOG2E;
    }
    function getInternalFormat(internalFormatName, glFormat, glType) {
        if (isWebGL2 === false) return glFormat;
        if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
            console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
        }
        let internalFormat = glFormat;
        if (glFormat === 6403) {
            if (glType === 5126) internalFormat = 33326;
            if (glType === 5131) internalFormat = 33325;
            if (glType === 5121) internalFormat = 33321;
        }
        if (glFormat === 6407) {
            if (glType === 5126) internalFormat = 34837;
            if (glType === 5131) internalFormat = 34843;
            if (glType === 5121) internalFormat = 32849;
        }
        if (glFormat === 6408) {
            if (glType === 5126) internalFormat = 34836;
            if (glType === 5131) internalFormat = 34842;
            if (glType === 5121) internalFormat = 32856;
        }
        if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) extensions.get('EXT_color_buffer_float');
        return internalFormat;
    }
    // Fallback filters for non-power-of-2 textures
    function filterFallback(f) {
        if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) return 9728;
        return 9729;
    }
    //
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        deallocateTexture(texture);
        if (texture.isVideoTexture) _videoTextures.delete(texture);
        info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
        const renderTarget = event.target;
        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        info.memory.textures--;
    }
    //
    function deallocateTexture(texture) {
        const textureProperties = properties.get(texture);
        if (textureProperties.__webglInit === undefined) return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(renderTarget.texture);
        if (!renderTarget) return;
        if (textureProperties.__webglTexture !== undefined) _gl.deleteTexture(textureProperties.__webglTexture);
        if (renderTarget.depthTexture) renderTarget.depthTexture.dispose();
        if (renderTarget.isWebGLCubeRenderTarget) for(let i1 = 0; i1 < 6; i1++){
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i1]);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i1]);
        }
        else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
            if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
        }
        properties.remove(renderTarget.texture);
        properties.remove(renderTarget);
    }
    //
    let textureUnits = 0;
    function resetTextureUnits() {
        textureUnits = 0;
    }
    function allocateTextureUnit() {
        const textureUnit = textureUnits;
        if (textureUnit >= maxTextures) console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
        textureUnits += 1;
        return textureUnit;
    }
    //
    function setTexture2D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.isVideoTexture) updateVideoTexture(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            const image = texture.image;
            if (image === undefined) console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
            else if (image.complete === false) console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
            else {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadCubeTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
    }
    const wrappingToGL = {
        [RepeatWrapping]: 10497,
        [ClampToEdgeWrapping]: 33071,
        [MirroredRepeatWrapping]: 33648
    };
    const filterToGL = {
        [NearestFilter]: 9728,
        [NearestMipmapNearestFilter]: 9984,
        [NearestMipmapLinearFilter]: 9986,
        [LinearFilter]: 9729,
        [LinearMipmapNearestFilter]: 9985,
        [LinearMipmapLinearFilter]: 9987
    };
    function setTextureParameters(textureType, texture, supportsMips) {
        if (supportsMips) {
            _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
            if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
            _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
        } else {
            _gl.texParameteri(textureType, 10242, 33071);
            _gl.texParameteri(textureType, 10243, 33071);
            if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, 33071);
            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
            _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
        }
        const extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension) {
            if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
            if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
        }
    }
    function initTexture(textureProperties, texture) {
        if (textureProperties.__webglInit === undefined) {
            textureProperties.__webglInit = true;
            texture.addEventListener('dispose', onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
        }
    }
    function uploadTexture(textureProperties, texture, slot) {
        let textureType = 3553;
        if (texture.isDataTexture2DArray) textureType = 35866;
        if (texture.isDataTexture3D) textureType = 32879;
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
        const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
        let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(textureType, texture, supportsMips);
        let mipmap;
        const mipmaps = texture.mipmaps;
        if (texture.isDepthTexture) {
            // populate depth texture with dummy data
            glInternalFormat = 6402;
            if (isWebGL2) {
                if (texture.type === FloatType) glInternalFormat = 36012;
                else if (texture.type === UnsignedIntType) glInternalFormat = 33190;
                else if (texture.type === UnsignedInt248Type) glInternalFormat = 35056;
                else glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
            } else if (texture.type === FloatType) console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
            // validation checks for WebGL 1
            if (texture.format === DepthFormat && glInternalFormat === 6402) // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
            // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
            // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
            {
                if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                    texture.type = UnsignedShortType;
                    glType = utils.convert(texture.type);
                }
            }
            if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
                // Depth stencil textures need the DEPTH_STENCIL internal format
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                glInternalFormat = 34041;
                // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                if (texture.type !== UnsignedInt248Type) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                    texture.type = UnsignedInt248Type;
                    glType = utils.convert(texture.type);
                }
            }
            //
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        } else if (texture.isDataTexture) {
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps.length > 0 && supportsMips) {
                for(let i1 = 0, il = mipmaps.length; i1 < il; i1++){
                    mipmap = mipmaps[i1];
                    state.texImage2D(3553, i1, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                texture.generateMipmaps = false;
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                textureProperties.__maxMipLevel = 0;
            }
        } else if (texture.isCompressedTexture) {
            for(let i1 = 0, il = mipmaps.length; i1 < il; i1++){
                mipmap = mipmaps[i1];
                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                    if (glFormat !== null) state.compressedTexImage2D(3553, i1, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                } else state.texImage2D(3553, i1, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else if (texture.isDataTexture2DArray) {
            state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else if (texture.isDataTexture3D) {
            state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else // regular Texture (image, video, canvas)
        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels
        if (mipmaps.length > 0 && supportsMips) {
            for(let i1 = 0, il = mipmaps.length; i1 < il; i1++){
                mipmap = mipmaps[i1];
                state.texImage2D(3553, i1, glInternalFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
            textureProperties.__maxMipLevel = 0;
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(textureType, texture, image.width, image.height);
        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
        if (texture.image.length !== 6) return;
        initTexture(textureProperties, texture);
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture.flipY);
        _gl.pixelStorei(37441, texture.premultiplyAlpha);
        _gl.pixelStorei(3317, texture.unpackAlignment);
        const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
        const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        const cubeImage = [];
        for(let i1 = 0; i1 < 6; i1++)if (!isCompressed && !isDataTexture) cubeImage[i1] = resizeImage(texture.image[i1], false, true, maxCubemapSize);
        else cubeImage[i1] = isDataTexture ? texture.image[i1].image : texture.image[i1];
        const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(34067, texture, supportsMips);
        let mipmaps;
        if (isCompressed) {
            for(let i2 = 0; i2 < 6; i2++){
                mipmaps = cubeImage[i2].mipmaps;
                for(let j = 0; j < mipmaps.length; j++){
                    const mipmap = mipmaps[j];
                    if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                        if (glFormat !== null) state.compressedTexImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                    } else state.texImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
            mipmaps = texture.mipmaps;
            for(let i2 = 0; i2 < 6; i2++)if (isDataTexture) {
                state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
                for(let j = 0; j < mipmaps.length; j++){
                    const mipmap = mipmaps[j];
                    const mipmapImage = mipmap.image[i2].image;
                    state.texImage2D(34069 + i2, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
            } else {
                state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
                for(let j = 0; j < mipmaps.length; j++){
                    const mipmap = mipmaps[j];
                    state.texImage2D(34069 + i2, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
                }
            }
            textureProperties.__maxMipLevel = mipmaps.length;
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) // We assume images for cube map have the same size.
        generateMipmap(34067, texture, image.width, image.height);
        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
    }
    // Render targets
    // Setup storage for target texture and bind it to correct framebuffer
    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
        const glFormat = utils.convert(renderTarget.texture.format);
        const glType = utils.convert(renderTarget.texture.type);
        const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        _gl.bindFramebuffer(36160, framebuffer);
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
        _gl.bindFramebuffer(36160, null);
    }
    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
        _gl.bindRenderbuffer(36161, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            let glInternalFormat = 33189;
            if (isMultisample) {
                const depthTexture = renderTarget.depthTexture;
                if (depthTexture && depthTexture.isDepthTexture) {
                    if (depthTexture.type === FloatType) glInternalFormat = 36012;
                    else if (depthTexture.type === UnsignedIntType) glInternalFormat = 33190;
                }
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
        } else {
            const glFormat = utils.convert(renderTarget.texture.format);
            const glType = utils.convert(renderTarget.texture.type);
            const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.bindRenderbuffer(36161, null);
    }
    // Setup resources for a Depth Texture for a FBO (needs an extension)
    function setupDepthTexture(framebuffer, renderTarget) {
        const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
        if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
        _gl.bindFramebuffer(36160, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
        // upload an empty depth texture with framebuffer size
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === DepthFormat) _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        else if (renderTarget.depthTexture.format === DepthStencilFormat) _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        else throw new Error('Unknown depthTexture format');
    }
    // Setup GL resources for a non-texture depth buffer
    function setupDepthRenderbuffer(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        if (renderTarget.depthTexture) {
            if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for(let i1 = 0; i1 < 6; i1++){
                _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i1]);
                renderTargetProperties.__webglDepthbuffer[i1] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i1], renderTarget, false);
            }
        } else {
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
        _gl.bindFramebuffer(36160, null);
    }
    // Set up GL resources for the render target
    function setupRenderTarget(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(renderTarget.texture);
        renderTarget.addEventListener('dispose', onRenderTargetDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
        const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        // Handles WebGL2 RGBFormat fallback - #18858
        if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {
            renderTarget.texture.format = RGBAFormat;
            console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
        }
        // Setup framebuffer
        if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for(let i1 = 0; i1 < 6; i1++)renderTargetProperties.__webglFramebuffer[i1] = _gl.createFramebuffer();
        } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultisample) {
                if (isWebGL2) {
                    renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                    renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                    _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
                    const glFormat = utils.convert(renderTarget.texture.format);
                    const glType = utils.convert(renderTarget.texture.type);
                    const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                    const samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                    _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
                    _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
                    _gl.bindRenderbuffer(36161, null);
                    if (renderTarget.depthBuffer) {
                        renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                    }
                    _gl.bindFramebuffer(36160, null);
                } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
            }
        }
        // Setup color buffer
        if (isCube) {
            state.bindTexture(34067, textureProperties.__webglTexture);
            setTextureParameters(34067, renderTarget.texture, supportsMips);
            for(let i1 = 0; i1 < 6; i1++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i1], renderTarget, 36064, 34069 + i1);
            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
            state.bindTexture(34067, null);
        } else {
            state.bindTexture(3553, textureProperties.__webglTexture);
            setTextureParameters(3553, renderTarget.texture, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);
            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
            state.bindTexture(3553, null);
        }
        // Setup depth and stencil buffers
        if (renderTarget.depthBuffer) setupDepthRenderbuffer(renderTarget);
    }
    function updateRenderTargetMipmap(renderTarget) {
        const texture = renderTarget.texture;
        const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
            const webglTexture = properties.get(texture).__webglTexture;
            state.bindTexture(target, webglTexture);
            generateMipmap(target, texture, renderTarget.width, renderTarget.height);
            state.bindTexture(target, null);
        }
    }
    function updateMultisampleRenderTarget(renderTarget) {
        if (renderTarget.isWebGLMultisampleRenderTarget) {
            if (isWebGL2) {
                const renderTargetProperties = properties.get(renderTarget);
                _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
                _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
                const width5 = renderTarget.width;
                const height5 = renderTarget.height;
                let mask = 16384;
                if (renderTarget.depthBuffer) mask |= 256;
                if (renderTarget.stencilBuffer) mask |= 1024;
                _gl.blitFramebuffer(0, 0, width5, height5, 0, 0, width5, height5, mask, 9728);
                _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer); // see #18905
            } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
    }
    function getRenderTargetSamples(renderTarget) {
        return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
    }
    function updateVideoTexture(texture) {
        const frame = info.render.frame;
        // Check the last frame we updated the VideoTexture
        if (_videoTextures.get(texture) !== frame) {
            _videoTextures.set(texture, frame);
            texture.update();
        }
    }
    // backwards compatibility
    let warnedTexture2D = false;
    let warnedTextureCube = false;
    function safeSetTexture2D(texture, slot) {
        if (texture && texture.isWebGLRenderTarget) {
            if (warnedTexture2D === false) {
                console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
                warnedTexture2D = true;
            }
            texture = texture.texture;
        }
        setTexture2D(texture, slot);
    }
    function safeSetTextureCube(texture, slot) {
        if (texture && texture.isWebGLCubeRenderTarget) {
            if (warnedTextureCube === false) {
                console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
                warnedTextureCube = true;
            }
            texture = texture.texture;
        }
        setTextureCube(texture, slot);
    }
    //
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p) {
        let extension;
        if (p === UnsignedByteType) return 5121;
        if (p === UnsignedShort4444Type) return 32819;
        if (p === UnsignedShort5551Type) return 32820;
        if (p === UnsignedShort565Type) return 33635;
        if (p === ByteType) return 5120;
        if (p === ShortType) return 5122;
        if (p === UnsignedShortType) return 5123;
        if (p === IntType) return 5124;
        if (p === UnsignedIntType) return 5125;
        if (p === FloatType) return 5126;
        if (p === HalfFloatType) {
            if (isWebGL2) return 5131;
            extension = extensions.get('OES_texture_half_float');
            if (extension !== null) return extension.HALF_FLOAT_OES;
            else return null;
        }
        if (p === AlphaFormat) return 6406;
        if (p === RGBFormat) return 6407;
        if (p === RGBAFormat) return 6408;
        if (p === LuminanceFormat) return 6409;
        if (p === LuminanceAlphaFormat) return 6410;
        if (p === DepthFormat) return 6402;
        if (p === DepthStencilFormat) return 34041;
        if (p === RedFormat) return 6403;
        // WebGL2 formats.
        if (p === RedIntegerFormat) return 36244;
        if (p === RGFormat) return 33319;
        if (p === RGIntegerFormat) return 33320;
        if (p === RGBIntegerFormat) return 36248;
        if (p === RGBAIntegerFormat) return 36249;
        if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
            extension = extensions.get('WEBGL_compressed_texture_s3tc');
            if (extension !== null) {
                if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
        }
        if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_pvrtc');
            if (extension !== null) {
                if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        }
        if (p === RGB_ETC1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc1');
            if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            else return null;
        }
        if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc');
            if (extension !== null) {
                if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
                if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
            }
        }
        if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
            extension = extensions.get('WEBGL_compressed_texture_astc');
            if (extension !== null) // TODO Complete?
            return p;
            else return null;
        }
        if (p === RGBA_BPTC_Format) {
            extension = extensions.get('EXT_texture_compression_bptc');
            if (extension !== null) // TODO Complete?
            return p;
            else return null;
        }
        if (p === UnsignedInt248Type) {
            if (isWebGL2) return 34042;
            extension = extensions.get('WEBGL_depth_texture');
            if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            else return null;
        }
    }
    return {
        convert: convert
    };
}
function ArrayCamera(array = []) {
    PerspectiveCamera.call(this);
    this.cameras = array;
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
    constructor: ArrayCamera,
    isArrayCamera: true
});
function Group() {
    Object3D.call(this);
    this.type = 'Group';
}
Group.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Group,
    isGroup: true
});
function WebXRController() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
}
Object.assign(WebXRController.prototype, {
    constructor: WebXRController,
    getHandSpace: function() {
        if (this._hand === null) {
            this._hand = new Group();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {
            };
            this._hand.inputState = {
                pinching: false
            };
        }
        return this._hand;
    },
    getTargetRaySpace: function() {
        if (this._targetRay === null) {
            this._targetRay = new Group();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
        }
        return this._targetRay;
    },
    getGripSpace: function() {
        if (this._grip === null) {
            this._grip = new Group();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
        }
        return this._grip;
    },
    dispatchEvent: function(event) {
        if (this._targetRay !== null) this._targetRay.dispatchEvent(event);
        if (this._grip !== null) this._grip.dispatchEvent(event);
        if (this._hand !== null) this._hand.dispatchEvent(event);
        return this;
    },
    disconnect: function(inputSource) {
        this.dispatchEvent({
            type: 'disconnected',
            data: inputSource
        });
        if (this._targetRay !== null) this._targetRay.visible = false;
        if (this._grip !== null) this._grip.visible = false;
        if (this._hand !== null) this._hand.visible = false;
        return this;
    },
    update: function(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        let handPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        const hand = this._hand;
        if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
            if (hand && inputSource.hand) {
                handPose = true;
                for (const inputjoint of inputSource.hand.values()){
                    // Update the joints groups with the XRJoint poses
                    const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                    if (hand.joints[inputjoint.jointName] === undefined) {
                        // The transform of this joint will be updated with the joint pose on each frame
                        const joint = new Group();
                        joint.matrixAutoUpdate = false;
                        joint.visible = false;
                        hand.joints[inputjoint.jointName] = joint;
                        // ??
                        hand.add(joint);
                    }
                    const joint = hand.joints[inputjoint.jointName];
                    if (jointPose !== null) {
                        joint.matrix.fromArray(jointPose.transform.matrix);
                        joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                        joint.jointRadius = jointPose.radius;
                    }
                    joint.visible = jointPose !== null;
                }
                // Custom events
                // Check pinchz
                const indexTip = hand.joints['index-finger-tip'];
                const thumbTip = hand.joints['thumb-tip'];
                const distance = indexTip.position.distanceTo(thumbTip.position);
                const distanceToPinch = 0.02;
                const threshold = 0.005;
                if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                    hand.inputState.pinching = false;
                    this.dispatchEvent({
                        type: 'pinchend',
                        handedness: inputSource.handedness,
                        target: this
                    });
                } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                    hand.inputState.pinching = true;
                    this.dispatchEvent({
                        type: 'pinchstart',
                        handedness: inputSource.handedness,
                        target: this
                    });
                }
            } else {
                if (targetRay !== null) {
                    inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                    if (inputPose !== null) {
                        targetRay.matrix.fromArray(inputPose.transform.matrix);
                        targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                    }
                }
                if (grip !== null && inputSource.gripSpace) {
                    gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                    if (gripPose !== null) {
                        grip.matrix.fromArray(gripPose.transform.matrix);
                        grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                    }
                }
            }
        }
        if (targetRay !== null) targetRay.visible = inputPose !== null;
        if (grip !== null) grip.visible = gripPose !== null;
        if (hand !== null) hand.visible = handPose !== null;
        return this;
    }
});
function WebXRManager(renderer, gl) {
    const scope1 = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = 'local-floor';
    let pose = null;
    const controllers = [];
    const inputSourcesMap = new Map();
    //
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [
        cameraL,
        cameraR
    ];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    //
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController();
            controllers[index] = controller;
        }
        return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController();
            controllers[index] = controller;
        }
        return controller.getGripSpace();
    };
    this.getHand = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController();
            controllers[index] = controller;
        }
        return controller.getHandSpace();
    };
    //
    function onSessionEvent(event) {
        const controller = inputSourcesMap.get(event.inputSource);
        if (controller) controller.dispatchEvent({
            type: event.type,
            data: event.inputSource
        });
    }
    function onSessionEnd() {
        inputSourcesMap.forEach(function(controller, inputSource) {
            controller.disconnect(inputSource);
        });
        inputSourcesMap.clear();
        _currentDepthNear = null;
        _currentDepthFar = null;
        //
        renderer.setFramebuffer(null);
        renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830
        animation.stop();
        scope1.isPresenting = false;
        scope1.dispatchEvent({
            type: 'sessionend'
        });
    }
    this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
        if (scope1.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
    };
    this.setReferenceSpaceType = function(value) {
        referenceSpaceType = value;
        if (scope1.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
    };
    this.getReferenceSpace = function() {
        return referenceSpace;
    };
    this.getSession = function() {
        return session;
    };
    this.setSession = async function(value) {
        session = value;
        if (session !== null) {
            session.addEventListener('select', onSessionEvent);
            session.addEventListener('selectstart', onSessionEvent);
            session.addEventListener('selectend', onSessionEvent);
            session.addEventListener('squeeze', onSessionEvent);
            session.addEventListener('squeezestart', onSessionEvent);
            session.addEventListener('squeezeend', onSessionEvent);
            session.addEventListener('end', onSessionEnd);
            session.addEventListener('inputsourceschange', onInputSourcesChange);
            const attributes = gl.getContextAttributes();
            if (attributes.xrCompatible !== true) await gl.makeXRCompatible();
            const layerInit = {
                antialias: attributes.antialias,
                alpha: attributes.alpha,
                depth: attributes.depth,
                stencil: attributes.stencil,
                framebufferScaleFactor: framebufferScaleFactor
            };
            // eslint-disable-next-line no-undef
            const baseLayer = new XRWebGLLayer(session, gl, layerInit);
            session.updateRenderState({
                baseLayer: baseLayer
            });
            referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
            animation.setContext(session);
            animation.start();
            scope1.isPresenting = true;
            scope1.dispatchEvent({
                type: 'sessionstart'
            });
        }
    };
    function onInputSourcesChange(event) {
        const inputSources = session.inputSources;
        // Assign inputSources to available controllers
        for(let i1 = 0; i1 < controllers.length; i1++)inputSourcesMap.set(inputSources[i1], controllers[i1]);
        // Notify disconnected
        for(let i2 = 0; i2 < event.removed.length; i2++){
            const inputSource = event.removed[i2];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) {
                controller.dispatchEvent({
                    type: 'disconnected',
                    data: inputSource
                });
                inputSourcesMap.delete(inputSource);
            }
        }
        // Notify connected
        for(let i3 = 0; i3 < event.added.length; i3++){
            const inputSource = event.added[i3];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) controller.dispatchEvent({
                type: 'connected',
                data: inputSource
            });
        }
    }
    //
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    /**
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */ function setProjectionFromUnion(camera, cameraL1, cameraR1) {
        cameraLPos.setFromMatrixPosition(cameraL1.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR1.matrixWorld);
        const ipd = cameraLPos.distanceTo(cameraRPos);
        const projL = cameraL1.projectionMatrix.elements;
        const projR = cameraR1.projectionMatrix.elements;
        // VR systems will have identical far and near planes, and
        // most likely identical top and bottom frustum extents.
        // Use the left camera for these values.
        const near = projL[14] / (projL[10] - 1);
        const far = projL[14] / (projL[10] + 1);
        const topFov = (projL[9] + 1) / projL[5];
        const bottomFov = (projL[9] - 1) / projL[5];
        const leftFov = (projL[8] - 1) / projL[0];
        const rightFov = (projR[8] + 1) / projR[0];
        const left = near * leftFov;
        const right = near * rightFov;
        // Calculate the new camera's position offset from the
        // left camera. xOffset should be roughly half `ipd`.
        const zOffset = ipd / (-leftFov + rightFov);
        const xOffset = zOffset * -leftFov;
        // TODO: Better way to apply this offset?
        cameraL1.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
        camera.translateX(xOffset);
        camera.translateZ(zOffset);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        // Find the union of the frustum values of the cameras and scale
        // the values so that the near plane's position does not change in world space,
        // although must now be relative to the new union camera.
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
        if (parent === null) camera.matrixWorld.copy(camera.matrix);
        else camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.getCamera = function(camera) {
        cameraVR.near = cameraR.near = cameraL.near = camera.near;
        cameraVR.far = cameraR.far = cameraL.far = camera.far;
        if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
            // Note that the new renderState won't apply until the next frame. See #18320
            session.updateRenderState({
                depthNear: cameraVR.near,
                depthFar: cameraVR.far
            });
            _currentDepthNear = cameraVR.near;
            _currentDepthFar = cameraVR.far;
        }
        const parent = camera.parent;
        const cameras1 = cameraVR.cameras;
        updateCamera(cameraVR, parent);
        for(let i1 = 0; i1 < cameras1.length; i1++)updateCamera(cameras1[i1], parent);
        // update camera and its children
        camera.matrixWorld.copy(cameraVR.matrixWorld);
        camera.matrix.copy(cameraVR.matrix);
        camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
        const children = camera.children;
        for(let i2 = 0, l = children.length; i2 < l; i2++)children[i2].updateMatrixWorld(true);
        // update projection matrix for proper view frustum culling
        if (cameras1.length === 2) setProjectionFromUnion(cameraVR, cameraL, cameraR);
        else // assume single camera setup (AR)
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
        return cameraVR;
    };
    // Animation Loop
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
        pose = frame.getViewerPose(referenceSpace);
        if (pose !== null) {
            const views = pose.views;
            const baseLayer = session.renderState.baseLayer;
            renderer.setFramebuffer(baseLayer.framebuffer);
            let cameraVRNeedsUpdate = false;
            // check if it's necessary to rebuild cameraVR's camera list
            if (views.length !== cameraVR.cameras.length) {
                cameraVR.cameras.length = 0;
                cameraVRNeedsUpdate = true;
            }
            for(let i1 = 0; i1 < views.length; i1++){
                const view = views[i1];
                const viewport = baseLayer.getViewport(view);
                const camera = cameras[i1];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i1 === 0) cameraVR.matrix.copy(camera.matrix);
                if (cameraVRNeedsUpdate === true) cameraVR.cameras.push(camera);
            }
        }
        //
        const inputSources = session.inputSources;
        for(let i1 = 0; i1 < controllers.length; i1++){
            const controller = controllers[i1];
            const inputSource = inputSources[i1];
            controller.update(inputSource, frame, referenceSpace);
        }
        if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
}
Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
function WebGLMaterials(properties) {
    function refreshFogUniforms(uniforms, fog) {
        uniforms.fogColor.value.copy(fog.color);
        if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) uniforms.fogDensity.value = fog.density;
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height5) {
        if (material.isMeshBasicMaterial) refreshUniformsCommon(uniforms, material);
        else if (material.isMeshLambertMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsLambert(uniforms, material);
        } else if (material.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsToon(uniforms, material);
        } else if (material.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsPhong(uniforms, material);
        } else if (material.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material);
            if (material.isMeshPhysicalMaterial) refreshUniformsPhysical(uniforms, material);
            else refreshUniformsStandard(uniforms, material);
        } else if (material.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsMatcap(uniforms, material);
        } else if (material.isMeshDepthMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDepth(uniforms, material);
        } else if (material.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDistance(uniforms, material);
        } else if (material.isMeshNormalMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsNormal(uniforms, material);
        } else if (material.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material);
            if (material.isLineDashedMaterial) refreshUniformsDash(uniforms, material);
        } else if (material.isPointsMaterial) refreshUniformsPoints(uniforms, material, pixelRatio, height5);
        else if (material.isSpriteMaterial) refreshUniformsSprites(uniforms, material);
        else if (material.isShadowMaterial) {
            uniforms.color.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
        } else if (material.isShaderMaterial) material.uniformsNeedUpdate = false; // #15581
    }
    function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        if (material.color) uniforms.diffuse.value.copy(material.color);
        if (material.emissive) uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        if (material.specularMap) uniforms.specularMap.value = material.specularMap;
        const envMap = properties.get(material).envMap;
        if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.refractionRatio.value = material.refractionRatio;
            const maxMipLevel = properties.get(envMap).__maxMipLevel;
            if (maxMipLevel !== undefined) uniforms.maxMipLevel.value = maxMipLevel;
        }
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. displacementMap map
        // 4. normal map
        // 5. bump map
        // 6. roughnessMap map
        // 7. metalnessMap map
        // 8. alphaMap map
        // 9. emissiveMap map
        // 10. clearcoat map
        // 11. clearcoat normal map
        // 12. clearcoat roughnessMap map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.specularMap) uvScaleMap = material.specularMap;
        else if (material.displacementMap) uvScaleMap = material.displacementMap;
        else if (material.normalMap) uvScaleMap = material.normalMap;
        else if (material.bumpMap) uvScaleMap = material.bumpMap;
        else if (material.roughnessMap) uvScaleMap = material.roughnessMap;
        else if (material.metalnessMap) uvScaleMap = material.metalnessMap;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        else if (material.emissiveMap) uvScaleMap = material.emissiveMap;
        else if (material.clearcoatMap) uvScaleMap = material.clearcoatMap;
        else if (material.clearcoatNormalMap) uvScaleMap = material.clearcoatNormalMap;
        else if (material.clearcoatRoughnessMap) uvScaleMap = material.clearcoatRoughnessMap;
        if (uvScaleMap !== undefined) {
            // backwards compatibility
            if (uvScaleMap.isWebGLRenderTarget) uvScaleMap = uvScaleMap.texture;
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
        // uv repeat and offset setting priorities for uv2
        // 1. ao map
        // 2. light map
        let uv2ScaleMap;
        if (material.aoMap) uv2ScaleMap = material.aoMap;
        else if (material.lightMap) uv2ScaleMap = material.lightMap;
        if (uv2ScaleMap !== undefined) {
            // backwards compatibility
            if (uv2ScaleMap.isWebGLRenderTarget) uv2ScaleMap = uv2ScaleMap.texture;
            if (uv2ScaleMap.matrixAutoUpdate === true) uv2ScaleMap.updateMatrix();
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
        }
    }
    function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height5) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * pixelRatio;
        uniforms.scale.value = height5 * 0.5;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsSprites(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.rotation.value = material.rotation;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsLambert(uniforms, material) {
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
    }
    function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value.copy(material.specular);
        uniforms.shininess.value = Math.max(material.shininess, 0.0001); // to prevent pow( 0.0, 0.0 )
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsToon(uniforms, material) {
        if (material.gradientMap) uniforms.gradientMap.value = material.gradientMap;
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsStandard(uniforms, material) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) uniforms.roughnessMap.value = material.roughnessMap;
        if (material.metalnessMap) uniforms.metalnessMap.value = material.metalnessMap;
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        const envMap = properties.get(material).envMap;
        if (envMap) //uniforms.envMap.value = material.envMap; // part of uniforms common
        uniforms.envMapIntensity.value = material.envMapIntensity;
    }
    function refreshUniformsPhysical(uniforms, material) {
        refreshUniformsStandard(uniforms, material);
        uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.sheen) uniforms.sheen.value.copy(material.sheen);
        if (material.clearcoatMap) uniforms.clearcoatMap.value = material.clearcoatMap;
        if (material.clearcoatRoughnessMap) uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        if (material.clearcoatNormalMap) {
            uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
            uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
            if (material.side === BackSide) uniforms.clearcoatNormalScale.value.negate();
        }
        uniforms.transmission.value = material.transmission;
        if (material.transmissionMap) uniforms.transmissionMap.value = material.transmissionMap;
    }
    function refreshUniformsMatcap(uniforms, material) {
        if (material.matcap) uniforms.matcap.value = material.matcap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDepth(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDistance(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        uniforms.referencePosition.value.copy(material.referencePosition);
        uniforms.nearDistance.value = material.nearDistance;
        uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    return {
        refreshFogUniforms: refreshFogUniforms,
        refreshMaterialUniforms: refreshMaterialUniforms
    };
}
function createCanvasElement() {
    const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    canvas.style.display = 'block';
    return canvas;
}
function WebGLRenderer(parameters) {
    parameters = parameters || {
    };
    const _canvas1 = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default', _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
    let currentRenderList = null;
    let currentRenderState = null;
    // render() can be called from within a callback triggered by another render.
    // We track this so that the nested render call gets its state isolated from the parent render call.
    const renderStateStack = [];
    // public properties
    this.domElement = _canvas1;
    // Debug configuration container
    this.debug = {
        /**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */ checkShaderErrors: true
    };
    // clearing
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    // scene graph
    this.sortObjects = true;
    // user-defined clipping
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    // physically based shading
    this.gammaFactor = 2; // for backwards compatibility
    this.outputEncoding = LinearEncoding;
    // physical lights
    this.physicallyCorrectLights = false;
    // tone mapping
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    // morphs
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    // internal properties
    const _this = this;
    let _isContextLost = false;
    // internal state cache
    let _framebuffer = null;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentFramebuffer = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    //
    let _width = _canvas1.width;
    let _height = _canvas1.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    // frustum
    const _frustum = new Frustum();
    // clipping
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    // camera matrices cache
    const _projScreenMatrix = new Matrix4();
    const _vector3 = new Vector3();
    const _emptyScene = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
    };
    function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    // initialize
    let _gl = _context;
    function getContext(contextNames, contextAttributes) {
        for(let i1 = 0; i1 < contextNames.length; i1++){
            const contextName = contextNames[i1];
            const context = _canvas1.getContext(contextName, contextAttributes);
            if (context !== null) return context;
        }
        return null;
    }
    try {
        const contextAttributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
        };
        // event listeners must be registered before WebGL context is created, see #12753
        _canvas1.addEventListener('webglcontextlost', onContextLost, false);
        _canvas1.addEventListener('webglcontextrestored', onContextRestore, false);
        if (_gl === null) {
            const contextNames = [
                'webgl2',
                'webgl',
                'experimental-webgl'
            ];
            if (_this.isWebGL1Renderer === true) contextNames.shift();
            _gl = getContext(contextNames, contextAttributes);
            if (_gl === null) {
                if (getContext(contextNames)) throw new Error('Error creating WebGL context with your selected attributes.');
                else throw new Error('Error creating WebGL context.');
            }
        }
        // Some experimental-webgl implementations do not have getShaderPrecisionFormat
        if (_gl.getShaderPrecisionFormat === undefined) _gl.getShaderPrecisionFormat = function() {
            return {
                'rangeMin': 1,
                'rangeMax': 1,
                'precision': 1
            };
        };
    } catch (error) {
        console.error('THREE.WebGLRenderer: ' + error.message);
        throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
        extensions = new WebGLExtensions(_gl);
        capabilities = new WebGLCapabilities(_gl, extensions, parameters);
        extensions.init(capabilities);
        utils = new WebGLUtils(_gl, extensions, capabilities);
        state = new WebGLState(_gl, extensions, capabilities);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        info = new WebGLInfo(_gl);
        properties = new WebGLProperties();
        textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
        cubemaps = new WebGLCubeMaps(_this);
        attributes = new WebGLAttributes(_gl, capabilities);
        bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
        geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
        objects = new WebGLObjects(_gl, geometries, attributes, info);
        morphtargets = new WebGLMorphtargets(_gl);
        clipping = new WebGLClipping(properties);
        programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
        materials = new WebGLMaterials(properties);
        renderLists = new WebGLRenderLists(properties);
        renderStates = new WebGLRenderStates(extensions, capabilities);
        background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
        bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.state = state;
        _this.info = info;
    }
    initGLContext();
    // xr
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    // shadow map
    const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
    this.shadowMap = shadowMap;
    // API
    this.getContext = function() {
        return _gl;
    };
    this.getContextAttributes = function() {
        return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
        return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
        if (value === undefined) return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
            target = new Vector2();
        }
        return target.set(_width, _height);
    };
    this.setSize = function(width5, height5, updateStyle) {
        if (xr.isPresenting) {
            console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
            return;
        }
        _width = width5;
        _height = height5;
        _canvas1.width = Math.floor(width5 * _pixelRatio);
        _canvas1.height = Math.floor(height5 * _pixelRatio);
        if (updateStyle !== false) {
            _canvas1.style.width = width5 + 'px';
            _canvas1.style.height = height5 + 'px';
        }
        this.setViewport(0, 0, width5, height5);
    };
    this.getDrawingBufferSize = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
            target = new Vector2();
        }
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width5, height5, pixelRatio) {
        _width = width5;
        _height = height5;
        _pixelRatio = pixelRatio;
        _canvas1.width = Math.floor(width5 * pixelRatio);
        _canvas1.height = Math.floor(height5 * pixelRatio);
        this.setViewport(0, 0, width5, height5);
    };
    this.getCurrentViewport = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
            target = new Vector4();
        }
        return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
        return target.copy(_viewport);
    };
    this.setViewport = function(x6, y6, width5, height5) {
        if (x6.isVector4) _viewport.set(x6.x, x6.y, x6.z, x6.w);
        else _viewport.set(x6, y6, width5, height5);
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
        return target.copy(_scissor);
    };
    this.setScissor = function(x6, y6, width5, height5) {
        if (x6.isVector4) _scissor.set(x6.x, x6.y, x6.z, x6.w);
        else _scissor.set(x6, y6, width5, height5);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
        return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
        _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
        _transparentSort = method;
    };
    // Clearing
    this.getClearColor = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getClearColor() now requires a Color as an argument');
            target = new Color();
        }
        return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
        return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color2, depth2, stencil) {
        let bits = 0;
        if (color2 === undefined || color2) bits |= 16384;
        if (depth2 === undefined || depth2) bits |= 256;
        if (stencil === undefined || stencil) bits |= 1024;
        _gl.clear(bits);
    };
    this.clearColor = function() {
        this.clear(true, false, false);
    };
    this.clearDepth = function() {
        this.clear(false, true, false);
    };
    this.clearStencil = function() {
        this.clear(false, false, true);
    };
    //
    this.dispose = function() {
        _canvas1.removeEventListener('webglcontextlost', onContextLost, false);
        _canvas1.removeEventListener('webglcontextrestored', onContextRestore, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        cubemaps.dispose();
        objects.dispose();
        bindingStates.dispose();
        xr.dispose();
        animation.stop();
    };
    // Events
    function onContextLost(event) {
        event.preventDefault();
        console.log('THREE.WebGLRenderer: Context Lost.');
        _isContextLost = true;
    }
    function onContextRestore() {
        console.log('THREE.WebGLRenderer: Context Restored.');
        _isContextLost = false;
        initGLContext();
    }
    function onMaterialDispose(event) {
        const material = event.target;
        material.removeEventListener('dispose', onMaterialDispose);
        deallocateMaterial(material);
    }
    // Buffer deallocation
    function deallocateMaterial(material) {
        releaseMaterialProgramReference(material);
        properties.remove(material);
    }
    function releaseMaterialProgramReference(material) {
        const programInfo = properties.get(material).program;
        if (programInfo !== undefined) programCache.releaseProgram(programInfo);
    }
    // Buffer rendering
    function renderObjectImmediate(object, program) {
        object.render(function(object1) {
            _this.renderBufferImmediate(object1, program);
        });
    }
    this.renderBufferImmediate = function(object, program) {
        bindingStates.initAttributes();
        const buffers = properties.get(object);
        if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
        const programAttributes = program.getAttributes();
        if (object.hasPositions) {
            _gl.bindBuffer(34962, buffers.position);
            _gl.bufferData(34962, object.positionArray, 35048);
            bindingStates.enableAttribute(programAttributes.position);
            _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
        }
        if (object.hasNormals) {
            _gl.bindBuffer(34962, buffers.normal);
            _gl.bufferData(34962, object.normalArray, 35048);
            bindingStates.enableAttribute(programAttributes.normal);
            _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
        }
        if (object.hasUvs) {
            _gl.bindBuffer(34962, buffers.uv);
            _gl.bufferData(34962, object.uvArray, 35048);
            bindingStates.enableAttribute(programAttributes.uv);
            _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
        }
        if (object.hasColors) {
            _gl.bindBuffer(34962, buffers.color);
            _gl.bufferData(34962, object.colorArray, 35048);
            bindingStates.enableAttribute(programAttributes.color);
            _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
        }
        bindingStates.disableUnusedAttributes();
        _gl.drawArrays(4, 0, object.count);
        object.count = 0;
    };
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
        if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)
        const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        const program = setProgram(camera, scene, material, object);
        state.setMaterial(material, frontFaceCW);
        //
        let index = geometry.index;
        const position = geometry.attributes.position;
        //
        if (index === null) {
            if (position === undefined || position.count === 0) return;
        } else if (index.count === 0) return;
        //
        let rangeFactor = 1;
        if (material.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry);
            rangeFactor = 2;
        }
        if (material.morphTargets || material.morphNormals) morphtargets.update(object, geometry, material, program);
        bindingStates.setup(object, material, program, geometry, index);
        let attribute;
        let renderer = bufferRenderer;
        if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
        }
        //
        const dataCount = index !== null ? index.count : position.count;
        const rangeStart = geometry.drawRange.start * rangeFactor;
        const rangeCount = geometry.drawRange.count * rangeFactor;
        const groupStart1 = group !== null ? group.start * rangeFactor : 0;
        const groupCount = group !== null ? group.count * rangeFactor : Infinity;
        const drawStart = Math.max(rangeStart, groupStart1);
        const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart1 + groupCount) - 1;
        const drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0) return;
        //
        if (object.isMesh) {
            if (material.wireframe === true) {
                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                renderer.setMode(1);
            } else renderer.setMode(4);
        } else if (object.isLine) {
            let lineWidth = material.linewidth;
            if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) renderer.setMode(1);
            else if (object.isLineLoop) renderer.setMode(2);
            else renderer.setMode(3);
        } else if (object.isPoints) renderer.setMode(0);
        else if (object.isSprite) renderer.setMode(4);
        if (object.isInstancedMesh) renderer.renderInstances(drawStart, drawCount, object.count);
        else if (geometry.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
            renderer.renderInstances(drawStart, drawCount, instanceCount);
        } else renderer.render(drawStart, drawCount);
    };
    // Compile
    this.compile = function(scene, camera) {
        currentRenderState = renderStates.get(scene);
        currentRenderState.init();
        scene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            }
        });
        currentRenderState.setupLights();
        const compiled = new WeakMap();
        scene.traverse(function(object) {
            const material = object.material;
            if (material) {
                if (Array.isArray(material)) for(let i1 = 0; i1 < material.length; i1++){
                    const material2 = material[i1];
                    if (compiled.has(material2) === false) {
                        initMaterial(material2, scene, object);
                        compiled.set(material2);
                    }
                }
                else if (compiled.has(material) === false) {
                    initMaterial(material, scene, object);
                    compiled.set(material);
                }
            }
        });
    };
    // Animation Loop
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
        if (xr.isPresenting) return;
        if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== 'undefined') animation.setContext(window);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation.stop() : animation.start();
    };
    // Rendering
    this.render = function(scene, camera) {
        let renderTarget, forceClear;
        if (arguments[2] !== undefined) {
            console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
            renderTarget = arguments[2];
        }
        if (arguments[3] !== undefined) {
            console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
            forceClear = arguments[3];
        }
        if (camera !== undefined && camera.isCamera !== true) {
            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
            return;
        }
        if (_isContextLost === true) return;
        // reset caching for this frame
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        // update scene graph
        if (scene.autoUpdate === true) scene.updateMatrixWorld();
        // update camera matrices and frustum
        if (camera.parent === null) camera.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) camera = xr.getCamera(camera);
        //
        if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
        currentRenderState = renderStates.get(scene, renderStateStack.length);
        currentRenderState.init();
        renderStateStack.push(currentRenderState);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        currentRenderList = renderLists.get(scene, camera);
        currentRenderList.init();
        projectObject(scene, camera, 0, _this.sortObjects);
        currentRenderList.finish();
        if (_this.sortObjects === true) currentRenderList.sort(_opaqueSort, _transparentSort);
        //
        if (_clippingEnabled === true) clipping.beginShadows();
        const shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        currentRenderState.setupLights();
        currentRenderState.setupLightsView(camera);
        if (_clippingEnabled === true) clipping.endShadows();
        //
        if (this.info.autoReset === true) this.info.reset();
        if (renderTarget !== undefined) this.setRenderTarget(renderTarget);
        //
        background.render(currentRenderList, scene, camera, forceClear);
        // render scene
        const opaqueObjects = currentRenderList.opaque;
        const transparentObjects = currentRenderList.transparent;
        if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
        if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
        //
        if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
        //
        if (_currentRenderTarget !== null) {
            // Generate mipmap if we're using any kind of mipmap filtering
            textures.updateRenderTargetMipmap(_currentRenderTarget);
            // resolve multisample renderbuffers to a single-sample texture if necessary
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
        }
        // Ensure depth buffer writing is enabled so it can be cleared on next render
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
        // _gl.finish();
        renderStateStack.pop();
        if (renderStateStack.length > 0) currentRenderState = renderStateStack[renderStateStack.length - 1];
        else currentRenderState = null;
        currentRenderList = null;
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible) {
            if (object.isGroup) groupOrder = object.renderOrder;
            else if (object.isLOD) {
                if (object.autoUpdate === true) object.update(camera);
            } else if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            } else if (object.isSprite) {
                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (material.visible) currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
            } else if (object.isImmediateRenderObject) {
                if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
            } else if (object.isMesh || object.isLine || object.isPoints) {
                if (object.isSkinnedMesh) // update skeleton only once in a frame
                {
                    if (object.skeleton.frame !== info.render.frame) {
                        object.skeleton.update();
                        object.skeleton.frame = info.render.frame;
                    }
                }
                if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (Array.isArray(material)) {
                        const groups = geometry.groups;
                        for(let i1 = 0, l = groups.length; i1 < l; i1++){
                            const group = groups[i1];
                            const groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                        }
                    } else if (material.visible) currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                }
            }
        }
        const children = object.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)projectObject(children[i1], camera, groupOrder, sortObjects);
    }
    function renderObjects(renderList, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        for(let i1 = 0, l = renderList.length; i1 < l; i1++){
            const renderItem = renderList[i1];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (camera.isArrayCamera) {
                const cameras = camera.cameras;
                for(let j = 0, jl = cameras.length; j < jl; j++){
                    const camera2 = cameras[j];
                    if (object.layers.test(camera2.layers)) {
                        state.viewport(_currentViewport.copy(camera2.viewport));
                        currentRenderState.setupLightsView(camera2);
                        renderObject(object, scene, camera2, geometry, material, group);
                    }
                }
            } else renderObject(object, scene, camera, geometry, material, group);
        }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material, group);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object.isImmediateRenderObject) {
            const program = setProgram(camera, scene, material, object);
            state.setMaterial(material);
            bindingStates.reset();
            renderObjectImmediate(object, program);
        } else _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function initMaterial(material, scene, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        const shadowsArray = currentRenderState.state.shadowsArray;
        const lightsStateVersion = lights.state.version;
        const parameters1 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
        const programCacheKey = programCache.getProgramCacheKey(parameters1);
        let program = materialProperties.program;
        let programChange = true;
        // always update environment and fog - changing these trigger an initMaterial call, but it's possible that the program doesn't change
        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.fog = scene.fog;
        materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
        if (program === undefined) // new material
        material.addEventListener('dispose', onMaterialDispose);
        else if (program.cacheKey !== programCacheKey) // changed glsl or parameters
        releaseMaterialProgramReference(material);
        else if (materialProperties.lightsStateVersion !== lightsStateVersion) programChange = false;
        else if (parameters1.shaderID !== undefined) // same glsl and uniform list
        return;
        else // only rebuild uniform list
        programChange = false;
        if (programChange) {
            parameters1.uniforms = programCache.getUniforms(material);
            material.onBeforeCompile(parameters1, _this);
            program = programCache.acquireProgram(parameters1, programCacheKey);
            materialProperties.program = program;
            materialProperties.uniforms = parameters1.uniforms;
            materialProperties.outputEncoding = parameters1.outputEncoding;
        }
        const uniforms = materialProperties.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
            materialProperties.numClippingPlanes = clipping.numPlanes;
            materialProperties.numIntersection = clipping.numIntersection;
            uniforms.clippingPlanes = clipping.uniform;
        }
        // store the light setup it was created for
        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
            // wire up the material to this renderer's lighting state
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.ltc_1.value = lights.state.rectAreaLTC1;
            uniforms.ltc_2.value = lights.state.rectAreaLTC2;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        // TODO (abelnation): add area lights shadow info to uniforms
        }
        const progUniforms = materialProperties.program.getUniforms();
        const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.uniformsList = uniformsList;
    }
    function setProgram(camera, scene, material, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        textures.resetTextureUnits();
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
        const envMap = cubemaps.get(material.envMap || environment);
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
                const useCache = camera === _currentCamera && material.id === _currentMaterialId;
                // we might want to call this function with some ClippingGroup
                // object instead of the material, once it becomes feasible
                // (#8465, #8379)
                clipping.setState(material, camera, useCache);
            }
        }
        if (material.version === materialProperties.__version) {
            if (material.fog && materialProperties.fog !== fog) initMaterial(material, scene, object);
            else if (materialProperties.environment !== environment) initMaterial(material, scene, object);
            else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) initMaterial(material, scene, object);
            else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) initMaterial(material, scene, object);
            else if (materialProperties.outputEncoding !== encoding) initMaterial(material, scene, object);
            else if (materialProperties.envMap !== envMap) initMaterial(material, scene, object);
        } else {
            initMaterial(material, scene, object);
            materialProperties.__version = material.version;
        }
        let refreshProgram = false;
        let refreshMaterial = false;
        let refreshLights = false;
        const program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) p_uniforms.setValue(_gl, 'logDepthBufFC', 2 / (Math.log(camera.far + 1) / Math.LN2));
            if (_currentCamera !== camera) {
                _currentCamera = camera;
                // lighting uniforms depend on the camera so enforce an update
                // now, in case this material supports lights - or later, when
                // the next material that does gets activated:
                refreshMaterial = true; // set to true on material change
                refreshLights = true; // remains set until update done
            }
            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
                const uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
        }
        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // otherwise textures used for skinning can take over texture units reserved for other material textures
        if (material.skinning) {
            p_uniforms.setOptional(_gl, object, 'bindMatrix');
            p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
            const skeleton = object.skeleton;
            if (skeleton) {
                const bones = skeleton.bones;
                if (capabilities.floatVertexTextures) {
                    if (skeleton.boneTexture === null) {
                        // layout (1 matrix = 4 pixels)
                        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
                        let size1 = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                        size1 = MathUtils.ceilPowerOfTwo(size1);
                        size1 = Math.max(size1, 4);
                        const boneMatrices = new Float32Array(size1 * size1 * 4); // 4 floats per RGBA pixel
                        boneMatrices.set(skeleton.boneMatrices); // copy current values
                        const boneTexture = new DataTexture(boneMatrices, size1, size1, RGBAFormat, FloatType);
                        skeleton.boneMatrices = boneMatrices;
                        skeleton.boneTexture = boneTexture;
                        skeleton.boneTextureSize = size1;
                    }
                    p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                    p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                } else p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
            }
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
        }
        if (refreshMaterial) {
            p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
            if (materialProperties.needsLights) // the current material requires lighting info
            // note: all lighting uniforms are always set correctly
            // they simply reference the renderer's state for their
            // values
            //
            // use the current material's .needsUpdate flags to set
            // the GL state when required
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            // refresh uniforms common to several materials
            if (fog && material.fog) materials.refreshFogUniforms(m_uniforms, fog);
            materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) p_uniforms.setValue(_gl, 'center', object.center);
        // common matrices
        p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
        p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
        p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
        return program;
    }
    // If uniforms are marked as clean, they don't need to be loaded to the GPU.
    function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    //
    this.setFramebuffer = function(value) {
        if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(36160, value);
        _framebuffer = value;
    };
    this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
    };
    this.getRenderList = function() {
        return currentRenderList;
    };
    this.setRenderList = function(renderList) {
        currentRenderList = renderList;
    };
    this.getRenderTarget = function() {
        return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) textures.setupRenderTarget(renderTarget);
        let framebuffer = _framebuffer;
        let isCube = false;
        if (renderTarget) {
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
                framebuffer = __webglFramebuffer[activeCubeFace];
                isCube = true;
            } else if (renderTarget.isWebGLMultisampleRenderTarget) framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            else framebuffer = __webglFramebuffer;
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
        } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
        }
        if (_currentFramebuffer !== framebuffer) {
            _gl.bindFramebuffer(36160, framebuffer);
            _currentFramebuffer = framebuffer;
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
        }
    };
    this.readRenderTargetPixels = function(renderTarget, x6, y6, width5, height5, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
            return;
        }
        let framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) framebuffer = framebuffer[activeCubeFaceIndex];
        if (framebuffer) {
            let restore = false;
            if (framebuffer !== _currentFramebuffer) {
                _gl.bindFramebuffer(36160, framebuffer);
                restore = true;
            }
            try {
                const texture = renderTarget.texture;
                const textureFormat = texture.format;
                const textureType = texture.type;
                if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                    return;
                }
                const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));
                if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && !halfFloatSupportedByExt) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                    return;
                }
                if (_gl.checkFramebufferStatus(36160) === 36053) // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                {
                    if (x6 >= 0 && x6 <= renderTarget.width - width5 && y6 >= 0 && y6 <= renderTarget.height - height5) _gl.readPixels(x6, y6, width5, height5, utils.convert(textureFormat), utils.convert(textureType), buffer);
                } else console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
            } finally{
                if (restore) _gl.bindFramebuffer(36160, _currentFramebuffer);
            }
        }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
        const levelScale = Math.pow(2, -level);
        const width5 = Math.floor(texture.image.width * levelScale);
        const height5 = Math.floor(texture.image.height * levelScale);
        const glFormat = utils.convert(texture.format);
        textures.setTexture2D(texture, 0);
        _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width5, height5, 0);
        state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
        const width5 = srcTexture.image.width;
        const height5 = srcTexture.image.height;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        textures.setTexture2D(dstTexture, 0);
        // As another texture upload may have changed pixelStorei
        // parameters, make sure they are correct for the dstTexture
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        if (srcTexture.isDataTexture) _gl.texSubImage2D(3553, level, position.x, position.y, width5, height5, glFormat, glType, srcTexture.image.data);
        else if (srcTexture.isCompressedTexture) _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        else _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
        // Generate mipmaps only when copying level 0
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
        state.unbindTexture();
    };
    this.initTexture = function(texture) {
        textures.setTexture2D(texture, 0);
        state.unbindTexture();
    };
    this.resetState = function() {
        state.reset();
        bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
    })); // eslint-disable-line no-undef
}
function WebGL1Renderer(parameters) {
    WebGLRenderer.call(this, parameters);
}
WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {
    constructor: WebGL1Renderer,
    isWebGL1Renderer: true
});
class FogExp2 {
    constructor(color2, density){
        Object.defineProperty(this, 'isFogExp2', {
            value: true
        });
        this.name = '';
        this.color = new Color(color2);
        this.density = density !== undefined ? density : 0.00025;
    }
    clone() {
        return new FogExp2(this.color, this.density);
    }
    toJSON() {
        return {
            type: 'FogExp2',
            color: this.color.getHex(),
            density: this.density
        };
    }
}
class Fog {
    constructor(color3, near1, far1){
        Object.defineProperty(this, 'isFog', {
            value: true
        });
        this.name = '';
        this.color = new Color(color3);
        this.near = near1 !== undefined ? near1 : 1;
        this.far = far1 !== undefined ? far1 : 1000;
    }
    clone() {
        return new Fog(this.color, this.near, this.far);
    }
    toJSON() {
        return {
            type: 'Fog',
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }
}
class Scene extends Object3D {
    constructor(){
        super();
        Object.defineProperty(this, 'isScene', {
            value: true
        });
        this.type = 'Scene';
        this.background = null;
        this.environment = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true; // checked by the renderer
        if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
            detail: this
        })); // eslint-disable-line no-undef
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        if (source.background !== null) this.background = source.background.clone();
        if (source.environment !== null) this.environment = source.environment.clone();
        if (source.fog !== null) this.fog = source.fog.clone();
        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.background !== null) data.object.background = this.background.toJSON(meta);
        if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
        if (this.fog !== null) data.object.fog = this.fog.toJSON();
        return data;
    }
}
function InterleavedBuffer(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
    this.uuid = MathUtils.generateUUID();
}
Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
    set: function(value) {
        if (value === true) this.version++;
    }
});
Object.assign(InterleavedBuffer.prototype, {
    isInterleavedBuffer: true,
    onUploadCallback: function() {
    },
    setUsage: function(value) {
        this.usage = value;
        return this;
    },
    copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
    },
    copyAt: function(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for(let i1 = 0, l = this.stride; i1 < l; i1++)this.array[index1 + i1] = attribute.array[index2 + i1];
        return this;
    },
    set: function(value, offset = 0) {
        this.array.set(value, offset);
        return this;
    },
    clone: function(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {
        };
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = MathUtils.generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new InterleavedBuffer(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    },
    toJSON: function(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {
        };
        // generate UUID for array buffer if necessary
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = MathUtils.generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        //
        return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        };
    }
});
const _vector$6 = new Vector3();
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
    this.name = '';
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
    count: {
        get: function() {
            return this.data.count;
        }
    },
    array: {
        get: function() {
            return this.data.array;
        }
    },
    needsUpdate: {
        set: function(value) {
            this.data.needsUpdate = value;
        }
    }
});
Object.assign(InterleavedBufferAttribute.prototype, {
    isInterleavedBufferAttribute: true,
    applyMatrix4: function(m) {
        for(let i1 = 0, l = this.data.count; i1 < l; i1++){
            _vector$6.x = this.getX(i1);
            _vector$6.y = this.getY(i1);
            _vector$6.z = this.getZ(i1);
            _vector$6.applyMatrix4(m);
            this.setXYZ(i1, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
    },
    setX: function(index, x6) {
        this.data.array[index * this.data.stride + this.offset] = x6;
        return this;
    },
    setY: function(index, y6) {
        this.data.array[index * this.data.stride + this.offset + 1] = y6;
        return this;
    },
    setZ: function(index, z5) {
        this.data.array[index * this.data.stride + this.offset + 2] = z5;
        return this;
    },
    setW: function(index, w3) {
        this.data.array[index * this.data.stride + this.offset + 3] = w3;
        return this;
    },
    getX: function(index) {
        return this.data.array[index * this.data.stride + this.offset];
    },
    getY: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
    },
    getZ: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
    },
    getW: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
    },
    setXY: function(index, x6, y6) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x6;
        this.data.array[index + 1] = y6;
        return this;
    },
    setXYZ: function(index, x6, y6, z5) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x6;
        this.data.array[index + 1] = y6;
        this.data.array[index + 2] = z5;
        return this;
    },
    setXYZW: function(index, x6, y6, z5, w3) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x6;
        this.data.array[index + 1] = y6;
        this.data.array[index + 2] = z5;
        this.data.array[index + 3] = w3;
        return this;
    },
    clone: function(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
            const array = [];
            for(let i1 = 0; i1 < this.count; i1++){
                const index = i1 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
            }
            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {
            };
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
    },
    toJSON: function(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
            const array = [];
            for(let i1 = 0; i1 < this.count; i1++){
                const index = i1 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
            }
            // deinterleave data and save it as an ordinary buffer attribute for now
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: array,
                normalized: this.normalized
            };
        } else {
            // save as true interlaved attribtue
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {
            };
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            return {
                isInterleavedBufferAttribute: true,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
});
/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */ function SpriteMaterial(parameters) {
    Material.call(this);
    this.type = 'SpriteMaterial';
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
}
SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;
SpriteMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
};
let _geometry;
const _intersectPoint = new Vector3();
const _worldScale = new Vector3();
const _mvPosition = new Vector3();
const _alignedPosition = new Vector2();
const _rotatedPosition = new Vector2();
const _viewWorldMatrix = new Matrix4();
const _vA$1 = new Vector3();
const _vB$1 = new Vector3();
const _vC$1 = new Vector3();
const _uvA$1 = new Vector2();
const _uvB$1 = new Vector2();
const _uvC$1 = new Vector2();
function Sprite(material) {
    Object3D.call(this);
    this.type = 'Sprite';
    if (_geometry === undefined) {
        _geometry = new BufferGeometry();
        const float32Array = new Float32Array([
            -0.5,
            -0.5,
            0,
            0,
            0,
            0.5,
            -0.5,
            0,
            1,
            0,
            0.5,
            0.5,
            0,
            1,
            1,
            -0.5,
            0.5,
            0,
            0,
            1
        ]);
        const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
        _geometry.setIndex([
            0,
            1,
            2,
            0,
            2,
            3
        ]);
        _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
        _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== undefined ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
}
Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Sprite,
    isSprite: true,
    raycast: function(raycaster, intersects) {
        if (raycaster.camera === null) console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        _worldScale.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) _worldScale.multiplyScalar(-_mvPosition.z);
        const rotation = this.material.rotation;
        let sin, cos;
        if (rotation !== 0) {
            cos = Math.cos(rotation);
            sin = Math.sin(rotation);
        }
        const center2 = this.center;
        transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
        transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
        transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
        _uvA$1.set(0, 0);
        _uvB$1.set(1, 0);
        _uvC$1.set(1, 1);
        // check first triangle
        let intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
        if (intersect === null) {
            // check second triangle
            transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
            _uvB$1.set(0, 1);
            intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
            if (intersect === null) return;
        }
        const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects.push({
            distance: distance,
            point: _intersectPoint.clone(),
            uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
            face: null,
            object: this
        });
    },
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        if (source.center !== undefined) this.center.copy(source.center);
        this.material = source.material;
        return this;
    }
});
function transformVertex(vertexPosition, mvPosition, center2, scale, sin, cos) {
    // compute position in camera space
    _alignedPosition.subVectors(vertexPosition, center2).addScalar(0.5).multiply(scale);
    // to check if rotation is not zero
    if (sin !== undefined) {
        _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
        _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else _rotatedPosition.copy(_alignedPosition);
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    // transform to world space
    vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const _v1$4 = new Vector3();
const _v2$2 = new Vector3();
function LOD() {
    Object3D.call(this);
    this._currentLevel = 0;
    this.type = 'LOD';
    Object.defineProperties(this, {
        levels: {
            enumerable: true,
            value: []
        }
    });
    this.autoUpdate = true;
}
LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: LOD,
    isLOD: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source, false);
        const levels = source.levels;
        for(let i1 = 0, l = levels.length; i1 < l; i1++){
            const level = levels[i1];
            this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
    },
    addLevel: function(object, distance = 0) {
        distance = Math.abs(distance);
        const levels = this.levels;
        let l;
        for(l = 0; l < levels.length; l++){
            if (distance < levels[l].distance) break;
        }
        levels.splice(l, 0, {
            distance: distance,
            object: object
        });
        this.add(object);
        return this;
    },
    getCurrentLevel: function() {
        return this._currentLevel;
    },
    getObjectForDistance: function(distance) {
        const levels = this.levels;
        if (levels.length > 0) {
            let i1, l;
            for(i1 = 1, l = levels.length; i1 < l; i1++){
                if (distance < levels[i1].distance) break;
            }
            return levels[i1 - 1].object;
        }
        return null;
    },
    raycast: function(raycaster, intersects) {
        const levels = this.levels;
        if (levels.length > 0) {
            _v1$4.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(_v1$4);
            this.getObjectForDistance(distance).raycast(raycaster, intersects);
        }
    },
    update: function(camera) {
        const levels = this.levels;
        if (levels.length > 1) {
            _v1$4.setFromMatrixPosition(camera.matrixWorld);
            _v2$2.setFromMatrixPosition(this.matrixWorld);
            const distance = _v1$4.distanceTo(_v2$2) / camera.zoom;
            levels[0].object.visible = true;
            let i1, l;
            for(i1 = 1, l = levels.length; i1 < l; i1++){
                if (distance >= levels[i1].distance) {
                    levels[i1 - 1].object.visible = false;
                    levels[i1].object.visible = true;
                } else break;
            }
            this._currentLevel = i1 - 1;
            for(; i1 < l; i1++)levels[i1].object.visible = false;
        }
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        if (this.autoUpdate === false) data.object.autoUpdate = false;
        data.object.levels = [];
        const levels = this.levels;
        for(let i1 = 0, l = levels.length; i1 < l; i1++){
            const level = levels[i1];
            data.object.levels.push({
                object: level.object.uuid,
                distance: level.distance
            });
        }
        return data;
    }
});
const _basePosition = new Vector3();
const _skinIndex = new Vector4();
const _skinWeight = new Vector4();
const _vector$7 = new Vector3();
const _matrix$1 = new Matrix4();
function SkinnedMesh(geometry, material) {
    if (geometry && geometry.isGeometry) console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    Mesh.call(this, geometry, material);
    this.type = 'SkinnedMesh';
    this.bindMode = 'attached';
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: SkinnedMesh,
    isSkinnedMesh: true,
    copy: function(source) {
        Mesh.prototype.copy.call(this, source);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        return this;
    },
    bind: function(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === undefined) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.copy(bindMatrix).invert();
    },
    pose: function() {
        this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
        const vector = new Vector4();
        const skinWeight = this.geometry.attributes.skinWeight;
        for(let i1 = 0, l = skinWeight.count; i1 < l; i1++){
            vector.x = skinWeight.getX(i1);
            vector.y = skinWeight.getY(i1);
            vector.z = skinWeight.getZ(i1);
            vector.w = skinWeight.getW(i1);
            const scale = 1 / vector.manhattanLength();
            if (scale !== Infinity) vector.multiplyScalar(scale);
            else vector.set(1, 0, 0, 0); // do something reasonable
            skinWeight.setXYZW(i1, vector.x, vector.y, vector.z, vector.w);
        }
    },
    updateMatrixWorld: function(force) {
        Mesh.prototype.updateMatrixWorld.call(this, force);
        if (this.bindMode === 'attached') this.bindMatrixInverse.copy(this.matrixWorld).invert();
        else if (this.bindMode === 'detached') this.bindMatrixInverse.copy(this.bindMatrix).invert();
        else console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    },
    boneTransform: function(index, target) {
        const skeleton = this.skeleton;
        const geometry = this.geometry;
        _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
        _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
        _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
        target.set(0, 0, 0);
        for(let i1 = 0; i1 < 4; i1++){
            const weight = _skinWeight.getComponent(i1);
            if (weight !== 0) {
                const boneIndex = _skinIndex.getComponent(i1);
                _matrix$1.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                target.addScaledVector(_vector$7.copy(_basePosition).applyMatrix4(_matrix$1), weight);
            }
        }
        return target.applyMatrix4(this.bindMatrixInverse);
    }
});
function Bone() {
    Object3D.call(this);
    this.type = 'Bone';
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Bone,
    isBone: true
});
const _offsetMatrix = new Matrix4();
const _identityMatrix = new Matrix4();
function Skeleton(bones = [], boneInverses = []) {
    this.uuid = MathUtils.generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
}
Object.assign(Skeleton.prototype, {
    init: function() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        this.boneMatrices = new Float32Array(bones.length * 16);
        // calculate inverse bone matrices if necessary
        if (boneInverses.length === 0) this.calculateInverses();
        else // handle special case
        if (bones.length !== boneInverses.length) {
            console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
            this.boneInverses = [];
            for(let i1 = 0, il = this.bones.length; i1 < il; i1++)this.boneInverses.push(new Matrix4());
        }
    },
    calculateInverses: function() {
        this.boneInverses.length = 0;
        for(let i1 = 0, il = this.bones.length; i1 < il; i1++){
            const inverse = new Matrix4();
            if (this.bones[i1]) inverse.copy(this.bones[i1].matrixWorld).invert();
            this.boneInverses.push(inverse);
        }
    },
    pose: function() {
        // recover the bind-time world matrices
        for(let i1 = 0, il = this.bones.length; i1 < il; i1++){
            const bone = this.bones[i1];
            if (bone) bone.matrixWorld.copy(this.boneInverses[i1]).invert();
        }
        // compute the local matrices, positions, rotations and scales
        for(let i2 = 0, il1 = this.bones.length; i2 < il1; i2++){
            const bone = this.bones[i2];
            if (bone) {
                if (bone.parent && bone.parent.isBone) {
                    bone.matrix.copy(bone.parent.matrixWorld).invert();
                    bone.matrix.multiply(bone.matrixWorld);
                } else bone.matrix.copy(bone.matrixWorld);
                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
        }
    },
    update: function() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        const boneMatrices = this.boneMatrices;
        const boneTexture = this.boneTexture;
        // flatten bone matrices to array
        for(let i1 = 0, il = bones.length; i1 < il; i1++){
            // compute the offset between the current and the original transform
            const matrix = bones[i1] ? bones[i1].matrixWorld : _identityMatrix;
            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i1]);
            _offsetMatrix.toArray(boneMatrices, i1 * 16);
        }
        if (boneTexture !== null) boneTexture.needsUpdate = true;
    },
    clone: function() {
        return new Skeleton(this.bones, this.boneInverses);
    },
    getBoneByName: function(name) {
        for(let i1 = 0, il = this.bones.length; i1 < il; i1++){
            const bone = this.bones[i1];
            if (bone.name === name) return bone;
        }
        return undefined;
    },
    dispose: function() {
        if (this.boneTexture !== null) {
            this.boneTexture.dispose();
            this.boneTexture = null;
        }
    },
    fromJSON: function(json, bones) {
        this.uuid = json.uuid;
        for(let i1 = 0, l = json.bones.length; i1 < l; i1++){
            const uuid = json.bones[i1];
            let bone = bones[uuid];
            if (bone === undefined) {
                console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
                bone = new Bone();
            }
            this.bones.push(bone);
            this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i1]));
        }
        this.init();
        return this;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'Skeleton',
                generator: 'Skeleton.toJSON'
            },
            bones: [],
            boneInverses: []
        };
        data.uuid = this.uuid;
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        for(let i1 = 0, l = bones.length; i1 < l; i1++){
            const bone = bones[i1];
            data.bones.push(bone.uuid);
            const boneInverse = boneInverses[i1];
            data.boneInverses.push(boneInverse.toArray());
        }
        return data;
    }
});
const _instanceLocalMatrix = new Matrix4();
const _instanceWorldMatrix = new Matrix4();
const _instanceIntersects = [];
const _mesh = new Mesh();
function InstancedMesh(geometry, material, count) {
    Mesh.call(this, geometry, material);
    this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
}
InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: InstancedMesh,
    isInstancedMesh: true,
    copy: function(source) {
        Mesh.prototype.copy.call(this, source);
        this.instanceMatrix.copy(source.instanceMatrix);
        if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
        this.count = source.count;
        return this;
    },
    getColorAt: function(index, color4) {
        color4.fromArray(this.instanceColor.array, index * 3);
    },
    getMatrixAt: function(index, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index * 16);
    },
    raycast: function(raycaster, intersects) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        _mesh.geometry = this.geometry;
        _mesh.material = this.material;
        if (_mesh.material === undefined) return;
        for(let instanceId = 0; instanceId < raycastTimes; instanceId++){
            // calculate the world matrix for each instance
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            // the mesh represents this single instance
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            // process the result of raycast
            for(let i1 = 0, l = _instanceIntersects.length; i1 < l; i1++){
                const intersect = _instanceIntersects[i1];
                intersect.instanceId = instanceId;
                intersect.object = this;
                intersects.push(intersect);
            }
            _instanceIntersects.length = 0;
        }
    },
    setColorAt: function(index, color4) {
        if (this.instanceColor === null) this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
        color4.toArray(this.instanceColor.array, index * 3);
    },
    setMatrixAt: function(index, matrix) {
        matrix.toArray(this.instanceMatrix.array, index * 16);
    },
    updateMorphTargets: function() {
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */ function LineBasicMaterial(parameters) {
    Material.call(this);
    this.type = 'LineBasicMaterial';
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';
    this.morphTargets = false;
    this.setValues(parameters);
}
LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;
LineBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
};
const _start = new Vector3();
const _end = new Vector3();
const _inverseMatrix$1 = new Matrix4();
const _ray$1 = new Ray();
const _sphere$2 = new Sphere();
function Line(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    Object3D.call(this);
    this.type = 'Line';
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Line,
    isLine: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            // we assume non-indexed geometry
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [
                    0
                ];
                for(let i1 = 1, l = positionAttribute.count; i1 < l; i1++){
                    _start.fromBufferAttribute(positionAttribute, i1 - 1);
                    _end.fromBufferAttribute(positionAttribute, i1);
                    lineDistances[i1] = lineDistances[i1 - 1];
                    lineDistances[i1] += _start.distanceTo(_end);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
            } else console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry.isGeometry) console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        return this;
    },
    raycast: function(raycaster, intersects) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$2.copy(geometry.boundingSphere);
        _sphere$2.applyMatrix4(matrixWorld);
        _sphere$2.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$2) === false) return;
        //
        _inverseMatrix$1.copy(matrixWorld).invert();
        _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const vStart = new Vector3();
        const vEnd = new Vector3();
        const interSegment = new Vector3();
        const interRay = new Vector3();
        const step = this.isLineSegments ? 2 : 1;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
                const indices2 = index.array;
                for(let i1 = 0, l = indices2.length - 1; i1 < l; i1 += step){
                    const a3 = indices2[i1];
                    const b4 = indices2[i1 + 1];
                    vStart.fromBufferAttribute(positionAttribute, a3);
                    vEnd.fromBufferAttribute(positionAttribute, b4);
                    const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > localThresholdSq) continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    const distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i1,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            } else for(let i1 = 0, l = positionAttribute.count - 1; i1 < l; i1 += step){
                vStart.fromBufferAttribute(positionAttribute, i1);
                vEnd.fromBufferAttribute(positionAttribute, i1 + 1);
                const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq) continue;
                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far) continue;
                intersects.push({
                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i1,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        } else if (geometry.isGeometry) console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {
                    };
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
});
const _start$1 = new Vector3();
const _end$1 = new Vector3();
function LineSegments(geometry, material) {
    Line.call(this, geometry, material);
    this.type = 'LineSegments';
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineSegments,
    isLineSegments: true,
    computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            // we assume non-indexed geometry
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [];
                for(let i1 = 0, l = positionAttribute.count; i1 < l; i1 += 2){
                    _start$1.fromBufferAttribute(positionAttribute, i1);
                    _end$1.fromBufferAttribute(positionAttribute, i1 + 1);
                    lineDistances[i1] = i1 === 0 ? 0 : lineDistances[i1 - 1];
                    lineDistances[i1 + 1] = lineDistances[i1] + _start$1.distanceTo(_end$1);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
            } else console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry.isGeometry) console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        return this;
    }
});
function LineLoop(geometry, material) {
    Line.call(this, geometry, material);
    this.type = 'LineLoop';
}
LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineLoop,
    isLineLoop: true
});
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */ function PointsMaterial(parameters) {
    Material.call(this);
    this.type = 'PointsMaterial';
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
}
PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;
PointsMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
};
const _inverseMatrix$2 = new Matrix4();
const _ray$2 = new Ray();
const _sphere$3 = new Sphere();
const _position$1 = new Vector3();
function Points(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    Object3D.call(this);
    this.type = 'Points';
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Points,
    isPoints: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    raycast: function(raycaster, intersects) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Points.threshold;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$3.copy(geometry.boundingSphere);
        _sphere$3.applyMatrix4(matrixWorld);
        _sphere$3.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;
        //
        _inverseMatrix$2.copy(matrixWorld).invert();
        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
                const indices2 = index.array;
                for(let i1 = 0, il = indices2.length; i1 < il; i1++){
                    const a3 = indices2[i1];
                    _position$1.fromBufferAttribute(positionAttribute, a3);
                    testPoint(_position$1, a3, localThresholdSq, matrixWorld, raycaster, intersects, this);
                }
            } else for(let i1 = 0, l = positionAttribute.count; i1 < l; i1++){
                _position$1.fromBufferAttribute(positionAttribute, i1);
                testPoint(_position$1, i1, localThresholdSq, matrixWorld, raycaster, intersects, this);
            }
        } else console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {
                    };
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
});
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
    const rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
        const intersectPoint = new Vector3();
        _ray$2.closestPointToPoint(point, intersectPoint);
        intersectPoint.applyMatrix4(matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects.push({
            distance: distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint,
            index: index,
            face: null,
            object: object
        });
    }
}
function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== undefined ? format : RGBFormat;
    this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope1 = this;
    function updateVideo() {
        scope1.needsUpdate = true;
        video.requestVideoFrameCallback(updateVideo);
    }
    if ('requestVideoFrameCallback' in video) video.requestVideoFrameCallback(updateVideo);
}
VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
    constructor: VideoTexture,
    clone: function() {
        return new this.constructor(this.image).copy(this);
    },
    isVideoTexture: true,
    update: function() {
        const video = this.image;
        const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) this.needsUpdate = true;
    }
});
function CompressedTexture(mipmaps, width5, height5, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        width: width5,
        height: height5
    };
    this.mipmaps = mipmaps;
    // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )
    this.flipY = false;
    // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files
    this.generateMipmaps = false;
}
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
}
CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
function DepthTexture(width5, height5, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== undefined ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
    if (type === undefined && format === DepthFormat) type = UnsignedShortType;
    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
        width: width5,
        height: height5
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
}
DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
class CircleGeometry extends BufferGeometry {
    constructor(radius2 = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2){
        super();
        this.type = 'CircleGeometry';
        this.parameters = {
            radius: radius2,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        segments = Math.max(3, segments);
        // buffers
        const indices2 = [];
        const vertices2 = [];
        const normals2 = [];
        const uvs2 = [];
        // helper variables
        const vertex = new Vector3();
        const uv = new Vector2();
        // center point
        vertices2.push(0, 0, 0);
        normals2.push(0, 0, 1);
        uvs2.push(0.5, 0.5);
        for(let s1 = 0, i1 = 3; s1 <= segments; s1++, i1 += 3){
            const segment = thetaStart + s1 / segments * thetaLength;
            // vertex
            vertex.x = radius2 * Math.cos(segment);
            vertex.y = radius2 * Math.sin(segment);
            vertices2.push(vertex.x, vertex.y, vertex.z);
            // normal
            normals2.push(0, 0, 1);
            // uvs
            uv.x = (vertices2[i1] / radius2 + 1) / 2;
            uv.y = (vertices2[i1 + 1] / radius2 + 1) / 2;
            uvs2.push(uv.x, uv.y);
        }
        // indices
        for(let i2 = 1; i2 <= segments; i2++)indices2.push(i2, i2 + 1, 0);
        // build geometry
        this.setIndex(indices2);
        this.setAttribute('position', new Float32BufferAttribute(vertices2, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals2, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs2, 2));
    }
}
class CylinderGeometry extends BufferGeometry {
    constructor(radiusTop = 1, radiusBottom = 1, height5 = 1, radialSegments = 8, heightSegments2 = 1, openEnded = false, thetaStart1 = 0, thetaLength1 = Math.PI * 2){
        super();
        this.type = 'CylinderGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height5,
            radialSegments: radialSegments,
            heightSegments: heightSegments2,
            openEnded: openEnded,
            thetaStart: thetaStart1,
            thetaLength: thetaLength1
        };
        const scope1 = this;
        radialSegments = Math.floor(radialSegments);
        heightSegments2 = Math.floor(heightSegments2);
        // buffers
        const indices3 = [];
        const vertices3 = [];
        const normals3 = [];
        const uvs3 = [];
        // helper variables
        let index = 0;
        const indexArray = [];
        const halfHeight = height5 / 2;
        let groupStart1 = 0;
        // generate geometry
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0) generateCap(true);
            if (radiusBottom > 0) generateCap(false);
        }
        // build geometry
        this.setIndex(indices3);
        this.setAttribute('position', new Float32BufferAttribute(vertices3, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals3, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs3, 2));
        function generateTorso() {
            const normal3 = new Vector3();
            const vertex1 = new Vector3();
            let groupCount = 0;
            // this will be used to calculate the normal
            const slope = (radiusBottom - radiusTop) / height5;
            // generate vertices, normals and uvs
            for(let y6 = 0; y6 <= heightSegments2; y6++){
                const indexRow = [];
                const v = y6 / heightSegments2;
                // calculate the radius of the current row
                const radius3 = v * (radiusBottom - radiusTop) + radiusTop;
                for(let x6 = 0; x6 <= radialSegments; x6++){
                    const u = x6 / radialSegments;
                    const theta = u * thetaLength1 + thetaStart1;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    // vertex
                    vertex1.x = radius3 * sinTheta;
                    vertex1.y = -v * height5 + halfHeight;
                    vertex1.z = radius3 * cosTheta;
                    vertices3.push(vertex1.x, vertex1.y, vertex1.z);
                    // normal
                    normal3.set(sinTheta, slope, cosTheta).normalize();
                    normals3.push(normal3.x, normal3.y, normal3.z);
                    // uv
                    uvs3.push(u, 1 - v);
                    // save index of vertex in respective row
                    indexRow.push(index++);
                }
                // now save vertices of the row in our index array
                indexArray.push(indexRow);
            }
            // generate indices
            for(let x6 = 0; x6 < radialSegments; x6++)for(let y7 = 0; y7 < heightSegments2; y7++){
                // we use the index array to access the correct indices
                const a3 = indexArray[y7][x6];
                const b4 = indexArray[y7 + 1][x6];
                const c3 = indexArray[y7 + 1][x6 + 1];
                const d = indexArray[y7][x6 + 1];
                // faces
                indices3.push(a3, b4, d);
                indices3.push(b4, c3, d);
                // update group counter
                groupCount += 6;
            }
            // add a group to the geometry. this will ensure multi material support
            scope1.addGroup(groupStart1, groupCount, 0);
            // calculate new start value for groups
            groupStart1 += groupCount;
        }
        function generateCap(top) {
            // save the index of the first center vertex
            const centerIndexStart = index;
            const uv1 = new Vector2();
            const vertex1 = new Vector3();
            let groupCount = 0;
            const radius3 = top === true ? radiusTop : radiusBottom;
            const sign = top === true ? 1 : -1;
            // first we generate the center vertex data of the cap.
            // because the geometry needs one set of uvs per face,
            // we must generate a center vertex per face/segment
            for(let x6 = 1; x6 <= radialSegments; x6++){
                // vertex
                vertices3.push(0, halfHeight * sign, 0);
                // normal
                normals3.push(0, sign, 0);
                // uv
                uvs3.push(0.5, 0.5);
                // increase index
                index++;
            }
            // save the index of the last center vertex
            const centerIndexEnd = index;
            // now we generate the surrounding vertices, normals and uvs
            for(let x7 = 0; x7 <= radialSegments; x7++){
                const u = x7 / radialSegments;
                const theta = u * thetaLength1 + thetaStart1;
                const cosTheta = Math.cos(theta);
                const sinTheta = Math.sin(theta);
                // vertex
                vertex1.x = radius3 * sinTheta;
                vertex1.y = halfHeight * sign;
                vertex1.z = radius3 * cosTheta;
                vertices3.push(vertex1.x, vertex1.y, vertex1.z);
                // normal
                normals3.push(0, sign, 0);
                // uv
                uv1.x = cosTheta * 0.5 + 0.5;
                uv1.y = sinTheta * 0.5 * sign + 0.5;
                uvs3.push(uv1.x, uv1.y);
                // increase index
                index++;
            }
            // generate indices
            for(let x8 = 0; x8 < radialSegments; x8++){
                const c3 = centerIndexStart + x8;
                const i3 = centerIndexEnd + x8;
                if (top === true) // face top
                indices3.push(i3, i3 + 1, c3);
                else // face bottom
                indices3.push(i3 + 1, i3, c3);
                groupCount += 3;
            }
            // add a group to the geometry. this will ensure multi material support
            scope1.addGroup(groupStart1, groupCount, top === true ? 1 : 2);
            // calculate new start value for groups
            groupStart1 += groupCount;
        }
    }
}
class ConeGeometry extends CylinderGeometry {
    constructor(radius3 = 1, height6 = 1, radialSegments1 = 8, heightSegments3 = 1, openEnded1 = false, thetaStart2 = 0, thetaLength2 = Math.PI * 2){
        super(0, radius3, height6, radialSegments1, heightSegments3, openEnded1, thetaStart2, thetaLength2);
        this.type = 'ConeGeometry';
        this.parameters = {
            radius: radius3,
            height: height6,
            radialSegments: radialSegments1,
            heightSegments: heightSegments3,
            openEnded: openEnded1,
            thetaStart: thetaStart2,
            thetaLength: thetaLength2
        };
    }
}
class PolyhedronGeometry extends BufferGeometry {
    constructor(vertices4, indices4, radius4 = 1, detail = 0){
        super();
        this.type = 'PolyhedronGeometry';
        this.parameters = {
            vertices: vertices4,
            indices: indices4,
            radius: radius4,
            detail: detail
        };
        // default buffer data
        const vertexBuffer = [];
        const uvBuffer = [];
        // the subdivision creates the vertex buffer data
        subdivide(detail);
        // all vertices should lie on a conceptual sphere with a given radius
        applyRadius(radius4);
        // finally, create the uv data
        generateUVs1();
        // build non-indexed geometry
        this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
        this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
        if (detail === 0) this.computeVertexNormals(); // flat normals
        else this.normalizeNormals(); // smooth normals
        // helper functions
        function subdivide(detail1) {
            const a3 = new Vector3();
            const b4 = new Vector3();
            const c3 = new Vector3();
            // iterate over all faces and apply a subdivison with the given detail value
            for(let i3 = 0; i3 < indices4.length; i3 += 3){
                // get the vertices of the face
                getVertexByIndex(indices4[i3 + 0], a3);
                getVertexByIndex(indices4[i3 + 1], b4);
                getVertexByIndex(indices4[i3 + 2], c3);
                // perform subdivision
                subdivideFace(a3, b4, c3, detail1);
            }
        }
        function subdivideFace(a3, b4, c3, detail1) {
            const cols = detail1 + 1;
            // we use this multidimensional array as a data structure for creating the subdivision
            const v = [];
            // construct all of the vertices for this subdivision
            for(let i3 = 0; i3 <= cols; i3++){
                v[i3] = [];
                const aj = a3.clone().lerp(c3, i3 / cols);
                const bj = b4.clone().lerp(c3, i3 / cols);
                const rows = cols - i3;
                for(let j = 0; j <= rows; j++)if (j === 0 && i3 === cols) v[i3][j] = aj;
                else v[i3][j] = aj.clone().lerp(bj, j / rows);
            }
            // construct all of the faces
            for(let i4 = 0; i4 < cols; i4++)for(let j = 0; j < 2 * (cols - i4) - 1; j++){
                const k = Math.floor(j / 2);
                if (j % 2 === 0) {
                    pushVertex(v[i4][k + 1]);
                    pushVertex(v[i4 + 1][k]);
                    pushVertex(v[i4][k]);
                } else {
                    pushVertex(v[i4][k + 1]);
                    pushVertex(v[i4 + 1][k + 1]);
                    pushVertex(v[i4 + 1][k]);
                }
            }
        }
        function applyRadius(radius5) {
            const vertex1 = new Vector3();
            // iterate over the entire buffer and apply the radius to each vertex
            for(let i3 = 0; i3 < vertexBuffer.length; i3 += 3){
                vertex1.x = vertexBuffer[i3 + 0];
                vertex1.y = vertexBuffer[i3 + 1];
                vertex1.z = vertexBuffer[i3 + 2];
                vertex1.normalize().multiplyScalar(radius5);
                vertexBuffer[i3 + 0] = vertex1.x;
                vertexBuffer[i3 + 1] = vertex1.y;
                vertexBuffer[i3 + 2] = vertex1.z;
            }
        }
        function generateUVs1() {
            const vertex1 = new Vector3();
            for(let i3 = 0; i3 < vertexBuffer.length; i3 += 3){
                vertex1.x = vertexBuffer[i3 + 0];
                vertex1.y = vertexBuffer[i3 + 1];
                vertex1.z = vertexBuffer[i3 + 2];
                const u = azimuth(vertex1) / 2 / Math.PI + 0.5;
                const v = inclination(vertex1) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
        }
        function correctSeam() {
            // handle case when face straddles the seam, see #3269
            for(let i3 = 0; i3 < uvBuffer.length; i3 += 6){
                // uv data of a single face
                const x0 = uvBuffer[i3 + 0];
                const x11 = uvBuffer[i3 + 2];
                const x21 = uvBuffer[i3 + 4];
                const max2 = Math.max(x0, x11, x21);
                const min2 = Math.min(x0, x11, x21);
                // 0.9 is somewhat arbitrary
                if (max2 > 0.9 && min2 < 0.1) {
                    if (x0 < 0.2) uvBuffer[i3 + 0] += 1;
                    if (x11 < 0.2) uvBuffer[i3 + 2] += 1;
                    if (x21 < 0.2) uvBuffer[i3 + 4] += 1;
                }
            }
        }
        function pushVertex(vertex1) {
            vertexBuffer.push(vertex1.x, vertex1.y, vertex1.z);
        }
        function getVertexByIndex(index1, vertex1) {
            const stride = index1 * 3;
            vertex1.x = vertices4[stride + 0];
            vertex1.y = vertices4[stride + 1];
            vertex1.z = vertices4[stride + 2];
        }
        function correctUVs() {
            const a3 = new Vector3();
            const b4 = new Vector3();
            const c3 = new Vector3();
            const centroid = new Vector3();
            const uvA = new Vector2();
            const uvB = new Vector2();
            const uvC = new Vector2();
            for(let i3 = 0, j = 0; i3 < vertexBuffer.length; i3 += 9, j += 6){
                a3.set(vertexBuffer[i3 + 0], vertexBuffer[i3 + 1], vertexBuffer[i3 + 2]);
                b4.set(vertexBuffer[i3 + 3], vertexBuffer[i3 + 4], vertexBuffer[i3 + 5]);
                c3.set(vertexBuffer[i3 + 6], vertexBuffer[i3 + 7], vertexBuffer[i3 + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a3).add(b4).add(c3).divideScalar(3);
                const azi = azimuth(centroid);
                correctUV(uvA, j + 0, a3, azi);
                correctUV(uvB, j + 2, b4, azi);
                correctUV(uvC, j + 4, c3, azi);
            }
        }
        function correctUV(uv1, stride, vector, azimuth) {
            if (azimuth < 0 && uv1.x === 1) uvBuffer[stride] = uv1.x - 1;
            if (vector.x === 0 && vector.z === 0) uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
        }
        // Angle around the Y axis, counter-clockwise when looking from above.
        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        // Angle above the XZ plane.
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
    }
}
class DodecahedronGeometry extends PolyhedronGeometry {
    constructor(radius5 = 1, detail1 = 0){
        const t2 = (1 + Math.sqrt(5)) / 2;
        const r2 = 1 / t2;
        const vertices5 = [
            // (Â±1, Â±1, Â±1)
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            // (0, Â±1/Ï†, Â±Ï†)
            0,
            -r2,
            -t2,
            0,
            -r2,
            t2,
            0,
            r2,
            -t2,
            0,
            r2,
            t2,
            // (Â±1/Ï†, Â±Ï†, 0)
            -r2,
            -t2,
            0,
            -r2,
            t2,
            0,
            r2,
            -t2,
            0,
            r2,
            t2,
            0,
            // (Â±Ï†, 0, Â±1/Ï†)
            -t2,
            0,
            -r2,
            t2,
            0,
            -r2,
            -t2,
            0,
            r2,
            t2,
            0,
            r2
        ];
        const indices5 = [
            3,
            11,
            7,
            3,
            7,
            15,
            3,
            15,
            13,
            7,
            19,
            17,
            7,
            17,
            6,
            7,
            6,
            15,
            17,
            4,
            8,
            17,
            8,
            10,
            17,
            10,
            6,
            8,
            0,
            16,
            8,
            16,
            2,
            8,
            2,
            10,
            0,
            12,
            1,
            0,
            1,
            18,
            0,
            18,
            16,
            6,
            10,
            2,
            6,
            2,
            13,
            6,
            13,
            15,
            2,
            16,
            18,
            2,
            18,
            3,
            2,
            3,
            13,
            18,
            1,
            9,
            18,
            9,
            11,
            18,
            11,
            3,
            4,
            14,
            12,
            4,
            12,
            0,
            4,
            0,
            8,
            11,
            9,
            5,
            11,
            5,
            19,
            11,
            19,
            7,
            19,
            5,
            14,
            19,
            14,
            4,
            19,
            4,
            17,
            1,
            12,
            14,
            1,
            14,
            5,
            1,
            5,
            9
        ];
        super(vertices5, indices5, radius5, detail1);
        this.type = 'DodecahedronGeometry';
        this.parameters = {
            radius: radius5,
            detail: detail1
        };
    }
}
const _v0$2 = new Vector3();
const _v1$5 = new Vector3();
const _normal$1 = new Vector3();
const _triangle = new Triangle();
class EdgesGeometry extends BufferGeometry {
    constructor(geometry, thresholdAngle){
        super();
        this.type = 'EdgesGeometry';
        this.parameters = {
            thresholdAngle: thresholdAngle
        };
        thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
        if (geometry.isGeometry === true) {
            console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
            return;
        }
        const precisionPoints = 4;
        const precision = Math.pow(10, precisionPoints);
        const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
        const indexAttr = geometry.getIndex();
        const positionAttr = geometry.getAttribute('position');
        const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
        const indexArr = [
            0,
            0,
            0
        ];
        const vertKeys = [
            'a',
            'b',
            'c'
        ];
        const hashes = new Array(3);
        const edgeData = {
        };
        const vertices6 = [];
        for(let i3 = 0; i3 < indexCount; i3 += 3){
            if (indexAttr) {
                indexArr[0] = indexAttr.getX(i3);
                indexArr[1] = indexAttr.getX(i3 + 1);
                indexArr[2] = indexAttr.getX(i3 + 2);
            } else {
                indexArr[0] = i3;
                indexArr[1] = i3 + 1;
                indexArr[2] = i3 + 2;
            }
            const { a: a3 , b: b4 , c: c3  } = _triangle;
            a3.fromBufferAttribute(positionAttr, indexArr[0]);
            b4.fromBufferAttribute(positionAttr, indexArr[1]);
            c3.fromBufferAttribute(positionAttr, indexArr[2]);
            _triangle.getNormal(_normal$1);
            // create hashes for the edge from the vertices
            hashes[0] = `${Math.round(a3.x * precision)},${Math.round(a3.y * precision)},${Math.round(a3.z * precision)}`;
            hashes[1] = `${Math.round(b4.x * precision)},${Math.round(b4.y * precision)},${Math.round(b4.z * precision)}`;
            hashes[2] = `${Math.round(c3.x * precision)},${Math.round(c3.y * precision)},${Math.round(c3.z * precision)}`;
            // skip degenerate triangles
            if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) continue;
            // iterate over every edge
            for(let j = 0; j < 3; j++){
                // get the first and next vertex making up the edge
                const jNext = (j + 1) % 3;
                const vecHash0 = hashes[j];
                const vecHash1 = hashes[jNext];
                const v0 = _triangle[vertKeys[j]];
                const v1 = _triangle[vertKeys[jNext]];
                const hash = `${vecHash0}_${vecHash1}`;
                const reverseHash = `${vecHash1}_${vecHash0}`;
                if (reverseHash in edgeData && edgeData[reverseHash]) {
                    // if we found a sibling edge add it into the vertex array if
                    // it meets the angle threshold and delete the edge from the map.
                    if (_normal$1.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                        vertices6.push(v0.x, v0.y, v0.z);
                        vertices6.push(v1.x, v1.y, v1.z);
                    }
                    edgeData[reverseHash] = null;
                } else if (!(hash in edgeData)) // if we've already got an edge here then skip adding a new one
                edgeData[hash] = {
                    index0: indexArr[j],
                    index1: indexArr[jNext],
                    normal: _normal$1.clone()
                };
            }
        }
        // iterate over all remaining, unmatched edges and add them to the vertex array
        for(const key in edgeData)if (edgeData[key]) {
            const { index0 , index1  } = edgeData[key];
            _v0$2.fromBufferAttribute(positionAttr, index0);
            _v1$5.fromBufferAttribute(positionAttr, index1);
            vertices6.push(_v0$2.x, _v0$2.y, _v0$2.z);
            vertices6.push(_v1$5.x, _v1$5.y, _v1$5.z);
        }
        this.setAttribute('position', new Float32BufferAttribute(vertices6, 3));
    }
}
/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */ const Earcut = {
    triangulate: function(data, holeIndices, dim) {
        dim = dim || 2;
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        let minX, minY, maxX, maxY, x6, y6, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for(let i4 = dim; i4 < outerLen; i4 += dim){
                x6 = data[i4];
                y6 = data[i4 + 1];
                if (x6 < minX) minX = x6;
                if (y6 < minY) minY = y6;
                if (x6 > maxX) maxX = x6;
                if (y6 > maxY) maxY = y6;
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    let i4, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) for(i4 = start; i4 < end; i4 += dim)last = insertNode(i4, data[i4], data[i4 + 1], last);
    else for(i4 = end - dim; i4 >= start; i4 -= dim)last = insertNode(i4, data[i4], data[i4 + 1], last);
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else p = p.next;
    }while (again || p !== end)
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) splitEarcut(ear, triangles, dim, minX, minY, invSize);
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    const a3 = ear.prev, b4 = ear, c3 = ear.next;
    if (area(a3, b4, c3) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    let p = ear.next.next;
    while(p !== ear.prev){
        if (pointInTriangle(a3.x, a3.y, b4.x, b4.y, c3.x, c3.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    const a3 = ear.prev, b4 = ear, c3 = ear.next;
    if (area(a3, b4, c3) >= 0) return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    const minTX = a3.x < b4.x ? a3.x < c3.x ? a3.x : c3.x : b4.x < c3.x ? b4.x : c3.x, minTY = a3.y < b4.y ? a3.y < c3.y ? a3.y : c3.y : b4.y < c3.y ? b4.y : c3.y, maxTX = a3.x > b4.x ? a3.x > c3.x ? a3.x : c3.x : b4.x > c3.x ? b4.x : c3.x, maxTY = a3.y > b4.y ? a3.y > c3.y ? a3.y : c3.y : b4.y > c3.y ? b4.y : c3.y;
    // z-order range for the current triangle bbox;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a3.x, a3.y, b4.x, b4.y, c3.x, c3.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a3.x, a3.y, b4.x, b4.y, c3.x, c3.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a3.x, a3.y, b4.x, b4.y, c3.x, c3.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a3.x, a3.y, b4.x, b4.y, c3.x, c3.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
        const a3 = p.prev, b4 = p.next.next;
        if (!equals(a3, b4) && intersects(a3, p, p.next, b4) && locallyInside(a3, b4) && locallyInside(b4, a3)) {
            triangles.push(a3.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b4.i / dim);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b4;
        }
        p = p.next;
    }while (p !== start)
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a3 = start;
    do {
        let b4 = a3.next.next;
        while(b4 !== a3.prev){
            if (a3.i !== b4.i && isValidDiagonal(a3, b4)) {
                // split the polygon in two by the diagonal
                let c3 = splitPolygon(a3, b4);
                // filter colinear points around the cuts
                a3 = filterPoints(a3, a3.next);
                c3 = filterPoints(c3, c3.next);
                // run earcut on each half
                earcutLinked(a3, triangles, dim, minX, minY, invSize);
                earcutLinked(c3, triangles, dim, minX, minY, invSize);
                return;
            }
            b4 = b4.next;
        }
        a3 = a3.next;
    }while (a3 !== start)
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i4, len, start, end, list;
    for(i4 = 0, len = holeIndices.length; i4 < len; i4++){
        start = holeIndices[i4] * dim;
        end = i4 < len - 1 ? holeIndices[i4 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i4 = 0; i4 < queue.length; i4++){
        eliminateHole(queue[i4], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a3, b4) {
    return a3.x - b4.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        const b4 = splitPolygon(outerNode, hole);
        // filter collinear points around the cuts
        filterPoints(outerNode, outerNode.next);
        filterPoints(b4, b4.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x6 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x6 <= hx && x6 > qx) {
                qx = x6;
                if (x6 === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop)
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    let i4, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i4 = 0; i4 < inSize; i4++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x6, y6, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x6 = 32767 * (x6 - minX) * invSize;
    y6 = 32767 * (y6 - minY) * invSize;
    x6 = (x6 | x6 << 8) & 16711935;
    x6 = (x6 | x6 << 4) & 252645135;
    x6 = (x6 | x6 << 2) & 858993459;
    x6 = (x6 | x6 << 1) & 1431655765;
    y6 = (y6 | y6 << 8) & 16711935;
    y6 = (y6 | y6 << 4) & 252645135;
    y6 = (y6 | y6 << 2) & 858993459;
    y6 = (y6 | y6 << 1) & 1431655765;
    return x6 | y6 << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    let p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a3, b4) {
    return a3.next.i !== b4.i && a3.prev.i !== b4.i && !intersectsPolygon(a3, b4) && (locallyInside(a3, b4) && locallyInside(b4, a3) && middleInside(a3, b4) && (area(a3.prev, a3, b4.prev) || area(a3, b4.prev, b4)) || equals(a3, b4) && area(a3.prev, a3, a3.next) > 0 && area(b4.prev, b4, b4.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r3) {
    return (q.y - p.y) * (r3.x - q.x) - (q.x - p.x) * (r3.y - q.y);
}
// check if two points are equal
function equals(p12, p22) {
    return p12.x === p22.x && p12.y === p22.y;
}
// check if two segments intersect
function intersects(p12, q1, p22, q2) {
    const o1 = sign(area(p12, q1, p22));
    const o2 = sign(area(p12, q1, q2));
    const o3 = sign(area(p22, q2, p12));
    const o4 = sign(area(p22, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p12, p22, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p12, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p22, p12, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p22, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r3) {
    return q.x <= Math.max(p.x, r3.x) && q.x >= Math.min(p.x, r3.x) && q.y <= Math.max(p.y, r3.y) && q.y >= Math.min(p.y, r3.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a3, b4) {
    let p = a3;
    do {
        if (p.i !== a3.i && p.next.i !== a3.i && p.i !== b4.i && p.next.i !== b4.i && intersects(p, p.next, a3, b4)) return true;
        p = p.next;
    }while (p !== a3)
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a3, b4) {
    return area(a3.prev, a3, a3.next) < 0 ? area(a3, b4, a3.next) >= 0 && area(a3, a3.prev, b4) >= 0 : area(a3, b4, a3.prev) < 0 || area(a3, a3.next, b4) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a3, b4) {
    let p = a3, inside = false;
    const px = (a3.x + b4.x) / 2, py = (a3.y + b4.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a3)
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a3, b4) {
    const a21 = new Node1(a3.i, a3.x, a3.y), b21 = new Node1(b4.i, b4.x, b4.y), an = a3.next, bp = b4.prev;
    a3.next = b4;
    b4.prev = a3;
    a21.next = an;
    an.prev = a21;
    b21.next = a21;
    a21.prev = b21;
    bp.next = b21;
    b21.prev = bp;
    return b21;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i4, x6, y6, last) {
    const p = new Node1(i4, x6, y6);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node1(i4, x6, y6) {
    // vertex index in coordinates array
    this.i = i4;
    // vertex coordinates
    this.x = x6;
    this.y = y6;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = null;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
function signedArea(data, start, end, dim) {
    let sum = 0;
    for(let i4 = start, j = end - dim; i4 < end; i4 += dim){
        sum += (data[j] - data[i4]) * (data[i4 + 1] + data[j + 1]);
        j = i4;
    }
    return sum;
}
const ShapeUtils = {
    // calculate area of the contour polygon
    area: function(contour) {
        const n = contour.length;
        let a3 = 0;
        for(let p = n - 1, q = 0; q < n; p = q++)a3 += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        return a3 * 0.5;
    },
    isClockWise: function(pts) {
        return ShapeUtils.area(pts) < 0;
    },
    triangulateShape: function(contour, holes) {
        const vertices7 = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        const holeIndices = []; // array of hole indices
        const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
        removeDupEndPts(contour);
        addContour(vertices7, contour);
        //
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for(let i4 = 0; i4 < holes.length; i4++){
            holeIndices.push(holeIndex);
            holeIndex += holes[i4].length;
            addContour(vertices7, holes[i4]);
        }
        //
        const triangles = Earcut.triangulate(vertices7, holeIndices);
        //
        for(let i5 = 0; i5 < triangles.length; i5 += 3)faces.push(triangles.slice(i5, i5 + 3));
        return faces;
    }
};
function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) points.pop();
}
function addContour(vertices7, contour) {
    for(let i4 = 0; i4 < contour.length; i4++){
        vertices7.push(contour[i4].x);
        vertices7.push(contour[i4].y);
    }
}
/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */ class ExtrudeGeometry extends BufferGeometry {
    constructor(shapes3, options3){
        super();
        this.type = 'ExtrudeGeometry';
        this.parameters = {
            shapes: shapes3,
            options: options3
        };
        shapes3 = Array.isArray(shapes3) ? shapes3 : [
            shapes3
        ];
        const scope2 = this;
        const verticesArray = [];
        const uvArray = [];
        for(let i4 = 0, l = shapes3.length; i4 < l; i4++){
            const shape = shapes3[i4];
            addShape1(shape);
        }
        // build geometry
        this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
        this.computeVertexNormals();
        // functions
        function addShape1(shape) {
            const placeholder = [];
            // options
            const curveSegments = options3.curveSegments !== undefined ? options3.curveSegments : 12;
            const steps = options3.steps !== undefined ? options3.steps : 1;
            let depth2 = options3.depth !== undefined ? options3.depth : 100;
            let bevelEnabled = options3.bevelEnabled !== undefined ? options3.bevelEnabled : true;
            let bevelThickness = options3.bevelThickness !== undefined ? options3.bevelThickness : 6;
            let bevelSize = options3.bevelSize !== undefined ? options3.bevelSize : bevelThickness - 2;
            let bevelOffset = options3.bevelOffset !== undefined ? options3.bevelOffset : 0;
            let bevelSegments = options3.bevelSegments !== undefined ? options3.bevelSegments : 3;
            const extrudePath = options3.extrudePath;
            const uvgen = options3.UVGenerator !== undefined ? options3.UVGenerator : WorldUVGenerator;
            // deprecated options
            if (options3.amount !== undefined) {
                console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
                depth2 = options3.amount;
            }
            //
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal3, position2;
            if (extrudePath) {
                extrudePts = extrudePath.getSpacedPoints(steps);
                extrudeByPath = true;
                bevelEnabled = false; // bevels not supported for path extrusion
                // SETUP TNB variables
                // TODO1 - have a .isClosed in spline?
                splineTube = extrudePath.computeFrenetFrames(steps, false);
                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
                binormal = new Vector3();
                normal3 = new Vector3();
                position2 = new Vector3();
            }
            // Safeguards if bevels are not enabled
            if (!bevelEnabled) {
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
                bevelOffset = 0;
            }
            // Variables initialization
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices7 = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !ShapeUtils.isClockWise(vertices7);
            if (reverse) {
                vertices7 = vertices7.reverse();
                // Maybe we should also check if holes are in the opposite direction, just to be safe ...
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    if (ShapeUtils.isClockWise(ahole)) holes[h] = ahole.reverse();
                }
            }
            const faces = ShapeUtils.triangulateShape(vertices7, holes);
            /* Vertices */ const contour = vertices7; // vertices has all points but contour has only points of circumference
            for(let h = 0, hl = holes.length; h < hl; h++){
                const ahole = holes[h];
                vertices7 = vertices7.concat(ahole);
            }
            function scalePt2(pt, vec, size1) {
                if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
                return vec.clone().multiplyScalar(size1).add(pt);
            }
            const vlen = vertices7.length, flen = faces.length;
            // Find directions for point movement
            function getBevelVec(inPt, inPrev, inNext) {
                // computes for inPt the corresponding point inPt' on a new contour
                //   shifted by 1 unit (length of normalized vector) to the left
                // if we walk along contour clockwise, this new contour is outside the old one
                //
                // inPt' is the intersection of the two lines parallel to the two
                //  adjacent edges of inPt at a distance of 1 unit on the left side.
                let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
                // good reading for geometry algorithms (here: line-line intersection)
                // http://geomalgorithms.com/a05-_intersect-1.html
                const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
                const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
                const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
                // check for collinear edges
                const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
                if (Math.abs(collinear0) > Number.EPSILON) {
                    // not collinear
                    // length of vectors for normalizing
                    const v_prev_len = Math.sqrt(v_prev_lensq);
                    const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                    // shift adjacent points by unit vectors to the left
                    const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                    const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                    const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                    const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                    // scaling factor for v_prev to intersection point
                    const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    // vector from inPt to intersection point
                    v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                    v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                    // Don't normalize!, otherwise sharp corners become ugly
                    //  but prevent crazy spikes
                    const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                    if (v_trans_lensq <= 2) return new Vector2(v_trans_x, v_trans_y);
                    else shrink_by = Math.sqrt(v_trans_lensq / 2);
                } else {
                    // handle special case of collinear edges
                    let direction_eq = false; // assumes: opposite
                    if (v_prev_x > Number.EPSILON) {
                        if (v_next_x > Number.EPSILON) direction_eq = true;
                    } else {
                        if (v_prev_x < -Number.EPSILON) {
                            if (v_next_x < -Number.EPSILON) direction_eq = true;
                        } else if (Math.sign(v_prev_y) === Math.sign(v_next_y)) direction_eq = true;
                    }
                    if (direction_eq) {
                        // console.log("Warning: lines are a straight sequence");
                        v_trans_x = -v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt(v_prev_lensq);
                    } else {
                        // console.log("Warning: lines are a straight spike");
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt(v_prev_lensq / 2);
                    }
                }
                return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for(let i5 = 0, il = contour.length, j = il - 1, k = i5 + 1; i5 < il; i5++, j++, k++){
                if (j === il) j = 0;
                if (k === il) k = 0;
                //  (j)---(i)---(k)
                // console.log('i,j,k', i, j , k)
                contourMovements[i5] = getBevelVec(contour[i5], contour[j], contour[k]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for(let h1 = 0, hl1 = holes.length; h1 < hl1; h1++){
                const ahole = holes[h1];
                oneHoleMovements = [];
                for(let i6 = 0, il1 = ahole.length, j1 = il1 - 1, k1 = i6 + 1; i6 < il1; i6++, j1++, k1++){
                    if (j1 === il1) j1 = 0;
                    if (k1 === il1) k1 = 0;
                    //  (j)---(i)---(k)
                    oneHoleMovements[i6] = getBevelVec(ahole[i6], ahole[j1], ahole[k1]);
                }
                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            // Loop bevelSegments, 1 for the front, 1 for the back
            for(let b4 = 0; b4 < bevelSegments; b4++){
                //for ( b = bevelSegments; b > 0; b -- ) {
                const t1 = b4 / bevelSegments;
                const z5 = bevelThickness * Math.cos(t1 * Math.PI / 2);
                const bs = bevelSize * Math.sin(t1 * Math.PI / 2) + bevelOffset;
                // contract shape
                for(let i6 = 0, il1 = contour.length; i6 < il1; i6++){
                    const vert = scalePt2(contour[i6], contourMovements[i6], bs);
                    v(vert.x, vert.y, -z5);
                }
                // expand holes
                for(let h2 = 0, hl2 = holes.length; h2 < hl2; h2++){
                    const ahole = holes[h2];
                    oneHoleMovements = holesMovements[h2];
                    for(let i7 = 0, il2 = ahole.length; i7 < il2; i7++){
                        const vert = scalePt2(ahole[i7], oneHoleMovements[i7], bs);
                        v(vert.x, vert.y, -z5);
                    }
                }
            }
            const bs = bevelSize + bevelOffset;
            // Back facing vertices
            for(let i6 = 0; i6 < vlen; i6++){
                const vert = bevelEnabled ? scalePt2(vertices7[i6], verticesMovements[i6], bs) : vertices7[i6];
                if (!extrudeByPath) v(vert.x, vert.y, 0);
                else {
                    // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
                    normal3.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[0]).add(normal3).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            // Add stepped vertices...
            // Including front facing vertices
            for(let s1 = 1; s1 <= steps; s1++)for(let i7 = 0; i7 < vlen; i7++){
                const vert = bevelEnabled ? scalePt2(vertices7[i7], verticesMovements[i7], bs) : vertices7[i7];
                if (!extrudeByPath) v(vert.x, vert.y, depth2 / steps * s1);
                else {
                    // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
                    normal3.copy(splineTube.normals[s1]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[s1]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[s1]).add(normal3).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            // Add bevel segments planes
            //for ( b = 1; b <= bevelSegments; b ++ ) {
            for(let b5 = bevelSegments - 1; b5 >= 0; b5--){
                const t1 = b5 / bevelSegments;
                const z5 = bevelThickness * Math.cos(t1 * Math.PI / 2);
                const bs1 = bevelSize * Math.sin(t1 * Math.PI / 2) + bevelOffset;
                // contract shape
                for(let i8 = 0, il1 = contour.length; i8 < il1; i8++){
                    const vert = scalePt2(contour[i8], contourMovements[i8], bs1);
                    v(vert.x, vert.y, depth2 + z5);
                }
                // expand holes
                for(let h2 = 0, hl2 = holes.length; h2 < hl2; h2++){
                    const ahole = holes[h2];
                    oneHoleMovements = holesMovements[h2];
                    for(let i9 = 0, il2 = ahole.length; i9 < il2; i9++){
                        const vert = scalePt2(ahole[i9], oneHoleMovements[i9], bs1);
                        if (!extrudeByPath) v(vert.x, vert.y, depth2 + z5);
                        else v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z5);
                    }
                }
            }
            /* Faces */ // Top and bottom faces
            buildLidFaces();
            // Sides faces
            buildSideFaces();
            /////  Internal functions
            function buildLidFaces() {
                const start = verticesArray.length / 3;
                if (bevelEnabled) {
                    let layer = 0; // steps + 1
                    let offset = vlen * layer;
                    // Bottom faces
                    for(let i8 = 0; i8 < flen; i8++){
                        const face = faces[i8];
                        f3(face[2] + offset, face[1] + offset, face[0] + offset);
                    }
                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;
                    // Top faces
                    for(let i9 = 0; i9 < flen; i9++){
                        const face = faces[i9];
                        f3(face[0] + offset, face[1] + offset, face[2] + offset);
                    }
                } else {
                    // Bottom faces
                    for(let i8 = 0; i8 < flen; i8++){
                        const face = faces[i8];
                        f3(face[2], face[1], face[0]);
                    }
                    // Top faces
                    for(let i9 = 0; i9 < flen; i9++){
                        const face = faces[i9];
                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                    }
                }
                scope2.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            // Create faces for the z-sides of the shape
            function buildSideFaces() {
                const start = verticesArray.length / 3;
                let layeroffset = 0;
                sidewalls(contour, layeroffset);
                layeroffset += contour.length;
                for(let h2 = 0, hl2 = holes.length; h2 < hl2; h2++){
                    const ahole = holes[h2];
                    sidewalls(ahole, layeroffset);
                    //, true
                    layeroffset += ahole.length;
                }
                scope2.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour1, layeroffset) {
                let i8 = contour1.length;
                while((--i8) >= 0){
                    const j1 = i8;
                    let k1 = i8 - 1;
                    if (k1 < 0) k1 = contour1.length - 1;
                    //console.log('b', i,j, i-1, k,vertices.length);
                    for(let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++){
                        const slen1 = vlen * s2;
                        const slen2 = vlen * (s2 + 1);
                        const a3 = layeroffset + j1 + slen1, b6 = layeroffset + k1 + slen1, c3 = layeroffset + k1 + slen2, d = layeroffset + j1 + slen2;
                        f4(a3, b6, c3, d);
                    }
                }
            }
            function v(x6, y6, z5) {
                placeholder.push(x6);
                placeholder.push(y6);
                placeholder.push(z5);
            }
            function f3(a3, b6, c3) {
                addVertex(a3);
                addVertex(b6);
                addVertex(c3);
                const nextIndex = verticesArray.length / 3;
                const uvs4 = uvgen.generateTopUV(scope2, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs4[0]);
                addUV(uvs4[1]);
                addUV(uvs4[2]);
            }
            function f4(a3, b6, c3, d) {
                addVertex(a3);
                addVertex(b6);
                addVertex(d);
                addVertex(b6);
                addVertex(c3);
                addVertex(d);
                const nextIndex = verticesArray.length / 3;
                const uvs4 = uvgen.generateSideWallUV(scope2, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs4[0]);
                addUV(uvs4[1]);
                addUV(uvs4[3]);
                addUV(uvs4[1]);
                addUV(uvs4[2]);
                addUV(uvs4[3]);
            }
            function addVertex(index1) {
                verticesArray.push(placeholder[index1 * 3 + 0]);
                verticesArray.push(placeholder[index1 * 3 + 1]);
                verticesArray.push(placeholder[index1 * 3 + 2]);
            }
            function addUV(vector2) {
                uvArray.push(vector2.x);
                uvArray.push(vector2.y);
            }
        }
    }
    toJSON() {
        const data = BufferGeometry.prototype.toJSON.call(this);
        const shapes1 = this.parameters.shapes;
        const options4 = this.parameters.options;
        return toJSON(shapes1, options4, data);
    }
}
const WorldUVGenerator = {
    generateTopUV: function(geometry1, vertices7, indexA, indexB, indexC) {
        const a_x = vertices7[indexA * 3];
        const a_y = vertices7[indexA * 3 + 1];
        const b_x = vertices7[indexB * 3];
        const b_y = vertices7[indexB * 3 + 1];
        const c_x = vertices7[indexC * 3];
        const c_y = vertices7[indexC * 3 + 1];
        return [
            new Vector2(a_x, a_y),
            new Vector2(b_x, b_y),
            new Vector2(c_x, c_y)
        ];
    },
    generateSideWallUV: function(geometry1, vertices7, indexA, indexB, indexC, indexD) {
        const a_x = vertices7[indexA * 3];
        const a_y = vertices7[indexA * 3 + 1];
        const a_z = vertices7[indexA * 3 + 2];
        const b_x = vertices7[indexB * 3];
        const b_y = vertices7[indexB * 3 + 1];
        const b_z = vertices7[indexB * 3 + 2];
        const c_x = vertices7[indexC * 3];
        const c_y = vertices7[indexC * 3 + 1];
        const c_z = vertices7[indexC * 3 + 2];
        const d_x = vertices7[indexD * 3];
        const d_y = vertices7[indexD * 3 + 1];
        const d_z = vertices7[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < 0.01) return [
            new Vector2(a_x, 1 - a_z),
            new Vector2(b_x, 1 - b_z),
            new Vector2(c_x, 1 - c_z),
            new Vector2(d_x, 1 - d_z)
        ];
        else return [
            new Vector2(a_y, 1 - a_z),
            new Vector2(b_y, 1 - b_z),
            new Vector2(c_y, 1 - c_z),
            new Vector2(d_y, 1 - d_z)
        ];
    }
};
function toJSON(shapes1, options4, data) {
    data.shapes = [];
    if (Array.isArray(shapes1)) for(let i5 = 0, l1 = shapes1.length; i5 < l1; i5++){
        const shape = shapes1[i5];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes1.uuid);
    if (options4.extrudePath !== undefined) data.options.extrudePath = options4.extrudePath.toJSON();
    return data;
}
class IcosahedronGeometry extends PolyhedronGeometry {
    constructor(radius6 = 1, detail2 = 0){
        const t1 = (1 + Math.sqrt(5)) / 2;
        const vertices7 = [
            -1,
            t1,
            0,
            1,
            t1,
            0,
            -1,
            -t1,
            0,
            1,
            -t1,
            0,
            0,
            -1,
            t1,
            0,
            1,
            t1,
            0,
            -1,
            -t1,
            0,
            1,
            -t1,
            t1,
            0,
            -1,
            t1,
            0,
            1,
            -t1,
            0,
            -1,
            -t1,
            0,
            1
        ];
        const indices6 = [
            0,
            11,
            5,
            0,
            5,
            1,
            0,
            1,
            7,
            0,
            7,
            10,
            0,
            10,
            11,
            1,
            5,
            9,
            5,
            11,
            4,
            11,
            10,
            2,
            10,
            7,
            6,
            7,
            1,
            8,
            3,
            9,
            4,
            3,
            4,
            2,
            3,
            2,
            6,
            3,
            6,
            8,
            3,
            8,
            9,
            4,
            9,
            5,
            2,
            4,
            11,
            6,
            2,
            10,
            8,
            6,
            7,
            9,
            8,
            1
        ];
        super(vertices7, indices6, radius6, detail2);
        this.type = 'IcosahedronGeometry';
        this.parameters = {
            radius: radius6,
            detail: detail2
        };
    }
}
class LatheGeometry extends BufferGeometry {
    constructor(points1, segments1 = 12, phiStart = 0, phiLength = Math.PI * 2){
        super();
        this.type = 'LatheGeometry';
        this.parameters = {
            points: points1,
            segments: segments1,
            phiStart: phiStart,
            phiLength: phiLength
        };
        segments1 = Math.floor(segments1);
        // clamp phiLength so it's in range of [ 0, 2PI ]
        phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);
        // buffers
        const indices7 = [];
        const vertices8 = [];
        const uvs4 = [];
        // helper variables
        const inverseSegments = 1 / segments1;
        const vertex1 = new Vector3();
        const uv1 = new Vector2();
        // generate vertices and uvs
        for(let i5 = 0; i5 <= segments1; i5++){
            const phi = phiStart + i5 * inverseSegments * phiLength;
            const sin = Math.sin(phi);
            const cos = Math.cos(phi);
            for(let j = 0; j <= points1.length - 1; j++){
                // vertex
                vertex1.x = points1[j].x * sin;
                vertex1.y = points1[j].y;
                vertex1.z = points1[j].x * cos;
                vertices8.push(vertex1.x, vertex1.y, vertex1.z);
                // uv
                uv1.x = i5 / segments1;
                uv1.y = j / (points1.length - 1);
                uvs4.push(uv1.x, uv1.y);
            }
        }
        // indices
        for(let i6 = 0; i6 < segments1; i6++)for(let j = 0; j < points1.length - 1; j++){
            const base = j + i6 * points1.length;
            const a3 = base;
            const b4 = base + points1.length;
            const c3 = base + points1.length + 1;
            const d = base + 1;
            // faces
            indices7.push(a3, b4, d);
            indices7.push(b4, c3, d);
        }
        // build geometry
        this.setIndex(indices7);
        this.setAttribute('position', new Float32BufferAttribute(vertices8, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs4, 2));
        // generate normals
        this.computeVertexNormals();
        // if the geometry is closed, we need to average the normals along the seam.
        // because the corresponding vertices are identical (but still have different UVs).
        if (phiLength === Math.PI * 2) {
            const normals4 = this.attributes.normal.array;
            const n1 = new Vector3();
            const n2 = new Vector3();
            const n = new Vector3();
            // this is the buffer offset for the last line of vertices
            const base = segments1 * points1.length * 3;
            for(let i7 = 0, j1 = 0; i7 < points1.length; i7++, j1 += 3){
                // select the normal of the vertex in the first line
                n1.x = normals4[j1 + 0];
                n1.y = normals4[j1 + 1];
                n1.z = normals4[j1 + 2];
                // select the normal of the vertex in the last line
                n2.x = normals4[base + j1 + 0];
                n2.y = normals4[base + j1 + 1];
                n2.z = normals4[base + j1 + 2];
                // average normals
                n.addVectors(n1, n2).normalize();
                // assign the new values to both normals
                normals4[j1 + 0] = normals4[base + j1 + 0] = n.x;
                normals4[j1 + 1] = normals4[base + j1 + 1] = n.y;
                normals4[j1 + 2] = normals4[base + j1 + 2] = n.z;
            }
        }
    }
}
class OctahedronGeometry extends PolyhedronGeometry {
    constructor(radius7 = 1, detail3 = 0){
        const vertices9 = [
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1
        ];
        const indices8 = [
            0,
            2,
            4,
            0,
            4,
            3,
            0,
            3,
            5,
            0,
            5,
            2,
            1,
            2,
            5,
            1,
            5,
            3,
            1,
            3,
            4,
            1,
            4,
            2
        ];
        super(vertices9, indices8, radius7, detail3);
        this.type = 'OctahedronGeometry';
        this.parameters = {
            radius: radius7,
            detail: detail3
        };
    }
}
/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */ function ParametricGeometry(func, slices, stacks) {
    BufferGeometry.call(this);
    this.type = 'ParametricGeometry';
    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };
    // buffers
    const indices9 = [];
    const vertices10 = [];
    const normals4 = [];
    const uvs5 = [];
    const EPS = 0.00001;
    const normal3 = new Vector3();
    const p02 = new Vector3(), p12 = new Vector3();
    const pu = new Vector3(), pv = new Vector3();
    if (func.length < 3) console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
    // generate vertices, normals and uvs
    const sliceCount = slices + 1;
    for(let i7 = 0; i7 <= stacks; i7++){
        const v = i7 / stacks;
        for(let j1 = 0; j1 <= slices; j1++){
            const u = j1 / slices;
            // vertex
            func(u, v, p02);
            vertices10.push(p02.x, p02.y, p02.z);
            // normal
            // approximate tangent vectors via finite differences
            if (u - EPS >= 0) {
                func(u - EPS, v, p12);
                pu.subVectors(p02, p12);
            } else {
                func(u + EPS, v, p12);
                pu.subVectors(p12, p02);
            }
            if (v - EPS >= 0) {
                func(u, v - EPS, p12);
                pv.subVectors(p02, p12);
            } else {
                func(u, v + EPS, p12);
                pv.subVectors(p12, p02);
            }
            // cross product of tangent vectors returns surface normal
            normal3.crossVectors(pu, pv).normalize();
            normals4.push(normal3.x, normal3.y, normal3.z);
            // uv
            uvs5.push(u, v);
        }
    }
    // generate indices
    for(let i8 = 0; i8 < stacks; i8++)for(let j1 = 0; j1 < slices; j1++){
        const a3 = i8 * sliceCount + j1;
        const b4 = i8 * sliceCount + j1 + 1;
        const c3 = (i8 + 1) * sliceCount + j1 + 1;
        const d = (i8 + 1) * sliceCount + j1;
        // faces one and two
        indices9.push(a3, b4, d);
        indices9.push(b4, c3, d);
    }
    // build geometry
    this.setIndex(indices9);
    this.setAttribute('position', new Float32BufferAttribute(vertices10, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals4, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs5, 2));
}
ParametricGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
class RingGeometry extends BufferGeometry {
    constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart3 = 0, thetaLength3 = Math.PI * 2){
        super();
        this.type = 'RingGeometry';
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart3,
            thetaLength: thetaLength3
        };
        thetaSegments = Math.max(3, thetaSegments);
        phiSegments = Math.max(1, phiSegments);
        // buffers
        const indices9 = [];
        const vertices10 = [];
        const normals4 = [];
        const uvs5 = [];
        // some helper variables
        let radius8 = innerRadius;
        const radiusStep = (outerRadius - innerRadius) / phiSegments;
        const vertex2 = new Vector3();
        const uv2 = new Vector2();
        // generate vertices, normals and uvs
        for(let j1 = 0; j1 <= phiSegments; j1++){
            for(let i7 = 0; i7 <= thetaSegments; i7++){
                // values are generate from the inside of the ring to the outside
                const segment = thetaStart3 + i7 / thetaSegments * thetaLength3;
                // vertex
                vertex2.x = radius8 * Math.cos(segment);
                vertex2.y = radius8 * Math.sin(segment);
                vertices10.push(vertex2.x, vertex2.y, vertex2.z);
                // normal
                normals4.push(0, 0, 1);
                // uv
                uv2.x = (vertex2.x / outerRadius + 1) / 2;
                uv2.y = (vertex2.y / outerRadius + 1) / 2;
                uvs5.push(uv2.x, uv2.y);
            }
            // increase the radius for next row of vertices
            radius8 += radiusStep;
        }
        // indices
        for(let j2 = 0; j2 < phiSegments; j2++){
            const thetaSegmentLevel = j2 * (thetaSegments + 1);
            for(let i7 = 0; i7 < thetaSegments; i7++){
                const segment = i7 + thetaSegmentLevel;
                const a3 = segment;
                const b4 = segment + thetaSegments + 1;
                const c3 = segment + thetaSegments + 2;
                const d = segment + 1;
                // faces
                indices9.push(a3, b4, d);
                indices9.push(b4, c3, d);
            }
        }
        // build geometry
        this.setIndex(indices9);
        this.setAttribute('position', new Float32BufferAttribute(vertices10, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals4, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs5, 2));
    }
}
class ShapeGeometry extends BufferGeometry {
    constructor(shapes1, curveSegments = 12){
        super();
        this.type = 'ShapeGeometry';
        this.parameters = {
            shapes: shapes1,
            curveSegments: curveSegments
        };
        // buffers
        const indices10 = [];
        const vertices11 = [];
        const normals5 = [];
        const uvs6 = [];
        // helper variables
        let groupStart2 = 0;
        let groupCount = 0;
        // allow single and array values for "shapes" parameter
        if (Array.isArray(shapes1) === false) addShape2(shapes1);
        else for(let i7 = 0; i7 < shapes1.length; i7++){
            addShape2(shapes1[i7]);
            this.addGroup(groupStart2, groupCount, i7); // enables MultiMaterial support
            groupStart2 += groupCount;
            groupCount = 0;
        }
        // build geometry
        this.setIndex(indices10);
        this.setAttribute('position', new Float32BufferAttribute(vertices11, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals5, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs6, 2));
        // helper functions
        function addShape2(shape) {
            const indexOffset = vertices11.length / 3;
            const points1 = shape.extractPoints(curveSegments);
            let shapeVertices = points1.shape;
            const shapeHoles = points1.holes;
            // check direction of vertices
            if (ShapeUtils.isClockWise(shapeVertices) === false) shapeVertices = shapeVertices.reverse();
            for(let i8 = 0, l1 = shapeHoles.length; i8 < l1; i8++){
                const shapeHole = shapeHoles[i8];
                if (ShapeUtils.isClockWise(shapeHole) === true) shapeHoles[i8] = shapeHole.reverse();
            }
            const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            // join vertices of inner and outer paths to a single array
            for(let i9 = 0, l2 = shapeHoles.length; i9 < l2; i9++){
                const shapeHole = shapeHoles[i9];
                shapeVertices = shapeVertices.concat(shapeHole);
            }
            // vertices, normals, uvs
            for(let i10 = 0, l3 = shapeVertices.length; i10 < l3; i10++){
                const vertex3 = shapeVertices[i10];
                vertices11.push(vertex3.x, vertex3.y, 0);
                normals5.push(0, 0, 1);
                uvs6.push(vertex3.x, vertex3.y); // world uvs
            }
            // incides
            for(let i11 = 0, l4 = faces.length; i11 < l4; i11++){
                const face = faces[i11];
                const a3 = face[0] + indexOffset;
                const b4 = face[1] + indexOffset;
                const c3 = face[2] + indexOffset;
                indices10.push(a3, b4, c3);
                groupCount += 3;
            }
        }
    }
    toJSON() {
        const data = BufferGeometry.prototype.toJSON.call(this);
        const shapes2 = this.parameters.shapes;
        return toJSON$1(shapes2, data);
    }
}
function toJSON$1(shapes2, data) {
    data.shapes = [];
    if (Array.isArray(shapes2)) for(let i8 = 0, l1 = shapes2.length; i8 < l1; i8++){
        const shape = shapes2[i8];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes2.uuid);
    return data;
}
class SphereGeometry extends BufferGeometry {
    constructor(radius9 = 1, widthSegments2 = 8, heightSegments4 = 6, phiStart1 = 0, phiLength1 = Math.PI * 2, thetaStart4 = 0, thetaLength4 = Math.PI){
        super();
        this.type = 'SphereGeometry';
        this.parameters = {
            radius: radius9,
            widthSegments: widthSegments2,
            heightSegments: heightSegments4,
            phiStart: phiStart1,
            phiLength: phiLength1,
            thetaStart: thetaStart4,
            thetaLength: thetaLength4
        };
        widthSegments2 = Math.max(3, Math.floor(widthSegments2));
        heightSegments4 = Math.max(2, Math.floor(heightSegments4));
        const thetaEnd = Math.min(thetaStart4 + thetaLength4, Math.PI);
        let index1 = 0;
        const grid = [];
        const vertex3 = new Vector3();
        const normal3 = new Vector3();
        // buffers
        const indices11 = [];
        const vertices12 = [];
        const normals6 = [];
        const uvs7 = [];
        // generate vertices, normals and uvs
        for(let iy2 = 0; iy2 <= heightSegments4; iy2++){
            const verticesRow = [];
            const v = iy2 / heightSegments4;
            // special case for the poles
            let uOffset = 0;
            if (iy2 == 0 && thetaStart4 == 0) uOffset = 0.5 / widthSegments2;
            else if (iy2 == heightSegments4 && thetaEnd == Math.PI) uOffset = -0.5 / widthSegments2;
            for(let ix1 = 0; ix1 <= widthSegments2; ix1++){
                const u = ix1 / widthSegments2;
                // vertex
                vertex3.x = -radius9 * Math.cos(phiStart1 + u * phiLength1) * Math.sin(thetaStart4 + v * thetaLength4);
                vertex3.y = radius9 * Math.cos(thetaStart4 + v * thetaLength4);
                vertex3.z = radius9 * Math.sin(phiStart1 + u * phiLength1) * Math.sin(thetaStart4 + v * thetaLength4);
                vertices12.push(vertex3.x, vertex3.y, vertex3.z);
                // normal
                normal3.copy(vertex3).normalize();
                normals6.push(normal3.x, normal3.y, normal3.z);
                // uv
                uvs7.push(u + uOffset, 1 - v);
                verticesRow.push(index1++);
            }
            grid.push(verticesRow);
        }
        // indices
        for(let iy3 = 0; iy3 < heightSegments4; iy3++)for(let ix1 = 0; ix1 < widthSegments2; ix1++){
            const a3 = grid[iy3][ix1 + 1];
            const b4 = grid[iy3][ix1];
            const c3 = grid[iy3 + 1][ix1];
            const d = grid[iy3 + 1][ix1 + 1];
            if (iy3 !== 0 || thetaStart4 > 0) indices11.push(a3, b4, d);
            if (iy3 !== heightSegments4 - 1 || thetaEnd < Math.PI) indices11.push(b4, c3, d);
        }
        // build geometry
        this.setIndex(indices11);
        this.setAttribute('position', new Float32BufferAttribute(vertices12, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals6, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs7, 2));
    }
}
class TetrahedronGeometry extends PolyhedronGeometry {
    constructor(radius10 = 1, detail4 = 0){
        const vertices13 = [
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            1,
            -1,
            -1
        ];
        const indices12 = [
            2,
            1,
            0,
            0,
            3,
            2,
            1,
            3,
            0,
            2,
            3,
            1
        ];
        super(vertices13, indices12, radius10, detail4);
        this.type = 'TetrahedronGeometry';
        this.parameters = {
            radius: radius10,
            detail: detail4
        };
    }
}
/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */ class TextGeometry extends ExtrudeGeometry {
    constructor(text1, parameters = {
    }){
        const font = parameters.font;
        if (!(font && font.isFont)) {
            console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
            return new BufferGeometry();
        }
        const shapes2 = font.generateShapes(text1, parameters.size);
        // translate parameters to ExtrudeGeometry API
        parameters.depth = parameters.height !== undefined ? parameters.height : 50;
        // defaults
        if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
        if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
        if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
        super(shapes2, parameters);
        this.type = 'TextGeometry';
    }
}
class TorusGeometry extends BufferGeometry {
    constructor(radius11 = 1, tube = 0.4, radialSegments2 = 8, tubularSegments = 6, arc = Math.PI * 2){
        super();
        this.type = 'TorusGeometry';
        this.parameters = {
            radius: radius11,
            tube: tube,
            radialSegments: radialSegments2,
            tubularSegments: tubularSegments,
            arc: arc
        };
        radialSegments2 = Math.floor(radialSegments2);
        tubularSegments = Math.floor(tubularSegments);
        // buffers
        const indices13 = [];
        const vertices14 = [];
        const normals7 = [];
        const uvs8 = [];
        // helper variables
        const center2 = new Vector3();
        const vertex4 = new Vector3();
        const normal4 = new Vector3();
        // generate vertices, normals and uvs
        for(let j3 = 0; j3 <= radialSegments2; j3++)for(let i8 = 0; i8 <= tubularSegments; i8++){
            const u = i8 / tubularSegments * arc;
            const v = j3 / radialSegments2 * Math.PI * 2;
            // vertex
            vertex4.x = (radius11 + tube * Math.cos(v)) * Math.cos(u);
            vertex4.y = (radius11 + tube * Math.cos(v)) * Math.sin(u);
            vertex4.z = tube * Math.sin(v);
            vertices14.push(vertex4.x, vertex4.y, vertex4.z);
            // normal
            center2.x = radius11 * Math.cos(u);
            center2.y = radius11 * Math.sin(u);
            normal4.subVectors(vertex4, center2).normalize();
            normals7.push(normal4.x, normal4.y, normal4.z);
            // uv
            uvs8.push(i8 / tubularSegments);
            uvs8.push(j3 / radialSegments2);
        }
        // generate indices
        for(let j4 = 1; j4 <= radialSegments2; j4++)for(let i9 = 1; i9 <= tubularSegments; i9++){
            // indices
            const a3 = (tubularSegments + 1) * j4 + i9 - 1;
            const b4 = (tubularSegments + 1) * (j4 - 1) + i9 - 1;
            const c3 = (tubularSegments + 1) * (j4 - 1) + i9;
            const d = (tubularSegments + 1) * j4 + i9;
            // faces
            indices13.push(a3, b4, d);
            indices13.push(b4, c3, d);
        }
        // build geometry
        this.setIndex(indices13);
        this.setAttribute('position', new Float32BufferAttribute(vertices14, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals7, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs8, 2));
    }
}
class TorusKnotGeometry extends BufferGeometry {
    constructor(radius12 = 1, tube1 = 0.4, tubularSegments1 = 64, radialSegments3 = 8, p = 2, q = 3){
        super();
        this.type = 'TorusKnotGeometry';
        this.parameters = {
            radius: radius12,
            tube: tube1,
            tubularSegments: tubularSegments1,
            radialSegments: radialSegments3,
            p: p,
            q: q
        };
        tubularSegments1 = Math.floor(tubularSegments1);
        radialSegments3 = Math.floor(radialSegments3);
        // buffers
        const indices14 = [];
        const vertices15 = [];
        const normals8 = [];
        const uvs9 = [];
        // helper variables
        const vertex5 = new Vector3();
        const normal5 = new Vector3();
        const P1 = new Vector3();
        const P2 = new Vector3();
        const B = new Vector3();
        const T = new Vector3();
        const N = new Vector3();
        // generate vertices, normals and uvs
        for(let i10 = 0; i10 <= tubularSegments1; ++i10){
            // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
            const u = i10 / tubularSegments1 * p * Math.PI * 2;
            // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
            // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
            calculatePositionOnCurve(u, p, q, radius12, P1);
            calculatePositionOnCurve(u + 0.01, p, q, radius12, P2);
            // calculate orthonormal basis
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            // normalize B, N. T can be ignored, we don't use it
            B.normalize();
            N.normalize();
            for(let j5 = 0; j5 <= radialSegments3; ++j5){
                // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
                const v = j5 / radialSegments3 * Math.PI * 2;
                const cx = -tube1 * Math.cos(v);
                const cy = tube1 * Math.sin(v);
                // now calculate the final vertex position.
                // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
                vertex5.x = P1.x + (cx * N.x + cy * B.x);
                vertex5.y = P1.y + (cx * N.y + cy * B.y);
                vertex5.z = P1.z + (cx * N.z + cy * B.z);
                vertices15.push(vertex5.x, vertex5.y, vertex5.z);
                // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
                normal5.subVectors(vertex5, P1).normalize();
                normals8.push(normal5.x, normal5.y, normal5.z);
                // uv
                uvs9.push(i10 / tubularSegments1);
                uvs9.push(j5 / radialSegments3);
            }
        }
        // generate indices
        for(let j5 = 1; j5 <= tubularSegments1; j5++)for(let i11 = 1; i11 <= radialSegments3; i11++){
            // indices
            const a3 = (radialSegments3 + 1) * (j5 - 1) + (i11 - 1);
            const b4 = (radialSegments3 + 1) * j5 + (i11 - 1);
            const c3 = (radialSegments3 + 1) * j5 + i11;
            const d = (radialSegments3 + 1) * (j5 - 1) + i11;
            // faces
            indices14.push(a3, b4, d);
            indices14.push(b4, c3, d);
        }
        // build geometry
        this.setIndex(indices14);
        this.setAttribute('position', new Float32BufferAttribute(vertices15, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals8, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs9, 2));
        // this function calculates the current position on the torus curve
        function calculatePositionOnCurve(u, p6, q1, radius13, position) {
            const cu = Math.cos(u);
            const su = Math.sin(u);
            const quOverP = q1 / p6 * u;
            const cs = Math.cos(quOverP);
            position.x = radius13 * (2 + cs) * 0.5 * cu;
            position.y = radius13 * (2 + cs) * su * 0.5;
            position.z = radius13 * Math.sin(quOverP) * 0.5;
        }
    }
}
class TubeGeometry extends BufferGeometry {
    constructor(path, tubularSegments2 = 64, radius13 = 1, radialSegments4 = 8, closed = false){
        super();
        this.type = 'TubeGeometry';
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments2,
            radius: radius13,
            radialSegments: radialSegments4,
            closed: closed
        };
        const frames = path.computeFrenetFrames(tubularSegments2, closed);
        // expose internals
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
        // helper variables
        const vertex6 = new Vector3();
        const normal6 = new Vector3();
        const uv3 = new Vector2();
        let P = new Vector3();
        // buffer
        const vertices16 = [];
        const normals9 = [];
        const uvs10 = [];
        const indices15 = [];
        // create buffer data
        generateBufferData();
        // build geometry
        this.setIndex(indices15);
        this.setAttribute('position', new Float32BufferAttribute(vertices16, 3));
        this.setAttribute('normal', new Float32BufferAttribute(normals9, 3));
        this.setAttribute('uv', new Float32BufferAttribute(uvs10, 2));
        // functions
        function generateBufferData() {
            for(let i12 = 0; i12 < tubularSegments2; i12++)generateSegment(i12);
            // if the geometry is not closed, generate the last row of vertices and normals
            // at the regular position on the given path
            //
            // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
            generateSegment(closed === false ? tubularSegments2 : 0);
            // uvs are generated in a separate function.
            // this makes it easy compute correct values for closed geometries
            generateUVs2();
            // finally create faces
            generateIndices();
        }
        function generateSegment(i12) {
            // we use getPointAt to sample evenly distributed points from the given path
            P = path.getPointAt(i12 / tubularSegments2, P);
            // retrieve corresponding normal and binormal
            const N1 = frames.normals[i12];
            const B1 = frames.binormals[i12];
            // generate normals and vertices for the current segment
            for(let j6 = 0; j6 <= radialSegments4; j6++){
                const v = j6 / radialSegments4 * Math.PI * 2;
                const sin = Math.sin(v);
                const cos = -Math.cos(v);
                // normal
                normal6.x = cos * N1.x + sin * B1.x;
                normal6.y = cos * N1.y + sin * B1.y;
                normal6.z = cos * N1.z + sin * B1.z;
                normal6.normalize();
                normals9.push(normal6.x, normal6.y, normal6.z);
                // vertex
                vertex6.x = P.x + radius13 * normal6.x;
                vertex6.y = P.y + radius13 * normal6.y;
                vertex6.z = P.z + radius13 * normal6.z;
                vertices16.push(vertex6.x, vertex6.y, vertex6.z);
            }
        }
        function generateIndices() {
            for(let j6 = 1; j6 <= tubularSegments2; j6++)for(let i12 = 1; i12 <= radialSegments4; i12++){
                const a3 = (radialSegments4 + 1) * (j6 - 1) + (i12 - 1);
                const b4 = (radialSegments4 + 1) * j6 + (i12 - 1);
                const c3 = (radialSegments4 + 1) * j6 + i12;
                const d = (radialSegments4 + 1) * (j6 - 1) + i12;
                // faces
                indices15.push(a3, b4, d);
                indices15.push(b4, c3, d);
            }
        }
        function generateUVs2() {
            for(let i12 = 0; i12 <= tubularSegments2; i12++)for(let j6 = 0; j6 <= radialSegments4; j6++){
                uv3.x = i12 / tubularSegments2;
                uv3.y = j6 / radialSegments4;
                uvs10.push(uv3.x, uv3.y);
            }
        }
    }
    toJSON() {
        const data = BufferGeometry.prototype.toJSON.call(this);
        data.path = this.parameters.path.toJSON();
        return data;
    }
}
class WireframeGeometry extends BufferGeometry {
    constructor(geometry1){
        super();
        this.type = 'WireframeGeometry';
        if (geometry1.isGeometry === true) {
            console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
            return;
        }
        // buffer
        const vertices17 = [];
        // helper variables
        const edge = [
            0,
            0
        ], edges = {
        };
        const vertex7 = new Vector3();
        if (geometry1.index !== null) {
            // indexed BufferGeometry
            const position = geometry1.attributes.position;
            const indices16 = geometry1.index;
            let groups = geometry1.groups;
            if (groups.length === 0) groups = [
                {
                    start: 0,
                    count: indices16.count,
                    materialIndex: 0
                }
            ];
            // create a data structure that contains all eges without duplicates
            for(let o = 0, ol = groups.length; o < ol; ++o){
                const group = groups[o];
                const start = group.start;
                const count = group.count;
                for(let i12 = start, l1 = start + count; i12 < l1; i12 += 3)for(let j6 = 0; j6 < 3; j6++){
                    const edge1 = indices16.getX(i12 + j6);
                    const edge2 = indices16.getX(i12 + (j6 + 1) % 3);
                    edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                    edge[1] = Math.max(edge1, edge2);
                    const key1 = edge[0] + ',' + edge[1];
                    if (edges[key1] === undefined) edges[key1] = {
                        index1: edge[0],
                        index2: edge[1]
                    };
                }
            }
            // generate vertices
            for(const key1 in edges){
                const e = edges[key1];
                vertex7.fromBufferAttribute(position, e.index1);
                vertices17.push(vertex7.x, vertex7.y, vertex7.z);
                vertex7.fromBufferAttribute(position, e.index2);
                vertices17.push(vertex7.x, vertex7.y, vertex7.z);
            }
        } else {
            // non-indexed BufferGeometry
            const position = geometry1.attributes.position;
            for(let i12 = 0, l1 = position.count / 3; i12 < l1; i12++)for(let j6 = 0; j6 < 3; j6++){
                // three edges per triangle, an edge is represented as (index1, index2)
                // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
                const index11 = 3 * i12 + j6;
                vertex7.fromBufferAttribute(position, index11);
                vertices17.push(vertex7.x, vertex7.y, vertex7.z);
                const index2 = 3 * i12 + (j6 + 1) % 3;
                vertex7.fromBufferAttribute(position, index2);
                vertices17.push(vertex7.x, vertex7.y, vertex7.z);
            }
        }
        // build geometry
        this.setAttribute('position', new Float32BufferAttribute(vertices17, 3));
    }
}
var Geometries = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    BoxGeometry: BoxGeometry,
    BoxBufferGeometry: BoxGeometry,
    CircleGeometry: CircleGeometry,
    CircleBufferGeometry: CircleGeometry,
    ConeGeometry: ConeGeometry,
    ConeBufferGeometry: ConeGeometry,
    CylinderGeometry: CylinderGeometry,
    CylinderBufferGeometry: CylinderGeometry,
    DodecahedronGeometry: DodecahedronGeometry,
    DodecahedronBufferGeometry: DodecahedronGeometry,
    EdgesGeometry: EdgesGeometry,
    ExtrudeGeometry: ExtrudeGeometry,
    ExtrudeBufferGeometry: ExtrudeGeometry,
    IcosahedronGeometry: IcosahedronGeometry,
    IcosahedronBufferGeometry: IcosahedronGeometry,
    LatheGeometry: LatheGeometry,
    LatheBufferGeometry: LatheGeometry,
    OctahedronGeometry: OctahedronGeometry,
    OctahedronBufferGeometry: OctahedronGeometry,
    ParametricGeometry: ParametricGeometry,
    ParametricBufferGeometry: ParametricGeometry,
    PlaneGeometry: PlaneGeometry,
    PlaneBufferGeometry: PlaneGeometry,
    PolyhedronGeometry: PolyhedronGeometry,
    PolyhedronBufferGeometry: PolyhedronGeometry,
    RingGeometry: RingGeometry,
    RingBufferGeometry: RingGeometry,
    ShapeGeometry: ShapeGeometry,
    ShapeBufferGeometry: ShapeGeometry,
    SphereGeometry: SphereGeometry,
    SphereBufferGeometry: SphereGeometry,
    TetrahedronGeometry: TetrahedronGeometry,
    TetrahedronBufferGeometry: TetrahedronGeometry,
    TextGeometry: TextGeometry,
    TextBufferGeometry: TextGeometry,
    TorusGeometry: TorusGeometry,
    TorusBufferGeometry: TorusGeometry,
    TorusKnotGeometry: TorusKnotGeometry,
    TorusKnotBufferGeometry: TorusKnotGeometry,
    TubeGeometry: TubeGeometry,
    TubeBufferGeometry: TubeGeometry,
    WireframeGeometry: WireframeGeometry
});
/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */ function ShadowMaterial(parameters1) {
    Material.call(this);
    this.type = 'ShadowMaterial';
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters1);
}
ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;
ShadowMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    return this;
};
function RawShaderMaterial(parameters1) {
    ShaderMaterial.call(this, parameters1);
    this.type = 'RawShaderMaterial';
}
RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshStandardMaterial(parameters1) {
    Material.call(this);
    this.defines = {
        'STANDARD': ''
    };
    this.type = 'MeshStandardMaterial';
    this.color = new Color(16777215); // diffuse
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.vertexTangents = false;
    this.setValues(parameters1);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = {
        'STANDARD': ''
    };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.vertexTangents = source.vertexTangents;
    return this;
};
/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *  ior: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> )
 * }
 */ function MeshPhysicalMaterial(parameters1) {
    MeshStandardMaterial.call(this);
    this.defines = {
        'STANDARD': '',
        'PHYSICAL': ''
    };
    this.type = 'MeshPhysicalMaterial';
    this.clearcoat = 0;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.reflectivity = 0.5; // maps to F0 = 0.04
    Object.defineProperty(this, 'ior', {
        get: function() {
            return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
        },
        set: function(ior) {
            this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
        }
    });
    this.sheen = null; // null will disable sheen bsdf
    this.transmission = 0;
    this.transmissionMap = null;
    this.setValues(parameters1);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
    MeshStandardMaterial.prototype.copy.call(this, source);
    this.defines = {
        'STANDARD': '',
        'PHYSICAL': ''
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.reflectivity = source.reflectivity;
    if (source.sheen) this.sheen = (this.sheen || new Color()).copy(source.sheen);
    else this.sheen = null;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshPhongMaterial(parameters1) {
    Material.call(this);
    this.type = 'MeshPhongMaterial';
    this.color = new Color(16777215); // diffuse
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters1);
}
MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshToonMaterial(parameters1) {
    Material.call(this);
    this.defines = {
        'TOON': ''
    };
    this.type = 'MeshToonMaterial';
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters1);
}
MeshToonMaterial.prototype = Object.create(Material.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;
MeshToonMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshNormalMaterial(parameters1) {
    Material.call(this);
    this.type = 'MeshNormalMaterial';
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters1);
}
MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
MeshNormalMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshLambertMaterial(parameters1) {
    Material.call(this);
    this.type = 'MeshLambertMaterial';
    this.color = new Color(16777215); // diffuse
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters1);
}
MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
MeshLambertMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ function MeshMatcapMaterial(parameters1) {
    Material.call(this);
    this.defines = {
        'MATCAP': ''
    };
    this.type = 'MeshMatcapMaterial';
    this.color = new Color(16777215); // diffuse
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters1);
}
MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
MeshMatcapMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = {
        'MATCAP': ''
    };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */ function LineDashedMaterial(parameters1) {
    LineBasicMaterial.call(this);
    this.type = 'LineDashedMaterial';
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters1);
}
LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
LineDashedMaterial.prototype.copy = function(source) {
    LineBasicMaterial.prototype.copy.call(this, source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
};
var Materials = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ShadowMaterial: ShadowMaterial,
    SpriteMaterial: SpriteMaterial,
    RawShaderMaterial: RawShaderMaterial,
    ShaderMaterial: ShaderMaterial,
    PointsMaterial: PointsMaterial,
    MeshPhysicalMaterial: MeshPhysicalMaterial,
    MeshStandardMaterial: MeshStandardMaterial,
    MeshPhongMaterial: MeshPhongMaterial,
    MeshToonMaterial: MeshToonMaterial,
    MeshNormalMaterial: MeshNormalMaterial,
    MeshLambertMaterial: MeshLambertMaterial,
    MeshDepthMaterial: MeshDepthMaterial,
    MeshDistanceMaterial: MeshDistanceMaterial,
    MeshBasicMaterial: MeshBasicMaterial,
    MeshMatcapMaterial: MeshMatcapMaterial,
    LineDashedMaterial: LineDashedMaterial,
    LineBasicMaterial: LineBasicMaterial,
    Material: Material
});
const AnimationUtils = {
    // same as Array.prototype.slice, but also works on typed arrays
    arraySlice: function(array, from, to) {
        if (AnimationUtils.isTypedArray(array)) // in ios9 array.subarray(from, undefined) will return empty array
        // but array.subarray(from) or array.subarray(from, len) is correct
        return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
        return array.slice(from, to);
    },
    // converts an array to a specific type
    convertArray: function(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type) return array;
        if (typeof type.BYTES_PER_ELEMENT === 'number') return new type(array); // create typed array
        return Array.prototype.slice.call(array); // create Array
    },
    isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    // returns an array by which times and values can be sorted
    getKeyframeOrder: function(times) {
        function compareTime(i12, j6) {
            return times[i12] - times[j6];
        }
        const n = times.length;
        const result = new Array(n);
        for(let i12 = 0; i12 !== n; ++i12)result[i12] = i12;
        result.sort(compareTime);
        return result;
    },
    // uses the array previously returned by 'getKeyframeOrder' to sort data
    sortedArray: function(values, stride, order2) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for(let i12 = 0, dstOffset = 0; dstOffset !== nValues; ++i12){
            const srcOffset = order2[i12] * stride;
            for(let j6 = 0; j6 !== stride; ++j6)result[dstOffset++] = values[srcOffset + j6];
        }
        return result;
    },
    // function for parsing AOS keyframe formats
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i12 = 1, key1 = jsonKeys[0];
        while(key1 !== undefined && key1[valuePropertyName] === undefined)key1 = jsonKeys[i12++];
        if (key1 === undefined) return; // no data
        let value = key1[valuePropertyName];
        if (value === undefined) return; // no data
        if (Array.isArray(value)) do {
            value = key1[valuePropertyName];
            if (value !== undefined) {
                times.push(key1.time);
                values.push.apply(values, value); // push all elements
            }
            key1 = jsonKeys[i12++];
        }while (key1 !== undefined)
        else if (value.toArray !== undefined) // ...assume THREE.Math-ish
        do {
            value = key1[valuePropertyName];
            if (value !== undefined) {
                times.push(key1.time);
                value.toArray(values, values.length);
            }
            key1 = jsonKeys[i12++];
        }while (key1 !== undefined)
        else // otherwise push as-is
        do {
            value = key1[valuePropertyName];
            if (value !== undefined) {
                times.push(key1.time);
                values.push(value);
            }
            key1 = jsonKeys[i12++];
        }while (key1 !== undefined)
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for(let i12 = 0; i12 < clip.tracks.length; ++i12){
            const track = clip.tracks[i12];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for(let j6 = 0; j6 < track.times.length; ++j6){
                const frame = track.times[j6] * fps;
                if (frame < startFrame || frame >= endFrame) continue;
                times.push(track.times[j6]);
                for(let k = 0; k < valueSize; ++k)values.push(track.values[j6 * valueSize + k]);
            }
            if (times.length === 0) continue;
            track.times = AnimationUtils.convertArray(times, track.times.constructor);
            track.values = AnimationUtils.convertArray(values, track.values.constructor);
            tracks.push(track);
        }
        clip.tracks = tracks;
        // find minimum .times value across all tracks in the trimmed clip
        let minStartTime = Infinity;
        for(let i13 = 0; i13 < clip.tracks.length; ++i13)if (minStartTime > clip.tracks[i13].times[0]) minStartTime = clip.tracks[i13].times[0];
        // shift all tracks such that clip begins at t=0
        for(let i14 = 0; i14 < clip.tracks.length; ++i14)clip.tracks[i14].shift(-1 * minStartTime);
        clip.resetDuration();
        return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
        if (fps <= 0) fps = 30;
        const numTracks = referenceClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        // Make each track's values relative to the values at the reference frame
        for(let i12 = 0; i12 < numTracks; ++i12){
            const referenceTrack = referenceClip.tracks[i12];
            const referenceTrackType = referenceTrack.ValueTypeName;
            // Skip this track if it's non-numeric
            if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;
            // Find the track in the target clip whose name and type matches the reference track
            const targetTrack = targetClip.tracks.find(function(track) {
                return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === undefined) continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) referenceOffset = referenceValueSize / 3;
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) targetOffset = targetValueSize / 3;
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            // Find the value to subtract out of the track
            if (referenceTime <= referenceTrack.times[0]) {
                // Reference frame is earlier than the first keyframe, so just use the first keyframe
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                // Reference frame is after the last keyframe, so just use the last keyframe
                const startIndex = lastIndex * referenceValueSize + referenceOffset;
                const endIndex = startIndex + referenceValueSize - referenceOffset;
                referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else {
                // Interpolate to the reference value
                const interpolant = referenceTrack.createInterpolant();
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                interpolant.evaluate(referenceTime);
                referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
            }
            // Conjugate the quaternion
            if (referenceTrackType === 'quaternion') {
                const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
                referenceQuat.toArray(referenceValue);
            }
            // Subtract the reference value from all of the track values
            const numTimes = targetTrack.times.length;
            for(let j6 = 0; j6 < numTimes; ++j6){
                const valueStart = j6 * targetValueSize + targetOffset;
                if (referenceTrackType === 'quaternion') // Multiply the conjugate for quaternion track types
                Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                else {
                    const valueEnd = targetValueSize - targetOffset * 2;
                    // Subtract each value for all other numeric track types
                    for(let k = 0; k < valueEnd; ++k)targetTrack.values[valueStart + k] -= referenceValue[k];
                }
            }
        }
        targetClip.blendMode = AdditiveAnimationBlendMode;
        return targetClip;
    }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */ function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
    evaluate: function(t2) {
        const pp = this.parameterPositions;
        let i12 = this._cachedIndex, t11 = pp[i12], t0 = pp[i12 - 1];
        validate_interval: {
            seek: {
                let right;
                linear_scan: {
                    //- See http://jsperf.com/comparison-to-undefined/3
                    //- slower code:
                    //-
                    //- 				if ( t >= t1 || t1 === undefined ) {
                    forward_scan: if (!(t2 < t11)) {
                        for(let giveUpAt = i12 + 2;;){
                            if (t11 === undefined) {
                                if (t2 < t0) break forward_scan;
                                // after end
                                i12 = pp.length;
                                this._cachedIndex = i12;
                                return this.afterEnd_(i12 - 1, t2, t0);
                            }
                            if (i12 === giveUpAt) break; // this loop
                            t0 = t11;
                            t11 = pp[++i12];
                            if (t2 < t11) break seek;
                        }
                        // prepare binary search on the right side of the index
                        right = pp.length;
                        break linear_scan;
                    }
                    //- slower code:
                    //-					if ( t < t0 || t0 === undefined ) {
                    if (!(t2 >= t0)) {
                        // looping?
                        const t1global = pp[1];
                        if (t2 < t1global) {
                            i12 = 2; // + 1, using the scan for the details
                            t0 = t1global;
                        }
                        // linear reverse scan
                        for(let giveUpAt = i12 - 2;;){
                            if (t0 === undefined) {
                                // before start
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t2, t11);
                            }
                            if (i12 === giveUpAt) break; // this loop
                            t11 = t0;
                            t0 = pp[(--i12) - 1];
                            if (t2 >= t0) break seek;
                        }
                        // prepare binary search on the left side of the index
                        right = i12;
                        i12 = 0;
                        break linear_scan;
                    }
                    break validate_interval;
                } // linear scan
                // binary search
                while(i12 < right){
                    const mid = i12 + right >>> 1;
                    if (t2 < pp[mid]) right = mid;
                    else i12 = mid + 1;
                }
                t11 = pp[i12];
                t0 = pp[i12 - 1];
                // check boundary cases, again
                if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t2, t11);
                }
                if (t11 === undefined) {
                    i12 = pp.length;
                    this._cachedIndex = i12;
                    return this.afterEnd_(i12 - 1, t0, t2);
                }
            } // seek
            this._cachedIndex = i12;
            this.intervalChanged_(i12, t0, t11);
        } // validate_interval
        return this.interpolate_(i12, t0, t2, t11);
    },
    settings: null,
    // Note: The indirection allows central control of many interpolants.
    // --- Protected interface
    DefaultSettings_: {
    },
    getSettings_: function() {
        return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(index2) {
        // copies a sample value to the result buffer
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index2 * stride;
        for(let i12 = 0; i12 !== stride; ++i12)result[i12] = values[offset + i12];
        return result;
    },
    // Template methods for derived classes:
    interpolate_: function() {
        throw new Error('call to abstract method');
    // implementations shall return this.resultBuffer
    },
    intervalChanged_: function() {
    // empty
    }
});
// DECLARE ALIAS AFTER assign prototype
Object.assign(Interpolant.prototype, {
    //( 0, t, t0 ), returns this.resultBuffer
    beforeStart_: Interpolant.prototype.copySampleValue_,
    //( N-1, tN-1, t ), returns this.resultBuffer
    afterEnd_: Interpolant.prototype.copySampleValue_
});
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */ function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: CubicInterpolant,
    DefaultSettings_: {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function(i12, t0, t11) {
        const pp = this.parameterPositions;
        let iPrev = i12 - 2, iNext = i12 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === undefined) switch(this.getSettings_().endingStart){
            case ZeroSlopeEnding:
                // f'(t0) = 0
                iPrev = i12;
                tPrev = 2 * t0 - t11;
                break;
            case WrapAroundEnding:
                // use the other end of the curve
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
            default:
                // f''(t0) = 0 a.k.a. Natural Spline
                iPrev = i12;
                tPrev = t11;
        }
        if (tNext === undefined) switch(this.getSettings_().endingEnd){
            case ZeroSlopeEnding:
                // f'(tN) = 0
                iNext = i12;
                tNext = 2 * t11 - t0;
                break;
            case WrapAroundEnding:
                // use the other end of the curve
                iNext = 1;
                tNext = t11 + pp[1] - pp[0];
                break;
            default:
                // f''(tN) = 0, a.k.a. Natural Spline
                iNext = i12 - 1;
                tNext = t0;
        }
        const halfDt = (t11 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t11);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
    },
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i12 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p6 = (t2 - t0) / (t11 - t0), pp = p6 * p6, ppp = pp * p6;
        // evaluate polynomials
        const sP = -wP * ppp + 2 * wP * pp - wP * p6;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p6 + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p6;
        const sN = wN * ppp - wN * pp;
        // combine data linearly
        for(let i13 = 0; i13 !== stride; ++i13)result[i13] = sP * values[oP + i13] + s0 * values[o0 + i13] + s1 * values[o1 + i13] + sN * values[oN + i13];
        return result;
    }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: LinearInterpolant,
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i12 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t11 - t0), weight0 = 1 - weight1;
        for(let i13 = 0; i13 !== stride; ++i13)result[i13] = values[offset0 + i13] * weight0 + values[offset1 + i13] * weight1;
        return result;
    }
});
/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */ function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: DiscreteInterpolant,
    interpolate_: function(i12/*, t0, t, t1 */ ) {
        return this.copySampleValue_(i12 - 1);
    }
});
function KeyframeTrack(name, times, values, interpolation) {
    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
}
// Static methods
Object.assign(KeyframeTrack, {
    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    toJSON: function(track) {
        const trackType = track.constructor;
        let json;
        // derived classes can define a static toJSON method
        if (trackType.toJSON !== undefined) json = trackType.toJSON(track);
        else {
            // by default, we assume the data can be serialized as-is
            json = {
                'name': track.name,
                'times': AnimationUtils.convertArray(track.times, Array),
                'values': AnimationUtils.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) json.interpolation = interpolation;
        }
        json.type = track.ValueTypeName; // mandatory
        return json;
    }
});
Object.assign(KeyframeTrack.prototype, {
    constructor: KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodLinear: function(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: function(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    setInterpolation: function(interpolation) {
        let factoryMethod;
        switch(interpolation){
            case InterpolateDiscrete:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;
            case InterpolateLinear:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;
            case InterpolateSmooth:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (factoryMethod === undefined) {
            const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
            if (this.createInterpolant === undefined) {
                // fall back to default, unless the default itself is messed up
                if (interpolation !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(message); // fatal, in this case
            }
            console.warn('THREE.KeyframeTrack:', message);
            return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
    },
    getInterpolation: function() {
        switch(this.createInterpolant){
            case this.InterpolantFactoryMethodDiscrete:
                return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
                return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
                return InterpolateSmooth;
        }
    },
    getValueSize: function() {
        return this.values.length / this.times.length;
    },
    // move all keyframes either forwards or backwards in time
    shift: function(timeOffset) {
        if (timeOffset !== 0) {
            const times = this.times;
            for(let i12 = 0, n = times.length; i12 !== n; ++i12)times[i12] += timeOffset;
        }
        return this;
    },
    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale: function(timeScale) {
        if (timeScale !== 1) {
            const times = this.times;
            for(let i12 = 0, n = times.length; i12 !== n; ++i12)times[i12] *= timeScale;
        }
        return this;
    },
    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim: function(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from = 0, to = nKeys - 1;
        while(from !== nKeys && times[from] < startTime)++from;
        while(to !== -1 && times[to] > endTime)--to;
        ++to; // inclusive -> exclusive bound
        if (from !== 0 || to !== nKeys) {
            // empty tracks are forbidden, so keep at least one keyframe
            if (from >= to) {
                to = Math.max(to, 1);
                from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = AnimationUtils.arraySlice(times, from, to);
            this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
    },
    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    validate: function() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
            console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
            valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
            console.error('THREE.KeyframeTrack: Track is empty.', this);
            valid = false;
        }
        let prevTime = null;
        for(let i12 = 0; i12 !== nKeys; i12++){
            const currTime = times[i12];
            if (typeof currTime === 'number' && isNaN(currTime)) {
                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i12, currTime);
                valid = false;
                break;
            }
            if (prevTime !== null && prevTime > currTime) {
                console.error('THREE.KeyframeTrack: Out of order keys.', this, i12, currTime, prevTime);
                valid = false;
                break;
            }
            prevTime = currTime;
        }
        if (values !== undefined) {
            if (AnimationUtils.isTypedArray(values)) for(let i13 = 0, n = values.length; i13 !== n; ++i13){
                const value = values[i13];
                if (isNaN(value)) {
                    console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i13, value);
                    valid = false;
                    break;
                }
            }
        }
        return valid;
    },
    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    optimize: function() {
        // times or values may be shared with other tracks, so overwriting is unsafe
        const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
        let writeIndex = 1;
        for(let i12 = 1; i12 < lastIndex; ++i12){
            let keep = false;
            const time = times[i12];
            const timeNext = times[i12 + 1];
            // remove adjacent keyframes scheduled at the same time
            if (time !== timeNext && (i12 !== 1 || time !== times[0])) {
                if (!smoothInterpolation) {
                    // remove unnecessary keyframes same as their neighbors
                    const offset = i12 * stride, offsetP = offset - stride, offsetN = offset + stride;
                    for(let j6 = 0; j6 !== stride; ++j6){
                        const value = values[offset + j6];
                        if (value !== values[offsetP + j6] || value !== values[offsetN + j6]) {
                            keep = true;
                            break;
                        }
                    }
                } else keep = true;
            }
            // in-place compaction
            if (keep) {
                if (i12 !== writeIndex) {
                    times[writeIndex] = times[i12];
                    const readOffset = i12 * stride, writeOffset = writeIndex * stride;
                    for(let j6 = 0; j6 !== stride; ++j6)values[writeOffset + j6] = values[readOffset + j6];
                }
                ++writeIndex;
            }
        }
        // flush last keyframe (compaction looks ahead)
        if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for(let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j6 = 0; j6 !== stride; ++j6)values[writeOffset + j6] = values[readOffset + j6];
            ++writeIndex;
        }
        if (writeIndex !== times.length) {
            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        } else {
            this.times = times;
            this.values = values;
        }
        return this;
    },
    clone: function() {
        const times = AnimationUtils.arraySlice(this.times, 0);
        const values = AnimationUtils.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        // Interpolant argument to constructor is not saved, so copy the factory method directly.
        track.createInterpolant = this.createInterpolant;
        return track;
    }
});
/**
 * A Track of Boolean keyframe values.
 */ function BooleanKeyframeTrack(name, times, values) {
    KeyframeTrack.call(this, name, times, values);
}
BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: BooleanKeyframeTrack,
    ValueTypeName: 'bool',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
/**
 * A Track of keyframe values that represent color.
 */ function ColorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: ColorKeyframeTrack,
    ValueTypeName: 'color'
});
/**
 * A Track of numeric keyframe values.
 */ function NumberKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: NumberKeyframeTrack,
    ValueTypeName: 'number'
});
/**
 * Spherical linear unit quaternion interpolant.
 */ function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: QuaternionLinearInterpolant,
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t11 - t0);
        let offset = i12 * stride;
        for(let end = offset + stride; offset !== end; offset += 4)Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        return result;
    }
});
/**
 * A Track of quaternion keyframe values.
 */ function QuaternionKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: QuaternionKeyframeTrack,
    ValueTypeName: 'quaternion',
    // ValueBufferType is inherited
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodLinear: function(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: undefined
});
/**
 * A Track that interpolates Strings
 */ function StringKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: StringKeyframeTrack,
    ValueTypeName: 'string',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
/**
 * A Track of vectored keyframe values.
 */ function VectorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
}
VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: VectorKeyframeTrack,
    ValueTypeName: 'vector'
});
function AnimationClip(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = MathUtils.generateUUID();
    // this means it should figure out its duration by scanning the tracks
    if (this.duration < 0) this.resetDuration();
}
function getTrackTypeForValueTypeName(typeName) {
    switch(typeName.toLowerCase()){
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
            return NumberKeyframeTrack;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
            return VectorKeyframeTrack;
        case 'color':
            return ColorKeyframeTrack;
        case 'quaternion':
            return QuaternionKeyframeTrack;
        case 'bool':
        case 'boolean':
            return BooleanKeyframeTrack;
        case 'string':
            return StringKeyframeTrack;
    }
    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}
function parseKeyframeTrack(json) {
    if (json.type === undefined) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === undefined) {
        const times = [], values = [];
        AnimationUtils.flattenJSON(json.keys, times, values, 'value');
        json.times = times;
        json.values = values;
    }
    // derived classes can define a static parse method
    if (trackType.parse !== undefined) return trackType.parse(json);
    else // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
}
Object.assign(AnimationClip, {
    parse: function(json) {
        const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for(let i12 = 0, n = jsonTracks.length; i12 !== n; ++i12)tracks.push(parseKeyframeTrack(jsonTracks[i12]).scale(frameTime));
        const clip = new AnimationClip(json.name, json.duration, tracks, json.blendMode);
        clip.uuid = json.uuid;
        return clip;
    },
    toJSON: function(clip) {
        const tracks = [], clipTracks = clip.tracks;
        const json = {
            'name': clip.name,
            'duration': clip.duration,
            'tracks': tracks,
            'uuid': clip.uuid,
            'blendMode': clip.blendMode
        };
        for(let i12 = 0, n = clipTracks.length; i12 !== n; ++i12)tracks.push(KeyframeTrack.toJSON(clipTracks[i12]));
        return json;
    },
    CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks = [];
        for(let i12 = 0; i12 < numMorphTargets; i12++){
            let times = [];
            let values = [];
            times.push((i12 + numMorphTargets - 1) % numMorphTargets, i12, (i12 + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order2 = AnimationUtils.getKeyframeOrder(times);
            times = AnimationUtils.sortedArray(times, 1, order2);
            values = AnimationUtils.sortedArray(values, 1, order2);
            // if there is a key at the first frame, duplicate it as the
            // last frame as well for perfect loop.
            if (!noLoop && times[0] === 0) {
                times.push(numMorphTargets);
                values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i12].name + ']', times, values).scale(1 / fps));
        }
        return new AnimationClip(name, -1, tracks);
    },
    findByName: function(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for(let i12 = 0; i12 < clipArray.length; i12++){
            if (clipArray[i12].name === name) return clipArray[i12];
        }
        return null;
    },
    CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {
        };
        // tested with https://regex101.com/ on trick sequences
        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
        const pattern = /^([\w-]*?)([\d]+)$/;
        // sort morph target names into animation groups based
        // patterns like Walk_001, Walk_002, Run_001, Run_002
        for(let i12 = 0, il = morphTargets.length; i12 < il; i12++){
            const morphTarget = morphTargets[i12];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
                const name = parts[1];
                let animationMorphTargets = animationToMorphTargets[name];
                if (!animationMorphTargets) animationToMorphTargets[name] = animationMorphTargets = [];
                animationMorphTargets.push(morphTarget);
            }
        }
        const clips = [];
        for(const name in animationToMorphTargets)clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        return clips;
    },
    // parse the animation.hierarchy format
    parseAnimation: function(animation, bones) {
        if (!animation) {
            console.error('THREE.AnimationClip: No animation in JSONLoader data.');
            return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            // only return track if there are actually keys.
            if (animationKeys.length !== 0) {
                const times = [];
                const values = [];
                AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                // empty keys are filtered out, so check again
                if (times.length !== 0) destTracks.push(new trackType(trackName, times, values));
            }
        };
        const tracks = [];
        const clipName = animation.name || 'default';
        const fps = animation.fps || 30;
        const blendMode = animation.blendMode;
        // automatic length determination in AnimationClip.
        let duration = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for(let h = 0; h < hierarchyTracks.length; h++){
            const animationKeys = hierarchyTracks[h].keys;
            // skip empty tracks
            if (!animationKeys || animationKeys.length === 0) continue;
            // process morph targets
            if (animationKeys[0].morphTargets) {
                // figure out all morph targets used in this track
                const morphTargetNames = {
                };
                let k;
                for(k = 0; k < animationKeys.length; k++){
                    if (animationKeys[k].morphTargets) for(let m = 0; m < animationKeys[k].morphTargets.length; m++)morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                }
                // create a track for each morph target with all zero
                // morphTargetInfluences except for the keys in which
                // the morphTarget is named.
                for(const morphTargetName in morphTargetNames){
                    const times = [];
                    const values = [];
                    for(let m = 0; m !== animationKeys[k].morphTargets.length; ++m){
                        const animationKey = animationKeys[k];
                        times.push(animationKey.time);
                        values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                }
                duration = morphTargetNames.length * (fps || 1);
            } else {
                // ...assume skeletal animation
                const boneName = '.bones[' + bones[h].name + ']';
                addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
            }
        }
        if (tracks.length === 0) return null;
        const clip = new AnimationClip(clipName, duration, tracks, blendMode);
        return clip;
    }
});
Object.assign(AnimationClip.prototype, {
    resetDuration: function() {
        const tracks = this.tracks;
        let duration = 0;
        for(let i12 = 0, n = tracks.length; i12 !== n; ++i12){
            const track = this.tracks[i12];
            duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
    },
    trim: function() {
        for(let i12 = 0; i12 < this.tracks.length; i12++)this.tracks[i12].trim(0, this.duration);
        return this;
    },
    validate: function() {
        let valid = true;
        for(let i12 = 0; i12 < this.tracks.length; i12++)valid = valid && this.tracks[i12].validate();
        return valid;
    },
    optimize: function() {
        for(let i12 = 0; i12 < this.tracks.length; i12++)this.tracks[i12].optimize();
        return this;
    },
    clone: function() {
        const tracks = [];
        for(let i12 = 0; i12 < this.tracks.length; i12++)tracks.push(this.tracks[i12].clone());
        return new AnimationClip(this.name, this.duration, tracks, this.blendMode);
    },
    toJSON: function() {
        return AnimationClip.toJSON(this);
    }
});
const Cache1 = {
    enabled: false,
    files: {
    },
    add: function(key1, file) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Adding key:', key );
        this.files[key1] = file;
    },
    get: function(key1) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Checking key:', key );
        return this.files[key1];
    },
    remove: function(key1) {
        delete this.files[key1];
    },
    clear: function() {
        this.files = {
        };
    }
};
function LoadingManager(onLoad, onProgress, onError) {
    const scope3 = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = undefined;
    const handlers = [];
    // Refer to #5689 for the reason why we don't set .onStart
    // in the constructor
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
            if (scope3.onStart !== undefined) scope3.onStart(url, itemsLoaded, itemsTotal);
        }
        isLoading = true;
    };
    this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope3.onProgress !== undefined) scope3.onProgress(url, itemsLoaded, itemsTotal);
        if (itemsLoaded === itemsTotal) {
            isLoading = false;
            if (scope3.onLoad !== undefined) scope3.onLoad();
        }
    };
    this.itemError = function(url) {
        if (scope3.onError !== undefined) scope3.onError(url);
    };
    this.resolveURL = function(url) {
        if (urlModifier) return urlModifier(url);
        return url;
    };
    this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
    };
    this.addHandler = function(regex, loader) {
        handlers.push(regex, loader);
        return this;
    };
    this.removeHandler = function(regex) {
        const index2 = handlers.indexOf(regex);
        if (index2 !== -1) handlers.splice(index2, 2);
        return this;
    };
    this.getHandler = function(file) {
        for(let i12 = 0, l1 = handlers.length; i12 < l1; i12 += 2){
            const regex = handlers[i12];
            const loader = handlers[i12 + 1];
            if (regex.global) regex.lastIndex = 0; // see #17920
            if (regex.test(file)) return loader;
        }
        return null;
    };
}
const DefaultLoadingManager = new LoadingManager();
function Loader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager;
    this.crossOrigin = 'anonymous';
    this.withCredentials = false;
    this.path = '';
    this.resourcePath = '';
    this.requestHeader = {
    };
}
Object.assign(Loader.prototype, {
    load: function() {
    },
    loadAsync: function(url, onProgress) {
        const scope3 = this;
        return new Promise(function(resolve, reject) {
            scope3.load(url, resolve, onProgress, reject);
        });
    },
    parse: function() {
    },
    setCrossOrigin: function(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
    },
    setWithCredentials: function(value) {
        this.withCredentials = value;
        return this;
    },
    setPath: function(path1) {
        this.path = path1;
        return this;
    },
    setResourcePath: function(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
    },
    setRequestHeader: function(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
    }
});
const loading = {
};
function FileLoader(manager) {
    Loader.call(this, manager);
}
FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: FileLoader,
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope3 = this;
        const cached = Cache1.get(url);
        if (cached !== undefined) {
            scope3.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope3.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        // Check if request is duplicate
        if (loading[url] !== undefined) {
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            return;
        }
        // Check for data: URI
        const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        const dataUriRegexResult = url.match(dataUriRegex);
        let request;
        // Safari can not handle Data URIs through XMLHttpRequest so process manually
        if (dataUriRegexResult) {
            const mimeType = dataUriRegexResult[1];
            const isBase64 = !!dataUriRegexResult[2];
            let data = dataUriRegexResult[3];
            data = decodeURIComponent(data);
            if (isBase64) data = atob(data);
            try {
                let response;
                const responseType = (this.responseType || '').toLowerCase();
                switch(responseType){
                    case 'arraybuffer':
                    case 'blob':
                        const view = new Uint8Array(data.length);
                        for(let i12 = 0; i12 < data.length; i12++)view[i12] = data.charCodeAt(i12);
                        if (responseType === 'blob') response = new Blob([
                            view.buffer
                        ], {
                            type: mimeType
                        });
                        else response = view.buffer;
                        break;
                    case 'document':
                        const parser = new DOMParser();
                        response = parser.parseFromString(data, mimeType);
                        break;
                    case 'json':
                        response = JSON.parse(data);
                        break;
                    default:
                        response = data;
                        break;
                }
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onLoad) onLoad(response);
                    scope3.manager.itemEnd(url);
                }, 0);
            } catch (error) {
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onError) onError(error);
                    scope3.manager.itemError(url);
                    scope3.manager.itemEnd(url);
                }, 0);
            }
        } else {
            // Initialise array for duplicate requests
            loading[url] = [];
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.addEventListener('load', function(event) {
                const response = this.response;
                const callbacks = loading[url];
                delete loading[url];
                if (this.status === 200 || this.status === 0) {
                    // Some browsers return HTTP Status 0 when using non-http protocol
                    // e.g. 'file://' or 'data://'. Handle as success.
                    if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');
                    // Add to cache only on HTTP success, so that we do not cache
                    // error response bodies as proper responses to requests.
                    Cache1.add(url, response);
                    for(let i12 = 0, il = callbacks.length; i12 < il; i12++){
                        const callback = callbacks[i12];
                        if (callback.onLoad) callback.onLoad(response);
                    }
                    scope3.manager.itemEnd(url);
                } else {
                    for(let i12 = 0, il = callbacks.length; i12 < il; i12++){
                        const callback = callbacks[i12];
                        if (callback.onError) callback.onError(event);
                    }
                    scope3.manager.itemError(url);
                    scope3.manager.itemEnd(url);
                }
            }, false);
            request.addEventListener('progress', function(event) {
                const callbacks = loading[url];
                for(let i12 = 0, il = callbacks.length; i12 < il; i12++){
                    const callback = callbacks[i12];
                    if (callback.onProgress) callback.onProgress(event);
                }
            }, false);
            request.addEventListener('error', function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i12 = 0, il = callbacks.length; i12 < il; i12++){
                    const callback = callbacks[i12];
                    if (callback.onError) callback.onError(event);
                }
                scope3.manager.itemError(url);
                scope3.manager.itemEnd(url);
            }, false);
            request.addEventListener('abort', function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i12 = 0, il = callbacks.length; i12 < il; i12++){
                    const callback = callbacks[i12];
                    if (callback.onError) callback.onError(event);
                }
                scope3.manager.itemError(url);
                scope3.manager.itemEnd(url);
            }, false);
            if (this.responseType !== undefined) request.responseType = this.responseType;
            if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
            if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
            for(const header in this.requestHeader)request.setRequestHeader(header, this.requestHeader[header]);
            request.send(null);
        }
        scope3.manager.itemStart(url);
        return request;
    },
    setResponseType: function(value) {
        this.responseType = value;
        return this;
    },
    setMimeType: function(value) {
        this.mimeType = value;
        return this;
    }
});
function AnimationLoader(manager) {
    Loader.call(this, manager);
}
AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: AnimationLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader(scope3.manager);
        loader.setPath(scope3.path);
        loader.setRequestHeader(scope3.requestHeader);
        loader.setWithCredentials(scope3.withCredentials);
        loader.load(url, function(text1) {
            try {
                onLoad(scope3.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope3.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const animations = [];
        for(let i12 = 0; i12 < json.length; i12++){
            const clip = AnimationClip.parse(json[i12]);
            animations.push(clip);
        }
        return animations;
    }
});
/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */ function CompressedTextureLoader(manager) {
    Loader.call(this, manager);
}
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: CompressedTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const images = [];
        const texture = new CompressedTexture();
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope3.withCredentials);
        let loaded = 0;
        function loadTexture(i12) {
            loader.load(url[i12], function(buffer) {
                const texDatas = scope3.parse(buffer, true);
                images[i12] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                };
                loaded += 1;
                if (loaded === 6) {
                    if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                    texture.image = images;
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, onProgress, onError);
        }
        if (Array.isArray(url)) for(let i12 = 0, il = url.length; i12 < il; ++i12)loadTexture(i12);
        else // compressed cubemap texture stored in a single DDS file
        loader.load(url, function(buffer) {
            const texDatas = scope3.parse(buffer, true);
            if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for(let f = 0; f < faces; f++){
                    images[f] = {
                        mipmaps: []
                    };
                    for(let i13 = 0; i13 < texDatas.mipmapCount; i13++){
                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i13]);
                        images[f].format = texDatas.format;
                        images[f].width = texDatas.width;
                        images[f].height = texDatas.height;
                    }
                }
                texture.image = images;
            } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
        }, onProgress, onError);
        return texture;
    }
});
function ImageLoader(manager) {
    Loader.call(this, manager);
}
ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ImageLoader,
    load: function(url, onLoad, onProgress, onError) {
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope3 = this;
        const cached = Cache1.get(url);
        if (cached !== undefined) {
            scope3.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope3.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
        function onImageLoad() {
            image.removeEventListener('load', onImageLoad, false);
            image.removeEventListener('error', onImageError, false);
            Cache1.add(url, this);
            if (onLoad) onLoad(this);
            scope3.manager.itemEnd(url);
        }
        function onImageError(event) {
            image.removeEventListener('load', onImageLoad, false);
            image.removeEventListener('error', onImageError, false);
            if (onError) onError(event);
            scope3.manager.itemError(url);
            scope3.manager.itemEnd(url);
        }
        image.addEventListener('load', onImageLoad, false);
        image.addEventListener('error', onImageError, false);
        if (url.substr(0, 5) !== 'data:') {
            if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
        }
        scope3.manager.itemStart(url);
        image.src = url;
        return image;
    }
});
function CubeTextureLoader(manager) {
    Loader.call(this, manager);
}
CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: CubeTextureLoader,
    load: function(urls, onLoad, onProgress, onError) {
        const texture = new CubeTexture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        let loaded = 0;
        function loadTexture(i12) {
            loader.load(urls[i12], function(image) {
                texture.images[i12] = image;
                loaded++;
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, undefined, onError);
        }
        for(let i12 = 0; i12 < urls.length; ++i12)loadTexture(i12);
        return texture;
    }
});
/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */ function DataTextureLoader(manager) {
    Loader.call(this, manager);
}
DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: DataTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const texture = new DataTexture();
        const loader = new FileLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        loader.setPath(this.path);
        loader.setWithCredentials(scope3.withCredentials);
        loader.load(url, function(buffer) {
            const texData = scope3.parse(buffer);
            if (!texData) return;
            if (texData.image !== undefined) texture.image = texData.image;
            else if (texData.data !== undefined) {
                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
            texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
            texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
            texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
            texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
            if (texData.encoding !== undefined) texture.encoding = texData.encoding;
            if (texData.flipY !== undefined) texture.flipY = texData.flipY;
            if (texData.format !== undefined) texture.format = texData.format;
            if (texData.type !== undefined) texture.type = texData.type;
            if (texData.mipmaps !== undefined) {
                texture.mipmaps = texData.mipmaps;
                texture.minFilter = LinearMipmapLinearFilter; // presumably...
            }
            if (texData.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
    }
});
function TextureLoader(manager) {
    Loader.call(this, manager);
}
TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: TextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const texture = new Texture();
        const loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image) {
            texture.image = image;
            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
            const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
            texture.format = isJPEG ? RGBFormat : RGBAFormat;
            texture.needsUpdate = true;
            if (onLoad !== undefined) onLoad(texture);
        }, onProgress, onError);
        return texture;
    }
});
/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/ function Curve() {
    this.type = 'Curve';
    this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
    // Virtual base class method to overwrite and implement in subclasses
    //	- t [0 .. 1]
    getPoint: function() {
        console.warn('THREE.Curve: .getPoint() not implemented.');
        return null;
    },
    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]
    getPointAt: function(u, optionalTarget) {
        const t2 = this.getUtoTmapping(u);
        return this.getPoint(t2, optionalTarget);
    },
    // Get sequence of points using getPoint( t )
    getPoints: function(divisions = 5) {
        const points1 = [];
        for(let d = 0; d <= divisions; d++)points1.push(this.getPoint(d / divisions));
        return points1;
    },
    // Get sequence of points using getPointAt( u )
    getSpacedPoints: function(divisions = 5) {
        const points1 = [];
        for(let d = 0; d <= divisions; d++)points1.push(this.getPointAt(d / divisions));
        return points1;
    },
    // Get total curve arc length
    getLength: function() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
    },
    // Get list of cumulative segment lengths
    getLengths: function(divisions) {
        if (divisions === undefined) divisions = this.arcLengthDivisions;
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for(let p6 = 1; p6 <= divisions; p6++){
            current = this.getPoint(p6 / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache; // { sums: cache, sum: sum }; Sum is in the last element.
    },
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.getLengths();
    },
    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
    getUtoTmapping: function(u, distance) {
        const arcLengths = this.getLengths();
        let i12 = 0;
        const il = arcLengths.length;
        let targetArcLength; // The targeted u distance value to get
        if (distance) targetArcLength = distance;
        else targetArcLength = u * arcLengths[il - 1];
        // binary search for the index with largest value smaller than target u distance
        let low = 0, high = il - 1, comparison;
        while(low <= high){
            i12 = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
            comparison = arcLengths[i12] - targetArcLength;
            if (comparison < 0) low = i12 + 1;
            else if (comparison > 0) high = i12 - 1;
            else {
                high = i12;
                break;
            // DONE
            }
        }
        i12 = high;
        if (arcLengths[i12] === targetArcLength) return i12 / (il - 1);
        // we could get finer grain at lengths, or use simple interpolation between two points
        const lengthBefore = arcLengths[i12];
        const lengthAfter = arcLengths[i12 + 1];
        const segmentLength = lengthAfter - lengthBefore;
        // determine where we are between the 'before' and 'after' points
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        // add that fractional amount to t
        const t2 = (i12 + segmentFraction) / (il - 1);
        return t2;
    },
    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation
    getTangent: function(t2, optionalTarget) {
        const delta = 0.0001;
        let t11 = t2 - delta;
        let t21 = t2 + delta;
        // Capping in case of danger
        if (t11 < 0) t11 = 0;
        if (t21 > 1) t21 = 1;
        const pt1 = this.getPoint(t11);
        const pt2 = this.getPoint(t21);
        const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
    },
    getTangentAt: function(u, optionalTarget) {
        const t2 = this.getUtoTmapping(u);
        return this.getTangent(t2, optionalTarget);
    },
    computeFrenetFrames: function(segments2, closed1) {
        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
        const normal7 = new Vector3();
        const tangents = [];
        const normals10 = [];
        const binormals = [];
        const vec = new Vector3();
        const mat = new Matrix4();
        // compute the tangent vectors for each segment on the curve
        for(let i12 = 0; i12 <= segments2; i12++){
            const u = i12 / segments2;
            tangents[i12] = this.getTangentAt(u, new Vector3());
            tangents[i12].normalize();
        }
        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the minimum tangent xyz component
        normals10[0] = new Vector3();
        binormals[0] = new Vector3();
        let min2 = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min2) {
            min2 = tx;
            normal7.set(1, 0, 0);
        }
        if (ty <= min2) {
            min2 = ty;
            normal7.set(0, 1, 0);
        }
        if (tz <= min2) normal7.set(0, 0, 1);
        vec.crossVectors(tangents[0], normal7).normalize();
        normals10[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals10[0]);
        // compute the slowly-varying normal and binormal vectors for each segment on the curve
        for(let i13 = 1; i13 <= segments2; i13++){
            normals10[i13] = normals10[i13 - 1].clone();
            binormals[i13] = binormals[i13 - 1].clone();
            vec.crossVectors(tangents[i13 - 1], tangents[i13]);
            if (vec.length() > Number.EPSILON) {
                vec.normalize();
                const theta = Math.acos(MathUtils.clamp(tangents[i13 - 1].dot(tangents[i13]), -1, 1)); // clamp for floating pt errors
                normals10[i13].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i13].crossVectors(tangents[i13], normals10[i13]);
        }
        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
        if (closed1 === true) {
            let theta = Math.acos(MathUtils.clamp(normals10[0].dot(normals10[segments2]), -1, 1));
            theta /= segments2;
            if (tangents[0].dot(vec.crossVectors(normals10[0], normals10[segments2])) > 0) theta = -theta;
            for(let i14 = 1; i14 <= segments2; i14++){
                // twist a little...
                normals10[i14].applyMatrix4(mat.makeRotationAxis(tangents[i14], theta * i14));
                binormals[i14].crossVectors(tangents[i14], normals10[i14]);
            }
        }
        return {
            tangents: tangents,
            normals: normals10,
            binormals: binormals
        };
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'Curve',
                generator: 'Curve.toJSON'
            }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
    },
    fromJSON: function(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
    }
});
function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    Curve.call(this);
    this.type = 'EllipseCurve';
    this.aX = aX || 0;
    this.aY = aY || 0;
    this.xRadius = xRadius || 1;
    this.yRadius = yRadius || 1;
    this.aStartAngle = aStartAngle || 0;
    this.aEndAngle = aEndAngle || 2 * Math.PI;
    this.aClockwise = aClockwise || false;
    this.aRotation = aRotation || 0;
}
EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;
EllipseCurve.prototype.getPoint = function(t2, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    // ensures that deltaAngle is 0 .. 2 PI
    while(deltaAngle < 0)deltaAngle += twoPi;
    while(deltaAngle > twoPi)deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
        if (samePoints) deltaAngle = 0;
        else deltaAngle = twoPi;
    }
    if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) deltaAngle = -twoPi;
        else deltaAngle = deltaAngle - twoPi;
    }
    const angle = this.aStartAngle + t2 * deltaAngle;
    let x6 = this.aX + this.xRadius * Math.cos(angle);
    let y6 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
        const cos = Math.cos(this.aRotation);
        const sin = Math.sin(this.aRotation);
        const tx = x6 - this.aX;
        const ty = y6 - this.aY;
        // Rotate the point about the center of the ellipse.
        x6 = tx * cos - ty * sin + this.aX;
        y6 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x6, y6);
};
EllipseCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
};
EllipseCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
};
EllipseCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
};
function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = 'ArcCurve';
}
ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */ /*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/ function CubicPoly() {
    let c0 = 0, c11 = 0, c21 = 0, c3 = 0;
    /*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */ function init(x0, x11, t0, t11) {
        c0 = x0;
        c11 = t0;
        c21 = -3 * x0 + 3 * x11 - 2 * t0 - t11;
        c3 = 2 * x0 - 2 * x11 + t0 + t11;
    }
    return {
        initCatmullRom: function(x0, x11, x21, x31, tension) {
            init(x11, x21, tension * (x21 - x0), tension * (x31 - x11));
        },
        initNonuniformCatmullRom: function(x0, x11, x21, x31, dt0, dt1, dt2) {
            // compute tangents when parameterized in [t1,t2]
            let t11 = (x11 - x0) / dt0 - (x21 - x0) / (dt0 + dt1) + (x21 - x11) / dt1;
            let t2 = (x21 - x11) / dt1 - (x31 - x11) / (dt1 + dt2) + (x31 - x21) / dt2;
            // rescale tangents for parametrization in [0,1]
            t11 *= dt1;
            t2 *= dt1;
            init(x11, x21, t11, t2);
        },
        calc: function(t2) {
            const t21 = t2 * t2;
            const t3 = t21 * t2;
            return c0 + c11 * t2 + c21 * t21 + c3 * t3;
        }
    };
}
//
const tmp = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
function CatmullRomCurve3(points1 = [], closed1 = false, curveType = 'centripetal', tension = 0.5) {
    Curve.call(this);
    this.type = 'CatmullRomCurve3';
    this.points = points1;
    this.closed = closed1;
    this.curveType = curveType;
    this.tension = tension;
}
CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
CatmullRomCurve3.prototype.getPoint = function(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points1 = this.points;
    const l1 = points1.length;
    const p6 = (l1 - (this.closed ? 0 : 1)) * t2;
    let intPoint = Math.floor(p6);
    let weight = p6 - intPoint;
    if (this.closed) intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l1) + 1) * l1;
    else if (weight === 0 && intPoint === l1 - 1) {
        intPoint = l1 - 2;
        weight = 1;
    }
    let p02, p32; // 4 points (p1 & p2 defined below)
    if (this.closed || intPoint > 0) p02 = points1[(intPoint - 1) % l1];
    else {
        // extrapolate first point
        tmp.subVectors(points1[0], points1[1]).add(points1[0]);
        p02 = tmp;
    }
    const p12 = points1[intPoint % l1];
    const p22 = points1[(intPoint + 1) % l1];
    if (this.closed || intPoint + 2 < l1) p32 = points1[(intPoint + 2) % l1];
    else {
        // extrapolate last point
        tmp.subVectors(points1[l1 - 1], points1[l1 - 2]).add(points1[l1 - 1]);
        p32 = tmp;
    }
    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
        // init Centripetal / Chordal Catmull-Rom
        const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
        let dt0 = Math.pow(p02.distanceToSquared(p12), pow);
        let dt1 = Math.pow(p12.distanceToSquared(p22), pow);
        let dt2 = Math.pow(p22.distanceToSquared(p32), pow);
        // safety check for repeated points
        if (dt1 < 0.0001) dt1 = 1;
        if (dt0 < 0.0001) dt0 = dt1;
        if (dt2 < 0.0001) dt2 = dt1;
        px.initNonuniformCatmullRom(p02.x, p12.x, p22.x, p32.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p02.y, p12.y, p22.y, p32.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p02.z, p12.z, p22.z, p32.z, dt0, dt1, dt2);
    } else if (this.curveType === 'catmullrom') {
        px.initCatmullRom(p02.x, p12.x, p22.x, p32.x, this.tension);
        py.initCatmullRom(p02.y, p12.y, p22.y, p32.y, this.tension);
        pz.initCatmullRom(p02.z, p12.z, p22.z, p32.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
};
CatmullRomCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for(let i12 = 0, l1 = source.points.length; i12 < l1; i12++){
        const point = source.points[i12];
        this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
};
CatmullRomCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for(let i12 = 0, l1 = this.points.length; i12 < l1; i12++){
        const point = this.points[i12];
        data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
};
CatmullRomCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for(let i12 = 0, l1 = json.points.length; i12 < l1; i12++){
        const point = json.points[i12];
        this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
};
/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/BÃ©zier_curve
 */ function CatmullRom(t2, p02, p12, p22, p32) {
    const v0 = (p22 - p02) * 0.5;
    const v1 = (p32 - p12) * 0.5;
    const t21 = t2 * t2;
    const t3 = t2 * t21;
    return (2 * p12 - 2 * p22 + v0 + v1) * t3 + (-3 * p12 + 3 * p22 - 2 * v0 - v1) * t21 + v0 * t2 + p12;
}
//
function QuadraticBezierP0(t2, p6) {
    const k = 1 - t2;
    return k * k * p6;
}
function QuadraticBezierP1(t2, p6) {
    return 2 * (1 - t2) * t2 * p6;
}
function QuadraticBezierP2(t2, p6) {
    return t2 * t2 * p6;
}
function QuadraticBezier(t2, p02, p12, p22) {
    return QuadraticBezierP0(t2, p02) + QuadraticBezierP1(t2, p12) + QuadraticBezierP2(t2, p22);
}
//
function CubicBezierP0(t2, p6) {
    const k = 1 - t2;
    return k * k * k * p6;
}
function CubicBezierP1(t2, p6) {
    const k = 1 - t2;
    return 3 * k * k * t2 * p6;
}
function CubicBezierP2(t2, p6) {
    return 3 * (1 - t2) * t2 * t2 * p6;
}
function CubicBezierP3(t2, p6) {
    return t2 * t2 * t2 * p6;
}
function CubicBezier(t2, p02, p12, p22, p32) {
    return CubicBezierP0(t2, p02) + CubicBezierP1(t2, p12) + CubicBezierP2(t2, p22) + CubicBezierP3(t2, p32);
}
function CubicBezierCurve(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    Curve.call(this);
    this.type = 'CubicBezierCurve';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
}
CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;
CubicBezierCurve.prototype.getPoint = function(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y));
    return point;
};
CubicBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function CubicBezierCurve3(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    Curve.call(this);
    this.type = 'CubicBezierCurve3';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
}
CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
CubicBezierCurve3.prototype.getPoint = function(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier(t2, v0.z, v1.z, v2.z, v3.z));
    return point;
};
CubicBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function LineCurve(v1 = new Vector2(), v2 = new Vector2()) {
    Curve.call(this);
    this.type = 'LineCurve';
    this.v1 = v1;
    this.v2 = v2;
}
LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;
LineCurve.prototype.getPoint = function(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t2 === 1) point.copy(this.v2);
    else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t2).add(this.v1);
    }
    return point;
};
// Line curve is linear, so we can overwrite default getPointAt
LineCurve.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve.prototype.getTangent = function(t2, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
};
LineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function LineCurve3(v1 = new Vector3(), v2 = new Vector3()) {
    Curve.call(this);
    this.type = 'LineCurve3';
    this.v1 = v1;
    this.v2 = v2;
}
LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;
LineCurve3.prototype.getPoint = function(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t2 === 1) point.copy(this.v2);
    else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t2).add(this.v1);
    }
    return point;
};
// Line curve is linear, so we can overwrite default getPointAt
LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    Curve.call(this);
    this.type = 'QuadraticBezierCurve';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
}
QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
QuadraticBezierCurve.prototype.getPoint = function(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y));
    return point;
};
QuadraticBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve3(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    Curve.call(this);
    this.type = 'QuadraticBezierCurve3';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
}
QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
QuadraticBezierCurve3.prototype.getPoint = function(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y), QuadraticBezier(t2, v0.z, v1.z, v2.z));
    return point;
};
QuadraticBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve3.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function SplineCurve(points1 = []) {
    Curve.call(this);
    this.type = 'SplineCurve';
    this.points = points1;
}
SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
SplineCurve.prototype.getPoint = function(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points1 = this.points;
    const p6 = (points1.length - 1) * t2;
    const intPoint = Math.floor(p6);
    const weight = p6 - intPoint;
    const p02 = points1[intPoint === 0 ? intPoint : intPoint - 1];
    const p12 = points1[intPoint];
    const p22 = points1[intPoint > points1.length - 2 ? points1.length - 1 : intPoint + 1];
    const p32 = points1[intPoint > points1.length - 3 ? points1.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p02.x, p12.x, p22.x, p32.x), CatmullRom(weight, p02.y, p12.y, p22.y, p32.y));
    return point;
};
SplineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for(let i12 = 0, l1 = source.points.length; i12 < l1; i12++){
        const point = source.points[i12];
        this.points.push(point.clone());
    }
    return this;
};
SplineCurve.prototype.toJSON = function() {
    const data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for(let i12 = 0, l1 = this.points.length; i12 < l1; i12++){
        const point = this.points[i12];
        data.points.push(point.toArray());
    }
    return data;
};
SplineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for(let i12 = 0, l1 = json.points.length; i12 < l1; i12++){
        const point = json.points[i12];
        this.points.push(new Vector2().fromArray(point));
    }
    return this;
};
var Curves = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ArcCurve: ArcCurve,
    CatmullRomCurve3: CatmullRomCurve3,
    CubicBezierCurve: CubicBezierCurve,
    CubicBezierCurve3: CubicBezierCurve3,
    EllipseCurve: EllipseCurve,
    LineCurve: LineCurve,
    LineCurve3: LineCurve3,
    QuadraticBezierCurve: QuadraticBezierCurve,
    QuadraticBezierCurve3: QuadraticBezierCurve3,
    SplineCurve: SplineCurve
});
/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/ function CurvePath() {
    Curve.call(this);
    this.type = 'CurvePath';
    this.curves = [];
    this.autoClose = false; // Automatically closes the path
}
CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
    constructor: CurvePath,
    add: function(curve) {
        this.curves.push(curve);
    },
    closePath: function() {
        // Add a line curve if start and end of lines are not connected
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) this.curves.push(new LineCurve(endPoint, startPoint));
    },
    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:
    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')
    getPoint: function(t2) {
        const d = t2 * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i12 = 0;
        // To think about boundaries points.
        while(i12 < curveLengths.length){
            if (curveLengths[i12] >= d) {
                const diff = curveLengths[i12] - d;
                const curve = this.curves[i12];
                const segmentLength = curve.getLength();
                const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u);
            }
            i12++;
        }
        return null;
    // loop where sum != 0, sum > d , sum+1 <d
    },
    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength
    getLength: function() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
    },
    // cacheLengths must be recalculated.
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
    },
    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.
    getCurveLengths: function() {
        // We use cache values if curves and cache array are same length
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        // Get length of sub-curve
        // Push sums into cached array
        const lengths = [];
        let sums = 0;
        for(let i12 = 0, l1 = this.curves.length; i12 < l1; i12++){
            sums += this.curves[i12].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    },
    getSpacedPoints: function(divisions = 40) {
        const points1 = [];
        for(let i12 = 0; i12 <= divisions; i12++)points1.push(this.getPoint(i12 / divisions));
        if (this.autoClose) points1.push(points1[0]);
        return points1;
    },
    getPoints: function(divisions = 12) {
        const points1 = [];
        let last;
        for(let i12 = 0, curves = this.curves; i12 < curves.length; i12++){
            const curve = curves[i12];
            const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for(let j6 = 0; j6 < pts.length; j6++){
                const point = pts[j6];
                if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates
                points1.push(point);
                last = point;
            }
        }
        if (this.autoClose && points1.length > 1 && !points1[points1.length - 1].equals(points1[0])) points1.push(points1[0]);
        return points1;
    },
    copy: function(source) {
        Curve.prototype.copy.call(this, source);
        this.curves = [];
        for(let i12 = 0, l1 = source.curves.length; i12 < l1; i12++){
            const curve = source.curves[i12];
            this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
    },
    toJSON: function() {
        const data = Curve.prototype.toJSON.call(this);
        data.autoClose = this.autoClose;
        data.curves = [];
        for(let i12 = 0, l1 = this.curves.length; i12 < l1; i12++){
            const curve = this.curves[i12];
            data.curves.push(curve.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for(let i12 = 0, l1 = json.curves.length; i12 < l1; i12++){
            const curve = json.curves[i12];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
    }
});
function Path(points1) {
    CurvePath.call(this);
    this.type = 'Path';
    this.currentPoint = new Vector2();
    if (points1) this.setFromPoints(points1);
}
Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
    constructor: Path,
    setFromPoints: function(points1) {
        this.moveTo(points1[0].x, points1[0].y);
        for(let i12 = 1, l1 = points1.length; i12 < l1; i12++)this.lineTo(points1[i12].x, points1[i12].y);
        return this;
    },
    moveTo: function(x6, y6) {
        this.currentPoint.set(x6, y6); // TODO consider referencing vectors instead of copying?
        return this;
    },
    lineTo: function(x6, y6) {
        const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x6, y6));
        this.curves.push(curve);
        this.currentPoint.set(x6, y6);
        return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    },
    splineThru: function(pts/*Array of Vector*/ ) {
        const npts = [
            this.currentPoint.clone()
        ].concat(pts);
        const curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
    },
    arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    },
    absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    },
    ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
    },
    absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
            // if a previous curve is present, attempt to join
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) this.lineTo(firstPoint.x, firstPoint.y);
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
    },
    copy: function(source) {
        CurvePath.prototype.copy.call(this, source);
        this.currentPoint.copy(source.currentPoint);
        return this;
    },
    toJSON: function() {
        const data = CurvePath.prototype.toJSON.call(this);
        data.currentPoint = this.currentPoint.toArray();
        return data;
    },
    fromJSON: function(json) {
        CurvePath.prototype.fromJSON.call(this, json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
    }
});
function Shape(points1) {
    Path.call(this, points1);
    this.uuid = MathUtils.generateUUID();
    this.type = 'Shape';
    this.holes = [];
}
Shape.prototype = Object.assign(Object.create(Path.prototype), {
    constructor: Shape,
    getPointsHoles: function(divisions) {
        const holesPts = [];
        for(let i12 = 0, l1 = this.holes.length; i12 < l1; i12++)holesPts[i12] = this.holes[i12].getPoints(divisions);
        return holesPts;
    },
    // get points of shape and holes (keypoints based on segments parameter)
    extractPoints: function(divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    },
    copy: function(source) {
        Path.prototype.copy.call(this, source);
        this.holes = [];
        for(let i12 = 0, l1 = source.holes.length; i12 < l1; i12++){
            const hole = source.holes[i12];
            this.holes.push(hole.clone());
        }
        return this;
    },
    toJSON: function() {
        const data = Path.prototype.toJSON.call(this);
        data.uuid = this.uuid;
        data.holes = [];
        for(let i12 = 0, l1 = this.holes.length; i12 < l1; i12++){
            const hole = this.holes[i12];
            data.holes.push(hole.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Path.prototype.fromJSON.call(this, json);
        this.uuid = json.uuid;
        this.holes = [];
        for(let i12 = 0, l1 = json.holes.length; i12 < l1; i12++){
            const hole = json.holes[i12];
            this.holes.push(new Path().fromJSON(hole));
        }
        return this;
    }
});
function Light(color4, intensity = 1) {
    Object3D.call(this);
    this.type = 'Light';
    this.color = new Color(color4);
    this.intensity = intensity;
}
Light.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Light,
    isLight: true,
    copy: function(source) {
        Object3D.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== undefined) data.object.distance = this.distance;
        if (this.angle !== undefined) data.object.angle = this.angle;
        if (this.decay !== undefined) data.object.decay = this.decay;
        if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
        if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
        return data;
    }
});
function HemisphereLight(skyColor, groundColor, intensity) {
    Light.call(this, skyColor, intensity);
    this.type = 'HemisphereLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
}
HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: HemisphereLight,
    isHemisphereLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
    }
});
function LightShadow(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
        new Vector4(0, 0, 1, 1)
    ];
}
Object.assign(LightShadow.prototype, {
    _projScreenMatrix: new Matrix4(),
    _lightPositionWorld: new Vector3(),
    _lookTarget: new Vector3(),
    getViewportCount: function() {
        return this._viewportCount;
    },
    getFrustum: function() {
        return this._frustum;
    },
    updateMatrices: function(light) {
        const shadowCamera = this.camera, shadowMatrix = this.matrix, projScreenMatrix = this._projScreenMatrix, lookTarget = this._lookTarget, lightPositionWorld = this._lightPositionWorld;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(lightPositionWorld);
        lookTarget.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(lookTarget);
        shadowCamera.updateMatrixWorld();
        projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(projScreenMatrix);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    },
    getViewport: function(viewportIndex) {
        return this._viewports[viewportIndex];
    },
    getFrameExtents: function() {
        return this._frameExtents;
    },
    copy: function(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        const object = {
        };
        if (this.bias !== 0) object.bias = this.bias;
        if (this.normalBias !== 0) object.normalBias = this.normalBias;
        if (this.radius !== 1) object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
    }
});
function SpotLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
}
SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: SpotLightShadow,
    isSpotLightShadow: true,
    updateMatrices: function(light) {
        const camera = this.camera;
        const fov1 = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
        const aspect1 = this.mapSize.width / this.mapSize.height;
        const far1 = light.distance || camera.far;
        if (fov1 !== camera.fov || aspect1 !== camera.aspect || far1 !== camera.far) {
            camera.fov = fov1;
            camera.aspect = aspect1;
            camera.far = far1;
            camera.updateProjectionMatrix();
        }
        LightShadow.prototype.updateMatrices.call(this, light);
    }
});
function SpotLight(color4, intensity, distance, angle, penumbra, decay) {
    Light.call(this, color4, intensity);
    this.type = 'SpotLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    Object.defineProperty(this, 'power', {
        get: function() {
            // intensity = power per solid angle.
            // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            return this.intensity * Math.PI;
        },
        set: function(power) {
            // intensity = power per solid angle.
            // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            this.intensity = power / Math.PI;
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.angle = angle !== undefined ? angle : Math.PI / 3;
    this.penumbra = penumbra !== undefined ? penumbra : 0;
    this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.
    this.shadow = new SpotLightShadow();
}
SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: SpotLight,
    isSpotLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
function PointLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
        // These viewports map a cube-map onto a 2D texture with the
        // following orientation:
        //
        //  xzXZ
        //   y Y
        //
        // X - Positive x direction
        // x - Negative x direction
        // Y - Positive y direction
        // y - Negative y direction
        // Z - Positive z direction
        // z - Negative z direction
        // positive X
        new Vector4(2, 1, 1, 1),
        // negative X
        new Vector4(0, 1, 1, 1),
        // positive Z
        new Vector4(3, 1, 1, 1),
        // negative Z
        new Vector4(1, 1, 1, 1),
        // positive Y
        new Vector4(3, 0, 1, 1),
        // negative Y
        new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1)
    ];
}
PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: PointLightShadow,
    isPointLightShadow: true,
    updateMatrices: function(light, viewportIndex = 0) {
        const camera = this.camera, shadowMatrix = this.matrix, lightPositionWorld = this._lightPositionWorld, lookTarget = this._lookTarget, projScreenMatrix = this._projScreenMatrix;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy(lightPositionWorld);
        lookTarget.copy(camera.position);
        lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt(lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
        projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(projScreenMatrix);
    }
});
function PointLight(color4, intensity, distance, decay) {
    Light.call(this, color4, intensity);
    this.type = 'PointLight';
    Object.defineProperty(this, 'power', {
        get: function() {
            // intensity = power per solid angle.
            // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            return this.intensity * 4 * Math.PI;
        },
        set: function(power) {
            // intensity = power per solid angle.
            // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            this.intensity = power / (4 * Math.PI);
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.
    this.shadow = new PointLightShadow();
}
PointLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: PointLight,
    isPointLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
    }
});
function OrthographicCamera(left = -1, right = 1, top = 1, bottom = -1, near1 = 0.1, far1 = 2000) {
    Camera.call(this);
    this.type = 'OrthographicCamera';
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near1;
    this.far = far1;
    this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
    constructor: OrthographicCamera,
    isOrthographicCamera: true,
    copy: function(source, recursive) {
        Camera.prototype.copy.call(this, source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({
        }, source.view);
        return this;
    },
    setViewOffset: function(fullWidth, fullHeight, x6, y6, width5, height7) {
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x6;
        this.view.offsetY = y6;
        this.view.width = width5;
        this.view.height = height7;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    },
    toJSON: function(meta) {
        const data = Object3D.prototype.toJSON.call(this, meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null) data.object.view = Object.assign({
        }, this.view);
        return data;
    }
});
function DirectionalLightShadow() {
    LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: DirectionalLightShadow,
    isDirectionalLightShadow: true,
    updateMatrices: function(light) {
        LightShadow.prototype.updateMatrices.call(this, light);
    }
});
function DirectionalLight(color4, intensity) {
    Light.call(this, color4, intensity);
    this.type = 'DirectionalLight';
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
}
DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: DirectionalLight,
    isDirectionalLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
function AmbientLight(color4, intensity) {
    Light.call(this, color4, intensity);
    this.type = 'AmbientLight';
}
AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: AmbientLight,
    isAmbientLight: true
});
function RectAreaLight(color4, intensity, width5, height7) {
    Light.call(this, color4, intensity);
    this.type = 'RectAreaLight';
    this.width = width5 !== undefined ? width5 : 10;
    this.height = height7 !== undefined ? height7 : 10;
}
RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: RectAreaLight,
    isRectAreaLight: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.width = source.width;
        this.height = source.height;
        return this;
    },
    toJSON: function(meta) {
        const data = Light.prototype.toJSON.call(this, meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
    }
});
/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */ // 3-band SH defined by 9 coefficients
class SphericalHarmonics3 {
    constructor(){
        Object.defineProperty(this, 'isSphericalHarmonics3', {
            value: true
        });
        this.coefficients = [];
        for(let i12 = 0; i12 < 9; i12++)this.coefficients.push(new Vector3());
    }
    set(coefficients) {
        for(let i13 = 0; i13 < 9; i13++)this.coefficients[i13].copy(coefficients[i13]);
        return this;
    }
    zero() {
        for(let i13 = 0; i13 < 9; i13++)this.coefficients[i13].set(0, 0, 0);
        return this;
    }
    // get the radiance in the direction of the normal
    // target is a Vector3
    getAt(normal, target) {
        // normal is assumed to be unit length
        const x6 = normal.x, y6 = normal.y, z5 = normal.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.282095);
        // band 1
        target.addScaledVector(coeff[1], 0.488603 * y6);
        target.addScaledVector(coeff[2], 0.488603 * z5);
        target.addScaledVector(coeff[3], 0.488603 * x6);
        // band 2
        target.addScaledVector(coeff[4], 1.092548 * (x6 * y6));
        target.addScaledVector(coeff[5], 1.092548 * (y6 * z5));
        target.addScaledVector(coeff[6], 0.315392 * (3 * z5 * z5 - 1));
        target.addScaledVector(coeff[7], 1.092548 * (x6 * z5));
        target.addScaledVector(coeff[8], 0.546274 * (x6 * x6 - y6 * y6));
        return target;
    }
    // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
    // target is a Vector3
    // https://graphics.stanford.edu/papers/envmap/envmap.pdf
    getIrradianceAt(normal, target) {
        // normal is assumed to be unit length
        const x6 = normal.x, y6 = normal.y, z5 = normal.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.886227); // Ï€ * 0.282095
        // band 1
        target.addScaledVector(coeff[1], 1.023328 * y6); // ( 2 * Ï€ / 3 ) * 0.488603
        target.addScaledVector(coeff[2], 1.023328 * z5);
        target.addScaledVector(coeff[3], 1.023328 * x6);
        // band 2
        target.addScaledVector(coeff[4], 0.858086 * x6 * y6); // ( Ï€ / 4 ) * 1.092548
        target.addScaledVector(coeff[5], 0.858086 * y6 * z5);
        target.addScaledVector(coeff[6], 0.743125 * z5 * z5 - 0.247708); // ( Ï€ / 4 ) * 0.315392 * 3
        target.addScaledVector(coeff[7], 0.858086 * x6 * z5);
        target.addScaledVector(coeff[8], 0.429043 * (x6 * x6 - y6 * y6)); // ( Ï€ / 4 ) * 0.546274
        return target;
    }
    add(sh) {
        for(let i13 = 0; i13 < 9; i13++)this.coefficients[i13].add(sh.coefficients[i13]);
        return this;
    }
    addScaledSH(sh, s) {
        for(let i13 = 0; i13 < 9; i13++)this.coefficients[i13].addScaledVector(sh.coefficients[i13], s);
        return this;
    }
    scale(s) {
        for(let i13 = 0; i13 < 9; i13++)this.coefficients[i13].multiplyScalar(s);
        return this;
    }
    lerp(sh, alpha) {
        for(let i13 = 0; i13 < 9; i13++)this.coefficients[i13].lerp(sh.coefficients[i13], alpha);
        return this;
    }
    equals(sh) {
        for(let i13 = 0; i13 < 9; i13++){
            if (!this.coefficients[i13].equals(sh.coefficients[i13])) return false;
        }
        return true;
    }
    copy(sh) {
        return this.set(sh.coefficients);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
        const coefficients = this.coefficients;
        for(let i13 = 0; i13 < 9; i13++)coefficients[i13].fromArray(array, offset + i13 * 3);
        return this;
    }
    toArray(array = [], offset = 0) {
        const coefficients = this.coefficients;
        for(let i13 = 0; i13 < 9; i13++)coefficients[i13].toArray(array, offset + i13 * 3);
        return array;
    }
    // evaluate the basis functions
    // shBasis is an Array[ 9 ]
    static getBasisAt(normal, shBasis) {
        // normal is assumed to be unit length
        const x6 = normal.x, y6 = normal.y, z5 = normal.z;
        // band 0
        shBasis[0] = 0.282095;
        // band 1
        shBasis[1] = 0.488603 * y6;
        shBasis[2] = 0.488603 * z5;
        shBasis[3] = 0.488603 * x6;
        // band 2
        shBasis[4] = 1.092548 * x6 * y6;
        shBasis[5] = 1.092548 * y6 * z5;
        shBasis[6] = 0.315392 * (3 * z5 * z5 - 1);
        shBasis[7] = 1.092548 * x6 * z5;
        shBasis[8] = 0.546274 * (x6 * x6 - y6 * y6);
    }
}
function LightProbe(sh, intensity) {
    Light.call(this, undefined, intensity);
    this.type = 'LightProbe';
    this.sh = sh !== undefined ? sh : new SphericalHarmonics3();
}
LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: LightProbe,
    isLightProbe: true,
    copy: function(source) {
        Light.prototype.copy.call(this, source);
        this.sh.copy(source.sh);
        return this;
    },
    fromJSON: function(json) {
        this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
        this.sh.fromArray(json.sh);
        return this;
    },
    toJSON: function(meta) {
        const data = Light.prototype.toJSON.call(this, meta);
        data.object.sh = this.sh.toArray();
        return data;
    }
});
function MaterialLoader(manager) {
    Loader.call(this, manager);
    this.textures = {
    };
}
MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: MaterialLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader(scope3.manager);
        loader.setPath(scope3.path);
        loader.setRequestHeader(scope3.requestHeader);
        loader.setWithCredentials(scope3.withCredentials);
        loader.load(url, function(text1) {
            try {
                onLoad(scope3.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope3.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const textures = this.textures;
        function getTexture(name) {
            if (textures[name] === undefined) console.warn('THREE.MaterialLoader: Undefined texture', name);
            return textures[name];
        }
        const material = new Materials[json.type]();
        if (json.uuid !== undefined) material.uuid = json.uuid;
        if (json.name !== undefined) material.name = json.name;
        if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
        if (json.roughness !== undefined) material.roughness = json.roughness;
        if (json.metalness !== undefined) material.metalness = json.metalness;
        if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
        if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
        if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
        if (json.shininess !== undefined) material.shininess = json.shininess;
        if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
        if (json.fog !== undefined) material.fog = json.fog;
        if (json.flatShading !== undefined) material.flatShading = json.flatShading;
        if (json.blending !== undefined) material.blending = json.blending;
        if (json.combine !== undefined) material.combine = json.combine;
        if (json.side !== undefined) material.side = json.side;
        if (json.opacity !== undefined) material.opacity = json.opacity;
        if (json.transparent !== undefined) material.transparent = json.transparent;
        if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined) material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
        if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
        if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
        if (json.wireframe !== undefined) material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== undefined) material.rotation = json.rotation;
        if (json.linewidth !== 1) material.linewidth = json.linewidth;
        if (json.dashSize !== undefined) material.dashSize = json.dashSize;
        if (json.gapSize !== undefined) material.gapSize = json.gapSize;
        if (json.scale !== undefined) material.scale = json.scale;
        if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.skinning !== undefined) material.skinning = json.skinning;
        if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
        if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
        if (json.dithering !== undefined) material.dithering = json.dithering;
        if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
        if (json.visible !== undefined) material.visible = json.visible;
        if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
        if (json.userData !== undefined) material.userData = json.userData;
        if (json.vertexColors !== undefined) {
            if (typeof json.vertexColors === 'number') material.vertexColors = json.vertexColors > 0 ? true : false;
            else material.vertexColors = json.vertexColors;
        }
        // Shader Material
        if (json.uniforms !== undefined) for(const name in json.uniforms){
            const uniform = json.uniforms[name];
            material.uniforms[name] = {
            };
            switch(uniform.type){
                case 't':
                    material.uniforms[name].value = getTexture(uniform.value);
                    break;
                case 'c':
                    material.uniforms[name].value = new Color().setHex(uniform.value);
                    break;
                case 'v2':
                    material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                    break;
                case 'v3':
                    material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                    break;
                case 'v4':
                    material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                    break;
                case 'm3':
                    material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                    break;
                case 'm4':
                    material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                    break;
                default:
                    material.uniforms[name].value = uniform.value;
            }
        }
        if (json.defines !== undefined) material.defines = json.defines;
        if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
        if (json.extensions !== undefined) for(const key1 in json.extensions)material.extensions[key1] = json.extensions[key1];
        // Deprecated
        if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
        // for PointsMaterial
        if (json.size !== undefined) material.size = json.size;
        if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
        // maps
        if (json.map !== undefined) material.map = getTexture(json.map);
        if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
        if (json.normalScale !== undefined) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) // Blender exporter used to export a scalar. See #7459
            normalScale = [
                normalScale,
                normalScale
            ];
            material.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
        if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
        if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
        if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
        if (json.transmission !== undefined) material.transmission = json.transmission;
        if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
        return material;
    },
    setTextures: function(value) {
        this.textures = value;
        return this;
    }
});
const LoaderUtils = {
    decodeText: function(array) {
        if (typeof TextDecoder !== 'undefined') return new TextDecoder().decode(array);
        // Avoid the String.fromCharCode.apply(null, array) shortcut, which
        // throws a "maximum call stack size exceeded" error for large arrays.
        let s2 = '';
        for(let i13 = 0, il = array.length; i13 < il; i13++)// Implicitly assumes little-endian.
        s2 += String.fromCharCode(array[i13]);
        try {
            // merges multi-byte utf-8 characters.
            return decodeURIComponent(escape(s2));
        } catch (e) {
            return s2;
        }
    },
    extractUrlBase: function(url) {
        const index2 = url.lastIndexOf('/');
        if (index2 === -1) return './';
        return url.substr(0, index2 + 1);
    }
};
function InstancedBufferGeometry() {
    BufferGeometry.call(this);
    this.type = 'InstancedBufferGeometry';
    this.instanceCount = Infinity;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
    constructor: InstancedBufferGeometry,
    isInstancedBufferGeometry: true,
    copy: function(source) {
        BufferGeometry.prototype.copy.call(this, source);
        this.instanceCount = source.instanceCount;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        const data = BufferGeometry.prototype.toJSON.call(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
    }
});
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === 'number') {
        meshPerAttribute = normalized;
        normalized = false;
        console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
    }
    BufferAttribute.call(this, array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
    constructor: InstancedBufferAttribute,
    isInstancedBufferAttribute: true,
    copy: function(source) {
        BufferAttribute.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    },
    toJSON: function() {
        const data = BufferAttribute.prototype.toJSON.call(this);
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
    }
});
function BufferGeometryLoader(manager) {
    Loader.call(this, manager);
}
BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: BufferGeometryLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader(scope3.manager);
        loader.setPath(scope3.path);
        loader.setRequestHeader(scope3.requestHeader);
        loader.setWithCredentials(scope3.withCredentials);
        loader.load(url, function(text1) {
            try {
                onLoad(scope3.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope3.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const interleavedBufferMap = {
        };
        const arrayBufferMap = {
        };
        function getInterleavedBuffer(json1, uuid) {
            if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
            const interleavedBuffers = json1.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json1, interleavedBuffer.buffer);
            const array = getTypedArray(interleavedBuffer.type, buffer);
            const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
        }
        function getArrayBuffer(json1, uuid) {
            if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
            const arrayBuffers = json1.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
        }
        const geometry2 = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
        const index2 = json.data.index;
        if (index2 !== undefined) {
            const typedArray = getTypedArray(index2.type, index2.array);
            geometry2.setIndex(new BufferAttribute(typedArray, 1));
        }
        const attributes = json.data.attributes;
        for(const key1 in attributes){
            const attribute = attributes[key1];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
                const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
                const typedArray = getTypedArray(attribute.type, attribute.array);
                const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
            geometry2.setAttribute(key1, bufferAttribute);
        }
        const morphAttributes = json.data.morphAttributes;
        if (morphAttributes) for(const key2 in morphAttributes){
            const attributeArray = morphAttributes[key2];
            const array = [];
            for(let i13 = 0, il = attributeArray.length; i13 < il; i13++){
                const attribute = attributeArray[i13];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                    const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                    bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                    const typedArray = getTypedArray(attribute.type, attribute.array);
                    bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                array.push(bufferAttribute);
            }
            geometry2.morphAttributes[key2] = array;
        }
        const morphTargetsRelative = json.data.morphTargetsRelative;
        if (morphTargetsRelative) geometry2.morphTargetsRelative = true;
        const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== undefined) for(let i13 = 0, n = groups.length; i13 !== n; ++i13){
            const group = groups[i13];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
            const center3 = new Vector3();
            if (boundingSphere.center !== undefined) center3.fromArray(boundingSphere.center);
            geometry2.boundingSphere = new Sphere(center3, boundingSphere.radius);
        }
        if (json.name) geometry2.name = json.name;
        if (json.userData) geometry2.userData = json.userData;
        return geometry2;
    }
});
class ObjectLoader extends Loader {
    constructor(manager){
        super(manager);
    }
    load(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const path1 = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path1;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text1) {
            let json = null;
            try {
                json = JSON.parse(text1);
            } catch (error) {
                if (onError !== undefined) onError(error);
                console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                return;
            }
            const metadata = json.metadata;
            if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                console.error('THREE.ObjectLoader: Can\'t load ' + url);
                return;
            }
            scope3.parse(json, onLoad);
        }, onProgress, onError);
    }
    parse(json, onLoad) {
        const animations = this.parseAnimations(json.animations);
        const shapes3 = this.parseShapes(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes3);
        const images = this.parseImages(json.images, function() {
            if (onLoad !== undefined) onLoad(object);
        });
        const textures = this.parseTextures(json.textures, images);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials, animations);
        const skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        //
        if (onLoad !== undefined) {
            let hasImages = false;
            for(const uuid in images)if (images[uuid] instanceof HTMLImageElement) {
                hasImages = true;
                break;
            }
            if (hasImages === false) onLoad(object);
        }
        return object;
    }
    parseShapes(json) {
        const shapes3 = {
        };
        if (json !== undefined) for(let i13 = 0, l1 = json.length; i13 < l1; i13++){
            const shape = new Shape().fromJSON(json[i13]);
            shapes3[shape.uuid] = shape;
        }
        return shapes3;
    }
    parseSkeletons(json, object) {
        const skeletons = {
        };
        const bones = {
        };
        // generate bone lookup table
        object.traverse(function(child) {
            if (child.isBone) bones[child.uuid] = child;
        });
        // create skeletons
        if (json !== undefined) for(let i13 = 0, l1 = json.length; i13 < l1; i13++){
            const skeleton = new Skeleton().fromJSON(json[i13], bones);
            skeletons[skeleton.uuid] = skeleton;
        }
        return skeletons;
    }
    parseGeometries(json, shapes) {
        const geometries = {
        };
        let geometryShapes;
        if (json !== undefined) {
            const bufferGeometryLoader = new BufferGeometryLoader();
            for(let i13 = 0, l1 = json.length; i13 < l1; i13++){
                let geometry2;
                const data = json[i13];
                switch(data.type){
                    case 'PlaneGeometry':
                    case 'PlaneBufferGeometry':
                        geometry2 = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                        break;
                    case 'BoxGeometry':
                    case 'BoxBufferGeometry':
                        geometry2 = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                        break;
                    case 'CircleGeometry':
                    case 'CircleBufferGeometry':
                        geometry2 = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                        break;
                    case 'CylinderGeometry':
                    case 'CylinderBufferGeometry':
                        geometry2 = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;
                    case 'ConeGeometry':
                    case 'ConeBufferGeometry':
                        geometry2 = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;
                    case 'SphereGeometry':
                    case 'SphereBufferGeometry':
                        geometry2 = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                        break;
                    case 'DodecahedronGeometry':
                    case 'DodecahedronBufferGeometry':
                    case 'IcosahedronGeometry':
                    case 'IcosahedronBufferGeometry':
                    case 'OctahedronGeometry':
                    case 'OctahedronBufferGeometry':
                    case 'TetrahedronGeometry':
                    case 'TetrahedronBufferGeometry':
                        geometry2 = new Geometries[data.type](data.radius, data.detail);
                        break;
                    case 'RingGeometry':
                    case 'RingBufferGeometry':
                        geometry2 = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                        break;
                    case 'TorusGeometry':
                    case 'TorusBufferGeometry':
                        geometry2 = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                        break;
                    case 'TorusKnotGeometry':
                    case 'TorusKnotBufferGeometry':
                        geometry2 = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                        break;
                    case 'TubeGeometry':
                    case 'TubeBufferGeometry':
                        // This only works for built-in curves (e.g. CatmullRomCurve3).
                        // User defined curves or instances of CurvePath will not be deserialized.
                        geometry2 = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
                        break;
                    case 'LatheGeometry':
                    case 'LatheBufferGeometry':
                        geometry2 = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                        break;
                    case 'PolyhedronGeometry':
                    case 'PolyhedronBufferGeometry':
                        geometry2 = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                        break;
                    case 'ShapeGeometry':
                    case 'ShapeBufferGeometry':
                        geometryShapes = [];
                        for(let j6 = 0, jl = data.shapes.length; j6 < jl; j6++){
                            const shape = shapes[data.shapes[j6]];
                            geometryShapes.push(shape);
                        }
                        geometry2 = new Geometries[data.type](geometryShapes, data.curveSegments);
                        break;
                    case 'ExtrudeGeometry':
                    case 'ExtrudeBufferGeometry':
                        geometryShapes = [];
                        for(let j7 = 0, jl1 = data.shapes.length; j7 < jl1; j7++){
                            const shape = shapes[data.shapes[j7]];
                            geometryShapes.push(shape);
                        }
                        const extrudePath = data.options.extrudePath;
                        if (extrudePath !== undefined) data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
                        geometry2 = new Geometries[data.type](geometryShapes, data.options);
                        break;
                    case 'BufferGeometry':
                    case 'InstancedBufferGeometry':
                        geometry2 = bufferGeometryLoader.parse(data);
                        break;
                    case 'Geometry':
                        console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                        continue;
                }
                geometry2.uuid = data.uuid;
                if (data.name !== undefined) geometry2.name = data.name;
                if (geometry2.isBufferGeometry === true && data.userData !== undefined) geometry2.userData = data.userData;
                geometries[data.uuid] = geometry2;
            }
        }
        return geometries;
    }
    parseMaterials(json, textures) {
        const cache = {
        }; // MultiMaterial
        const materials = {
        };
        if (json !== undefined) {
            const loader = new MaterialLoader();
            loader.setTextures(textures);
            for(let i13 = 0, l1 = json.length; i13 < l1; i13++){
                const data = json[i13];
                if (data.type === 'MultiMaterial') {
                    // Deprecated
                    const array = [];
                    for(let j6 = 0; j6 < data.materials.length; j6++){
                        const material = data.materials[j6];
                        if (cache[material.uuid] === undefined) cache[material.uuid] = loader.parse(material);
                        array.push(cache[material.uuid]);
                    }
                    materials[data.uuid] = array;
                } else {
                    if (cache[data.uuid] === undefined) cache[data.uuid] = loader.parse(data);
                    materials[data.uuid] = cache[data.uuid];
                }
            }
        }
        return materials;
    }
    parseAnimations(json) {
        const animations = {
        };
        if (json !== undefined) for(let i13 = 0; i13 < json.length; i13++){
            const data = json[i13];
            const clip = AnimationClip.parse(data);
            animations[clip.uuid] = clip;
        }
        return animations;
    }
    parseImages(json, onLoad) {
        const scope3 = this;
        const images = {
        };
        let loader;
        function loadImage(url) {
            scope3.manager.itemStart(url);
            return loader.load(url, function() {
                scope3.manager.itemEnd(url);
            }, undefined, function() {
                scope3.manager.itemError(url);
                scope3.manager.itemEnd(url);
            });
        }
        function deserializeImage(image) {
            if (typeof image === 'string') {
                const url = image;
                const path1 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope3.resourcePath + url;
                return loadImage(path1);
            } else {
                if (image.data) return {
                    data: getTypedArray(image.type, image.data),
                    width: image.width,
                    height: image.height
                };
                else return null;
            }
        }
        if (json !== undefined && json.length > 0) {
            const manager1 = new LoadingManager(onLoad);
            loader = new ImageLoader(manager1);
            loader.setCrossOrigin(this.crossOrigin);
            for(let i13 = 0, il = json.length; i13 < il; i13++){
                const image = json[i13];
                const url = image.url;
                if (Array.isArray(url)) {
                    // load array of images e.g CubeTexture
                    images[image.uuid] = [];
                    for(let j6 = 0, jl = url.length; j6 < jl; j6++){
                        const currentUrl = url[j6];
                        const deserializedImage = deserializeImage(currentUrl);
                        if (deserializedImage !== null) {
                            if (deserializedImage instanceof HTMLImageElement) images[image.uuid].push(deserializedImage);
                            else // special case: handle array of data textures for cube textures
                            images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                        }
                    }
                } else {
                    // load single image
                    const deserializedImage = deserializeImage(image.url);
                    if (deserializedImage !== null) images[image.uuid] = deserializedImage;
                }
            }
        }
        return images;
    }
    parseTextures(json, images) {
        function parseConstant(value, type) {
            if (typeof value === 'number') return value;
            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
            return type[value];
        }
        const textures = {
        };
        if (json !== undefined) for(let i13 = 0, l1 = json.length; i13 < l1; i13++){
            const data = json[i13];
            if (data.image === undefined) console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            if (images[data.image] === undefined) console.warn('THREE.ObjectLoader: Undefined image', data.image);
            let texture;
            const image = images[data.image];
            if (Array.isArray(image)) {
                texture = new CubeTexture(image);
                if (image.length === 6) texture.needsUpdate = true;
            } else {
                if (image && image.data) texture = new DataTexture(image.data, image.width, image.height);
                else texture = new Texture(image);
                if (image) texture.needsUpdate = true; // textures can have undefined image data
            }
            texture.uuid = data.uuid;
            if (data.name !== undefined) texture.name = data.name;
            if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
            if (data.offset !== undefined) texture.offset.fromArray(data.offset);
            if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
            if (data.center !== undefined) texture.center.fromArray(data.center);
            if (data.rotation !== undefined) texture.rotation = data.rotation;
            if (data.wrap !== undefined) {
                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
            }
            if (data.format !== undefined) texture.format = data.format;
            if (data.type !== undefined) texture.type = data.type;
            if (data.encoding !== undefined) texture.encoding = data.encoding;
            if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
            if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
            if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
            if (data.flipY !== undefined) texture.flipY = data.flipY;
            if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
            textures[data.uuid] = texture;
        }
        return textures;
    }
    parseObject(data, geometries, materials, animations) {
        let object;
        function getGeometry(name) {
            if (geometries[name] === undefined) console.warn('THREE.ObjectLoader: Undefined geometry', name);
            return geometries[name];
        }
        function getMaterial(name) {
            if (name === undefined) return undefined;
            if (Array.isArray(name)) {
                const array = [];
                for(let i13 = 0, l1 = name.length; i13 < l1; i13++){
                    const uuid = name[i13];
                    if (materials[uuid] === undefined) console.warn('THREE.ObjectLoader: Undefined material', uuid);
                    array.push(materials[uuid]);
                }
                return array;
            }
            if (materials[name] === undefined) console.warn('THREE.ObjectLoader: Undefined material', name);
            return materials[name];
        }
        let geometry2, material;
        switch(data.type){
            case 'Scene':
                object = new Scene();
                if (data.background !== undefined) {
                    if (Number.isInteger(data.background)) object.background = new Color(data.background);
                }
                if (data.fog !== undefined) {
                    if (data.fog.type === 'Fog') object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                    else if (data.fog.type === 'FogExp2') object.fog = new FogExp2(data.fog.color, data.fog.density);
                }
                break;
            case 'PerspectiveCamera':
                object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                if (data.focus !== undefined) object.focus = data.focus;
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                if (data.view !== undefined) object.view = Object.assign({
                }, data.view);
                break;
            case 'OrthographicCamera':
                object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.view !== undefined) object.view = Object.assign({
                }, data.view);
                break;
            case 'AmbientLight':
                object = new AmbientLight(data.color, data.intensity);
                break;
            case 'DirectionalLight':
                object = new DirectionalLight(data.color, data.intensity);
                break;
            case 'PointLight':
                object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                break;
            case 'RectAreaLight':
                object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                break;
            case 'SpotLight':
                object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                break;
            case 'HemisphereLight':
                object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                break;
            case 'LightProbe':
                object = new LightProbe().fromJSON(data);
                break;
            case 'SkinnedMesh':
                geometry2 = getGeometry(data.geometry);
                material = getMaterial(data.material);
                object = new SkinnedMesh(geometry2, material);
                if (data.bindMode !== undefined) object.bindMode = data.bindMode;
                if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
                if (data.skeleton !== undefined) object.skeleton = data.skeleton;
                break;
            case 'Mesh':
                geometry2 = getGeometry(data.geometry);
                material = getMaterial(data.material);
                object = new Mesh(geometry2, material);
                break;
            case 'InstancedMesh':
                geometry2 = getGeometry(data.geometry);
                material = getMaterial(data.material);
                const count = data.count;
                const instanceMatrix = data.instanceMatrix;
                object = new InstancedMesh(geometry2, material, count);
                object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
                break;
            case 'LOD':
                object = new LOD();
                break;
            case 'Line':
                object = new Line(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'LineLoop':
                object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'LineSegments':
                object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'PointCloud':
            case 'Points':
                object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'Sprite':
                object = new Sprite(getMaterial(data.material));
                break;
            case 'Group':
                object = new Group();
                break;
            case 'Bone':
                object = new Bone();
                break;
            default:
                object = new Object3D();
        }
        object.uuid = data.uuid;
        if (data.name !== undefined) object.name = data.name;
        if (data.matrix !== undefined) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
            if (data.position !== undefined) object.position.fromArray(data.position);
            if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
            if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
            if (data.scale !== undefined) object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== undefined) object.castShadow = data.castShadow;
        if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
            if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
            if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
            if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== undefined) object.visible = data.visible;
        if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
        if (data.userData !== undefined) object.userData = data.userData;
        if (data.layers !== undefined) object.layers.mask = data.layers;
        if (data.children !== undefined) {
            const children = data.children;
            for(let i13 = 0; i13 < children.length; i13++)object.add(this.parseObject(children[i13], geometries, materials, animations));
        }
        if (data.animations !== undefined) {
            const objectAnimations = data.animations;
            for(let i13 = 0; i13 < objectAnimations.length; i13++){
                const uuid = objectAnimations[i13];
                object.animations.push(animations[uuid]);
            }
        }
        if (data.type === 'LOD') {
            if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
            const levels = data.levels;
            for(let l1 = 0; l1 < levels.length; l1++){
                const level = levels[l1];
                const child = object.getObjectByProperty('uuid', level.object);
                if (child !== undefined) object.addLevel(child, level.distance);
            }
        }
        return object;
    }
    bindSkeletons(object, skeletons) {
        if (Object.keys(skeletons).length === 0) return;
        object.traverse(function(child) {
            if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
                const skeleton = skeletons[child.skeleton];
                if (skeleton === undefined) console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
                else child.bind(skeleton, child.bindMatrix);
            }
        });
    }
    /* DEPRECATED */ setTexturePath(value) {
        console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
        return this.setResourcePath(value);
    }
}
const TEXTURE_MAPPING = {
    UVMapping: UVMapping,
    CubeReflectionMapping: CubeReflectionMapping,
    CubeRefractionMapping: CubeRefractionMapping,
    EquirectangularReflectionMapping: EquirectangularReflectionMapping,
    EquirectangularRefractionMapping: EquirectangularRefractionMapping,
    CubeUVReflectionMapping: CubeUVReflectionMapping,
    CubeUVRefractionMapping: CubeUVRefractionMapping
};
const TEXTURE_WRAPPING = {
    RepeatWrapping: RepeatWrapping,
    ClampToEdgeWrapping: ClampToEdgeWrapping,
    MirroredRepeatWrapping: MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
    NearestFilter: NearestFilter,
    NearestMipmapNearestFilter: NearestMipmapNearestFilter,
    NearestMipmapLinearFilter: NearestMipmapLinearFilter,
    LinearFilter: LinearFilter,
    LinearMipmapNearestFilter: LinearMipmapNearestFilter,
    LinearMipmapLinearFilter: LinearMipmapLinearFilter
};
function ImageBitmapLoader(manager1) {
    if (typeof createImageBitmap === 'undefined') console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
    if (typeof fetch === 'undefined') console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
    Loader.call(this, manager1);
    this.options = {
        premultiplyAlpha: 'none'
    };
}
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: ImageBitmapLoader,
    isImageBitmapLoader: true,
    setOptions: function setOptions(options4) {
        this.options = options4;
        return this;
    },
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope3 = this;
        const cached = Cache1.get(url);
        if (cached !== undefined) {
            scope3.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope3.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const fetchOptions = {
        };
        fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
        fetch(url, fetchOptions).then(function(res) {
            return res.blob();
        }).then(function(blob) {
            return createImageBitmap(blob, scope3.options);
        }).then(function(imageBitmap) {
            Cache1.add(url, imageBitmap);
            if (onLoad) onLoad(imageBitmap);
            scope3.manager.itemEnd(url);
        }).catch(function(e) {
            if (onError) onError(e);
            scope3.manager.itemError(url);
            scope3.manager.itemEnd(url);
        });
        scope3.manager.itemStart(url);
    }
});
function ShapePath() {
    this.type = 'ShapePath';
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
}
Object.assign(ShapePath.prototype, {
    moveTo: function(x6, y6) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x6, y6);
        return this;
    },
    lineTo: function(x6, y6) {
        this.currentPath.lineTo(x6, y6);
        return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
    },
    splineThru: function(pts) {
        this.currentPath.splineThru(pts);
        return this;
    },
    toShapes: function(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            const shapes4 = [];
            for(let i13 = 0, l1 = inSubpaths.length; i13 < l1; i13++){
                const tmpPath = inSubpaths[i13];
                const tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes4.push(tmpShape);
            }
            return shapes4;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            // inPt on polygon contour => immediate success    or
            // toggling of inside/outside at every single! intersection point of an edge
            //  with the horizontal line through inPt, left of inPt
            //  not counting lowerY endpoints of edges and whole edges on that line
            let inside = false;
            for(let p6 = polyLen - 1, q1 = 0; q1 < polyLen; p6 = q1++){
                let edgeLowPt = inPolygon[p6];
                let edgeHighPt = inPolygon[q1];
                let edgeDx = edgeHighPt.x - edgeLowPt.x;
                let edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    // not parallel
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q1];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p6];
                        edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                    // continue;				// no intersection or edgeLowPt => doesn't count !!!
                    } else {
                        const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0) return true; // inPt is on contour ?
                        if (perpEdge < 0) continue;
                        inside = !inside; // true intersection left of inPt
                    }
                } else {
                    // parallel or collinear
                    if (inPt.y !== edgeLowPt.y) continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
                // continue;
                }
            }
            return inside;
        }
        const isClockWise = ShapeUtils.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        if (noHoles === true) return toShapesNoHoles(subPaths);
        let solid, tmpPath, tmpShape;
        const shapes4 = [];
        if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape();
            tmpShape.curves = tmpPath.curves;
            shapes4.push(tmpShape);
            return shapes4;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        // console.log("Holes first", holesFirst);
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for(let i13 = 0, l1 = subPaths.length; i13 < l1; i13++){
            tmpPath = subPaths[i13];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                newShapes[mainIdx] = {
                    s: new Shape(),
                    p: tmpPoints
                };
                newShapes[mainIdx].s.curves = tmpPath.curves;
                if (holesFirst) mainIdx++;
                newShapeHoles[mainIdx] = [];
            //console.log('cw', i);
            } else newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
            });
        }
        // only Holes? -> probably all Shapes with wrong orientation
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)betterShapeHoles[sIdx] = [];
            for(let sIdx1 = 0, sLen1 = newShapes.length; sIdx1 < sLen1; sIdx1++){
                const sho = newShapeHoles[sIdx1];
                for(let hIdx = 0; hIdx < sho.length; hIdx++){
                    const ho = sho[hIdx];
                    let hole_unassigned = true;
                    for(let s2Idx = 0; s2Idx < newShapes.length; s2Idx++)if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (sIdx1 !== s2Idx) toChange.push({
                            froms: sIdx1,
                            tos: s2Idx,
                            hole: hIdx
                        });
                        if (hole_unassigned) {
                            hole_unassigned = false;
                            betterShapeHoles[s2Idx].push(ho);
                        } else ambiguous = true;
                    }
                    if (hole_unassigned) betterShapeHoles[sIdx1].push(ho);
                }
            }
            // console.log("ambiguous: ", ambiguous);
            if (toChange.length > 0) // console.log("to change: ", toChange);
            {
                if (!ambiguous) newShapeHoles = betterShapeHoles;
            }
        }
        let tmpHoles;
        for(let i14 = 0, il = newShapes.length; i14 < il; i14++){
            tmpShape = newShapes[i14].s;
            shapes4.push(tmpShape);
            tmpHoles = newShapeHoles[i14];
            for(let j6 = 0, jl = tmpHoles.length; j6 < jl; j6++)tmpShape.holes.push(tmpHoles[j6].h);
        }
        //console.log("shape", shapes);
        return shapes4;
    }
});
class Font {
    constructor(data){
        Object.defineProperty(this, 'isFont', {
            value: true
        });
        this.type = 'Font';
        this.data = data;
    }
    generateShapes(text, size = 100) {
        const shapes4 = [];
        const paths = createPaths(text, size, this.data);
        for(let p6 = 0, pl = paths.length; p6 < pl; p6++)Array.prototype.push.apply(shapes4, paths[p6].toShapes());
        return shapes4;
    }
}
function createPaths(text2, size2, data1) {
    const chars = Array.from ? Array.from(text2) : String(text2).split(''); // workaround for IE11, see #13988
    const scale = size2 / data1.resolution;
    const line_height = (data1.boundingBox.yMax - data1.boundingBox.yMin + data1.underlineThickness) * scale;
    const paths = [];
    let offsetX = 0, offsetY = 0;
    for(let i13 = 0; i13 < chars.length; i13++){
        const char = chars[i13];
        if (char === '\n') {
            offsetX = 0;
            offsetY -= line_height;
        } else {
            const ret = createPath(char, scale, offsetX, offsetY, data1);
            offsetX += ret.offsetX;
            paths.push(ret.path);
        }
    }
    return paths;
}
function createPath(char, scale, offsetX, offsetY, data1) {
    const glyph = data1.glyphs[char] || data1.glyphs['?'];
    if (!glyph) {
        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data1.familyName + '.');
        return;
    }
    const path1 = new ShapePath();
    let x6, y6, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
        const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
        for(let i13 = 0, l1 = outline.length; i13 < l1;){
            const action = outline[i13++];
            switch(action){
                case 'm':
                    x6 = outline[i13++] * scale + offsetX;
                    y6 = outline[i13++] * scale + offsetY;
                    path1.moveTo(x6, y6);
                    break;
                case 'l':
                    x6 = outline[i13++] * scale + offsetX;
                    y6 = outline[i13++] * scale + offsetY;
                    path1.lineTo(x6, y6);
                    break;
                case 'q':
                    cpx = outline[i13++] * scale + offsetX;
                    cpy = outline[i13++] * scale + offsetY;
                    cpx1 = outline[i13++] * scale + offsetX;
                    cpy1 = outline[i13++] * scale + offsetY;
                    path1.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                    break;
                case 'b':
                    cpx = outline[i13++] * scale + offsetX;
                    cpy = outline[i13++] * scale + offsetY;
                    cpx1 = outline[i13++] * scale + offsetX;
                    cpy1 = outline[i13++] * scale + offsetY;
                    cpx2 = outline[i13++] * scale + offsetX;
                    cpy2 = outline[i13++] * scale + offsetY;
                    path1.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                    break;
            }
        }
    }
    return {
        offsetX: glyph.ha * scale,
        path: path1
    };
}
function FontLoader(manager1) {
    Loader.call(this, manager1);
}
FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: FontLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope3.withCredentials);
        loader.load(url, function(text2) {
            let json;
            try {
                json = JSON.parse(text2);
            } catch (e) {
                console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                json = JSON.parse(text2.substring(65, text2.length - 2));
            }
            const font1 = scope3.parse(json);
            if (onLoad) onLoad(font1);
        }, onProgress, onError);
    },
    parse: function(json) {
        return new Font(json);
    }
});
let _context;
const AudioContext1 = {
    getContext: function() {
        if (_context === undefined) _context = new (window.AudioContext || window.webkitAudioContext)();
        return _context;
    },
    setContext: function(value) {
        _context = value;
    }
};
function AudioLoader(manager1) {
    Loader.call(this, manager1);
}
AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: AudioLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader(scope3.manager);
        loader.setResponseType('arraybuffer');
        loader.setPath(scope3.path);
        loader.setRequestHeader(scope3.requestHeader);
        loader.setWithCredentials(scope3.withCredentials);
        loader.load(url, function(buffer) {
            try {
                // Create a copy of the buffer. The `decodeAudioData` method
                // detaches the buffer when complete, preventing reuse.
                const bufferCopy = buffer.slice(0);
                const context = AudioContext1.getContext();
                context.decodeAudioData(bufferCopy, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope3.manager.itemError(url);
            }
        }, onProgress, onError);
    }
});
function HemisphereLightProbe(skyColor, groundColor, intensity) {
    LightProbe.call(this, undefined, intensity);
    const color11 = new Color().set(skyColor);
    const color21 = new Color().set(groundColor);
    const sky = new Vector3(color11.r, color11.g, color11.b);
    const ground = new Vector3(color21.r, color21.g, color21.b);
    // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
    const c0 = Math.sqrt(Math.PI);
    const c11 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c11);
}
HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
    constructor: HemisphereLightProbe,
    isHemisphereLightProbe: true,
    copy: function(source) {
        LightProbe.prototype.copy.call(this, source);
        return this;
    },
    toJSON: function(meta) {
        const data1 = LightProbe.prototype.toJSON.call(this, meta);
        // data.sh = this.sh.toArray(); // todo
        return data1;
    }
});
function AmbientLightProbe(color4, intensity) {
    LightProbe.call(this, undefined, intensity);
    const color11 = new Color().set(color4);
    // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
    this.sh.coefficients[0].set(color11.r, color11.g, color11.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
    constructor: AmbientLightProbe,
    isAmbientLightProbe: true,
    copy: function(source) {
        LightProbe.prototype.copy.call(this, source);
        return this;
    },
    toJSON: function(meta) {
        const data1 = LightProbe.prototype.toJSON.call(this, meta);
        // data.sh = this.sh.toArray(); // todo
        return data1;
    }
});
const _eyeRight = new Matrix4();
const _eyeLeft = new Matrix4();
function StereoCamera() {
    this.type = 'StereoCamera';
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null
    };
}
Object.assign(StereoCamera.prototype, {
    update: function(camera) {
        const cache = this._cache;
        const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            // Off-axis stereoscopic effect based on
            // http://paulbourke.net/stereographics/stereorender/
            const projectionMatrix = camera.projectionMatrix.clone();
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            // translate xOffset
            _eyeLeft.elements[12] = -eyeSepHalf;
            _eyeRight.elements[12] = eyeSepHalf;
            // for left eye
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(projectionMatrix);
            // for right eye
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
    }
});
class Clock {
    constructor(autoStart){
        this.autoStart = autoStart !== undefined ? autoStart : true;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
    }
    start() {
        this.startTime = now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
    }
    stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
    }
    getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
    }
    getDelta() {
        let diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
            return 0;
        }
        if (this.running) {
            const newTime = now();
            diff = (newTime - this.oldTime) / 1000;
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
}
function now() {
    return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
}
const _position$2 = /*@__PURE__*/ new Vector3();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();
const _scale$1 = /*@__PURE__*/ new Vector3();
const _orientation = /*@__PURE__*/ new Vector3();
class AudioListener1 extends Object3D {
    constructor(){
        super();
        this.type = 'AudioListener';
        this.context = AudioContext1.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
        this.timeDelta = 0;
        // private
        this._clock = new Clock();
    }
    getInput() {
        return this.gain;
    }
    removeFilter() {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
        }
        return this;
    }
    getFilter() {
        return this.filter;
    }
    setFilter(value) {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
        } else this.gain.disconnect(this.context.destination);
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
    }
    getMasterVolume() {
        return this.gain.gain.value;
    }
    setMasterVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        const listener = this.context.listener;
        const up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);
        _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);
        if (listener.positionX) {
            // code path for Chrome (see #14393)
            const endTime = this.context.currentTime + this.timeDelta;
            listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
            listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
            listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
            listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
            listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
            listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
            listener.upX.linearRampToValueAtTime(up.x, endTime);
            listener.upY.linearRampToValueAtTime(up.y, endTime);
            listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
            listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
            listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
        }
    }
}
class Audio1 extends Object3D {
    constructor(listener){
        super();
        this.type = 'Audio';
        this.listener = listener;
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = undefined;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.source = null;
        this.sourceType = 'empty';
        this._startedAt = 0;
        this._progress = 0;
        this._connected = false;
        this.filters = [];
    }
    getOutput() {
        return this.gain;
    }
    setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = 'audioNode';
        this.source = audioNode;
        this.connect();
        return this;
    }
    setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaNode';
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
    }
    setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaStreamNode';
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
    }
    setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = 'buffer';
        if (this.autoplay) this.play();
        return this;
    }
    play(delay = 0) {
        if (this.isPlaying === true) {
            console.warn('THREE.Audio: Audio is already playing.');
            return;
        }
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._startedAt = this.context.currentTime + delay;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
    }
    pause() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        if (this.isPlaying === true) {
            // update current progress
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) // ensure _progress does not exceed duration with looped audios
            this._progress = this._progress % (this.duration || this.buffer.duration);
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
        }
        return this;
    }
    stop() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for(let i13 = 1, l1 = this.filters.length; i13 < l1; i13++)this.filters[i13 - 1].connect(this.filters[i13]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        this._connected = true;
        return this;
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for(let i13 = 1, l1 = this.filters.length; i13 < l1; i13++)this.filters[i13 - 1].disconnect(this.filters[i13]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        this._connected = false;
        return this;
    }
    getFilters() {
        return this.filters;
    }
    setFilters(value) {
        if (!value) value = [];
        if (this._connected === true) {
            this.disconnect();
            this.filters = value.slice();
            this.connect();
        } else this.filters = value.slice();
        return this;
    }
    setDetune(value) {
        this.detune = value;
        if (this.source.detune === undefined) return; // only set detune when available
        if (this.isPlaying === true) this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        return this;
    }
    getDetune() {
        return this.detune;
    }
    getFilter() {
        return this.getFilters()[0];
    }
    setFilter(filter) {
        return this.setFilters(filter ? [
            filter
        ] : []);
    }
    setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        return this;
    }
    getPlaybackRate() {
        return this.playbackRate;
    }
    onEnded() {
        this.isPlaying = false;
    }
    getLoop() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return false;
        }
        return this.loop;
    }
    setLoop(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.loop = value;
        if (this.isPlaying === true) this.source.loop = this.loop;
        return this;
    }
    setLoopStart(value) {
        this.loopStart = value;
        return this;
    }
    setLoopEnd(value) {
        this.loopEnd = value;
        return this;
    }
    getVolume() {
        return this.gain.gain.value;
    }
    setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
}
const _position$3 = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _orientation$1 = /*@__PURE__*/ new Vector3();
class PositionalAudio extends Audio1 {
    constructor(listener1){
        super(listener1);
        this.panner = this.context.createPanner();
        this.panner.panningModel = 'HRTF';
        this.panner.connect(this.gain);
    }
    getOutput() {
        return this.panner;
    }
    getRefDistance() {
        return this.panner.refDistance;
    }
    setRefDistance(value) {
        this.panner.refDistance = value;
        return this;
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor;
    }
    setRolloffFactor(value) {
        this.panner.rolloffFactor = value;
        return this;
    }
    getDistanceModel() {
        return this.panner.distanceModel;
    }
    setDistanceModel(value) {
        this.panner.distanceModel = value;
        return this;
    }
    getMaxDistance() {
        return this.panner.maxDistance;
    }
    setMaxDistance(value) {
        this.panner.maxDistance = value;
        return this;
    }
    setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.hasPlaybackControl === true && this.isPlaying === false) return;
        this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);
        _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);
        const panner = this.panner;
        if (panner.positionX) {
            // code path for Chrome and Firefox (see #14393)
            const endTime = this.context.currentTime + this.listener.timeDelta;
            panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
            panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
            panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
            panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
            panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
            panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
        } else {
            panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
            panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
        }
    }
}
class AudioAnalyser {
    constructor(audio, fftSize = 2048){
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
    }
    getAverageFrequency() {
        let value = 0;
        const data1 = this.getFrequencyData();
        for(let i13 = 0; i13 < data1.length; i13++)value += data1[i13];
        return value / data1.length;
    }
}
function PropertyMixer(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
    //
    // interpolators can use .buffer as their .result
    // the data then goes to 'incoming'
    //
    // 'accu0' and 'accu1' are used frame-interleaved for
    // the cumulative result and are compared to detect
    // changes
    //
    // 'orig' stores the original state of the property
    //
    // 'add' is used for additive cumulative results
    //
    // 'work' is optional and is only present for quaternion types. It is used
    // to store intermediate quaternion multiplication results
    switch(typeName){
        case 'quaternion':
            mixFunction = this._slerp;
            mixFunctionAdditive = this._slerpAdditive;
            setIdentity = this._setAdditiveIdentityQuaternion;
            this.buffer = new Float64Array(valueSize * 6);
            this._workIndex = 5;
            break;
        case 'string':
        case 'bool':
            mixFunction = this._select;
            // Use the regular mix function and for additive on these types,
            // additive is not relevant for non-numeric types
            mixFunctionAdditive = this._select;
            setIdentity = this._setAdditiveIdentityOther;
            this.buffer = new Array(valueSize * 5);
            break;
        default:
            mixFunction = this._lerp;
            mixFunctionAdditive = this._lerpAdditive;
            setIdentity = this._setAdditiveIdentityNumeric;
            this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
}
Object.assign(PropertyMixer.prototype, {
    // accumulate data in the 'incoming' region into 'accu<i>'
    accumulate: function(accuIndex, weight) {
        // note: happily accumulating nothing when weight = 0, the caller knows
        // the weight and shouldn't have made the call in the first place
        const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
            // accuN := incoming * weight
            for(let i13 = 0; i13 !== stride; ++i13)buffer[offset + i13] = buffer[i13];
            currentWeight = weight;
        } else {
            // accuN := accuN + incoming * weight
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
    },
    // accumulate data in the 'incoming' region into 'add'
    accumulateAdditive: function(weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) // add = identity
        this._setIdentity();
        // add := add + incoming * weight
        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
    },
    // apply the state of 'accu<i>' to the binding when accus differ
    apply: function(accuIndex) {
        const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
            // accuN := accuN + original * ( 1 - cumulativeWeight )
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) // accuN := accuN + additive accuN
        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        for(let i13 = stride, e = stride + stride; i13 !== e; ++i13)if (buffer[i13] !== buffer[i13 + stride]) {
            // value has changed -> update scene graph
            binding.setValue(buffer, offset);
            break;
        }
    },
    // remember the state of the bound property and copy it to both accus
    saveOriginalState: function() {
        const binding = this.binding;
        const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        // accu[0..1] := orig -- initially detect changes against the original
        for(let i13 = stride, e = originalValueOffset; i13 !== e; ++i13)buffer[i13] = buffer[originalValueOffset + i13 % stride];
        // Add to identity for additive
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
    },
    // apply the state previously taken via 'saveOriginalState' to the binding
    restoreOriginalState: function() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
    },
    _setAdditiveIdentityNumeric: function() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for(let i13 = startIndex; i13 < endIndex; i13++)this.buffer[i13] = 0;
    },
    _setAdditiveIdentityQuaternion: function() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
    },
    _setAdditiveIdentityOther: function() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for(let i13 = 0; i13 < this.valueSize; i13++)this.buffer[targetIndex + i13] = this.buffer[startIndex + i13];
    },
    // mix functions
    _select: function(buffer, dstOffset, srcOffset, t2, stride) {
        if (t2 >= 0.5) for(let i13 = 0; i13 !== stride; ++i13)buffer[dstOffset + i13] = buffer[srcOffset + i13];
    },
    _slerp: function(buffer, dstOffset, srcOffset, t2) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
    },
    _slerpAdditive: function(buffer, dstOffset, srcOffset, t2, stride) {
        const workOffset = this._workIndex * stride;
        // Store result in intermediate buffer offset
        Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        // Slerp to the intermediate result
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
    },
    _lerp: function(buffer, dstOffset, srcOffset, t2, stride) {
        const s2 = 1 - t2;
        for(let i13 = 0; i13 !== stride; ++i13){
            const j6 = dstOffset + i13;
            buffer[j6] = buffer[j6] * s2 + buffer[srcOffset + i13] * t2;
        }
    },
    _lerpAdditive: function(buffer, dstOffset, srcOffset, t2, stride) {
        for(let i13 = 0; i13 !== stride; ++i13){
            const j6 = dstOffset + i13;
            buffer[j6] = buffer[j6] + buffer[srcOffset + i13] * t2;
        }
    }
});
// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');
// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';
// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);
// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);
// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);
// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
const _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
const _supportedObjectNames = [
    'material',
    'materials',
    'bones'
];
function Composite(targetGroup, path1, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path1);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path1, parsedPath);
}
Object.assign(Composite.prototype, {
    getValue: function(array, offset) {
        this.bind(); // bind all binding
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        // and only call .getValue on the first
        if (binding !== undefined) binding.getValue(array, offset);
    },
    setValue: function(array, offset) {
        const bindings = this._bindings;
        for(let i13 = this._targetGroup.nCachedObjects_, n = bindings.length; i13 !== n; ++i13)bindings[i13].setValue(array, offset);
    },
    bind: function() {
        const bindings = this._bindings;
        for(let i13 = this._targetGroup.nCachedObjects_, n = bindings.length; i13 !== n; ++i13)bindings[i13].bind();
    },
    unbind: function() {
        const bindings = this._bindings;
        for(let i13 = this._targetGroup.nCachedObjects_, n = bindings.length; i13 !== n; ++i13)bindings[i13].unbind();
    }
});
function PropertyBinding(rootNode, path1, parsedPath) {
    this.path = path1;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path1);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
    Composite: Composite,
    create: function(root, path1, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) return new PropertyBinding(root, path1, parsedPath);
        else return new PropertyBinding.Composite(root, path1, parsedPath);
    },
    /**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */ sanitizeNodeName: function(name) {
        return name.replace(/\s/g, '_').replace(_reservedRe, '');
    },
    parseTrackName: function(trackName) {
        const matches = _trackRe.exec(trackName);
        if (!matches) throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
        const results = {
            // directoryName: matches[ 1 ], // (tschw) currently unused
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
        if (lastDot !== undefined && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            // Object names must be checked against an allowlist. Otherwise, there
            // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
            // 'bar' could be the objectName, or part of a nodeName (which can
            // include '.' characters).
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
                results.nodeName = results.nodeName.substring(0, lastDot);
                results.objectName = objectName;
            }
        }
        if (results.propertyName === null || results.propertyName.length === 0) throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
        return results;
    },
    findNode: function(root, nodeName) {
        if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) return root;
        // search into skeleton bones.
        if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== undefined) return bone;
        }
        // search into node subtree.
        if (root.children) {
            const searchNodeSubtree = function(children) {
                for(let i13 = 0; i13 < children.length; i13++){
                    const childNode = children[i13];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                    const result = searchNodeSubtree(childNode.children);
                    if (result) return result;
                }
                return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) return subTreeNode;
        }
        return null;
    }
});
Object.assign(PropertyBinding.prototype, {
    // these are used to "bind" a nonexistent property
    _getValue_unavailable: function() {
    },
    _setValue_unavailable: function() {
    },
    BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [
        function getValue_direct(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        },
        function getValue_array(buffer, offset) {
            const source = this.resolvedProperty;
            for(let i13 = 0, n = source.length; i13 !== n; ++i13)buffer[offset++] = source[i13];
        },
        function getValue_arrayElement(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        },
        function getValue_toArray(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        }
    ],
    SetterByBindingTypeAndVersioning: [
        [
            // Direct
            function setValue_direct(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
            },
            function setValue_direct_setNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // EntireArray
            function setValue_array(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i13 = 0, n = dest.length; i13 !== n; ++i13)dest[i13] = buffer[offset++];
            },
            function setValue_array_setNeedsUpdate(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i13 = 0, n = dest.length; i13 !== n; ++i13)dest[i13] = buffer[offset++];
                this.targetObject.needsUpdate = true;
            },
            function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i13 = 0, n = dest.length; i13 !== n; ++i13)dest[i13] = buffer[offset++];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // ArrayElement
            function setValue_arrayElement(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
            },
            function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // HasToFromArray
            function setValue_fromArray(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
            },
            function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.needsUpdate = true;
            },
            function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ]
    ],
    getValue: function getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
    // Note: This class uses a State pattern on a per-method basis:
    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
    // prototype version of these methods with one that represents
    // the bound state. When the property is not found, the methods
    // become no-ops.
    },
    setValue: function getValue_unbound1(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
    },
    // create getter / setter pair for a property in the scene graph
    bind: function() {
        let targetObject = this.node;
        const parsedPath = this.parsedPath;
        const objectName = parsedPath.objectName;
        const propertyName = parsedPath.propertyName;
        let propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
        }
        // set fail state so we can just 'return' on error
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        // ensure there is a value node
        if (!targetObject) {
            console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
            return;
        }
        if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            // special cases were we need to reach deeper into the hierarchy to get the face materials....
            switch(objectName){
                case 'materials':
                    if (!targetObject.material) {
                        console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                        return;
                    }
                    if (!targetObject.material.materials) {
                        console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                        return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                case 'bones':
                    if (!targetObject.skeleton) {
                        console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                        return;
                    }
                    // potential future optimization: skip this if propertyIndex is already an integer
                    // and convert the integer string to a true integer.
                    targetObject = targetObject.skeleton.bones;
                    // support resolving morphTarget names into indices.
                    for(let i13 = 0; i13 < targetObject.length; i13++)if (targetObject[i13].name === objectIndex) {
                        objectIndex = i13;
                        break;
                    }
                    break;
                default:
                    if (targetObject[objectName] === undefined) {
                        console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                        return;
                    }
                    targetObject = targetObject[objectName];
            }
            if (objectIndex !== undefined) {
                if (targetObject[objectIndex] === undefined) {
                    console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                    return;
                }
                targetObject = targetObject[objectIndex];
            }
        }
        // resolve property
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
            const nodeName = parsedPath.nodeName;
            console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
            return;
        }
        // determine versioning scheme
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== undefined) versioning = this.Versioning.NeedsUpdate;
        else if (targetObject.matrixWorldNeedsUpdate !== undefined) versioning = this.Versioning.MatrixWorldNeedsUpdate;
        // determine how the property gets bound
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
            // access a sub element of the property array (only primitives are supported right now)
            if (propertyName === 'morphTargetInfluences') {
                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                // support resolving morphTarget names into indices.
                if (!targetObject.geometry) {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                    return;
                }
                if (targetObject.geometry.isBufferGeometry) {
                    if (!targetObject.geometry.morphAttributes) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                        return;
                    }
                    if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                } else {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
                    return;
                }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
            // must use copy for Object3D.Euler/Quaternion
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
        } else this.propertyName = propertyName;
        // select getter / setter
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    },
    unbind: function() {
        this.node = null;
        // back to the prototype version of getValue / setValue
        // note: avoiding to mutate the shape of 'this' via 'delete'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
});
// DECLARE ALIAS AFTER assign prototype
Object.assign(PropertyBinding.prototype, {
    // initial state of these methods that calls 'bind'
    _getValue_unbound: PropertyBinding.prototype.getValue,
    _setValue_unbound: PropertyBinding.prototype.setValue
});
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */ function AnimationObjectGroup() {
    this.uuid = MathUtils.generateUUID();
    // cached objects followed by the active ones
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0; // threshold
    // note: read by PropertyBinding.Composite
    const indices16 = {
    };
    this._indicesByUUID = indices16; // for bookkeeping
    for(let i13 = 0, n = arguments.length; i13 !== n; ++i13)indices16[arguments[i13].uuid] = i13;
    this._paths = []; // inside: string
    this._parsedPaths = []; // inside: { we don't care, here }
    this._bindings = []; // inside: Array< PropertyBinding >
    this._bindingsIndicesByPath = {
    }; // inside: indices in these arrays
    const scope3 = this;
    this.stats = {
        objects: {
            get total () {
                return scope3._objects.length;
            },
            get inUse () {
                return this.total - scope3.nCachedObjects_;
            }
        },
        get bindingsPerObject () {
            return scope3._bindings.length;
        }
    };
}
Object.assign(AnimationObjectGroup.prototype, {
    isAnimationObjectGroup: true,
    add: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        let knownObject = undefined, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for(let i13 = 0, n = arguments.length; i13 !== n; ++i13){
            const object = arguments[i13], uuid = object.uuid;
            let index2 = indicesByUUID[uuid];
            if (index2 === undefined) {
                // unknown object -> add it to the ACTIVE region
                index2 = nObjects++;
                indicesByUUID[uuid] = index2;
                objects.push(object);
                // accounting is done, now do the same for all bindings
                for(let j6 = 0, m = nBindings; j6 !== m; ++j6)bindings[j6].push(new PropertyBinding(object, paths[j6], parsedPaths[j6]));
            } else if (index2 < nCachedObjects) {
                knownObject = objects[index2];
                // move existing object to the ACTIVE region
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                indicesByUUID[lastCachedObject.uuid] = index2;
                objects[index2] = lastCachedObject;
                indicesByUUID[uuid] = firstActiveIndex;
                objects[firstActiveIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j6 = 0, m = nBindings; j6 !== m; ++j6){
                    const bindingsForPath = bindings[j6], lastCached = bindingsForPath[firstActiveIndex];
                    let binding = bindingsForPath[index2];
                    bindingsForPath[index2] = lastCached;
                    if (binding === undefined) // since we do not bother to create new bindings
                    // for objects that are cached, the binding may
                    // or may not exist
                    binding = new PropertyBinding(object, paths[j6], parsedPaths[j6]);
                    bindingsForPath[firstActiveIndex] = binding;
                }
            } else if (objects[index2] !== knownObject) console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
             // else the object is already where we want it to be
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    remove: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_;
        for(let i13 = 0, n = arguments.length; i13 !== n; ++i13){
            const object = arguments[i13], uuid = object.uuid, index2 = indicesByUUID[uuid];
            if (index2 !== undefined && index2 >= nCachedObjects) {
                // move existing object into the CACHED region
                const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                indicesByUUID[firstActiveObject.uuid] = index2;
                objects[index2] = firstActiveObject;
                indicesByUUID[uuid] = lastCachedIndex;
                objects[lastCachedIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j6 = 0, m = nBindings; j6 !== m; ++j6){
                    const bindingsForPath = bindings[j6], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index2];
                    bindingsForPath[index2] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding;
                }
            }
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    // remove & forget
    uncache: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for(let i13 = 0, n = arguments.length; i13 !== n; ++i13){
            const object = arguments[i13], uuid = object.uuid, index2 = indicesByUUID[uuid];
            if (index2 !== undefined) {
                delete indicesByUUID[uuid];
                if (index2 < nCachedObjects) {
                    // object is cached, shrink the CACHED region
                    const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    // last cached object takes this object's place
                    indicesByUUID[lastCachedObject.uuid] = index2;
                    objects[index2] = lastCachedObject;
                    // last object goes to the activated slot and pop
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j6 = 0, m = nBindings; j6 !== m; ++j6){
                        const bindingsForPath = bindings[j6], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index2] = lastCached;
                        bindingsForPath[firstActiveIndex] = last;
                        bindingsForPath.pop();
                    }
                } else {
                    // object is active, just swap with the last and pop
                    const lastIndex = --nObjects, lastObject = objects[lastIndex];
                    if (lastIndex > 0) indicesByUUID[lastObject.uuid] = index2;
                    objects[index2] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j6 = 0, m = nBindings; j6 !== m; ++j6){
                        const bindingsForPath = bindings[j6];
                        bindingsForPath[index2] = bindingsForPath[lastIndex];
                        bindingsForPath.pop();
                    }
                } // cached or active
            } // if object is known
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    // Internal interface used by befriended PropertyBinding.Composite:
    subscribe_: function(path1, parsedPath) {
        // returns an array of bindings for the given path that is changed
        // according to the contained objects in the group
        const indicesByPath = this._bindingsIndicesByPath;
        let index2 = indicesByPath[path1];
        const bindings = this._bindings;
        if (index2 !== undefined) return bindings[index2];
        const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index2 = bindings.length;
        indicesByPath[path1] = index2;
        paths.push(path1);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for(let i13 = nCachedObjects, n = objects.length; i13 !== n; ++i13){
            const object = objects[i13];
            bindingsForPath[i13] = new PropertyBinding(object, path1, parsedPath);
        }
        return bindingsForPath;
    },
    unsubscribe_: function(path1) {
        // tells the group to forget about a property path and no longer
        // update the array previously obtained with 'subscribe_'
        const indicesByPath = this._bindingsIndicesByPath, index2 = indicesByPath[path1];
        if (index2 !== undefined) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path1[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index2;
            bindings[index2] = lastBindings;
            bindings.pop();
            parsedPaths[index2] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index2] = paths[lastBindingsIndex];
            paths.pop();
        }
    }
});
class AnimationAction {
    constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode){
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot;
        this.blendMode = blendMode;
        const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        const interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };
        for(let i13 = 0; i13 !== nTracks; ++i13){
            const interpolant = tracks[i13].createInterpolant(null);
            interpolants[i13] = interpolant;
            interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants; // bound by the mixer
        // inside: PropertyMixer (managed by the mixer)
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null; // for the memory manager
        this._byClipCacheIndex = null; // for the memory manager
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat;
        this._loopCount = -1;
        // global mixer time when the action is to be started
        // it's set back to 'null' upon start of the action
        this._startTime = null;
        // scaled local time of the action
        // gets clamped or wrapped to 0..clip.duration according to loop
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity; // no. of repetitions when looping
        this.paused = false; // true -> zero effective time scale
        this.enabled = true; // false -> zero effective weight
        this.clampWhenFinished = false; // keep feeding the last frame?
        this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
        this.zeroSlopeAtEnd = true; // clips for start, loop and end
    }
    // State & Scheduling
    play() {
        this._mixer._activateAction(this);
        return this;
    }
    stop() {
        this._mixer._deactivateAction(this);
        return this.reset();
    }
    reset() {
        this.paused = false;
        this.enabled = true;
        this.time = 0; // restart clip
        this._loopCount = -1; // forget previous loops
        this._startTime = null; // forget scheduling
        return this.stopFading().stopWarping();
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    // return true when play has been called
    isScheduled() {
        return this._mixer._isActiveAction(this);
    }
    startAt(time) {
        this._startTime = time;
        return this;
    }
    setLoop(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
    }
    // Weight
    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    setEffectiveWeight(weight) {
        this.weight = weight;
        // note: same logic as when updated at runtime
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
    }
    // return the weight considering fading and .enabled
    getEffectiveWeight() {
        return this._effectiveWeight;
    }
    fadeIn(duration) {
        return this._scheduleFading(duration, 0, 1);
    }
    fadeOut(duration) {
        return this._scheduleFading(duration, 1, 0);
    }
    crossFadeFrom(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
        }
        return this;
    }
    crossFadeTo(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
    }
    stopFading() {
        const weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
    }
    // Time Scale Control
    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    setEffectiveTimeScale(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
    }
    // return the time scale considering warping and .paused
    getEffectiveTimeScale() {
        return this._effectiveTimeScale;
    }
    setDuration(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
    }
    syncWith(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
    }
    halt(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
    }
    warp(startTimeScale, endTimeScale, duration) {
        const mixer1 = this._mixer, now1 = mixer1.time, timeScale = this.timeScale;
        let interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
            interpolant = mixer1._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now1;
        times[1] = now1 + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
    }
    stopWarping() {
        const timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
    }
    // Object Accessors
    getMixer() {
        return this._mixer;
    }
    getClip() {
        return this._clip;
    }
    getRoot() {
        return this._localRoot || this._mixer._root;
    }
    // Interna
    _update(time, deltaTime, timeDirection, accuIndex) {
        // called by the mixer
        if (!this.enabled) {
            // call ._updateWeight() to update ._effectiveWeight
            this._updateWeight(time);
            return;
        }
        const startTime = this._startTime;
        if (startTime !== null) {
            // check for scheduled start of action
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) return; // yet to come / don't decide when delta = 0
            // start
            this._startTime = null; // unschedule
            deltaTime = timeDirection * timeRunning;
        }
        // apply time scale and advance time
        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime);
        // note: _updateTime may disable the action resulting in
        // an effective weight of 0
        const weight = this._updateWeight(time);
        if (weight > 0) {
            const interpolants1 = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch(this.blendMode){
                case AdditiveAnimationBlendMode:
                    for(let j6 = 0, m = interpolants1.length; j6 !== m; ++j6){
                        interpolants1[j6].evaluate(clipTime);
                        propertyMixers[j6].accumulateAdditive(weight);
                    }
                    break;
                case NormalAnimationBlendMode:
                default:
                    for(let j7 = 0, m1 = interpolants1.length; j7 !== m1; ++j7){
                        interpolants1[j7].evaluate(clipTime);
                        propertyMixers[j7].accumulate(accuIndex, weight);
                    }
            }
        }
    }
    _updateWeight(time) {
        let weight = 0;
        if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                weight *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) // faded out, disable
                    this.enabled = false;
                }
            }
        }
        this._effectiveWeight = weight;
        return weight;
    }
    _updateTimeScale(time) {
        let timeScale = 0;
        if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                timeScale *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) // motion has halted, pause
                    this.paused = true;
                    else // warp done - apply final time scale
                    this.timeScale = timeScale;
                }
            }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
    }
    _updateTime(deltaTime) {
        const duration = this._clip.duration;
        const loop = this.loop;
        let time = this.time + deltaTime;
        let loopCount = this._loopCount;
        const pingPong = loop === LoopPingPong;
        if (deltaTime === 0) {
            if (loopCount === -1) return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === LoopOnce) {
            if (loopCount === -1) {
                // just started
                this._loopCount = 0;
                this._setEndings(true, true, false);
            }
            handle_stop: {
                if (time >= duration) time = duration;
                else if (time < 0) time = 0;
                else {
                    this.time = time;
                    break handle_stop;
                }
                if (this.clampWhenFinished) this.paused = true;
                else this.enabled = false;
                this.time = time;
                this._mixer.dispatchEvent({
                    type: 'finished',
                    action: this,
                    direction: deltaTime < 0 ? -1 : 1
                });
            }
        } else {
            if (loopCount === -1) {
                // just started
                if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(true, this.repetitions === 0, pingPong);
                } else // when looping in reverse direction, the initial
                // transition through zero counts as a repetition,
                // so leave loopCount at -1
                this._setEndings(this.repetitions === 0, true, pingPong);
            }
            if (time >= duration || time < 0) {
                // wrap around
                const loopDelta = Math.floor(time / duration); // signed
                time -= duration * loopDelta;
                loopCount += Math.abs(loopDelta);
                const pending = this.repetitions - loopCount;
                if (pending <= 0) {
                    // have to stop (switch state, clamp time, fire event)
                    if (this.clampWhenFinished) this.paused = true;
                    else this.enabled = false;
                    time = deltaTime > 0 ? duration : 0;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    });
                } else {
                    // keep running
                    if (pending === 1) {
                        // entering the last round
                        const atStart = deltaTime < 0;
                        this._setEndings(atStart, !atStart, pingPong);
                    } else this._setEndings(false, false, pingPong);
                    this._loopCount = loopCount;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'loop',
                        action: this,
                        loopDelta: loopDelta
                    });
                }
            } else this.time = time;
            if (pingPong && (loopCount & 1) === 1) // invert time for the "pong round"
            return duration - time;
        }
        return time;
    }
    _setEndings(atStart, atEnd, pingPong) {
        const settings = this._interpolantSettings;
        if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
        } else {
            // assuming for LoopOnce atStart == atEnd == true
            if (atStart) settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            else settings.endingStart = WrapAroundEnding;
            if (atEnd) settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            else settings.endingEnd = WrapAroundEnding;
        }
    }
    _scheduleFading(duration, weightNow, weightThen) {
        const mixer1 = this._mixer, now1 = mixer1.time;
        let interpolant = this._weightInterpolant;
        if (interpolant === null) {
            interpolant = mixer1._lendControlInterpolant();
            this._weightInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now1;
        values[0] = weightNow;
        times[1] = now1 + duration;
        values[1] = weightThen;
        return this;
    }
}
function AnimationMixer(root) {
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
}
AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: AnimationMixer,
    _bindAction: function(action, prototypeAction) {
        const root = action._localRoot || this._root, tracks1 = action._clip.tracks, nTracks1 = tracks1.length, bindings = action._propertyBindings, interpolants1 = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
        let bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === undefined) {
            bindingsByName = {
            };
            bindingsByRoot[rootUuid] = bindingsByName;
        }
        for(let i14 = 0; i14 !== nTracks1; ++i14){
            const track = tracks1[i14], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== undefined) bindings[i14] = binding;
            else {
                binding = bindings[i14];
                if (binding !== undefined) {
                    // existing binding, make sure the cache knows
                    if (binding._cacheIndex === null) {
                        ++binding.referenceCount;
                        this._addInactiveBinding(binding, rootUuid, trackName);
                    }
                    continue;
                }
                const path1 = prototypeAction && prototypeAction._propertyBindings[i14].binding.parsedPath;
                binding = new PropertyMixer(PropertyBinding.create(root, trackName, path1), track.ValueTypeName, track.getValueSize());
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
                bindings[i14] = binding;
            }
            interpolants1[i14].resultBuffer = binding.buffer;
        }
    },
    _activateAction: function(action) {
        if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
                // this action has been forgotten by the cache, but the user
                // appears to be still using it -> rebind
                const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            // increment reference counts / sort out state
            for(let i14 = 0, n = bindings.length; i14 !== n; ++i14){
                const binding = bindings[i14];
                if ((binding.useCount++) === 0) {
                    this._lendBinding(binding);
                    binding.saveOriginalState();
                }
            }
            this._lendAction(action);
        }
    },
    _deactivateAction: function(action) {
        if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            // decrement reference counts / sort out state
            for(let i14 = 0, n = bindings.length; i14 !== n; ++i14){
                const binding = bindings[i14];
                if ((--binding.useCount) === 0) {
                    binding.restoreOriginalState();
                    this._takeBackBinding(binding);
                }
            }
            this._takeBackAction(action);
        }
    },
    // Memory manager
    _initMemoryManager: function() {
        this._actions = []; // 'nActiveActions' followed by inactive ones
        this._nActiveActions = 0;
        this._actionsByClip = {
        };
        // inside:
        // {
        // 	knownActions: Array< AnimationAction > - used as prototypes
        // 	actionByRoot: AnimationAction - lookup
        // }
        this._bindings = []; // 'nActiveBindings' followed by inactive ones
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {
        }; // inside: Map< name, PropertyMixer >
        this._controlInterpolants = []; // same game as above
        this._nActiveControlInterpolants = 0;
        const scope3 = this;
        this.stats = {
            actions: {
                get total () {
                    return scope3._actions.length;
                },
                get inUse () {
                    return scope3._nActiveActions;
                }
            },
            bindings: {
                get total () {
                    return scope3._bindings.length;
                },
                get inUse () {
                    return scope3._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total () {
                    return scope3._controlInterpolants.length;
                },
                get inUse () {
                    return scope3._nActiveControlInterpolants;
                }
            }
        };
    },
    // Memory management for AnimationAction objects
    _isActiveAction: function(action) {
        const index2 = action._cacheIndex;
        return index2 !== null && index2 < this._nActiveActions;
    },
    _addInactiveAction: function(action, clipUuid, rootUuid) {
        const actions = this._actions, actionsByClip = this._actionsByClip;
        let actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === undefined) {
            actionsForClip = {
                knownActions: [
                    action
                ],
                actionByRoot: {
                }
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
        } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
    },
    _removeInactiveAction: function(action) {
        const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) delete actionsByClip[clipUuid];
        this._removeInactiveBindingsForAction(action);
    },
    _removeInactiveBindingsForAction: function(action) {
        const bindings = action._propertyBindings;
        for(let i14 = 0, n = bindings.length; i14 !== n; ++i14){
            const binding = bindings[i14];
            if ((--binding.referenceCount) === 0) this._removeInactiveBinding(binding);
        }
    },
    _lendAction: function(action) {
        // [ active actions |  inactive actions  ]
        // [  active actions >| inactive actions ]
        //                 s        a
        //                  <-swap->
        //                 a        s
        const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
    },
    _takeBackAction: function(action) {
        // [  active actions  | inactive actions ]
        // [ active actions |< inactive actions  ]
        //        a        s
        //         <-swap->
        //        s        a
        const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
    },
    // Memory management for PropertyMixer objects
    _addInactiveBinding: function(binding, rootUuid, trackName) {
        const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        let bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === undefined) {
            bindingByName = {
            };
            bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
    },
    _removeInactiveBinding: function(binding) {
        const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) delete bindingsByRoot[rootUuid];
    },
    _lendBinding: function(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
    },
    _takeBackBinding: function(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
    },
    // Memory management of Interpolants for weight and time scale
    _lendControlInterpolant: function() {
        const interpolants1 = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        let interpolant = interpolants1[lastActiveIndex];
        if (interpolant === undefined) {
            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants1[lastActiveIndex] = interpolant;
        }
        return interpolant;
    },
    _takeBackControlInterpolant: function(interpolant) {
        const interpolants1 = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants1[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants1[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants1[prevIndex] = lastActiveInterpolant;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
    clipAction: function(clip1, optionalRoot, blendMode1) {
        const root = optionalRoot || this._root, rootUuid = root.uuid;
        let clipObject = typeof clip1 === 'string' ? AnimationClip.findByName(root, clip1) : clip1;
        const clipUuid = clipObject !== null ? clipObject.uuid : clip1;
        const actionsForClip = this._actionsByClip[clipUuid];
        let prototypeAction = null;
        if (blendMode1 === undefined) {
            if (clipObject !== null) blendMode1 = clipObject.blendMode;
            else blendMode1 = NormalAnimationBlendMode;
        }
        if (actionsForClip !== undefined) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== undefined && existingAction.blendMode === blendMode1) return existingAction;
            // we know the clip, so we don't have to parse all
            // the bindings again but can just copy
            prototypeAction = actionsForClip.knownActions[0];
            // also, take the clip from the prototype action
            if (clipObject === null) clipObject = prototypeAction._clip;
        }
        // clip must be known when specified via string
        if (clipObject === null) return null;
        // allocate all resources required to run it
        const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode1);
        this._bindAction(newAction, prototypeAction);
        // and make the action known to the memory manager
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
    },
    // get an existing action
    existingAction: function(clip1, optionalRoot) {
        const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip1 === 'string' ? AnimationClip.findByName(root, clip1) : clip1, clipUuid = clipObject ? clipObject.uuid : clip1, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== undefined) return actionsForClip.actionByRoot[rootUuid] || null;
        return null;
    },
    // deactivates all previously scheduled actions
    stopAllAction: function() {
        const actions = this._actions, nActions = this._nActiveActions;
        for(let i14 = nActions - 1; i14 >= 0; --i14)actions[i14].stop();
        return this;
    },
    // advance the time and update apply the animation
    update: function(deltaTime) {
        deltaTime *= this.timeScale;
        const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        // run active actions
        for(let i14 = 0; i14 !== nActions; ++i14){
            const action = actions[i14];
            action._update(time, deltaTime, timeDirection, accuIndex);
        }
        // update scene graph
        const bindings = this._bindings, nBindings = this._nActiveBindings;
        for(let i15 = 0; i15 !== nBindings; ++i15)bindings[i15].apply(accuIndex);
        return this;
    },
    // Allows you to seek to a specific time in an animation.
    setTime: function(timeInSeconds) {
        this.time = 0; // Zero out time attribute for AnimationMixer object;
        for(let i14 = 0; i14 < this._actions.length; i14++)this._actions[i14].time = 0; // Zero out time attribute for all associated AnimationAction objects.
        return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
    },
    // return this mixer's root target object
    getRoot: function() {
        return this._root;
    },
    // free all resources specific to a particular clip
    uncacheClip: function(clip1) {
        const actions = this._actions, clipUuid = clip1.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            // note: just calling _removeInactiveAction would mess up the
            // iteration state and also require updating the state we can
            // just throw away
            const actionsToRemove = actionsForClip.knownActions;
            for(let i14 = 0, n = actionsToRemove.length; i14 !== n; ++i14){
                const action = actionsToRemove[i14];
                this._deactivateAction(action);
                const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                action._cacheIndex = null;
                action._byClipCacheIndex = null;
                lastInactiveAction._cacheIndex = cacheIndex;
                actions[cacheIndex] = lastInactiveAction;
                actions.pop();
                this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
        }
    },
    // free all resources specific to a particular root target object
    uncacheRoot: function(root) {
        const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for(const clipUuid in actionsByClip){
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== undefined) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
        const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== undefined) for(const trackName in bindingByName){
            const binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
        }
    },
    // remove a targeted clip from the cache
    uncacheAction: function(clip1, optionalRoot) {
        const action = this.existingAction(clip1, optionalRoot);
        if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
        }
    }
});
class Uniform {
    constructor(value){
        if (typeof value === 'string') {
            console.warn('THREE.Uniform: Type parameter is no longer needed.');
            value = arguments[1];
        }
        this.value = value;
    }
    clone() {
        return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
    }
}
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
    InterleavedBuffer.call(this, array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
    constructor: InstancedInterleavedBuffer,
    isInstancedInterleavedBuffer: true,
    copy: function(source) {
        InterleavedBuffer.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    },
    clone: function(data1) {
        const ib = InterleavedBuffer.prototype.clone.call(this, data1);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
    },
    toJSON: function(data1) {
        const json = InterleavedBuffer.prototype.toJSON.call(this, data1);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
    }
});
function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
}
Object.defineProperty(GLBufferAttribute.prototype, 'needsUpdate', {
    set: function(value1) {
        if (value1 === true) this.version++;
    }
});
Object.assign(GLBufferAttribute.prototype, {
    isGLBufferAttribute: true,
    setBuffer: function(buffer) {
        this.buffer = buffer;
        return this;
    },
    setType: function(type, elementSize) {
        this.type = type;
        this.elementSize = elementSize;
        return this;
    },
    setItemSize: function(itemSize) {
        this.itemSize = itemSize;
        return this;
    },
    setCount: function(count) {
        this.count = count;
        return this;
    }
});
function Raycaster(origin2, direction2, near1, far1) {
    this.ray = new Ray(origin2, direction2);
    // direction is assumed to be normalized (for accurate distance calculations)
    this.near = near1 || 0;
    this.far = far1 || Infinity;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
        Mesh: {
        },
        Line: {
            threshold: 1
        },
        LOD: {
        },
        Points: {
            threshold: 1
        },
        Sprite: {
        }
    };
    Object.defineProperties(this.params, {
        PointCloud: {
            get: function() {
                console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                return this.Points;
            }
        }
    });
}
function ascSort(a3, b4) {
    return a3.distance - b4.distance;
}
function intersectObject(object, raycaster, intersects1, recursive) {
    if (object.layers.test(raycaster.layers)) object.raycast(raycaster, intersects1);
    if (recursive === true) {
        const children = object.children;
        for(let i14 = 0, l1 = children.length; i14 < l1; i14++)intersectObject(children[i14], raycaster, intersects1, true);
    }
}
Object.assign(Raycaster.prototype, {
    set: function(origin2, direction2) {
        // direction is assumed to be normalized (for accurate distance calculations)
        this.ray.set(origin2, direction2);
    },
    setFromCamera: function(coords, camera) {
        if (camera && camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
        } else if (camera && camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
        } else console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
    },
    intersectObject: function(object, recursive, optionalTarget) {
        const intersects1 = optionalTarget || [];
        intersectObject(object, this, intersects1, recursive);
        intersects1.sort(ascSort);
        return intersects1;
    },
    intersectObjects: function(objects, recursive, optionalTarget) {
        const intersects1 = optionalTarget || [];
        if (Array.isArray(objects) === false) {
            console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
            return intersects1;
        }
        for(let i14 = 0, l1 = objects.length; i14 < l1; i14++)intersectObject(objects[i14], this, intersects1, recursive);
        intersects1.sort(ascSort);
        return intersects1;
    }
});
/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */ class Spherical {
    constructor(radius14 = 1, phi1 = 0, theta1 = 0){
        this.radius = radius14;
        this.phi = phi1; // polar angle
        this.theta = theta1; // azimuthal angle
        return this;
    }
    set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
    }
    // restrict phi to be betwee EPS and PI-EPS
    makeSafe() {
        const EPS = 0.000001;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
    }
    setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            this.theta = Math.atan2(x, z);
            this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
        }
        return this;
    }
}
/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */ class Cylindrical {
    constructor(radius15, theta2, y6){
        this.radius = radius15 !== undefined ? radius15 : 1; // distance from the origin to a point in the x-z plane
        this.theta = theta2 !== undefined ? theta2 : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
        this.y = y6 !== undefined ? y6 : 0; // height above the x-z plane
        return this;
    }
    set(radius, theta, y) {
        this.radius = radius;
        this.theta = theta;
        this.y = y;
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
    }
    setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + z * z);
        this.theta = Math.atan2(x, z);
        this.y = y;
        return this;
    }
}
const _vector$8 = /*@__PURE__*/ new Vector2();
class Box2 {
    constructor(min2, max2){
        Object.defineProperty(this, 'isBox2', {
            value: true
        });
        this.min = min2 !== undefined ? min2 : new Vector2(Infinity, Infinity);
        this.max = max2 !== undefined ? max2 : new Vector2(-Infinity, -Infinity);
    }
    set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    }
    setFromPoints(points) {
        this.makeEmpty();
        for(let i14 = 0, il = points.length; i14 < il; i14++)this.expandByPoint(points[i14]);
        return this;
    }
    setFromCenterAndSize(center, size) {
        const halfSize = _vector$8.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    }
    makeEmpty() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    }
    isEmpty() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(target) {
        if (target === undefined) {
            console.warn('THREE.Box2: .getCenter() target is now required');
            target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
        if (target === undefined) {
            console.warn('THREE.Box2: .getSize() target is now required');
            target = new Vector2();
        }
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    }
    expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    }
    expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    }
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
    getParameter(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        if (target === undefined) {
            console.warn('THREE.Box2: .getParameter() target is now required');
            target = new Vector2();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(box) {
        // using 4 splitting planes to rule out intersections
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }
    clampPoint(point, target) {
        if (target === undefined) {
            console.warn('THREE.Box2: .clampPoint() target is now required');
            target = new Vector2();
        }
        return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
        const clampedPoint = _vector$8.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    }
    intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    }
    union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    }
    translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
}
const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();
class Line3 {
    constructor(start1, end1){
        this.start = start1 !== undefined ? start1 : new Vector3();
        this.end = end1 !== undefined ? end1 : new Vector3();
    }
    set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    }
    getCenter(target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .getCenter() target is now required');
            target = new Vector3();
        }
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .delta() target is now required');
            target = new Vector3();
        }
        return target.subVectors(this.end, this.start);
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end);
    }
    distance() {
        return this.start.distanceTo(this.end);
    }
    at(t, target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .at() target is now required');
            target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t).add(this.start);
    }
    closestPointToPointParameter(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        const startEnd2 = _startEnd.dot(_startEnd);
        const startEnd_startP = _startEnd.dot(_startP);
        let t3 = startEnd_startP / startEnd2;
        if (clampToLine) t3 = MathUtils.clamp(t3, 0, 1);
        return t3;
    }
    closestPointToPoint(point, clampToLine, target) {
        const t3 = this.closestPointToPointParameter(point, clampToLine);
        if (target === undefined) {
            console.warn('THREE.Line3: .closestPointToPoint() target is now required');
            target = new Vector3();
        }
        return this.delta(target).multiplyScalar(t3).add(this.start);
    }
    applyMatrix4(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    }
    equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    }
}
function ImmediateRenderObject(material) {
    Object3D.call(this);
    this.material = material;
    this.render = function() {
    };
    this.hasPositions = false;
    this.hasNormals = false;
    this.hasColors = false;
    this.hasUvs = false;
    this.positionArray = null;
    this.normalArray = null;
    this.colorArray = null;
    this.uvArray = null;
    this.count = 0;
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
const _vector$9 = /*@__PURE__*/ new Vector3();
class SpotLightHelper extends Object3D {
    constructor(light, color4){
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color4;
        const geometry2 = new BufferGeometry();
        const positions = [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            -1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            -1,
            1
        ];
        for(let i14 = 0, j6 = 1, l1 = 32; i14 < l1; i14++, j6++){
            const p12 = i14 / l1 * Math.PI * 2;
            const p22 = j6 / l1 * Math.PI * 2;
            positions.push(Math.cos(p12), Math.sin(p12), 1, Math.cos(p22), Math.sin(p22), 1);
        }
        geometry2.setAttribute('position', new Float32BufferAttribute(positions, 3));
        const material8 = new LineBasicMaterial({
            fog: false,
            toneMapped: false
        });
        this.cone = new LineSegments(geometry2, material8);
        this.add(this.cone);
        this.update();
    }
    dispose() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
    }
    update() {
        this.light.updateMatrixWorld();
        const coneLength = this.light.distance ? this.light.distance : 1000;
        const coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        _vector$9.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(_vector$9);
        if (this.color !== undefined) this.cone.material.color.set(this.color);
        else this.cone.material.color.copy(this.light.color);
    }
}
const _vector$a = /*@__PURE__*/ new Vector3();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const _matrixWorldInv = /*@__PURE__*/ new Matrix4();
class SkeletonHelper extends LineSegments {
    constructor(object2){
        const bones = getBoneList(object2);
        const geometry3 = new BufferGeometry();
        const vertices18 = [];
        const colors = [];
        const color11 = new Color(0, 0, 1);
        const color21 = new Color(0, 1, 0);
        for(let i15 = 0; i15 < bones.length; i15++){
            const bone = bones[i15];
            if (bone.parent && bone.parent.isBone) {
                vertices18.push(0, 0, 0);
                vertices18.push(0, 0, 0);
                colors.push(color11.r, color11.g, color11.b);
                colors.push(color21.r, color21.g, color21.b);
            }
        }
        geometry3.setAttribute('position', new Float32BufferAttribute(vertices18, 3));
        geometry3.setAttribute('color', new Float32BufferAttribute(colors, 3));
        const material1 = new LineBasicMaterial({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
        });
        super(geometry3, material1);
        this.type = 'SkeletonHelper';
        this.isSkeletonHelper = true;
        this.root = object2;
        this.bones = bones;
        this.matrix = object2.matrixWorld;
        this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(force) {
        const bones1 = this.bones;
        const geometry4 = this.geometry;
        const position = geometry4.getAttribute('position');
        _matrixWorldInv.copy(this.root.matrixWorld).invert();
        for(let i16 = 0, j7 = 0; i16 < bones1.length; i16++){
            const bone = bones1[i16];
            if (bone.parent && bone.parent.isBone) {
                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
                _vector$a.setFromMatrixPosition(_boneMatrix);
                position.setXYZ(j7, _vector$a.x, _vector$a.y, _vector$a.z);
                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
                _vector$a.setFromMatrixPosition(_boneMatrix);
                position.setXYZ(j7 + 1, _vector$a.x, _vector$a.y, _vector$a.z);
                j7 += 2;
            }
        }
        geometry4.getAttribute('position').needsUpdate = true;
        super.updateMatrixWorld(force);
    }
}
function getBoneList(object1) {
    const boneList = [];
    if (object1 && object1.isBone) boneList.push(object1);
    for(let i16 = 0; i16 < object1.children.length; i16++)boneList.push.apply(boneList, getBoneList(object1.children[i16]));
    return boneList;
}
class PointLightHelper extends Mesh {
    constructor(light1, sphereSize, color5){
        const geometry4 = new SphereGeometry(sphereSize, 4, 2);
        const material2 = new MeshBasicMaterial({
            wireframe: true,
            fog: false,
            toneMapped: false
        });
        super(geometry4, material2);
        this.light = light1;
        this.light.updateMatrixWorld();
        this.color = color5;
        this.type = 'PointLightHelper';
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
    /*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/ }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
    update() {
        if (this.color !== undefined) this.material.color.set(this.color);
        else this.material.color.copy(this.light.color);
    /*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/ }
}
const _vector$b = /*@__PURE__*/ new Vector3();
const _color1 = /*@__PURE__*/ new Color();
const _color2 = /*@__PURE__*/ new Color();
class HemisphereLightHelper extends Object3D {
    constructor(light2, size2, color6){
        super();
        this.light = light2;
        this.light.updateMatrixWorld();
        this.matrix = light2.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color6;
        const geometry5 = new OctahedronGeometry(size2);
        geometry5.rotateY(Math.PI * 0.5);
        this.material = new MeshBasicMaterial({
            wireframe: true,
            fog: false,
            toneMapped: false
        });
        if (this.color === undefined) this.material.vertexColors = true;
        const position = geometry5.getAttribute('position');
        const colors1 = new Float32Array(position.count * 3);
        geometry5.setAttribute('color', new BufferAttribute(colors1, 3));
        this.add(new Mesh(geometry5, this.material));
        this.update();
    }
    dispose() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    }
    update() {
        const mesh = this.children[0];
        if (this.color !== undefined) this.material.color.set(this.color);
        else {
            const colors2 = mesh.geometry.getAttribute('color');
            _color1.copy(this.light.color);
            _color2.copy(this.light.groundColor);
            for(let i16 = 0, l2 = colors2.count; i16 < l2; i16++){
                const color7 = i16 < l2 / 2 ? _color1 : _color2;
                colors2.setXYZ(i16, color7.r, color7.g, color7.b);
            }
            colors2.needsUpdate = true;
        }
        mesh.lookAt(_vector$b.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
}
class GridHelper extends LineSegments {
    constructor(size3 = 10, divisions = 10, color12 = 4473924, color22 = 8947848){
        color12 = new Color(color12);
        color22 = new Color(color22);
        const center3 = divisions / 2;
        const step = size3 / divisions;
        const halfSize = size3 / 2;
        const vertices19 = [], colors2 = [];
        for(let i16 = 0, j7 = 0, k = -halfSize; i16 <= divisions; i16++, k += step){
            vertices19.push(-halfSize, 0, k, halfSize, 0, k);
            vertices19.push(k, 0, -halfSize, k, 0, halfSize);
            const color7 = i16 === center3 ? color12 : color22;
            color7.toArray(colors2, j7);
            j7 += 3;
            color7.toArray(colors2, j7);
            j7 += 3;
            color7.toArray(colors2, j7);
            j7 += 3;
            color7.toArray(colors2, j7);
            j7 += 3;
        }
        const geometry6 = new BufferGeometry();
        geometry6.setAttribute('position', new Float32BufferAttribute(vertices19, 3));
        geometry6.setAttribute('color', new Float32BufferAttribute(colors2, 3));
        const material3 = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry6, material3);
        this.type = 'GridHelper';
    }
}
class PolarGridHelper extends LineSegments {
    constructor(radius16 = 10, radials = 16, circles = 8, divisions1 = 64, color13 = 4473924, color23 = 8947848){
        color13 = new Color(color13);
        color23 = new Color(color23);
        const vertices20 = [];
        const colors3 = [];
        // create the radials
        for(let i17 = 0; i17 <= radials; i17++){
            const v = i17 / radials * (Math.PI * 2);
            const x6 = Math.sin(v) * radius16;
            const z5 = Math.cos(v) * radius16;
            vertices20.push(0, 0, 0);
            vertices20.push(x6, 0, z5);
            const color7 = i17 & 1 ? color13 : color23;
            colors3.push(color7.r, color7.g, color7.b);
            colors3.push(color7.r, color7.g, color7.b);
        }
        // create the circles
        for(let i18 = 0; i18 <= circles; i18++){
            const color7 = i18 & 1 ? color13 : color23;
            const r3 = radius16 - radius16 / circles * i18;
            for(let j8 = 0; j8 < divisions1; j8++){
                // first vertex
                let v = j8 / divisions1 * (Math.PI * 2);
                let x6 = Math.sin(v) * r3;
                let z5 = Math.cos(v) * r3;
                vertices20.push(x6, 0, z5);
                colors3.push(color7.r, color7.g, color7.b);
                // second vertex
                v = (j8 + 1) / divisions1 * (Math.PI * 2);
                x6 = Math.sin(v) * r3;
                z5 = Math.cos(v) * r3;
                vertices20.push(x6, 0, z5);
                colors3.push(color7.r, color7.g, color7.b);
            }
        }
        const geometry7 = new BufferGeometry();
        geometry7.setAttribute('position', new Float32BufferAttribute(vertices20, 3));
        geometry7.setAttribute('color', new Float32BufferAttribute(colors3, 3));
        const material4 = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry7, material4);
        this.type = 'PolarGridHelper';
    }
}
const _v1$6 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();
const _v3$1 = /*@__PURE__*/ new Vector3();
class DirectionalLightHelper extends Object3D {
    constructor(light3, size4, color7){
        super();
        this.light = light3;
        this.light.updateMatrixWorld();
        this.matrix = light3.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color7;
        if (size4 === undefined) size4 = 1;
        let geometry8 = new BufferGeometry();
        geometry8.setAttribute('position', new Float32BufferAttribute([
            -size4,
            size4,
            0,
            size4,
            size4,
            0,
            size4,
            -size4,
            0,
            -size4,
            -size4,
            0,
            -size4,
            size4,
            0
        ], 3));
        const material5 = new LineBasicMaterial({
            fog: false,
            toneMapped: false
        });
        this.lightPlane = new Line(geometry8, material5);
        this.add(this.lightPlane);
        geometry8 = new BufferGeometry();
        geometry8.setAttribute('position', new Float32BufferAttribute([
            0,
            0,
            0,
            0,
            0,
            1
        ], 3));
        this.targetLine = new Line(geometry8, material5);
        this.add(this.targetLine);
        this.update();
    }
    dispose() {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
    }
    update() {
        _v1$6.setFromMatrixPosition(this.light.matrixWorld);
        _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);
        _v3$1.subVectors(_v2$3, _v1$6);
        this.lightPlane.lookAt(_v2$3);
        if (this.color !== undefined) {
            this.lightPlane.material.color.set(this.color);
            this.targetLine.material.color.set(this.color);
        } else {
            this.lightPlane.material.color.copy(this.light.color);
            this.targetLine.material.color.copy(this.light.color);
        }
        this.targetLine.lookAt(_v2$3);
        this.targetLine.scale.z = _v3$1.length();
    }
}
const _vector$c = /*@__PURE__*/ new Vector3();
const _camera = /*@__PURE__*/ new Camera();
/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */ class CameraHelper extends LineSegments {
    constructor(camera){
        const geometry9 = new BufferGeometry();
        const material6 = new LineBasicMaterial({
            color: 16777215,
            vertexColors: true,
            toneMapped: false
        });
        const vertices21 = [];
        const colors4 = [];
        const pointMap = {
        };
        // colors
        const colorFrustum = new Color(16755200);
        const colorCone = new Color(16711680);
        const colorUp = new Color(43775);
        const colorTarget = new Color(16777215);
        const colorCross = new Color(3355443);
        // near
        addLine('n1', 'n2', colorFrustum);
        addLine('n2', 'n4', colorFrustum);
        addLine('n4', 'n3', colorFrustum);
        addLine('n3', 'n1', colorFrustum);
        // far
        addLine('f1', 'f2', colorFrustum);
        addLine('f2', 'f4', colorFrustum);
        addLine('f4', 'f3', colorFrustum);
        addLine('f3', 'f1', colorFrustum);
        // sides
        addLine('n1', 'f1', colorFrustum);
        addLine('n2', 'f2', colorFrustum);
        addLine('n3', 'f3', colorFrustum);
        addLine('n4', 'f4', colorFrustum);
        // cone
        addLine('p', 'n1', colorCone);
        addLine('p', 'n2', colorCone);
        addLine('p', 'n3', colorCone);
        addLine('p', 'n4', colorCone);
        // up
        addLine('u1', 'u2', colorUp);
        addLine('u2', 'u3', colorUp);
        addLine('u3', 'u1', colorUp);
        // target
        addLine('c', 't', colorTarget);
        addLine('p', 'c', colorCross);
        // cross
        addLine('cn1', 'cn2', colorCross);
        addLine('cn3', 'cn4', colorCross);
        addLine('cf1', 'cf2', colorCross);
        addLine('cf3', 'cf4', colorCross);
        function addLine(a3, b4, color8) {
            addPoint(a3, color8);
            addPoint(b4, color8);
        }
        function addPoint(id, color8) {
            vertices21.push(0, 0, 0);
            colors4.push(color8.r, color8.g, color8.b);
            if (pointMap[id] === undefined) pointMap[id] = [];
            pointMap[id].push(vertices21.length / 3 - 1);
        }
        geometry9.setAttribute('position', new Float32BufferAttribute(vertices21, 3));
        geometry9.setAttribute('color', new Float32BufferAttribute(colors4, 3));
        super(geometry9, material6);
        this.type = 'CameraHelper';
        this.camera = camera;
        if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
    }
    update() {
        const geometry10 = this.geometry;
        const pointMap1 = this.pointMap;
        const w3 = 1, h = 1;
        // we need just camera projection matrix inverse
        // world matrix must be identity
        _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
        // center / target
        setPoint('c', pointMap1, geometry10, _camera, 0, 0, -1);
        setPoint('t', pointMap1, geometry10, _camera, 0, 0, 1);
        // near
        setPoint('n1', pointMap1, geometry10, _camera, -w3, -h, -1);
        setPoint('n2', pointMap1, geometry10, _camera, w3, -h, -1);
        setPoint('n3', pointMap1, geometry10, _camera, -w3, h, -1);
        setPoint('n4', pointMap1, geometry10, _camera, w3, h, -1);
        // far
        setPoint('f1', pointMap1, geometry10, _camera, -w3, -h, 1);
        setPoint('f2', pointMap1, geometry10, _camera, w3, -h, 1);
        setPoint('f3', pointMap1, geometry10, _camera, -w3, h, 1);
        setPoint('f4', pointMap1, geometry10, _camera, w3, h, 1);
        // up
        setPoint('u1', pointMap1, geometry10, _camera, w3 * 0.7, h * 1.1, -1);
        setPoint('u2', pointMap1, geometry10, _camera, -w3 * 0.7, h * 1.1, -1);
        setPoint('u3', pointMap1, geometry10, _camera, 0, h * 2, -1);
        // cross
        setPoint('cf1', pointMap1, geometry10, _camera, -w3, 0, 1);
        setPoint('cf2', pointMap1, geometry10, _camera, w3, 0, 1);
        setPoint('cf3', pointMap1, geometry10, _camera, 0, -h, 1);
        setPoint('cf4', pointMap1, geometry10, _camera, 0, h, 1);
        setPoint('cn1', pointMap1, geometry10, _camera, -w3, 0, -1);
        setPoint('cn2', pointMap1, geometry10, _camera, w3, 0, -1);
        setPoint('cn3', pointMap1, geometry10, _camera, 0, -h, -1);
        setPoint('cn4', pointMap1, geometry10, _camera, 0, h, -1);
        geometry10.getAttribute('position').needsUpdate = true;
    }
}
function setPoint(point, pointMap1, geometry10, camera1, x6, y7, z5) {
    _vector$c.set(x6, y7, z5).unproject(camera1);
    const points2 = pointMap1[point];
    if (points2 !== undefined) {
        const position1 = geometry10.getAttribute('position');
        for(let i19 = 0, l2 = points2.length; i19 < l2; i19++)position1.setXYZ(points2[i19], _vector$c.x, _vector$c.y, _vector$c.z);
    }
}
const _box$3 = /*@__PURE__*/ new Box3();
class BoxHelper extends LineSegments {
    constructor(object1, color8 = 16776960){
        const indices16 = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]);
        const positions1 = new Float32Array(24);
        const geometry10 = new BufferGeometry();
        geometry10.setIndex(new BufferAttribute(indices16, 1));
        geometry10.setAttribute('position', new BufferAttribute(positions1, 3));
        super(geometry10, new LineBasicMaterial({
            color: color8,
            toneMapped: false
        }));
        this.object = object1;
        this.type = 'BoxHelper';
        this.matrixAutoUpdate = false;
        this.update();
    }
    update(object) {
        if (object !== undefined) console.warn('THREE.BoxHelper: .update() has no longer arguments.');
        if (this.object !== undefined) _box$3.setFromObject(this.object);
        if (_box$3.isEmpty()) return;
        const min3 = _box$3.min;
        const max3 = _box$3.max;
        /*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/ const position1 = this.geometry.attributes.position;
        const array = position1.array;
        array[0] = max3.x;
        array[1] = max3.y;
        array[2] = max3.z;
        array[3] = min3.x;
        array[4] = max3.y;
        array[5] = max3.z;
        array[6] = min3.x;
        array[7] = min3.y;
        array[8] = max3.z;
        array[9] = max3.x;
        array[10] = min3.y;
        array[11] = max3.z;
        array[12] = max3.x;
        array[13] = max3.y;
        array[14] = min3.z;
        array[15] = min3.x;
        array[16] = max3.y;
        array[17] = min3.z;
        array[18] = min3.x;
        array[19] = min3.y;
        array[20] = min3.z;
        array[21] = max3.x;
        array[22] = min3.y;
        array[23] = min3.z;
        position1.needsUpdate = true;
        this.geometry.computeBoundingSphere();
    }
    setFromObject(object) {
        this.object = object;
        this.update();
        return this;
    }
    copy(source) {
        LineSegments.prototype.copy.call(this, source);
        this.object = source.object;
        return this;
    }
}
class Box3Helper extends LineSegments {
    constructor(box, color9 = 16776960){
        const indices17 = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]);
        const positions2 = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            -1
        ];
        const geometry11 = new BufferGeometry();
        geometry11.setIndex(new BufferAttribute(indices17, 1));
        geometry11.setAttribute('position', new Float32BufferAttribute(positions2, 3));
        super(geometry11, new LineBasicMaterial({
            color: color9,
            toneMapped: false
        }));
        this.box = box;
        this.type = 'Box3Helper';
        this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(force) {
        const box1 = this.box;
        if (box1.isEmpty()) return;
        box1.getCenter(this.position);
        box1.getSize(this.scale);
        this.scale.multiplyScalar(0.5);
        super.updateMatrixWorld(force);
    }
}
class PlaneHelper extends Line {
    constructor(plane, size5 = 1, hex = 16776960){
        const color10 = hex;
        const positions3 = [
            1,
            -1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ];
        const geometry12 = new BufferGeometry();
        geometry12.setAttribute('position', new Float32BufferAttribute(positions3, 3));
        geometry12.computeBoundingSphere();
        super(geometry12, new LineBasicMaterial({
            color: color10,
            toneMapped: false
        }));
        this.type = 'PlaneHelper';
        this.plane = plane;
        this.size = size5;
        const positions21 = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1
        ];
        const geometry21 = new BufferGeometry();
        geometry21.setAttribute('position', new Float32BufferAttribute(positions21, 3));
        geometry21.computeBoundingSphere();
        this.add(new Mesh(geometry21, new MeshBasicMaterial({
            color: color10,
            opacity: 0.2,
            transparent: true,
            depthWrite: false,
            toneMapped: false
        })));
    }
    updateMatrixWorld(force) {
        let scale = -this.plane.constant;
        if (Math.abs(scale) < 0.00000001) scale = 0.00000001; // sign does not matter
        this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
        this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here
        this.lookAt(this.plane.normal);
        super.updateMatrixWorld(force);
    }
}
const _axis = /*@__PURE__*/ new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
    constructor(dir1, origin2, length1, color14, headLength1, headWidth1){
        super();
        // dir is assumed to be normalized
        this.type = 'ArrowHelper';
        if (dir1 === undefined) dir1 = new Vector3(0, 0, 1);
        if (origin2 === undefined) origin2 = new Vector3(0, 0, 0);
        if (length1 === undefined) length1 = 1;
        if (color14 === undefined) color14 = 16776960;
        if (headLength1 === undefined) headLength1 = 0.2 * length1;
        if (headWidth1 === undefined) headWidth1 = 0.2 * headLength1;
        if (_lineGeometry === undefined) {
            _lineGeometry = new BufferGeometry();
            _lineGeometry.setAttribute('position', new Float32BufferAttribute([
                0,
                0,
                0,
                0,
                1,
                0
            ], 3));
            _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
            _coneGeometry.translate(0, -0.5, 0);
        }
        this.position.copy(origin2);
        this.line = new Line(_lineGeometry, new LineBasicMaterial({
            color: color14,
            toneMapped: false
        }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
            color: color14,
            toneMapped: false
        }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir1);
        this.setLength(length1, headLength1, headWidth1);
    }
    setDirection(dir) {
        // dir is assumed to be normalized
        if (dir.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (dir.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            _axis.set(dir.z, 0, -dir.x).normalize();
            const radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(_axis, radians);
        }
    }
    setLength(length, headLength, headWidth) {
        if (headLength === undefined) headLength = 0.2 * length;
        if (headWidth === undefined) headWidth = 0.2 * headLength;
        this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
    }
    setColor(color) {
        this.line.material.color.set(color);
        this.cone.material.color.set(color);
    }
    copy(source) {
        super.copy(source, false);
        this.line.copy(source.line);
        this.cone.copy(source.cone);
        return this;
    }
}
class AxesHelper extends LineSegments {
    constructor(size6 = 1){
        const vertices22 = [
            0,
            0,
            0,
            size6,
            0,
            0,
            0,
            0,
            0,
            0,
            size6,
            0,
            0,
            0,
            0,
            0,
            0,
            size6
        ];
        const colors5 = [
            1,
            0,
            0,
            1,
            0.6,
            0,
            0,
            1,
            0,
            0.6,
            1,
            0,
            0,
            0,
            1,
            0,
            0.6,
            1
        ];
        const geometry13 = new BufferGeometry();
        geometry13.setAttribute('position', new Float32BufferAttribute(vertices22, 3));
        geometry13.setAttribute('color', new Float32BufferAttribute(colors5, 3));
        const material7 = new LineBasicMaterial({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry13, material7);
        this.type = 'AxesHelper';
    }
}
const _floatView = new Float32Array(1);
const _int32View = new Int32Array(_floatView.buffer);
const DataUtils = {
    // Converts float32 to float16 (stored as uint16 value).
    toHalfFloat: function(val) {
        // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410
        /* This method is faster than the OpenEXR implementation (very often
		* used, eg. in Ogre), with the additional benefit of rounding, inspired
		* by James Tursa?s half-precision code. */ _floatView[0] = val;
        const x6 = _int32View[0];
        let bits = x6 >> 16 & 32768; /* Get the sign */ 
        let m = x6 >> 12 & 2047; /* Keep one extra bit for rounding */ 
        const e = x6 >> 23 & 255; /* Using int is faster here */ 
        /* If zero, or denormal, or exponent underflows too much for a denormal
			* half, return signed zero. */ if (e < 103) return bits;
        /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */ if (e > 142) {
            bits |= 31744;
            /* If exponent was 0xff and one mantissa bit was set, it means NaN,
						* not Inf, so make sure we set one mantissa bit too. */ bits |= (e == 255 ? 0 : 1) && x6 & 8388607;
            return bits;
        }
        /* If exponent underflows but not too much, return a denormal */ if (e < 113) {
            m |= 2048;
            /* Extra rounding may overflow and set mantissa to 0 and exponent
				* to 1, which is OK. */ bits |= (m >> 114 - e) + (m >> 113 - e & 1);
            return bits;
        }
        bits |= e - 112 << 10 | m >> 1;
        /* Extra rounding. An overflow will set mantissa to 0 and increment
			* the exponent, which is OK. */ bits += m & 1;
        return bits;
    }
};
const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow(2, LOD_MAX);
// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [
    0.125,
    0.215,
    0.35,
    0.446,
    0.526,
    0.582
];
const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;
const ENCODINGS = {
    [LinearEncoding]: 0,
    [sRGBEncoding]: 1,
    [RGBEEncoding]: 2,
    [RGBM7Encoding]: 3,
    [RGBM16Encoding]: 4,
    [RGBDEncoding]: 5,
    [GammaEncoding]: 6
};
const backgroundMaterial = new MeshBasicMaterial({
    side: BackSide,
    depthWrite: false,
    depthTest: false
});
const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const { _lodPlanes , _sizeLods , _sigmas  } = /*@__PURE__*/ _createPlanes();
const _clearColor = /*@__PURE__*/ new Color();
let _oldTarget = null;
// Golden Ratio
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
    /*@__PURE__*/ new Vector3(1, 1, 1),
    /*@__PURE__*/ new Vector3(-1, 1, 1),
    /*@__PURE__*/ new Vector3(1, 1, -1),
    /*@__PURE__*/ new Vector3(-1, 1, -1),
    /*@__PURE__*/ new Vector3(0, PHI, INV_PHI),
    /*@__PURE__*/ new Vector3(0, PHI, -INV_PHI),
    /*@__PURE__*/ new Vector3(INV_PHI, 0, PHI),
    /*@__PURE__*/ new Vector3(-INV_PHI, 0, PHI),
    /*@__PURE__*/ new Vector3(PHI, INV_PHI, 0),
    /*@__PURE__*/ new Vector3(-PHI, INV_PHI, 0)
];
/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */ function convertLinearToRGBE(color15) {
    const maxComponent = Math.max(color15.r, color15.g, color15.b);
    const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
    color15.multiplyScalar(Math.pow(2, -fExp));
    const alpha = (fExp + 128) / 255;
    return alpha;
}
class PMREMGenerator {
    constructor(renderer){
        this._renderer = renderer;
        this._pingPongRenderTarget = null;
        this._blurMaterial = _getBlurShader(MAX_SAMPLES);
        this._equirectShader = null;
        this._cubemapShader = null;
        this._compileMaterial(this._blurMaterial);
    }
    /**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */ fromScene(scene, sigma = 0, near = 0.1, far = 100) {
        _oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets();
        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) this._blur(cubeUVRenderTarget, 0, 0, sigma);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    /**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */ fromEquirectangular(equirectangular) {
        return this._fromTexture(equirectangular);
    }
    /**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */ fromCubemap(cubemap) {
        return this._fromTexture(cubemap);
    }
    /**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */ compileCubemapShader() {
        if (this._cubemapShader === null) {
            this._cubemapShader = _getCubemapShader();
            this._compileMaterial(this._cubemapShader);
        }
    }
    /**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */ compileEquirectangularShader() {
        if (this._equirectShader === null) {
            this._equirectShader = _getEquirectShader();
            this._compileMaterial(this._equirectShader);
        }
    }
    /**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */ dispose() {
        this._blurMaterial.dispose();
        if (this._cubemapShader !== null) this._cubemapShader.dispose();
        if (this._equirectShader !== null) this._equirectShader.dispose();
        for(let i19 = 0; i19 < _lodPlanes.length; i19++)_lodPlanes[i19].dispose();
    }
    // private interface
    _cleanup(outputTarget) {
        this._pingPongRenderTarget.dispose();
        this._renderer.setRenderTarget(_oldTarget);
        outputTarget.scissorTest = false;
        _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
    _fromTexture(texture) {
        _oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets(texture);
        this._textureToCubeUV(texture, cubeUVRenderTarget);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    _allocateTargets(texture) {
        const params = {
            magFilter: NearestFilter,
            minFilter: NearestFilter,
            generateMipmaps: false,
            type: UnsignedByteType,
            format: RGBEFormat,
            encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
            depthBuffer: false
        };
        const cubeUVRenderTarget = _createRenderTarget(params);
        cubeUVRenderTarget.depthBuffer = texture ? false : true;
        this._pingPongRenderTarget = _createRenderTarget(params);
        return cubeUVRenderTarget;
    }
    _compileMaterial(material) {
        const tmpMesh = new Mesh(_lodPlanes[0], material);
        this._renderer.compile(tmpMesh, _flatCamera);
    }
    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        const fov1 = 90;
        const aspect1 = 1;
        const cubeCamera = new PerspectiveCamera(fov1, aspect1, near, far);
        const upSign = [
            1,
            -1,
            1,
            1,
            1,
            1
        ];
        const forwardSign = [
            1,
            1,
            1,
            -1,
            -1,
            -1
        ];
        const renderer1 = this._renderer;
        const originalAutoClear = renderer1.autoClear;
        const outputEncoding = renderer1.outputEncoding;
        const toneMapping = renderer1.toneMapping;
        renderer1.getClearColor(_clearColor);
        renderer1.toneMapping = NoToneMapping;
        renderer1.outputEncoding = LinearEncoding;
        renderer1.autoClear = false;
        let useSolidColor = false;
        const background = scene.background;
        if (background) {
            if (background.isColor) {
                backgroundMaterial.color.copy(background).convertSRGBToLinear();
                scene.background = null;
                const alpha = convertLinearToRGBE(backgroundMaterial.color);
                backgroundMaterial.opacity = alpha;
                useSolidColor = true;
            }
        } else {
            backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
            const alpha = convertLinearToRGBE(backgroundMaterial.color);
            backgroundMaterial.opacity = alpha;
            useSolidColor = true;
        }
        for(let i19 = 0; i19 < 6; i19++){
            const col = i19 % 3;
            if (col == 0) {
                cubeCamera.up.set(0, upSign[i19], 0);
                cubeCamera.lookAt(forwardSign[i19], 0, 0);
            } else if (col == 1) {
                cubeCamera.up.set(0, 0, upSign[i19]);
                cubeCamera.lookAt(0, forwardSign[i19], 0);
            } else {
                cubeCamera.up.set(0, upSign[i19], 0);
                cubeCamera.lookAt(0, 0, forwardSign[i19]);
            }
            _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i19 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
            renderer1.setRenderTarget(cubeUVRenderTarget);
            if (useSolidColor) renderer1.render(backgroundBox, cubeCamera);
            renderer1.render(scene, cubeCamera);
        }
        renderer1.toneMapping = toneMapping;
        renderer1.outputEncoding = outputEncoding;
        renderer1.autoClear = originalAutoClear;
    }
    _textureToCubeUV(texture, cubeUVRenderTarget) {
        const renderer1 = this._renderer;
        if (texture.isCubeTexture) {
            if (this._cubemapShader == null) this._cubemapShader = _getCubemapShader();
        } else if (this._equirectShader == null) this._equirectShader = _getEquirectShader();
        const material9 = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
        const mesh = new Mesh(_lodPlanes[0], material9);
        const uniforms = material9.uniforms;
        uniforms['envMap'].value = texture;
        if (!texture.isCubeTexture) uniforms['texelSize'].value.set(1 / texture.image.width, 1 / texture.image.height);
        uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
        uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];
        _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
        renderer1.setRenderTarget(cubeUVRenderTarget);
        renderer1.render(mesh, _flatCamera);
    }
    _applyPMREM(cubeUVRenderTarget) {
        const renderer1 = this._renderer;
        const autoClear = renderer1.autoClear;
        renderer1.autoClear = false;
        for(let i19 = 1; i19 < TOTAL_LODS; i19++){
            const sigma = Math.sqrt(_sigmas[i19] * _sigmas[i19] - _sigmas[i19 - 1] * _sigmas[i19 - 1]);
            const poleAxis = _axisDirections[(i19 - 1) % _axisDirections.length];
            this._blur(cubeUVRenderTarget, i19 - 1, i19, sigma, poleAxis);
        }
        renderer1.autoClear = autoClear;
    }
    /**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */ _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        const pingPongRenderTarget = this._pingPongRenderTarget;
        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
    }
    _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        const renderer1 = this._renderer;
        const blurMaterial = this._blurMaterial;
        if (direction !== 'latitudinal' && direction !== 'longitudinal') console.error('blur direction must be either latitudinal or longitudinal!');
        // Number of standard deviations at which to cut off the discrete approximation.
        const STANDARD_DEVIATIONS = 3;
        const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
        const blurUniforms = blurMaterial.uniforms;
        const pixels = _sizeLods[lodIn] - 1;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        const weights = [];
        let sum = 0;
        for(let i19 = 0; i19 < MAX_SAMPLES; ++i19){
            const x6 = i19 / sigmaPixels;
            const weight = Math.exp(-x6 * x6 / 2);
            weights.push(weight);
            if (i19 == 0) sum += weight;
            else if (i19 < samples) sum += 2 * weight;
        }
        for(let i20 = 0; i20 < weights.length; i20++)weights[i20] = weights[i20] / sum;
        blurUniforms['envMap'].value = targetIn.texture;
        blurUniforms['samples'].value = samples;
        blurUniforms['weights'].value = weights;
        blurUniforms['latitudinal'].value = direction === 'latitudinal';
        if (poleAxis) blurUniforms['poleAxis'].value = poleAxis;
        blurUniforms['dTheta'].value = radiansPerPixel;
        blurUniforms['mipInt'].value = LOD_MAX - lodIn;
        blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
        blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
        const outputSize = _sizeLods[lodOut];
        const x6 = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
        const y7 = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
        _setViewport(targetOut, x6, y7, 3 * outputSize, 2 * outputSize);
        renderer1.setRenderTarget(targetOut);
        renderer1.render(blurMesh, _flatCamera);
    }
}
function _isLDR(texture) {
    if (texture === undefined || texture.type !== UnsignedByteType) return false;
    return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
    const _lodPlanes1 = [];
    const _sizeLods1 = [];
    const _sigmas1 = [];
    let lod = LOD_MAX;
    for(let i19 = 0; i19 < TOTAL_LODS; i19++){
        const sizeLod = Math.pow(2, lod);
        _sizeLods1.push(sizeLod);
        let sigma = 1 / sizeLod;
        if (i19 > LOD_MAX - LOD_MIN) sigma = EXTRA_LOD_SIGMA[i19 - LOD_MAX + LOD_MIN - 1];
        else if (i19 == 0) sigma = 0;
        _sigmas1.push(sigma);
        const texelSize = 1 / (sizeLod - 1);
        const min3 = -texelSize / 2;
        const max3 = 1 + texelSize / 2;
        const uv11 = [
            min3,
            min3,
            max3,
            min3,
            max3,
            max3,
            min3,
            min3,
            max3,
            max3,
            min3,
            max3
        ];
        const cubeFaces = 6;
        const vertices23 = 6;
        const positionSize = 3;
        const uvSize = 2;
        const faceIndexSize = 1;
        const position1 = new Float32Array(positionSize * vertices23 * cubeFaces);
        const uv4 = new Float32Array(uvSize * vertices23 * cubeFaces);
        const faceIndex = new Float32Array(faceIndexSize * vertices23 * cubeFaces);
        for(let face = 0; face < cubeFaces; face++){
            const x6 = face % 3 * 2 / 3 - 1;
            const y7 = face > 2 ? 0 : -1;
            const coordinates = [
                x6,
                y7,
                0,
                x6 + 2 / 3,
                y7,
                0,
                x6 + 2 / 3,
                y7 + 1,
                0,
                x6,
                y7,
                0,
                x6 + 2 / 3,
                y7 + 1,
                0,
                x6,
                y7 + 1,
                0
            ];
            position1.set(coordinates, positionSize * vertices23 * face);
            uv4.set(uv11, uvSize * vertices23 * face);
            const fill = [
                face,
                face,
                face,
                face,
                face,
                face
            ];
            faceIndex.set(fill, faceIndexSize * vertices23 * face);
        }
        const planes = new BufferGeometry();
        planes.setAttribute('position', new BufferAttribute(position1, positionSize));
        planes.setAttribute('uv', new BufferAttribute(uv4, uvSize));
        planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
        _lodPlanes1.push(planes);
        if (lod > LOD_MIN) lod--;
    }
    return {
        _lodPlanes: _lodPlanes1,
        _sizeLods: _sizeLods1,
        _sigmas: _sigmas1
    };
}
function _createRenderTarget(params) {
    const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
}
function _setViewport(target, x6, y7, width5, height7) {
    target.viewport.set(x6, y7, width5, height7);
    target.scissor.set(x6, y7, width5, height7);
}
function _getBlurShader(maxSamples) {
    const weights = new Float32Array(maxSamples);
    const poleAxis = new Vector3(0, 1, 0);
    const shaderMaterial = new RawShaderMaterial({
        name: 'SphericalGaussianBlur',
        defines: {
            'n': maxSamples
        },
        uniforms: {
            'envMap': {
                value: null
            },
            'samples': {
                value: 1
            },
            'weights': {
                value: weights
            },
            'latitudinal': {
                value: false
            },
            'dTheta': {
                value: 0
            },
            'mipInt': {
                value: 0
            },
            'poleAxis': {
                value: poleAxis
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: /* glsl */ `\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			${_getEncodings()}\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getEquirectShader() {
    const texelSize = new Vector2(1, 1);
    const shaderMaterial = new RawShaderMaterial({
        name: 'EquirectangularToCubeUV',
        uniforms: {
            'envMap': {
                value: null
            },
            'texelSize': {
                value: texelSize
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: /* glsl */ `\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform vec2 texelSize;\n\n			${_getEncodings()}\n\n			#include <common>\n\n			void main() {\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				vec2 f = fract( uv / texelSize - 0.5 );\n				uv -= f * texelSize;\n				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.x += texelSize.x;\n				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.y += texelSize.y;\n				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.x -= texelSize.x;\n				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n				vec3 tm = mix( tl, tr, f.x );\n				vec3 bm = mix( bl, br, f.x );\n				gl_FragColor.rgb = mix( tm, bm, f.y );\n\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getCubemapShader() {
    const shaderMaterial = new RawShaderMaterial({
        name: 'CubemapToCubeUV',
        uniforms: {
            'envMap': {
                value: null
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: /* glsl */ `\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			${_getEncodings()}\n\n			void main() {\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getCommonVertexShader() {
    return(/* glsl */ `\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	`);
}
function _getEncodings() {
    return(/* glsl */ `\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	`);
}
function Face4(a3, b4, c3, d, normal7, color15, materialIndex1) {
    console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
    return new Face3(a3, b4, c3, normal7, color15, materialIndex1);
}
const LineStrip = 0;
const LinePieces = 1;
const NoColors = 0;
const FaceColors = 1;
const VertexColors = 2;
function MeshFaceMaterial(materials) {
    console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
    return materials;
}
function MultiMaterial(materials = []) {
    console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
    materials.isMultiMaterial = true;
    materials.materials = materials;
    materials.clone = function() {
        return materials.slice();
    };
    return materials;
}
function PointCloud(geometry14, material9) {
    console.warn('THREE.PointCloud has been renamed to THREE.Points.');
    return new Points(geometry14, material9);
}
function Particle(material9) {
    console.warn('THREE.Particle has been renamed to THREE.Sprite.');
    return new Sprite(material9);
}
function ParticleSystem(geometry14, material9) {
    console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
    return new Points(geometry14, material9);
}
function PointCloudMaterial(parameters1) {
    console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters1);
}
function ParticleBasicMaterial(parameters1) {
    console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters1);
}
function ParticleSystemMaterial(parameters1) {
    console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
    return new PointsMaterial(parameters1);
}
function Vertex(x6, y7, z5) {
    console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
    return new Vector3(x6, y7, z5);
}
//
function DynamicBufferAttribute(array, itemSize) {
    console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
    return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
}
function Int8Attribute(array, itemSize) {
    console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
    return new Int8BufferAttribute(array, itemSize);
}
function Uint8Attribute(array, itemSize) {
    console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
    return new Uint8BufferAttribute(array, itemSize);
}
function Uint8ClampedAttribute(array, itemSize) {
    console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
    return new Uint8ClampedBufferAttribute(array, itemSize);
}
function Int16Attribute(array, itemSize) {
    console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
    return new Int16BufferAttribute(array, itemSize);
}
function Uint16Attribute(array, itemSize) {
    console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
    return new Uint16BufferAttribute(array, itemSize);
}
function Int32Attribute(array, itemSize) {
    console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
    return new Int32BufferAttribute(array, itemSize);
}
function Uint32Attribute(array, itemSize) {
    console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
    return new Uint32BufferAttribute(array, itemSize);
}
function Float32Attribute(array, itemSize) {
    console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
    return new Float32BufferAttribute(array, itemSize);
}
function Float64Attribute(array, itemSize) {
    console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
    return new Float64BufferAttribute(array, itemSize);
}
//
Curve.create = function(construct, getPoint) {
    console.log('THREE.Curve.create() has been deprecated');
    construct.prototype = Object.create(Curve.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
};
//
Object.assign(Path.prototype, {
    fromPoints: function(points2) {
        console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
        return this.setFromPoints(points2);
    }
});
//
function ClosedSplineCurve3(points2) {
    console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
    CatmullRomCurve3.call(this, points2);
    this.type = 'catmullrom';
    this.closed = true;
}
ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
//
function SplineCurve3(points2) {
    console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
    CatmullRomCurve3.call(this, points2);
    this.type = 'catmullrom';
}
SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
//
function Spline(points2) {
    console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
    CatmullRomCurve3.call(this, points2);
    this.type = 'catmullrom';
}
Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
    initFromArray: function() {
        console.error('THREE.Spline: .initFromArray() has been removed.');
    },
    getControlPointsArray: function() {
        console.error('THREE.Spline: .getControlPointsArray() has been removed.');
    },
    reparametrizeByArcLength: function() {
        console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
    }
});
//
function AxisHelper(size7) {
    console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
    return new AxesHelper(size7);
}
function BoundingBoxHelper(object3, color15) {
    console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
    return new BoxHelper(object3, color15);
}
function EdgesHelper(object3, hex1) {
    console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
    return new LineSegments(new EdgesGeometry(object3.geometry), new LineBasicMaterial({
        color: hex1 !== undefined ? hex1 : 16777215
    }));
}
GridHelper.prototype.setColors = function() {
    console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};
SkeletonHelper.prototype.update = function() {
    console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
};
function WireframeHelper(object3, hex1) {
    console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
    return new LineSegments(new WireframeGeometry(object3.geometry), new LineBasicMaterial({
        color: hex1 !== undefined ? hex1 : 16777215
    }));
}
//
Object.assign(Loader.prototype, {
    extractUrlBase: function(url) {
        console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
        return LoaderUtils.extractUrlBase(url);
    }
});
Loader.Handlers = {
    add: function() {
        console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
    },
    get: function() {
        console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
    }
};
function XHRLoader(manager1) {
    console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
    return new FileLoader(manager1);
}
function BinaryTextureLoader(manager1) {
    console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
    return new DataTextureLoader(manager1);
}
//
Object.assign(Box2.prototype, {
    center: function(optionalTarget) {
        console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
        return this.getCenter(optionalTarget);
    },
    empty: function() {
        console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
        return this.isEmpty();
    },
    isIntersectionBox: function(box1) {
        console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
        return this.intersectsBox(box1);
    },
    size: function(optionalTarget) {
        console.warn('THREE.Box2: .size() has been renamed to .getSize().');
        return this.getSize(optionalTarget);
    }
});
Object.assign(Box3.prototype, {
    center: function(optionalTarget) {
        console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
        return this.getCenter(optionalTarget);
    },
    empty: function() {
        console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
        return this.isEmpty();
    },
    isIntersectionBox: function(box1) {
        console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
        return this.intersectsBox(box1);
    },
    isIntersectionSphere: function(sphere) {
        console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
        return this.intersectsSphere(sphere);
    },
    size: function(optionalTarget) {
        console.warn('THREE.Box3: .size() has been renamed to .getSize().');
        return this.getSize(optionalTarget);
    }
});
Object.assign(Sphere.prototype, {
    empty: function() {
        console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
        return this.isEmpty();
    }
});
Frustum.prototype.setFromMatrix = function(m) {
    console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
    return this.setFromProjectionMatrix(m);
};
Line3.prototype.center = function(optionalTarget) {
    console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
};
Object.assign(MathUtils, {
    random16: function() {
        console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
        return Math.random();
    },
    nearestPowerOfTwo: function(value1) {
        console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
        return MathUtils.floorPowerOfTwo(value1);
    },
    nextPowerOfTwo: function(value1) {
        console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
        return MathUtils.ceilPowerOfTwo(value1);
    }
});
Object.assign(Matrix3.prototype, {
    flattenToArrayOffset: function(array, offset) {
        console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
        return this.toArray(array, offset);
    },
    multiplyVector3: function(vector) {
        console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
        return vector.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
        console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
    },
    applyToBufferAttribute: function(attribute) {
        console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
        return attribute.applyMatrix3(this);
    },
    applyToVector3Array: function() {
        console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
    },
    getInverse: function(matrix) {
        console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
        return this.copy(matrix).invert();
    }
});
Object.assign(Matrix4.prototype, {
    extractPosition: function(m) {
        console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
        return this.copyPosition(m);
    },
    flattenToArrayOffset: function(array, offset) {
        console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
        return this.toArray(array, offset);
    },
    getPosition: function() {
        console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
        return new Vector3().setFromMatrixColumn(this, 3);
    },
    setRotationFromQuaternion: function(q1) {
        console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
        return this.makeRotationFromQuaternion(q1);
    },
    multiplyToArray: function() {
        console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
    },
    multiplyVector3: function(vector) {
        console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
    },
    multiplyVector4: function(vector) {
        console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
        console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
    },
    rotateAxis: function(v) {
        console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
        v.transformDirection(this);
    },
    crossVector: function(vector) {
        console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
    },
    translate: function() {
        console.error('THREE.Matrix4: .translate() has been removed.');
    },
    rotateX: function() {
        console.error('THREE.Matrix4: .rotateX() has been removed.');
    },
    rotateY: function() {
        console.error('THREE.Matrix4: .rotateY() has been removed.');
    },
    rotateZ: function() {
        console.error('THREE.Matrix4: .rotateZ() has been removed.');
    },
    rotateByAxis: function() {
        console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
    },
    applyToBufferAttribute: function(attribute) {
        console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
        return attribute.applyMatrix4(this);
    },
    applyToVector3Array: function() {
        console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
    },
    makeFrustum: function(left, right, bottom, top, near2, far2) {
        console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
        return this.makePerspective(left, right, top, bottom, near2, far2);
    },
    getInverse: function(matrix) {
        console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
        return this.copy(matrix).invert();
    }
});
Plane.prototype.isIntersectionLine = function(line) {
    console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
    return this.intersectsLine(line);
};
Object.assign(Quaternion.prototype, {
    multiplyVector3: function(vector) {
        console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
        return vector.applyQuaternion(this);
    },
    inverse: function() {
        console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
        return this.invert();
    }
});
Object.assign(Ray.prototype, {
    isIntersectionBox: function(box1) {
        console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
        return this.intersectsBox(box1);
    },
    isIntersectionPlane: function(plane1) {
        console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
        return this.intersectsPlane(plane1);
    },
    isIntersectionSphere: function(sphere) {
        console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
        return this.intersectsSphere(sphere);
    }
});
Object.assign(Triangle.prototype, {
    area: function() {
        console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
        return this.getArea();
    },
    barycoordFromPoint: function(point, target) {
        console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
        return this.getBarycoord(point, target);
    },
    midpoint: function(target) {
        console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
        return this.getMidpoint(target);
    },
    normal: function(target) {
        console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
        return this.getNormal(target);
    },
    plane: function(target) {
        console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
        return this.getPlane(target);
    }
});
Object.assign(Triangle, {
    barycoordFromPoint: function(point, a3, b4, c3, target) {
        console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
        return Triangle.getBarycoord(point, a3, b4, c3, target);
    },
    normal: function(a3, b4, c3, target) {
        console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
        return Triangle.getNormal(a3, b4, c3, target);
    }
});
Object.assign(Shape.prototype, {
    extractAllPoints: function(divisions2) {
        console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
        return this.extractPoints(divisions2);
    },
    extrude: function(options4) {
        console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
        return new ExtrudeGeometry(this, options4);
    },
    makeGeometry: function(options4) {
        console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
        return new ShapeGeometry(this, options4);
    }
});
Object.assign(Vector2.prototype, {
    fromAttribute: function(attribute, index2, offset) {
        console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
        return this.fromBufferAttribute(attribute, index2, offset);
    },
    distanceToManhattan: function(v) {
        console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
        return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
        console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
        return this.manhattanLength();
    }
});
Object.assign(Vector3.prototype, {
    setEulerFromRotationMatrix: function() {
        console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
    },
    setEulerFromQuaternion: function() {
        console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
    },
    getPositionFromMatrix: function(m) {
        console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
        return this.setFromMatrixPosition(m);
    },
    getScaleFromMatrix: function(m) {
        console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
        return this.setFromMatrixScale(m);
    },
    getColumnFromMatrix: function(index2, matrix) {
        console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
        return this.setFromMatrixColumn(matrix, index2);
    },
    applyProjection: function(m) {
        console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
        return this.applyMatrix4(m);
    },
    fromAttribute: function(attribute, index2, offset) {
        console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
        return this.fromBufferAttribute(attribute, index2, offset);
    },
    distanceToManhattan: function(v) {
        console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
        return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
        console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
        return this.manhattanLength();
    }
});
Object.assign(Vector4.prototype, {
    fromAttribute: function(attribute, index2, offset) {
        console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
        return this.fromBufferAttribute(attribute, index2, offset);
    },
    lengthManhattan: function() {
        console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
        return this.manhattanLength();
    }
});
//
Object.assign(Object3D.prototype, {
    getChildByName: function(name) {
        console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
        return this.getObjectByName(name);
    },
    renderDepth: function() {
        console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
    },
    translate: function(distance, axis) {
        console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
        return this.translateOnAxis(axis, distance);
    },
    getWorldRotation: function() {
        console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
    },
    applyMatrix: function(matrix) {
        console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
        return this.applyMatrix4(matrix);
    }
});
Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
        get: function() {
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
            return this.rotation.order;
        },
        set: function(value1) {
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
            this.rotation.order = value1;
        }
    },
    useQuaternion: {
        get: function() {
            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        },
        set: function() {
            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        }
    }
});
Object.assign(Mesh.prototype, {
    setDrawMode: function() {
        console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
    }
});
Object.defineProperties(Mesh.prototype, {
    drawMode: {
        get: function() {
            console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
            return TrianglesDrawMode;
        },
        set: function() {
            console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
        }
    }
});
Object.defineProperties(LOD.prototype, {
    objects: {
        get: function() {
            console.warn('THREE.LOD: .objects has been renamed to .levels.');
            return this.levels;
        }
    }
});
Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
    get: function() {
        console.warn('THREE.Skeleton: useVertexTexture has been removed.');
    },
    set: function() {
        console.warn('THREE.Skeleton: useVertexTexture has been removed.');
    }
});
SkinnedMesh.prototype.initBones = function() {
    console.error('THREE.SkinnedMesh: initBones() has been removed.');
};
Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
    get: function() {
        console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
        return this.arcLengthDivisions;
    },
    set: function(value1) {
        console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
        this.arcLengthDivisions = value1;
    }
});
//
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== undefined) this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
};
//
Object.defineProperties(Light.prototype, {
    onlyShadow: {
        set: function() {
            console.warn('THREE.Light: .onlyShadow has been removed.');
        }
    },
    shadowCameraFov: {
        set: function(value1) {
            console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
            this.shadow.camera.fov = value1;
        }
    },
    shadowCameraLeft: {
        set: function(value1) {
            console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
            this.shadow.camera.left = value1;
        }
    },
    shadowCameraRight: {
        set: function(value1) {
            console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
            this.shadow.camera.right = value1;
        }
    },
    shadowCameraTop: {
        set: function(value1) {
            console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
            this.shadow.camera.top = value1;
        }
    },
    shadowCameraBottom: {
        set: function(value1) {
            console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
            this.shadow.camera.bottom = value1;
        }
    },
    shadowCameraNear: {
        set: function(value1) {
            console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
            this.shadow.camera.near = value1;
        }
    },
    shadowCameraFar: {
        set: function(value1) {
            console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
            this.shadow.camera.far = value1;
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
        }
    },
    shadowBias: {
        set: function(value1) {
            console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
            this.shadow.bias = value1;
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn('THREE.Light: .shadowDarkness has been removed.');
        }
    },
    shadowMapWidth: {
        set: function(value1) {
            console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
            this.shadow.mapSize.width = value1;
        }
    },
    shadowMapHeight: {
        set: function(value1) {
            console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
            this.shadow.mapSize.height = value1;
        }
    }
});
//
Object.defineProperties(BufferAttribute.prototype, {
    length: {
        get: function() {
            console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
            return this.array.length;
        }
    },
    dynamic: {
        get: function() {
            console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
            return this.usage === DynamicDrawUsage;
        },
        set: function() {
            console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
            this.setUsage(DynamicDrawUsage);
        }
    }
});
Object.assign(BufferAttribute.prototype, {
    setDynamic: function(value1) {
        console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
        this.setUsage(value1 === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
    },
    copyIndicesArray: function() {
        console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
    },
    setArray: function() {
        console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
    }
});
Object.assign(BufferGeometry.prototype, {
    addIndex: function(index2) {
        console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
        this.setIndex(index2);
    },
    addAttribute: function(name, attribute) {
        console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');
        if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
            console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
            return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
        }
        if (name === 'index') {
            console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
            this.setIndex(attribute);
            return this;
        }
        return this.setAttribute(name, attribute);
    },
    addDrawCall: function(start2, count, indexOffset) {
        if (indexOffset !== undefined) console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
        console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
        this.addGroup(start2, count);
    },
    clearDrawCalls: function() {
        console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
        this.clearGroups();
    },
    computeOffsets: function() {
        console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
    },
    removeAttribute: function(name) {
        console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
        return this.deleteAttribute(name);
    },
    applyMatrix: function(matrix) {
        console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
        return this.applyMatrix4(matrix);
    }
});
Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
        get: function() {
            console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
            return this.groups;
        }
    },
    offsets: {
        get: function() {
            console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
            return this.groups;
        }
    }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
    maxInstancedCount: {
        get: function() {
            console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
            return this.instanceCount;
        },
        set: function(value1) {
            console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
            this.instanceCount = value1;
        }
    }
});
Object.defineProperties(Raycaster.prototype, {
    linePrecision: {
        get: function() {
            console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
            return this.params.Line.threshold;
        },
        set: function(value1) {
            console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
            this.params.Line.threshold = value1;
        }
    }
});
Object.defineProperties(InterleavedBuffer.prototype, {
    dynamic: {
        get: function() {
            console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
            return this.usage === DynamicDrawUsage;
        },
        set: function(value1) {
            console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
            this.setUsage(value1);
        }
    }
});
Object.assign(InterleavedBuffer.prototype, {
    setDynamic: function(value1) {
        console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
        this.setUsage(value1 === true ? DynamicDrawUsage : StaticDrawUsage);
        return this;
    },
    setArray: function() {
        console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
    }
});
//
Object.assign(ExtrudeGeometry.prototype, {
    getArrays: function() {
        console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
    },
    addShapeList: function() {
        console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
    },
    addShape: function() {
        console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
    }
});
//
Object.assign(Scene.prototype, {
    dispose: function() {
        console.error('THREE.Scene: .dispose() has been removed.');
    }
});
//
Object.defineProperties(Uniform.prototype, {
    dynamic: {
        set: function() {
            console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
        }
    },
    onUpdate: {
        value: function() {
            console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
            return this;
        }
    }
});
//
Object.defineProperties(Material.prototype, {
    wrapAround: {
        get: function() {
            console.warn('THREE.Material: .wrapAround has been removed.');
        },
        set: function() {
            console.warn('THREE.Material: .wrapAround has been removed.');
        }
    },
    overdraw: {
        get: function() {
            console.warn('THREE.Material: .overdraw has been removed.');
        },
        set: function() {
            console.warn('THREE.Material: .overdraw has been removed.');
        }
    },
    wrapRGB: {
        get: function() {
            console.warn('THREE.Material: .wrapRGB has been removed.');
            return new Color();
        }
    },
    shading: {
        get: function() {
            console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        },
        set: function(value1) {
            console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
            this.flatShading = value1 === FlatShading;
        }
    },
    stencilMask: {
        get: function() {
            console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
            return this.stencilFuncMask;
        },
        set: function(value1) {
            console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
            this.stencilFuncMask = value1;
        }
    }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
    metal: {
        get: function() {
            console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
            return false;
        },
        set: function() {
            console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
        }
    }
});
Object.defineProperties(MeshPhysicalMaterial.prototype, {
    transparency: {
        get: function() {
            console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.');
            return this.transmission;
        },
        set: function(value1) {
            console.warn('THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.');
            this.transmission = value1;
        }
    }
});
Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
        get: function() {
            console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            return this.extensions.derivatives;
        },
        set: function(value1) {
            console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            this.extensions.derivatives = value1;
        }
    }
});
//
Object.assign(WebGLRenderer.prototype, {
    clearTarget: function(renderTarget, color15, depth2, stencil) {
        console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
        this.setRenderTarget(renderTarget);
        this.clear(color15, depth2, stencil);
    },
    animate: function(callback) {
        console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
        this.setAnimationLoop(callback);
    },
    getCurrentRenderTarget: function() {
        console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
        return this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
        console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
        return this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
        console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
        return this.capabilities.precision;
    },
    resetGLState: function() {
        console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
        return this.state.reset();
    },
    supportsFloatTextures: function() {
        console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
        return this.extensions.get('OES_texture_float');
    },
    supportsHalfFloatTextures: function() {
        console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
        return this.extensions.get('OES_texture_half_float');
    },
    supportsStandardDerivatives: function() {
        console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
        return this.extensions.get('OES_standard_derivatives');
    },
    supportsCompressedTextureS3TC: function() {
        console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
        return this.extensions.get('WEBGL_compressed_texture_s3tc');
    },
    supportsCompressedTexturePVRTC: function() {
        console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
        return this.extensions.get('WEBGL_compressed_texture_pvrtc');
    },
    supportsBlendMinMax: function() {
        console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
        return this.extensions.get('EXT_blend_minmax');
    },
    supportsVertexTextures: function() {
        console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
        return this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
        console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
        return this.extensions.get('ANGLE_instanced_arrays');
    },
    enableScissorTest: function(boolean) {
        console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
        this.setScissorTest(boolean);
    },
    initMaterial: function() {
        console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
    },
    addPrePlugin: function() {
        console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
    },
    addPostPlugin: function() {
        console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
    },
    updateShadowMap: function() {
        console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
    },
    setFaceCulling: function() {
        console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
    },
    allocTextureUnit: function() {
        console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
    },
    setTexture: function() {
        console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
    },
    setTexture2D: function() {
        console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
    },
    setTextureCube: function() {
        console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
    },
    getActiveMipMapLevel: function() {
        console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
        return this.getActiveMipmapLevel();
    }
});
Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
            this.shadowMap.enabled = value1;
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
            this.shadowMap.type = value1;
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
        }
    },
    context: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
            return this.getContext();
        }
    },
    vr: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
            return this.xr;
        }
    },
    gammaInput: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
            return false;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
        }
    },
    gammaOutput: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
            return false;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
            this.outputEncoding = value1 === true ? sRGBEncoding : LinearEncoding;
        }
    },
    toneMappingWhitePoint: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
            return 1;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
        }
    }
});
Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
        }
    }
});
function WebGLRenderTargetCube(width5, height7, options4) {
    console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
    return new WebGLCubeRenderTarget(width5, options4);
}
//
Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
            return this.texture.wrapS;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
            this.texture.wrapS = value1;
        }
    },
    wrapT: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
            return this.texture.wrapT;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
            this.texture.wrapT = value1;
        }
    },
    magFilter: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
            return this.texture.magFilter;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
            this.texture.magFilter = value1;
        }
    },
    minFilter: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
            return this.texture.minFilter;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
            this.texture.minFilter = value1;
        }
    },
    anisotropy: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
            return this.texture.anisotropy;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
            this.texture.anisotropy = value1;
        }
    },
    offset: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
            return this.texture.offset;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
            this.texture.offset = value1;
        }
    },
    repeat: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
            return this.texture.repeat;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
            this.texture.repeat = value1;
        }
    },
    format: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
            return this.texture.format;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
            this.texture.format = value1;
        }
    },
    type: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
            return this.texture.type;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
            this.texture.type = value1;
        }
    },
    generateMipmaps: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
            return this.texture.generateMipmaps;
        },
        set: function(value1) {
            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
            this.texture.generateMipmaps = value1;
        }
    }
});
//
Object.defineProperties(Audio1.prototype, {
    load: {
        value: function(file) {
            console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
            const scope3 = this;
            const audioLoader = new AudioLoader();
            audioLoader.load(file, function(buffer) {
                scope3.setBuffer(buffer);
            });
            return this;
        }
    },
    startTime: {
        set: function() {
            console.warn('THREE.Audio: .startTime is now .play( delay ).');
        }
    }
});
AudioAnalyser.prototype.getData = function() {
    console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
    return this.getFrequencyData();
};
//
CubeCamera.prototype.updateCubeMap = function(renderer1, scene) {
    console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
    return this.update(renderer1, scene);
};
CubeCamera.prototype.clear = function(renderer1, color15, depth2, stencil) {
    console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
    return this.renderTarget.clear(renderer1, color15, depth2, stencil);
};
//
const GeometryUtils = {
    merge: function(geometry14, geometry22, materialIndexOffset) {
        console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
        let matrix;
        if (geometry22.isMesh) {
            geometry22.matrixAutoUpdate && geometry22.updateMatrix();
            matrix = geometry22.matrix;
            geometry22 = geometry22.geometry;
        }
        geometry14.merge(geometry22, matrix, materialIndexOffset);
    },
    center: function(geometry14) {
        console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
        return geometry14.center();
    }
};
ImageUtils.crossOrigin = undefined;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
    console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
    const loader = new TextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(url, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
    console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
    const loader = new CubeTextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    const texture = loader.load(urls, onLoad, undefined, onError);
    if (mapping) texture.mapping = mapping;
    return texture;
};
ImageUtils.loadCompressedTexture = function() {
    console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
};
ImageUtils.loadCompressedTextureCube = function() {
    console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
};
//
function CanvasRenderer() {
    console.error('THREE.CanvasRenderer has been removed');
}
//
function JSONLoader() {
    console.error('THREE.JSONLoader has been removed.');
}
//
const SceneUtils = {
    createMultiMaterialObject: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    },
    detach: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    },
    attach: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    }
};
//
function LensFlare() {
    console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
}
if (typeof __THREE_DEVTOOLS__ !== 'undefined') /* eslint-disable no-undef */ __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
    detail: {
        revision: REVISION
    }
}));
if (typeof window !== 'undefined') {
    if (window.__THREE__) console.warn('WARNING: Multiple instances of Three.js being imported.');
    else window.__THREE__ = REVISION;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"kcMTN"}],"kcMTN":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule') return;
        // Skip duplicate re-exports when they have the same value.
        if (key in dest && dest[key] === source[key]) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"gmleG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OrbitControls", ()=>OrbitControls
);
parcelHelpers.export(exports, "MapControls", ()=>MapControls
);
var _threeModuleJs = require("../../../build/three.module.js");
// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
var OrbitControls = function(object, domElement) {
    if (domElement === undefined) console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
    if (domElement === document) console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
    this.object = object;
    this.domElement = domElement;
    // Set to false to disable this control
    this.enabled = true;
    // "target" sets the location of focus, where the object orbits around
    this.target = new _threeModuleJs.Vector3();
    // How far you can dolly in and out ( PerspectiveCamera only )
    this.minDistance = 0;
    this.maxDistance = Infinity;
    // How far you can zoom in and out ( OrthographicCamera only )
    this.minZoom = 0;
    this.maxZoom = Infinity;
    // How far you can orbit vertically, upper and lower limits.
    // Range is 0 to Math.PI radians.
    this.minPolarAngle = 0; // radians
    this.maxPolarAngle = Math.PI; // radians
    // How far you can orbit horizontally, upper and lower limits.
    // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
    this.minAzimuthAngle = -Infinity; // radians
    this.maxAzimuthAngle = Infinity; // radians
    // Set to true to enable damping (inertia)
    // If damping is enabled, you must call controls.update() in your animation loop
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
    // Set to false to disable zooming
    this.enableZoom = true;
    this.zoomSpeed = 1;
    // Set to false to disable rotating
    this.enableRotate = true;
    this.rotateSpeed = 1;
    // Set to false to disable panning
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
    this.keyPanSpeed = 7; // pixels moved per arrow key push
    // Set to true to automatically rotate around the target
    // If auto-rotate is enabled, you must call controls.update() in your animation loop
    this.autoRotate = false;
    this.autoRotateSpeed = 2; // 30 seconds per round when fps is 60
    // The four arrow keys
    this.keys = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40
    };
    // Mouse buttons
    this.mouseButtons = {
        LEFT: _threeModuleJs.MOUSE.ROTATE,
        MIDDLE: _threeModuleJs.MOUSE.DOLLY,
        RIGHT: _threeModuleJs.MOUSE.PAN
    };
    // Touch fingers
    this.touches = {
        ONE: _threeModuleJs.TOUCH.ROTATE,
        TWO: _threeModuleJs.TOUCH.DOLLY_PAN
    };
    // for reset
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    // the target DOM element for key events
    this._domElementKeyEvents = null;
    //
    // public methods
    //
    this.getPolarAngle = function() {
        return spherical.phi;
    };
    this.getAzimuthalAngle = function() {
        return spherical.theta;
    };
    this.listenToKeyEvents = function(domElement1) {
        domElement1.addEventListener('keydown', onKeyDown);
        this._domElementKeyEvents = domElement1;
    };
    this.saveState = function() {
        scope.target0.copy(scope.target);
        scope.position0.copy(scope.object.position);
        scope.zoom0 = scope.object.zoom;
    };
    this.reset = function() {
        scope.target.copy(scope.target0);
        scope.object.position.copy(scope.position0);
        scope.object.zoom = scope.zoom0;
        scope.object.updateProjectionMatrix();
        scope.dispatchEvent(changeEvent);
        scope.update();
        state = STATE.NONE;
    };
    // this method is exposed, but perhaps it would be better if we can make it private...
    this.update = (function() {
        var offset = new _threeModuleJs.Vector3();
        // so camera.up is the orbit axis
        var quat = new _threeModuleJs.Quaternion().setFromUnitVectors(object.up, new _threeModuleJs.Vector3(0, 1, 0));
        var quatInverse = quat.clone().invert();
        var lastPosition = new _threeModuleJs.Vector3();
        var lastQuaternion = new _threeModuleJs.Quaternion();
        var twoPI = 2 * Math.PI;
        return function update() {
            var position = scope.object.position;
            offset.copy(position).sub(scope.target);
            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion(quat);
            // angle from z-axis around y-axis
            spherical.setFromVector3(offset);
            if (scope.autoRotate && state === STATE.NONE) rotateLeft(getAutoRotationAngle());
            if (scope.enableDamping) {
                spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                spherical.phi += sphericalDelta.phi * scope.dampingFactor;
            } else {
                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;
            }
            // restrict theta to be between desired limits
            var min = scope.minAzimuthAngle;
            var max = scope.maxAzimuthAngle;
            if (isFinite(min) && isFinite(max)) {
                if (min < -Math.PI) min += twoPI;
                else if (min > Math.PI) min -= twoPI;
                if (max < -Math.PI) max += twoPI;
                else if (max > Math.PI) max -= twoPI;
                if (min <= max) spherical.theta = Math.max(min, Math.min(max, spherical.theta));
                else spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
            }
            // restrict phi to be between desired limits
            spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
            spherical.makeSafe();
            spherical.radius *= scale;
            // restrict radius to be between desired limits
            spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
            // move target to panned location
            if (scope.enableDamping === true) scope.target.addScaledVector(panOffset, scope.dampingFactor);
            else scope.target.add(panOffset);
            offset.setFromSpherical(spherical);
            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion(quatInverse);
            position.copy(scope.target).add(offset);
            scope.object.lookAt(scope.target);
            if (scope.enableDamping === true) {
                sphericalDelta.theta *= 1 - scope.dampingFactor;
                sphericalDelta.phi *= 1 - scope.dampingFactor;
                panOffset.multiplyScalar(1 - scope.dampingFactor);
            } else {
                sphericalDelta.set(0, 0, 0);
                panOffset.set(0, 0, 0);
            }
            scale = 1;
            // update condition is:
            // min(camera displacement, camera rotation in radians)^2 > EPS
            // using small-angle approximation cos(x/2) = 1 - x^2 / 8
            if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
                scope.dispatchEvent(changeEvent);
                lastPosition.copy(scope.object.position);
                lastQuaternion.copy(scope.object.quaternion);
                zoomChanged = false;
                return true;
            }
            return false;
        };
    })();
    this.dispose = function() {
        scope.domElement.removeEventListener('contextmenu', onContextMenu);
        scope.domElement.removeEventListener('pointerdown', onPointerDown);
        scope.domElement.removeEventListener('wheel', onMouseWheel);
        scope.domElement.removeEventListener('touchstart', onTouchStart);
        scope.domElement.removeEventListener('touchend', onTouchEnd);
        scope.domElement.removeEventListener('touchmove', onTouchMove);
        scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);
        scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
        if (scope._domElementKeyEvents !== null) scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown);
    //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
    };
    //
    // internals
    //
    var scope = this;
    var changeEvent = {
        type: 'change'
    };
    var startEvent = {
        type: 'start'
    };
    var endEvent = {
        type: 'end'
    };
    var STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
    };
    var state = STATE.NONE;
    var EPS = 0.000001;
    // current position in spherical coordinates
    var spherical = new _threeModuleJs.Spherical();
    var sphericalDelta = new _threeModuleJs.Spherical();
    var scale = 1;
    var panOffset = new _threeModuleJs.Vector3();
    var zoomChanged = false;
    var rotateStart = new _threeModuleJs.Vector2();
    var rotateEnd = new _threeModuleJs.Vector2();
    var rotateDelta = new _threeModuleJs.Vector2();
    var panStart = new _threeModuleJs.Vector2();
    var panEnd = new _threeModuleJs.Vector2();
    var panDelta = new _threeModuleJs.Vector2();
    var dollyStart = new _threeModuleJs.Vector2();
    var dollyEnd = new _threeModuleJs.Vector2();
    var dollyDelta = new _threeModuleJs.Vector2();
    function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
        return Math.pow(0.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
        sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
        sphericalDelta.phi -= angle;
    }
    var panLeft = function() {
        var v = new _threeModuleJs.Vector3();
        return function panLeft1(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
            v.multiplyScalar(-distance);
            panOffset.add(v);
        };
    }();
    var panUp = function() {
        var v = new _threeModuleJs.Vector3();
        return function panUp1(distance, objectMatrix) {
            if (scope.screenSpacePanning === true) v.setFromMatrixColumn(objectMatrix, 1);
            else {
                v.setFromMatrixColumn(objectMatrix, 0);
                v.crossVectors(scope.object.up, v);
            }
            v.multiplyScalar(distance);
            panOffset.add(v);
        };
    }();
    // deltaX and deltaY are in pixels; right and down are positive
    var pan = function() {
        var offset = new _threeModuleJs.Vector3();
        return function pan1(deltaX, deltaY) {
            var element = scope.domElement;
            if (scope.object.isPerspectiveCamera) {
                // perspective
                var position = scope.object.position;
                offset.copy(position).sub(scope.target);
                var targetDistance = offset.length();
                // half of the fov is center to top of screen
                targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
                // we use only clientHeight here so aspect ratio does not distort speed
                panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
                panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
            } else if (scope.object.isOrthographicCamera) {
                // orthographic
                panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
                panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
            } else {
                // camera neither orthographic nor perspective
                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
                scope.enablePan = false;
            }
        };
    }();
    function dollyOut(dollyScale) {
        if (scope.object.isPerspectiveCamera) scale /= dollyScale;
        else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
        } else {
            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
            scope.enableZoom = false;
        }
    }
    function dollyIn(dollyScale) {
        if (scope.object.isPerspectiveCamera) scale *= dollyScale;
        else if (scope.object.isOrthographicCamera) {
            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
        } else {
            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
            scope.enableZoom = false;
        }
    }
    //
    // event callbacks - update the object state
    //
    function handleMouseDownRotate(event) {
        rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
        dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
        panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
        rotateEnd.set(event.clientX, event.clientY);
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        var element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
        scope.update();
    }
    function handleMouseMoveDolly(event) {
        dollyEnd.set(event.clientX, event.clientY);
        dollyDelta.subVectors(dollyEnd, dollyStart);
        if (dollyDelta.y > 0) dollyOut(getZoomScale());
        else if (dollyDelta.y < 0) dollyIn(getZoomScale());
        dollyStart.copy(dollyEnd);
        scope.update();
    }
    function handleMouseMovePan(event) {
        panEnd.set(event.clientX, event.clientY);
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
        scope.update();
    }
    function handleMouseUp() {
    // no-op
    }
    function handleMouseWheel(event) {
        if (event.deltaY < 0) dollyIn(getZoomScale());
        else if (event.deltaY > 0) dollyOut(getZoomScale());
        scope.update();
    }
    function handleKeyDown(event) {
        var needsUpdate = false;
        switch(event.keyCode){
            case scope.keys.UP:
                pan(0, scope.keyPanSpeed);
                needsUpdate = true;
                break;
            case scope.keys.BOTTOM:
                pan(0, -scope.keyPanSpeed);
                needsUpdate = true;
                break;
            case scope.keys.LEFT:
                pan(scope.keyPanSpeed, 0);
                needsUpdate = true;
                break;
            case scope.keys.RIGHT:
                pan(-scope.keyPanSpeed, 0);
                needsUpdate = true;
                break;
        }
        if (needsUpdate) {
            // prevent the browser from scrolling on cursor keys
            event.preventDefault();
            scope.update();
        }
    }
    function handleTouchStartRotate(event) {
        if (event.touches.length == 1) rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
        else {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            rotateStart.set(x, y);
        }
    }
    function handleTouchStartPan(event) {
        if (event.touches.length == 1) panStart.set(event.touches[0].pageX, event.touches[0].pageY);
        else {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            panStart.set(x, y);
        }
    }
    function handleTouchStartDolly(event) {
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan(event) {
        if (scope.enableZoom) handleTouchStartDolly(event);
        if (scope.enablePan) handleTouchStartPan(event);
    }
    function handleTouchStartDollyRotate(event) {
        if (scope.enableZoom) handleTouchStartDolly(event);
        if (scope.enableRotate) handleTouchStartRotate(event);
    }
    function handleTouchMoveRotate(event) {
        if (event.touches.length == 1) rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
        else {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            rotateEnd.set(x, y);
        }
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        var element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
        if (event.touches.length == 1) panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
        else {
            var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
            var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
            panEnd.set(x, y);
        }
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance);
        dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
        dollyOut(dollyDelta.y);
        dollyStart.copy(dollyEnd);
    }
    function handleTouchMoveDollyPan(event) {
        if (scope.enableZoom) handleTouchMoveDolly(event);
        if (scope.enablePan) handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
        if (scope.enableZoom) handleTouchMoveDolly(event);
        if (scope.enableRotate) handleTouchMoveRotate(event);
    }
    function handleTouchEnd() {
    // no-op
    }
    //
    // event handlers - FSM: listen for events and reset state
    //
    function onPointerDown(event) {
        if (scope.enabled === false) return;
        switch(event.pointerType){
            case 'mouse':
            case 'pen':
                onMouseDown(event);
                break;
        }
    }
    function onPointerMove(event) {
        if (scope.enabled === false) return;
        switch(event.pointerType){
            case 'mouse':
            case 'pen':
                onMouseMove(event);
                break;
        }
    }
    function onPointerUp(event) {
        switch(event.pointerType){
            case 'mouse':
            case 'pen':
                onMouseUp(event);
                break;
        }
    }
    function onMouseDown(event) {
        // Prevent the browser from scrolling.
        event.preventDefault();
        // Manually set the focus since calling preventDefault above
        // prevents the browser from setting it automatically.
        scope.domElement.focus ? scope.domElement.focus() : window.focus();
        var mouseAction;
        switch(event.button){
            case 0:
                mouseAction = scope.mouseButtons.LEFT;
                break;
            case 1:
                mouseAction = scope.mouseButtons.MIDDLE;
                break;
            case 2:
                mouseAction = scope.mouseButtons.RIGHT;
                break;
            default:
                mouseAction = -1;
        }
        switch(mouseAction){
            case _threeModuleJs.MOUSE.DOLLY:
                if (scope.enableZoom === false) return;
                handleMouseDownDolly(event);
                state = STATE.DOLLY;
                break;
            case _threeModuleJs.MOUSE.ROTATE:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                    if (scope.enablePan === false) return;
                    handleMouseDownPan(event);
                    state = STATE.PAN;
                } else {
                    if (scope.enableRotate === false) return;
                    handleMouseDownRotate(event);
                    state = STATE.ROTATE;
                }
                break;
            case _threeModuleJs.MOUSE.PAN:
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                    if (scope.enableRotate === false) return;
                    handleMouseDownRotate(event);
                    state = STATE.ROTATE;
                } else {
                    if (scope.enablePan === false) return;
                    handleMouseDownPan(event);
                    state = STATE.PAN;
                }
                break;
            default:
                state = STATE.NONE;
        }
        if (state !== STATE.NONE) {
            scope.domElement.ownerDocument.addEventListener('pointermove', onPointerMove);
            scope.domElement.ownerDocument.addEventListener('pointerup', onPointerUp);
            scope.dispatchEvent(startEvent);
        }
    }
    function onMouseMove(event) {
        if (scope.enabled === false) return;
        event.preventDefault();
        switch(state){
            case STATE.ROTATE:
                if (scope.enableRotate === false) return;
                handleMouseMoveRotate(event);
                break;
            case STATE.DOLLY:
                if (scope.enableZoom === false) return;
                handleMouseMoveDolly(event);
                break;
            case STATE.PAN:
                if (scope.enablePan === false) return;
                handleMouseMovePan(event);
                break;
        }
    }
    function onMouseUp(event) {
        scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);
        scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);
        if (scope.enabled === false) return;
        handleMouseUp(event);
        scope.dispatchEvent(endEvent);
        state = STATE.NONE;
    }
    function onMouseWheel(event) {
        if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;
        event.preventDefault();
        event.stopPropagation();
        scope.dispatchEvent(startEvent);
        handleMouseWheel(event);
        scope.dispatchEvent(endEvent);
    }
    function onKeyDown(event) {
        if (scope.enabled === false || scope.enablePan === false) return;
        handleKeyDown(event);
    }
    function onTouchStart(event) {
        if (scope.enabled === false) return;
        event.preventDefault(); // prevent scrolling
        switch(event.touches.length){
            case 1:
                switch(scope.touches.ONE){
                    case _threeModuleJs.TOUCH.ROTATE:
                        if (scope.enableRotate === false) return;
                        handleTouchStartRotate(event);
                        state = STATE.TOUCH_ROTATE;
                        break;
                    case _threeModuleJs.TOUCH.PAN:
                        if (scope.enablePan === false) return;
                        handleTouchStartPan(event);
                        state = STATE.TOUCH_PAN;
                        break;
                    default:
                        state = STATE.NONE;
                }
                break;
            case 2:
                switch(scope.touches.TWO){
                    case _threeModuleJs.TOUCH.DOLLY_PAN:
                        if (scope.enableZoom === false && scope.enablePan === false) return;
                        handleTouchStartDollyPan(event);
                        state = STATE.TOUCH_DOLLY_PAN;
                        break;
                    case _threeModuleJs.TOUCH.DOLLY_ROTATE:
                        if (scope.enableZoom === false && scope.enableRotate === false) return;
                        handleTouchStartDollyRotate(event);
                        state = STATE.TOUCH_DOLLY_ROTATE;
                        break;
                    default:
                        state = STATE.NONE;
                }
                break;
            default:
                state = STATE.NONE;
        }
        if (state !== STATE.NONE) scope.dispatchEvent(startEvent);
    }
    function onTouchMove(event) {
        if (scope.enabled === false) return;
        event.preventDefault(); // prevent scrolling
        event.stopPropagation();
        switch(state){
            case STATE.TOUCH_ROTATE:
                if (scope.enableRotate === false) return;
                handleTouchMoveRotate(event);
                scope.update();
                break;
            case STATE.TOUCH_PAN:
                if (scope.enablePan === false) return;
                handleTouchMovePan(event);
                scope.update();
                break;
            case STATE.TOUCH_DOLLY_PAN:
                if (scope.enableZoom === false && scope.enablePan === false) return;
                handleTouchMoveDollyPan(event);
                scope.update();
                break;
            case STATE.TOUCH_DOLLY_ROTATE:
                if (scope.enableZoom === false && scope.enableRotate === false) return;
                handleTouchMoveDollyRotate(event);
                scope.update();
                break;
            default:
                state = STATE.NONE;
        }
    }
    function onTouchEnd(event) {
        if (scope.enabled === false) return;
        handleTouchEnd(event);
        scope.dispatchEvent(endEvent);
        state = STATE.NONE;
    }
    function onContextMenu(event) {
        if (scope.enabled === false) return;
        event.preventDefault();
    }
    //
    scope.domElement.addEventListener('contextmenu', onContextMenu);
    scope.domElement.addEventListener('pointerdown', onPointerDown);
    scope.domElement.addEventListener('wheel', onMouseWheel);
    scope.domElement.addEventListener('touchstart', onTouchStart);
    scope.domElement.addEventListener('touchend', onTouchEnd);
    scope.domElement.addEventListener('touchmove', onTouchMove);
    // force an update at start
    this.update();
};
OrbitControls.prototype = Object.create(_threeModuleJs.EventDispatcher.prototype);
OrbitControls.prototype.constructor = OrbitControls;
// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
// This is very similar to OrbitControls, another set of touch behavior
//
//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - left mouse, or arrow keys / touch: one-finger move
var MapControls = function(object, domElement) {
    OrbitControls.call(this, object, domElement);
    this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up
    this.mouseButtons.LEFT = _threeModuleJs.MOUSE.PAN;
    this.mouseButtons.RIGHT = _threeModuleJs.MOUSE.ROTATE;
    this.touches.ONE = _threeModuleJs.TOUCH.PAN;
    this.touches.TWO = _threeModuleJs.TOUCH.DOLLY_ROTATE;
};
MapControls.prototype = Object.create(_threeModuleJs.EventDispatcher.prototype);
MapControls.prototype.constructor = MapControls;

},{"../../../build/three.module.js":"1gWoM","@parcel/transformer-js/src/esmodule-helpers.js":"kcMTN"}],"cGDrh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$", ()=>$
);
parcelHelpers.export(exports, "$0", ()=>$0
);
parcelHelpers.export(exports, "putInGui", ()=>putInGui
);
parcelHelpers.export(exports, "parseElements", ()=>parseElements
);
function checkForIE() {
    return !!window.MSInputMethodContext && !!document.documentMode;
}
const $ = document.querySelectorAll.bind(document);
const $0 = document.querySelector.bind(document);
function putInGui(input, nodeList, precision) {
    let index = 0;
    for (let node of nodeList){
        node.textContent = input[index].toFixed(precision);
        index++;
    }
}
function parseElements(nodeList, output) {
    const array = nodeList.map((node)=>Number(node.textContent.replace(/\s/g, ""))
    );
    if (array.includes(NaN)) return false;
    output.fromArray(array);
    return true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"kcMTN"}],"3X92b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "floor", ()=>floor
);
parcelHelpers.export(exports, "wood", ()=>wood
);
parcelHelpers.export(exports, "nylon", ()=>nylon
);
parcelHelpers.export(exports, "water", ()=>water
);
var _three = require("three");
const textureLoader = new _three.TextureLoader();
const floor = new _three.MeshStandardMaterial({
    map: textureLoader.load(require("url:./assets/floor/Map.jpg"), (texture)=>{
        texture.repeat.set(50, 50);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    normalMap: textureLoader.load(require("url:./assets/floor/Normal.jpg"), (texture)=>{
        texture.repeat.set(50, 50);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    roughnessMap: textureLoader.load(require("url:./assets/floor/Roughness.jpg"), (texture)=>{
        texture.repeat.set(50, 50);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    aoMap: textureLoader.load(require("url:./assets/floor/AO.jpg"), (texture)=>{
        texture.repeat.set(50, 50);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    roughness: 0.95
});
const wood = new _three.MeshStandardMaterial({
    map: textureLoader.load(require("url:./assets/wood/Map.jpg"), (texture)=>{
        texture.repeat.set(0.5, 0.5);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    normalMap: textureLoader.load(require("url:./assets/wood/Normal.jpg"), (texture)=>{
        texture.repeat.set(0.5, 0.5);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    roughnessMap: textureLoader.load(require("url:./assets/wood/Roughness.jpg"), (texture)=>{
        texture.repeat.set(0.5, 0.5);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    aoMap: textureLoader.load(require("url:./assets/wood/AO.jpg"), (texture)=>{
        texture.repeat.set(0.5, 0.5);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    roughness: 1
});
const nylon = new _three.MeshStandardMaterial({
    map: textureLoader.load(require("url:./assets/nylon/Map.jpg"), (texture)=>{
        texture.repeat.set(0.5, 0.5);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    normalMap: textureLoader.load(require("url:./assets/nylon/Normal.jpg"), (texture)=>{
        texture.repeat.set(0.5, 0.5);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    roughnessMap: textureLoader.load(require("url:./assets/nylon/Roughness.jpg"), (texture)=>{
        texture.repeat.set(0.5, 0.5);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    aoMap: textureLoader.load(require("url:./assets/nylon/AO.jpg"), (texture)=>{
        texture.repeat.set(0.5, 0.5);
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    roughness: 1
});
const water = new _three.MeshStandardMaterial({
    map: textureLoader.load(require("url:./assets/mineral/Map.jpg"), (texture)=>{
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    normalMap: textureLoader.load(require("url:./assets/mineral/Normal.jpg"), (texture)=>{
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    aoMap: textureLoader.load(require("url:./assets/mineral/AO.jpg"), (texture)=>{
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    bumpMap: textureLoader.load(require("url:./assets/mineral/Displacement.png"), (texture)=>{
        texture.wrapT = texture.wrapS = _three.RepeatWrapping;
    }),
    displacementScale: 0.05
});

},{"three":"5bvHB","url:./assets/floor/Map.jpg":"6CIut","url:./assets/floor/Normal.jpg":"cQdeW","url:./assets/floor/Roughness.jpg":"aXQMH","url:./assets/floor/AO.jpg":"it6Vk","url:./assets/wood/Map.jpg":"6ts2v","url:./assets/wood/Normal.jpg":"ckePG","url:./assets/wood/Roughness.jpg":"dDUvs","url:./assets/wood/AO.jpg":"iycoL","url:./assets/nylon/Map.jpg":"i4wzs","url:./assets/nylon/Normal.jpg":"bZfHI","url:./assets/nylon/Roughness.jpg":"fQI0b","url:./assets/nylon/AO.jpg":"bSf05","url:./assets/mineral/Map.jpg":"8rHXy","url:./assets/mineral/Normal.jpg":"VY8d6","url:./assets/mineral/AO.jpg":"1k22I","url:./assets/mineral/Displacement.png":"ebDck","@parcel/transformer-js/src/esmodule-helpers.js":"kcMTN"}],"6CIut":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Map.03d424e6.jpg";

},{"./bundle-url":"kGdAt"}],"kGdAt":[function(require,module,exports) {
"use strict";
/* globals document:readonly */ var bundleURL = null;
function getBundleURLCached() {
    if (!bundleURL) bundleURL = getBundleURL();
    return bundleURL;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ('' + err.stack).match(/(https?|file|ftp):\/\/[^)\n]+/g);
        if (matches) return getBaseURL(matches[0]);
    }
    return '/';
}
function getBaseURL(url) {
    return ('' + url).replace(/^((?:https?|file|ftp):\/\/.+)\/[^/]+$/, '$1') + '/';
} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    let matches = ('' + url).match(/(https?|file|ftp):\/\/[^/]+/);
    if (!matches) throw new Error('Origin not found');
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"cQdeW":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Normal.64e50053.jpg";

},{"./bundle-url":"kGdAt"}],"aXQMH":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Roughness.e2812146.jpg";

},{"./bundle-url":"kGdAt"}],"it6Vk":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "AO.a2a52976.jpg";

},{"./bundle-url":"kGdAt"}],"6ts2v":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Map.231497d3.jpg";

},{"./bundle-url":"kGdAt"}],"ckePG":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Normal.b3e51282.jpg";

},{"./bundle-url":"kGdAt"}],"dDUvs":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Roughness.1034e60c.jpg";

},{"./bundle-url":"kGdAt"}],"iycoL":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "AO.3df4f413.jpg";

},{"./bundle-url":"kGdAt"}],"i4wzs":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Map.fe0152dd.jpg";

},{"./bundle-url":"kGdAt"}],"bZfHI":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Normal.a7aec527.jpg";

},{"./bundle-url":"kGdAt"}],"fQI0b":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Roughness.00c6db00.jpg";

},{"./bundle-url":"kGdAt"}],"bSf05":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "AO.21d0a872.jpg";

},{"./bundle-url":"kGdAt"}],"8rHXy":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Map.8674cbd6.jpg";

},{"./bundle-url":"kGdAt"}],"VY8d6":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Normal.5d82f45a.jpg";

},{"./bundle-url":"kGdAt"}],"1k22I":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "AO.fc7ddbce.jpg";

},{"./bundle-url":"kGdAt"}],"ebDck":[function(require,module,exports) {
module.exports = require('./bundle-url').getBundleURL() + "Displacement.37160cf3.png";

},{"./bundle-url":"kGdAt"}]},["2t7XM","3pX0n"], "3pX0n", "parcelRequire4c92")

//# sourceMappingURL=index.138fadf4.js.map
